------- FILE mytb.asm LEVEL 1 PASS 6
      1 U4426				   input      processor	6502
      2 U4426 ????						;=====================================================
      3 U4426 ????						; Concurrent Tiny Basic, no longer Tiny
      4 U4426 ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U4426 ????						; Free Time. Now abiut 6K Full OS features.
      6 U4426 ????						;
      7 U4426 ????						; While working on the Corsham Technologies KIM Clone
      8 U4426 ????						; project, I wanted to include a TINY BASIC since that
      9 U4426 ????						; was a highly desirable feature of early computers.
     10 U4426 ????						;
     11 U4426 ????						; Rather than negotiating copyright issues for
     12 U4426 ????						; existing BASICs, I decided to just write one from
     13 U4426 ????						; scratch.
     14 U4426 ????						;
     15 U4426 ????						; 10/07/2017
     16 U4426 ????						;
     17 U4426 ????						; This implements a stripped down Tiny BASIC
     18 U4426 ????						; interpreter using the Interpretive Language (IL)
     19 U4426 ????						; method as described in the first few issues of
     20 U4426 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U4426 ????						; to write various languages simply by changing the
     22 U4426 ????						; IL code rather than the interpreter itself.
     23 U4426 ????						;
     24 U4426 ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U4426 ????						;		* Fixed major bug in findLine that
     26 U4426 ????						;		  caused corrupted lines, crashes, etc.
     27 U4426 ????						;		* If no parameter given to RND, assume
     28 U4426 ????						;		  32766.
     29 U4426 ????						;		* No more error 5 when a program
     30 U4426 ????						;		  reaches the end without an END.
     31 U4426 ????						;
     32 U4426 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U4426 ????						;		 * Unexpanded version to play with everything
     34 U4426 ????						;		 * Add some usefull system level functions
     35 U4426 ????						;		 * allow a larger number of tiny basic formats
     36 U4426 ????						;		 * Add byte at start of line holding length
     37 U4426 ????						;		   for faster execution of goto and gosub
     38 U4426 ????						;		 * Re-added gosub
     39 U4426 ????						;		 * allow ; or , at end if print stmt
     40 U4426 ????						;		   without CRLF being added.
     41 U4426 ????						;		 * Added extended function erase to
     42 U4426 ????						;		   use the extended ctmon65 rm file
     43 U4426 ????						;		 * Fix quoted text to not have to backtrack
     44 U4426 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U4426 ????						;		 * Add concurrency features
     46 U4426 ????						;		 * Add Compile at runtime for gosub and goto addresses
     47 U4426 ????						;
     48 U4426 ????						; 10/31/2023 v0.5 Justlostintime@gmail.com
     49 U4426 ????						;		 * Inline in il some var load value instead of calling
     50 U4426 ????						;
     51 U4426 ????						; 11/20/2023 v1.1.3 Justlostintime@gmail.com
     52 U4426 ????						;		 * Many improvment, bug fixes
     53 U4426 ????						;
     54 U4426 ????						; 07/11/2025 v1.1.4 Justlostintime@gmail.com
     55 U4426 ????						;		  * Added While..wend speed improvement
     56 U4426 ????						;
     57 U4426 ????						; www.corshamtech.com Now defunct
     58 U4426 ????						; bob@corshamtech.com Bob sadly passed away
     59 U4426 ????						; JustLostInTime@gmail.com Active development
     60 U4426 ????						;
     61 U4426 ????						;=====================================================
     62 U4426 ????						;
     63 U4426 ????						; Create TRUE and FALSE values for conditionals.
     64 U4426 ????						;
     65 U4426 ????
     66 U4426 ????	       00 00	   FALSE      equ	0
     67 U4426 ????	       ff ff ff ff TRUE       equ	~FALSE
     68 U4426 ????						;
     69 U4426 ????						;---------------------------------------------------------
     70 U4426 ????						; One of these must be set to indicate which environment
     71 U4426 ????						; Tiny BASIC will be running in.  Here are the current
     72 U4426 ????						; environments:
     73 U4426 ????						;
     74 U4426 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     75 U4426 ????						; more K of RAM.
     76 U4426 ????						;
     77 U4426 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     78 U4426 ????						; which enhances, without replacing, the standard KIM
     79 U4426 ????						; monitor.  It gives access to routines to save/load files
     80 U4426 ????						; to a micro SD card.
     81 U4426 ????						;
     82 U4426 ????						; CTMON65 is a from-scratch monitor written for the
     83 U4426 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     84 U4426 ????						; easily be ported to other systems.  It has support for
     85 U4426 ????						; using a micro SD card for file storage/retrieval.
     86 U4426 ????						;
     87 U4426 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     88 U4426 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     89 U4426 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     90 U4426 ????	       ff ff ff ff IL_DEBUG_TEXT equ	TRUE	;Print out as text IL instructions
     91 U4426 ????						;
     92 U4426 ????						;   Need to define some macros for the dasm assembler
     93 U4426 ????						;
     94 U4426 ????				      MACRO	dw
     95 U4426 ????				      .word	{0}
     96 U4426 ????				      ENDM
     97 U4426 ????
     98 U4426 ????				      MACRO	db
     99 U4426 ????				      .byte	{0}
    100 U4426 ????				      ENDM
    101 U4426 ????
    102 U4426 ????						;
    103 U4426 ????						; If set, include disk functions.
    104 U4426 ????						;
    105 U4426 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
    106 U4426 ????						;
    107 U4426 ????						; If ILTRACE is set then dump out the address of every
    108 U4426 ????						; IL opcode before executing it.
    109 U4426 ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    110 U4426 ????						;
    111 U4426 ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    112 U4426 ????						;
    113 U4426 ????						; If FIXED is set, put the IL code and the user
    114 U4426 ????						; program space at fixed locations in memory.	This is
    115 U4426 ????						; meant only for debugging.
    116 U4426 ????						;
    117 U4426 ????	       00 00	   FIXED      equ	FALSE
    118 U4426 ????
    119 U4426 ????	       00 0f	   terminalIOblockLen equ	[TerminalIOblockEnd - TerminalIOblock]
    120 U4426 ????
    121 U4426 ????						;
    122 U4426 ????						; Sets the arithmetic stack depth.  This is *TINY*
    123 U4426 ????						; BASIC, so keep this small!
    124 U4426 ????						;
    125 U4426 ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    126 U4426 ????	       00 32	   ILSTACKSIZE equ	50	;number of entries in ilstack
    127 U4426 ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    128 U4426 ????	       00 25	   VARIABLESSIZE equ	37	;26 variables + 1 for exit code + 10 entries (20bytes) for ioblock
    129 U4426 ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 10 tasks
    130 U4426 ????	       00 ff	   TASKCYCLESDEFAULT equ	255	;Default Task Switch 0-255 uses a single byte
    131 U4426 ????	       00 02	   TASKCYCLESHIGH equ	2	;hi order count
    132 U4426 ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    133 U4426 ????
    134 U4426 ????	       00 36	   taskSTDIN  equ	[[VARIABLESSIZE - 10]*2]	;io vector
    135 U4426 ????	       00 38	   taskSTDOUT equ	[[[VARIABLESSIZE - 10]*2]+2]	;io vector
    136 U4426 ????
    137 U4426 ????	       00 3f	   taskIOinPort equ	[[[VARIABLESSIZE - 10]*2]+4+5]	;Offset into the ioblock
    138 U4426 ????	       00 3b	   taskIOoutPort equ	[[[VARIABLESSIZE - 10]*2]+4+1]	;Offset into the ioblock
    139 U4426 ????	       00 46	   taskIOstatusPort equ	[[[VARIABLESSIZE - 10]*2]+4+12]	;Offset into the ioblock
    140 U4426 ????						;
    141 U4426 ????						; Common ASCII constants
    142 U4426 ????						;
    143 U4426 ????	       00 07	   BEL	      equ	$07
    144 U4426 ????	       00 08	   BS	      equ	$08
    145 U4426 ????	       00 09	   TAB	      equ	$09
    146 U4426 ????	       00 0a	   LF	      equ	$0A
    147 U4426 ????	       00 0d	   CR	      equ	$0D
    148 U4426 ????	       00 22	   quote      equ	$22
    149 U4426 ????	       00 20	   SPACE      equ	$20
    150 U4426 ????	       00 2c	   COMMA      equ	',
    151 U4426 ????	       00 3b	   SEMICOLON  equ	';
    152 U4426 ????	       00 3a	   COLON      equ	':
    153 U4426 ????	       00 24	   DOLLAR     equ	'$
    154 U4426 ????						;
    155 U4426 ????						; These are error codes
    156 U4426 ????						;
    157 U4426 ????	       00 00	   ERR_NONE   equ	0	;No Errror
    158 U4426 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    159 U4426 ????	       00 02	   ERR_UNDER  equ	2	;The Math stack underflow
    160 U4426 ????	       00 03	   ERR_OVER   equ	3	;The Math stack overflow
    161 U4426 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    162 U4426 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    163 U4426 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    164 U4426 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    165 U4426 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    166 U4426 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    167 U4426 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    168 U4426 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    169 U4426 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;the gosub Stack overflow
    170 U4426 ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    171 U4426 ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    172 U4426 ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    173 U4426 ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    174 U4426 ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    175 U4426 ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    176 U4426 ????	       00 13	   ERR_NO_RETURN_VALUE_PROVIDED equ	19	;No value returned by a gofn call
    177 U4426 ????	       00 14	   ERR_LINE_NOT_FOUND equ	20	;Gosub/goto/gofn line number not found
    178 U4426 ????	       00 15	   ERR_IL_STACK_OVER_FLOW equ	21	;The IL return stack has overflowed
    179 U4426 ????	       00 16	   ERR_EXPECTVAR equ	22	;Expected a variable name or definition
    180 U4426 ????	       00 17	   ERR_CLOSINGBRACKET equ	23	;Expected a closing bracket
    181 U4426 ????	       00 18	   ERR_MISSINGEQUALSIGN equ	24	;Expected an equal sign for assignment
    182 U4426 ????	       00 19	   ERR_FUNCTION_EXPECTED_PARAMETERS equ	25	;Function expected parameters
    183 U4426 ????	       00 1a	   ERR_EXPECTED_OPENING_BRACKET equ	26	;Expected opening bracket [ or (
    184 U4426 ????	       00 1b	   ERR_NO_MATCHING_BEGIN_BLOCK equ	27	;expected a while,for, if endif statement, was not found
    185 U4426 ????	       00 1c	   ERR_NO_MATCHING_END_BLOCK equ	28	;expected a closing block value wend, next, endif
    186 U4426 ????
    187 U4426 ????						;
    188 U4426 ????						;=====================================================
    189 U4426 ????						; Zero page storage.
    190 U4426 ????						;
    191 U00f6 ????				      SEG.U	ZEROPAGE
    192 U0040					      org	$0040
    193 U0040
    194 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    195 U0041
    196 U0041							; The context is used to locate a task switch
    197 U0041							; it copies from here till all task fields are saved/swapped
    198 U0041							; The max number of tasks is 256 / context length
    199 U0041							; All positions POS values are plus one task table incldues
    200 U0041							; a leading status byte .
    201 U0041							;
    202 U0041		       00 41	   CONTEXT    equ	*
    203 U0041							;StatusCode		 db	 1  this is here to remind why everything is plus 1 this and is only in the Task table
    204 U0041
    205 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    206 U0041		       00 01	   VARIABLEPOS equ	VARIABLES - CONTEXT + 1
    207 U0043
    208 U0043		       00 00	   ILPC       ds	2	; IL program counter
    209 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    210 U0047		       00	   ILSTACKPTR ds	1
    211 U0048
    212 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    213 U0048		       00 08	   MATHSTACKPOS equ	MATHSTACK - CONTEXT + 1
    214 U004a
    215 U004a		       00	   MATHSTACKPTR ds	1
    216 U004a		       00 0a	   MATHSTACKPTRPOS equ	MATHSTACKPTR - CONTEXT + 1
    217 U004b
    218 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    219 U004b		       00 0b	   GOSUBSTKPOS equ	GOSUBSTACK - CONTEXT + 1	; Get the offset to the gosub/msg stack
    220 U004d
    221 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    222 U004d		       00 0d	   GOSUBPTRPOS equ	GOSUBSTACKPTR - CONTEXT+1	; Pointer to gosub stack pointer
    223 U004e
    224 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of gosub stack
    225 U004e		       00 0e	   MSGPTRPOS  equ	MESSAGEPTR - CONTEXT+1	; Pointer to the message counter
    226 U004f							;
    227 U004f							; CURPTR is a pointer to curent BASIC line being
    228 U004f							; executed.  Always points to start of line, CUROFF
    229 U004f							; is the offset to the current character.
    230 U004f							; The order of these fields is important
    231 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    232 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    233 U0052							;
    234 U0052							;The order of these fields in important
    235 U0052
    236 U0052							;
    237 U0052							; R0, R1 and MQ are used for arithmetic operations and
    238 U0052							; general use.
    239 U0052							;
    240 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    241 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    242 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    243 U0056		       00 00	   MQ	      ds	2	;used for some math
    244 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    245 U0058		       00 59	   REGISTERSEND equ	*
    246 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    247 U0059
    248 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    249 U0059		       00 19	   CONTEXTLEN equ	CONTEXTEND - CONTEXT + 1	; length of the context plus the status byte
    250 U0059
    251 U0059		       00 00	   dpl	      ds	2	; Used as a pointer to call il instructions
    252 U005b							;
    253 U005b							; This is zero if in immediate mode, or non-zero
    254 U005b							; if currently running a program.  Any input from
    255 U005b							; the main loop clears this, and the XFER IL
    256 U005b							; statement will set it.
    257 U005b							;
    258 U005b		       00	   RunMode    ds	1	;Basic program is running or stop
    259 U005c							;
    260 U005c							; Used for line insertion/removal.
    261 U005c							;
    262 U005c		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    263 U005e
    264 U005e							; THE ADDRESS USED BY THE PRINTER FUNCTION
    265 U005e							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    266 U005e							;
    267 U005e		       00 00	   PrtFrom    ds	2	; FROM
    268 U0060
    269 U0060							;
    270 U0060							;=====================================================
    271 U0060							;
    272  3750 ????				      SEG	Code
    273  0200					      org	$0200
    274  0200							;
    275  0200							; Cold start is at $0200.  Warm start is at $0203.
    276  0200							;
    277  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    278  0203		       4c 6f 02    warm       jmp	warm2	;Entry point for worm restart
    279  0206							;
    280  0206							; These are the user-supplied vectors to I/O routines.
    281  0206							; If you want, you can just patch these in the binary
    282  0206							; file, but it would be better to change the source
    283  0206							; code.
    284  0206							;
    285  0206				  -	      if	KIM
    286  0206				  -OUTCH      jmp	$1ea0	;output char in A
    287  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    288  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    289  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    290  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    291  0206					      endif
    292  0206				  -	      if	XKIM
    293  0206				  -	      include	"xkim.inc"
    294  0206				  -	      SEG	Code
    295  0206				  -OUTCH      jmp	$1ea0
    296  0206				  -GETCH      jmp	xkGETCH
    297  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    298  0206				  -OUTHEX     jmp	xkPRTBYT
    299  0206				  -MONITOR    jmp	extKIM
    300  0206				  -puts       equ	putsil
    301  0206				  -BUFFER_SIZE equ	132
    302  0206					      endif
    303  0206
    304  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0060					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    306 Udf8e
    307  0206					      SEG	Code
    308  0206							;
    309  0206		       f0 0c	   OUTCH      equ	cout
    310  0206		       f0 09	   GETCH      equ	cin
    311  0206		       2e 39	   CRLF       equ	tbcrlf
    312  0206		       21 63	   OUTHEX     equ	HexToOut
    313  0206		       f0 03	   MONITOR    equ	WARM
    314  0206		       f0 0f	   ISCHAR     equ	cstatus
    315  0206		       21 80	   puts       equ	tbputs
    316  0206					      endif
    317  0206							;
    318  0206		       20 82 2f    cold2      jsr	SetOutConsole
    319  0209		       20 8f 2f 	      jsr	SetInConsole
    320  020c		       20 80 21 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.1.40"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.1.40"
      0  022e					      db	CR,LF,0
      1  022e		       0d 0a 00 	      .byte.b	CR,LF,0
    324  0231							;
    325  0231		       20 6f 23 	      jsr	MemInit	;setup the free space available
    326  0234
    327  0234		       a9 01	   calcstack  lda	#1
    328  0236		       8d a2 38 	      sta	taskCounter	; Initialize number of tasks to 1
    329  0239		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    330  023b		       8d a4 37 	      sta	taskTable	; mark the main task as active
    331  023e		       20 b8 26 	      jsr	taskSetStacks	; setup all the task stacks/Variables, Init task io block
    332  0241		       a9 c9		      lda	#IL&$ff
    333  0243		       85 43		      sta	ILPC
    334  0245		       a9 32		      lda	#IL>>8
    335  0247		       85 44		      sta	ILPC+1
    336  0249							;
    337  0249							;		  lda	  ProgramStart		     ; user prog
    338  0249							;		  sta	  ProgramEnd
    339  0249							;		  lda	  ProgramStart+1
    340  0249							;		  sta	  ProgramEnd+1
    341  0249							;
    342  0249
    343  0249							;  Init time slices defaults
    344  0249		       a9 02		      lda	#TASKCYCLESHIGH
    345  024b		       8d a1 38 	      sta	taskResetValue+1
    346  024e		       a9 ff		      lda	#TASKCYCLESDEFAULT
    347  0250		       8d a0 38 	      sta	taskResetValue
    348  0253							;
    349  0253							; Initialize the pseudo-random number sequence...
    350  0253							;
    351  0253		       a9 5a		      lda	#$5a
    352  0255		       8d 0c 44 	      sta	rtemp1
    353  0258		       a9 9d		      lda	#%10011101
    354  025a		       8d 0e 44 	      sta	random
    355  025d		       a9 5b		      lda	#%01011011
    356  025f		       8d 0f 44 	      sta	random+1
    357  0262							;
    358  0262							;   Insert a Basic irq handler for the basic Language
    359  0262		       a9 fb		      lda	#ServiceIrq&$ff
    360  0264		       8d 00 df 	      sta	IRQvec
    361  0267		       a9 19		      lda	#ServiceIrq>>8
    362  0269		       8d 01 df 	      sta	IRQvec+1
    363  026c		       4c 82 02 	      jmp	coldtwo
    364  026f
    365  026f							;
    366  026f							;
    367  026f							; This is the warm start entry point
    368  026f							;
    369  026f		       20 82 2f    warm2      jsr	SetOutConsole
    370  0272		       20 8f 2f 	      jsr	SetInConsole
    371  0275		       20 39 2e 	      jsr	CRLF
    372  0278		       ad 09 44 	      lda	errGoto
    373  027b		       85 43		      sta	ILPC
    374  027d		       ad 0a 44 	      lda	errGoto+1
    375  0280		       85 44		      sta	ILPC+1
    376  0282							;
    377  0282							; And continue with both starts here
    378  0282							;
    379  0282				   coldtwo
    380  0282							;
    381  0282							; The ILTrace flag is now run-time settable.
    382  0282							;
    383  0282		       a9 00		      lda	#ILTRACE&$ff
    384  0284		       85 40		      sta	ILTrace
    385  0286							;
    386  0286
    387  0286		       a9 00		      lda	#0
    388  0288		       85 5b		      sta	RunMode
    389  028a		       8d 7f 43 	      sta	LINBUF
    390  028d
    391  028d							; Clear everything from the stacks
    392  028d
    393  028d		       8d 16 44 	      sta	taskIOPending	; No one waiting for io
    394  0290		       8d 17 44 	      sta	taskRDPending	; No one waiting for bg io
    395  0293
    396  0293		       20 34 27 	      jsr	taskReset
    397  0296							;
    398  0296		       a9 7f		      lda	#LINBUF&$ff
    399  0298		       85 4f		      sta	CURPTR
    400  029a		       a9 43		      lda	#LINBUF>>8
    401  029c		       85 50		      sta	CURPTR+1	;fall through...
    402  029e
    403  029e							;=====================================================
    404  029e							; This is the top of the IL interpreter.  This fetches
    405  029e							; and executes the instruction currently pointed to
    406  029e							; by ILPC and adjusts ILPC to point to the next
    407  029e							; instruction to execute.
    408  029e							;
    409  029e				   NextIL
    410  029e		       ba		      tsx		; Get the stack pointer value
    411  029f		       e0 ff		      cpx	#$FF	; Should be empty
    412  02a1		       d0 29		      bne	ILbad	; Halt and catch fire now!
    413  02a3
    414  02a3		       ce 9e 38 	      dec	taskCurrentCycles
    415  02a6		       d0 03		      bne	NextIlNow
    416  02a8		       20 5d 27 	      jsr	iTaskSwitch	;check for a task switch
    417  02ab		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    418  02ad		       f0 03		      beq	NextIL2	;Skip if no bits set
    419  02af
    420  02af		       20 cc 2e 	      jsr	dbgLine	;Print the IL trace information
    421  02b2
    422  02b2		       a4 51	   NextIL2    ldy	CUROFF
    423  02b4							;		  jsr	  SkipSpaces	       ; no longer needed as tokenizer takes care of this
    424  02b4							;		  sty	  CUROFF
    425  02b4							;Task IO Management
    426  02b4		       ad 17 44 	      lda	taskRDPending	; if it is zero then Nothing pending
    427  02b7		       f0 08		      beq	NextILStr
    428  02b9		       20 72 2c 	      jsr	ReadLine	; else Pending and poll keyboard
    429  02bc		       90 03		      bcc	NextILStr	; if carry is clear then no end of line yet
    430  02be		       ce 17 44 	      dec	taskRDPending	; Carry is set if CR has been recieved
    431  02c1							;
    432  02c1		       20 f5 2a    NextILStr  jsr	getILByte
    433  02c4							;
    434  02c4							; When the handler is called, these are the conditions
    435  02c4							; of several important items:
    436  02c4							;
    437  02c4							;    (ILPC) will point to the byte AFTER the IL
    438  02c4							;    opcode being executed.
    439  02c4							;
    440  02c4							;    (CURPTR),CUROFF will point to the start of the
    441  02c4							;    next word in the input buffer.  Ie, the next word
    442  02c4							;    in the user program.
    443  02c4							;
    444  02c4		       18		      clc		; Clear carry before shift
    445  02c5		       0a		      asl		; valid for 0-127
    446  02c6		       b0 04		      bcs	ILbad	; Out of range
    447  02c8		       aa		      tax		; Move value to x
      0  02c9					      db	$7c	; jmp (ILTBL,X) ; dasm does not support 65c02 inst
      1  02c9		       7c		      .byte.b	$7c
      0  02ca					      dw	ILTBL	; Actual IL table address
      1  02ca		       0d 03		      .word.w	ILTBL
    450  02cc
    451  02cc							;		asl
    452  02cc							;		cmp	#ILTBLend-ILTBL+2
    453  02cc							;		bcc	ILgood
    454  02cc							;
    455  02cc							; This handles an illegal IL opcode.  This is serious
    456  02cc							; and there's no way to recover.
    457  02cc							;
    458  02cc				   iBadOP
    459  02cc		       20 80 21    ILbad      jsr	puts
      0  02cf					      db	CR,LF
      1  02cf		       0d 0a		      .byte.b	CR,LF
      0  02d1					      db	"Illegal IL "
      1  02d1		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02dc					      db	0
      1  02dc		       00		      .byte.b	0
    463  02dd							;
    464  02dd							; Well this is awkward, we need to back up the IL
    465  02dd							; by one since it no longer points to the current
    466  02dd							; opcode.
    467  02dd							;
    468  02dd		       20 02 2b 	      jsr	decIL
    469  02e0							;
    470  02e0		       a0 00		      ldy	#0
    471  02e2		       b1 43		      lda	(ILPC),y
    472  02e4		       20 63 21 	      jsr	OUTHEX
    473  02e7		       20 80 21 	      jsr	puts
      0  02ea					      db	" at ",0
      1  02ea		       20 61 74 20*	      .byte.b	" at ",0
    475  02ef		       a5 44		      lda	ILPC+1
    476  02f1		       20 63 21 	      jsr	OUTHEX
    477  02f4		       a5 43		      lda	ILPC
    478  02f6		       20 63 21 	      jsr	OUTHEX
    479  02f9		       20 39 2e 	      jsr	CRLF
    480  02fc		       4c 03 f0 	      jmp	MONITOR
    481  02ff							;
    482  02ff							; Just jump to the address (ILPC),y.  Have to do
    483  02ff							; some goofy stuff.
    484  02ff							;
    485  02ff		       a8	   ILgood     tay		;move index into Y
    486  0300		       b9 0d 03 	      lda	ILTBL,y
    487  0303		       85 59		      sta	dpl
    488  0305		       b9 0e 03 	      lda	ILTBL+1,y
    489  0308		       85 5a		      sta	dpl+1
    490  030a		       6c 59 00 	      jmp	(dpl)	;go to handler
    491  030d							;
    492  030d							;=====================================================
    493  030d							; This is the IL jump table.  The IL opcode is
    494  030d							; mulitplied by two, then looked-up in this table.
    495  030d							; There is absolutely nothing special about the order
    496  030d							; of entries here... they all decode at exactly the
    497  030d							; same speed.	However the entry number must match the
    498  030d							; values in IL.inc.
    499  030d							;
    500  030d				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  030d					      include	"ilvectortable.asm"
      1  030d					      seg	Code
      2  030d				   ILTBL1
      0  030d					      dw	iXINIT	;0  Initialize the IL
      1  030d		       45 04		      .word.w	iXINIT
      0  030f					      dw	iDONE	;1  Verify nothing left on statement line, return error if is
      1  030f		       62 04		      .word.w	iDONE
      0  0311					      dw	iPRS	;2  Print string until closing quote
      1  0311		       79 04		      .word.w	iPRS
      0  0313					      dw	iPRN	;3  Pop the top off the stack and print it as a signed decimal number.
      1  0313		       81 04		      .word.w	iPRN
      0  0315					      dw	iSPC	;4  Space to next zone. Otherwise print a tab
      1  0315		       8a 04		      .word.w	iSPC
      0  0317					      dw	iNLINE	;5  Print a newline
      1  0317		       31 09		      .word.w	iNLINE
      0  0319					      dw	iNXT	;6  CMD MODE: Jump inst following NXT inst., Else move to next line of user code
      1  0319		       92 04		      .word.w	iNXT
      0  031b					      dw	iXFER	;7  Get line number from top of stack, transfer to it or next higher if not found
      1  031b		       d4 04		      .word.w	iXFER
      0  031d					      dw	iSAV	;8  Save a pointer to the next basic code line to the CAll stack
      1  031d		       f2 04		      .word.w	iSAV
      0  031f					      dw	iRSTR	;9  Return from gosub or function, pops the line pointer from stack and sets pc
      1  031f		       37 25		      .word.w	iRSTR
      0  0321					      dw	iCMPR	;10 Compares top two entries on stach an pushes true or false onto stack, stack enries expected = val1, cmp type, val2
      1  0321		       38 05		      .word.w	iCMPR
      0  0323					      dw	iINNUM	;11 Read line of text, convert to number and puch onto stack
      1  0323		       b7 05		      .word.w	iINNUM
      0  0325					      dw	iFIN	;12 Stop program, enter command mode
      1  0325		       ef 05		      .word.w	iFIN
      0  0327					      dw	iERR	;13 Print error code, stop program, enter command mode
      1  0327		       03 06		      .word.w	iERR
      0  0329					      dw	iADD	;14 Add the two value at top of stack push answer to top of stack
      1  0329		       8c 06		      .word.w	iADD
      0  032b					      dw	iSUB	;15
      1  032b		       a2 06		      .word.w	iSUB
      0  032d					      dw	iNEG	;16
      1  032d		       b8 06		      .word.w	iNEG
      0  032f					      dw	iMUL	;17
      1  032f		       d0 06		      .word.w	iMUL
      0  0331					      dw	iDIV	;18
      1  0331		       10 07		      .word.w	iDIV
      0  0333					      dw	iSTORE	;19 Pops two entries off stack, first is value, second is address where to store it
      1  0333		       68 07		      .word.w	iSTORE
      0  0335					      dw	iIND	;20 Indirect fetch, byte or word, pop address from stack, use address to get value and push onto stack
      1  0335		       86 07		      .word.w	iIND
      0  0337					      dw	iLST	;21 List the current user program in memory
      1  0337		       27 08		      .word.w	iLST
      0  0339					      dw	iINIT	;22 Initialize the IL virtual machine
      1  0339		       0d 04		      .word.w	iINIT
      0  033b					      dw	iGETLINE	;23 Read a line from the terminal, terminate with a null byte
      1  033b		       5d 08		      .word.w	iGETLINE
      0  033d					      dw	iINSRT	;24 Insert a line of user code into a program at correct location
      1  033d		       7a 08		      .word.w	iINSRT
      0  033f					      dw	iRTN	;25 POP value from IL stack and place into ip program counter, then continue executing from there
      1  033f		       2b 09		      .word.w	iRTN
      0  0341					      dw	MONITOR	;26 Exit basic and return to system monitor
      1  0341		       03 f0		      .word.w	MONITOR
      0  0343					      dw	iLIT	;27 Push a literal value onto the math stack
      1  0343		       55 09		      .word.w	iLIT
      0  0345					      dw	iCALL	;28 Call and IL function, push nextil onto il stach and branch to provided address
      1  0345		       37 09		      .word.w	iCALL
      0  0347					      dw	iJMP	;29 Immeadiate jump to provided address
      1  0347		       43 09		      .word.w	iJMP
      0  0349					      dw	iVINIT	;30 Initialize all variables for a single task.  Ie, set to zero. And internal stack pointers
      1  0349		       7a 09		      .word.w	iVINIT
      0  034b					      dw	iERRGOTO	;31 Sets the error HAndler Address
      1  034b		       83 09		      .word.w	iERRGOTO
      0  034d					      dw	iTST	;32 compare string, if match continue else jump to provided address
      1  034d		       8f 09		      .word.w	iTST
      0  034f					      dw	iTSTV	;33 Test if next is a variable name, if it is then continue, else branch to provided address
      1  034f		       b4 0a		      .word.w	iTSTV
      0  0351					      dw	iTSTL	;34 Test for valid line number and leave it in r0, branch to provided address if not
      1  0351		       5a 0b		      .word.w	iTSTL
      0  0353					      dw	iTSTN	;35 Check for number, if it is then convert push onto math stack and continue, if not then branch to provided address
      1  0353		       75 0b		      .word.w	iTSTN
      0  0355					      dw	iFREE	;36 Push the number of free bytes available for user programs into the math stack
      1  0355		       2e 0c		      .word.w	iFREE
      0  0357					      dw	iRANDOM	;37 push a random number onto the math stack
      1  0357		       34 0c		      .word.w	iRANDOM
      0  0359					      dw	iABS	;38 pop math stack, push asbsolute value onto stack
      1  0359		       05 0d		      .word.w	iABS
     42  035b							;
     43  035b							; Disk functions.  There must be pointers
     44  035b							; to functions even if no disk is supported.
     45  035b							; Makes things easier in IL.inc.
     46  035b							; Life, universe, everything(hitch hiker)
     47  035b							; Did you remember your towel?
     48  035b					      if	DISK_ACCESS
      0  035b					      dw	iOPENREAD	;39  OPen a file for reading
      1  035b		       db 30		      .word.w	iOPENREAD
      0  035d					      dw	iOPENWRITE	;40  Open a file for writing
      1  035d		       3c 31		      .word.w	iOPENWRITE
      0  035f					      dw	iDCLOSE	;41  Close an open file
      1  035f		       d0 31		      .word.w	iDCLOSE
      0  0361					      dw	iDGETLINE	;42  Read a line from an open file
      1  0361		       5e 31		      .word.w	iDGETLINE
      0  0363					      dw	iDLIST	;43  List the content of the user program to an open disk file... basically save
      1  0363		       ca 31		      .word.w	iDLIST
      0  0365					      dw	iDDIR	;44  List the content of the directory on disk
      1  0365		       a5 31		      .word.w	iDDIR
      0  0367					      dw	iRMFILE	;45  Delete as file from disk
      1  0367		       2a 31		      .word.w	iRMFILE
     56  0369				  -	      else
     57  0369				  -	      dw	NextIL	;39
     58  0369				  -	      dw	NextIL	;40
     59  0369				  -	      dw	NextIL	;41
     60  0369				  -	      dw	NextIL	;42
     61  0369				  -	      dw	NextIL	;43
     62  0369				  -	      dw	NextIL	;44
     63  0369				  -	      dw	NextIL	;45
     64  0369					      endif
     65  0369							;
      0  0369					      dw	iCLEARSCREEN	;46	   Clear the terminal of text
      1  0369		       9c 2f		      .word.w	iCLEARSCREEN
      0  036b					      dw	iPOKEMEMORY	;47	   Put a byte value into memory location, pop value from stack, pop memory address from stack.
      1  036b		       92 0c		      .word.w	iPOKEMEMORY
      0  036d					      dw	iPEEKMEMORY	;48	   Get a byte from memory, pop memory address from stack
      1  036d		       a7 0c		      .word.w	iPEEKMEMORY
      0  036f					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  036f		       d6 09		      .word.w	iTSTLET
      0  0371					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  0371		       5b 0a		      .word.w	iTSTDONE
      0  0373					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  0373		       d4 0c		      .word.w	iGETCHAR
      0  0375					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  0375		       e8 0c		      .word.w	iPUTCHAR
      0  0377					      dw	iCallFunc	;53	   call a machine func rtn accumulator
      1  0377		       bd 0c		      .word.w	iCallFunc
      0  0379					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  0379		       85 05		      .word.w	iBranch
      0  037b					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  037b		       b9 09		      .word.w	iTSTStr
      0  037d					      dw	iSetIrq	;56	   sets the irq handler
      1  037d		       ac 0d		      .word.w	iSetIrq
      0  037f					      dw	iTstIrq	;57	   test if irq is pending
      1  037f		       ec 0b		      .word.w	iTstIrq
      0  0381					      dw	iRET	;58	   return from interupt
      1  0381		       26 05		      .word.w	iRET
      0  0383					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  0383		       d0 05		      .word.w	iINSTR
      0  0385					      dw	iMOD	;60	   returns remainder of division
      1  0385		       19 07		      .word.w	iMOD
      0  0387					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  0387		       b1 27		      .word.w	iTaskSet
      0  0389					      dw	iETask	;62	   Terminates a task
      1  0389		       ee 28		      .word.w	iETask
      0  038b					      dw	iNTask	;63	   goto next task
      1  038b		       a1 28		      .word.w	iNTask
     84  038d				   ILTBL2
      0  038d					      dw	iArray	;64	   Allow Variable to have a subscript
      1  038d		       a5 07		      .word.w	iArray
      0  038f					      dw	iTaskKill	;65	   kill a running task
      1  038f		       99 28		      .word.w	iTaskKill
      0  0391					      dw	iTaskStat	;66	   return the state of a task PID
      1  0391		       6d 28		      .word.w	iTaskStat
      0  0393					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  0393		       f3 0c		      .word.w	iHexOut
      0  0395					      dw	iReadComplete	;68	   Called after a background read completes
      1  0395		       a1 05		      .word.w	iReadComplete
      0  0397					      dw	iReadStart	;69	   Called to start a background read request
      1  0397		       97 05		      .word.w	iReadStart
      0  0399					      dw	iStartIO	;70	   Lock task until io complete
      1  0399		       d1 28		      .word.w	iStartIO
      0  039b					      dw	iEndIO	;71	   release task lock for io
      1  039b		       d7 28		      .word.w	iEndIO
      0  039d					      dw	iLogNot	;72	   Logical not
      1  039d		       5e 0d		      .word.w	iLogNot
      0  039f					      dw	iLogOr	;73	   Logical Or
      1  039f		       34 0d		      .word.w	iLogOr
      0  03a1					      dw	iLogAnd	;74	   Logical And
      1  03a1		       1f 0d		      .word.w	iLogAnd
      0  03a3					      dw	iLogXor	;75	   Logical Xor
      1  03a3		       49 0d		      .word.w	iLogXor
      0  03a5					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03a5		       ac 28		      .word.w	iWTASK
      0  03a7					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03a7		       e2 28		      .word.w	iTASKPID
      0  03a9					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03a9		       ea 0d		      .word.w	iTRACEPROG
      0  03ab					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03ab		       46 2e		      .word.w	idbgBasic
      0  03ad					      dw	iIPCS	;80	   Sending a msg to a task
      1  03ad		       ce 29		      .word.w	iIPCS
      0  03af					      dw	iIPCR	;81	   Recieve a message from a task
      1  03af		       e5 29		      .word.w	iIPCR
      0  03b1					      dw	iIPCC	;82	   Check if any message available for task
      1  03b1		       f9 29		      .word.w	iIPCC
      0  03b3					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03b3		       06 2a		      .word.w	iIPCIO
      0  03b5					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03b5		       9d 24		      .word.w	iPushMathStack
      0  03b7					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03b7		       cd 24		      .word.w	iPopMathStack
      0  03b9					      dw	iSaveMathStack	;86	   Save all math info
      1  03b9		       ea 24		      .word.w	iSaveMathStack
      0  03bb					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03bb		       09 25		      .word.w	iRestoreMathStack
      0  03bd					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03bd		       ba 24		      .word.w	iIncParmCount
      0  03bf					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03bf		       0e 29		      .word.w	iTaskGetMathStack
      0  03c1					      dw	iTaskEnable	;90	   enable a suspended task
      1  03c1		       3b 28		      .word.w	iTaskEnable
      0  03c3					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03c3		       55 28		      .word.w	iTaskSuspend
      0  03c5					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03c5		       28 29		      .word.w	iTaskPutMathPtr
      0  03c7					      dw	iTSTVT	;93	   test for another tasks variable
      1  03c7		       ab 0a		      .word.w	iTSTVT
      0  03c9					      dw	iSetR2	;94	   Set the Working register R2 to a value
      1  03c9		       4d 09		      .word.w	iSetR2
      0  03cb					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03cb		       04 05		      .word.w	iStk2Tmp
      0  03cd					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03cd		       15 05		      .word.w	iTmp2Stk
      0  03cf					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03cf		       f7 09		      .word.w	iTSTBYTE
      0  03d1					      dw	iINCVAR	;98	   Increment variable
      1  03d1		       7d 0a		      .word.w	iINCVAR
      0  03d3					      dw	iDECVAR	;99	   Decrement variable
      1  03d3		       95 0a		      .word.w	iDECVAR
      0  03d5					      dw	iSLICE	;100	   set the time slice for tasks
      1  03d5		       61 29		      .word.w	iSLICE
      0  03d7					      dw	iTSTB	;101	   Test if byte equals
      1  03d7		       16 0a		      .word.w	iTSTB
      0  03d9					      dw	iTSTW	;102	   Test If word equals
      1  03d9		       31 0a		      .word.w	iTSTW
      0  03db					      dw	iOnGoto	;103	   Branch to table entry based upon buffer value
      1  03db		       19 1f		      .word.w	iOnGoto
      0  03dd					      dw	iTSTRELOP	;104	   Test relop, push mask onto stack if true, branch otherwise
      1  03dd		       4a 1f		      .word.w	iTSTRELOP
      0  03df					      dw	iRepeatLine	;105	   Repeat the same line again, start execution from beginning of the same line
      1  03df		       b8 04		      .word.w	iRepeatLine
      0  03e1					      dw	iTSTBRANCH	;106	   Test for compiled branch, take branch if is, skip two bytes and following integer value(line number) goto, gosub, gofn
      1  03e1		       71 1f		      .word.w	iTSTBRANCH
      0  03e3					      dw	iFastXfer	;107	   move top of stack to curptr
      1  03e3		       bf 04		      .word.w	iFastXfer
      0  03e5					      dw	iSetTerminal	;108	   Set the Io Terminal to be used by print and input statements
      1  03e5		       1e 30		      .word.w	iSetTerminal
      0  03e7					      dw	iINDB	;109	   fetch a single byte from memory indirect
      1  03e7		       93 07		      .word.w	iINDB
      0  03e9					      dw	iSetBlock	;110	   Set a block or words or byte to a value 16 bit length
      1  03e9		       c4 23		      .word.w	iSetBlock
      0  03eb					      dw	iCopyBlock	;111	   Copy a block or memory from one location to another 16 bit length
      1  03eb		       1a 24		      .word.w	iCopyBlock
      0  03ed					      dw	iCmpBlock	;112	   Compare to parts of memory
      1  03ed		       4e 24		      .word.w	iCmpBlock
      0  03ef					      dw	iShift	;113	   Shift left 0 or right 1 as parameters
      1  03ef		       82 0d		      .word.w	iShift
      0  03f1					      dw	iTimer	;114	   Start/Stop/Set timer and enable disable system irq
      1  03f1		       33 19		      .word.w	iTimer
    136  03f3
      0  03f3					      dw	iJmpEnd	;115	   Point PC to end of Block if top of math stack is true(0)
      1  03f3		       38 26		      .word.w	iJmpEnd
      0  03f5					      dw	iJmpStart	;116	   Point the PC to beginning of block in stack
      1  03f5		       5e 26		      .word.w	iJmpStart
      0  03f7					      dw	iBeginBlock	;117	   Puts an entry onto the gosub stack for some type of block
      1  03f7		       bc 25		      .word.w	iBeginBlock
      0  03f9					      dw	iIfTrue	;118	   Pops the top off math stack and branches if true
      1  03f9		       91 26		      .word.w	iIfTrue
      0  03fb					      dw	iIfFalse	;119	   Pops the top off math stack and branches if false
      1  03fb		       a3 26		      .word.w	iIfFalse
      0  03fd					      dw	iBadOP	;120	   Invalid IL op code
      1  03fd		       cc 02		      .word.w	iBadOP
      0  03ff					      dw	iBadOP	;121	   Invalid IL op code
      1  03ff		       cc 02		      .word.w	iBadOP
      0  0401					      dw	iBadOP	;122	   Invalid IL op code
      1  0401		       cc 02		      .word.w	iBadOP
      0  0403					      dw	iBadOP	;123	   Invalid IL op code
      1  0403		       cc 02		      .word.w	iBadOP
      0  0405					      dw	iBadOP	;124	   Invalid IL op code
      1  0405		       cc 02		      .word.w	iBadOP
      0  0407					      dw	iBadOP	;125	   Invalid IL op code
      1  0407		       cc 02		      .word.w	iBadOP
      0  0409					      dw	iBadOP	;126	   Invalid IL op code
      1  0409		       cc 02		      .word.w	iBadOP
      0  040b					      dw	iBadOP	;127	   Invalid IL op code
      1  040b		       cc 02		      .word.w	iBadOP
------- FILE mytb.asm
    502  040b		       04 0d	   ILTBLend   equ	*
    503  040d
    504  040d							;
    505  040d							;=====================================================
    506  040d							;=====================================================
    507  040d							;=====================================================
    508  040d							; This marks the start of the handlers for IL opcodes.
    509  040d							;=====================================================
    510  040d							;=====================================================
    511  040d							;=====================================================
    512  040d							;
    513  040d							;
    514  040d		       a9 00	   iINIT      lda	#0	; clear IL stack pointer,gosub stack
    515  040f		       85 47		      sta	ILSTACKPTR
    516  0411		       85 4a		      sta	MATHSTACKPTR
    517  0413		       85 4d		      sta	GOSUBSTACKPTR
    518  0415		       a9 38		      lda	#[[GOSUBSTACKSIZE - 2] * 4]	; Reserve two entries for gosubs
    519  0417		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    520  0419							;
    521  0419		       ad 1c 44 	      lda	ProgramStart	; user prog
    522  041c		       85 4f		      sta	CURPTR
    523  041e		       8d a5 37 	      sta	taskTable+1
    524  0421		       8d 1e 44 	      sta	ProgramEnd
    525  0424		       ad 1d 44 	      lda	ProgramStart+1
    526  0427		       85 50		      sta	CURPTR+1
    527  0429		       8d a6 37 	      sta	taskTable+2
    528  042c		       8d 1f 44 	      sta	ProgramEnd+1
    529  042f		       a9 80		      lda	#TASKACTIVE
    530  0431		       8d a4 37 	      sta	taskTable	;Mark the first slot as active
    531  0434		       a9 01		      lda	#1
    532  0436		       8d a2 38 	      sta	taskCounter	;there is always one task / Main task
    533  0439		       ad a0 38 	      lda	taskResetValue
    534  043c		       8d 9e 38 	      sta	taskCurrentCycles	; set up the task switch counts
    535  043f		       ad a1 38 	      lda	taskResetValue+1
    536  0442		       8d 9f 38 	      sta	taskCurrentCycles+1
    537  0445							;
    538  0445							; fall into XINIT...
    539  0445							;
    540  0445							;=====================================================
    541  0445							; This initializes for the start of the next line of
    542  0445							; BASIC text.
    543  0445							;
    544  0445		       78	   iXINIT     sei		; ensure interupts are off
    545  0446		       20 34 27 	      jsr	taskReset	; Clear the task table
    546  0449		       a9 00		      lda	#0	; Clear the irq flags
    547  044b		       8d 80 19 	      sta	IRQPending	; reset the irq pending
    548  044e		       8d 7f 19 	      sta	IRQStatus	; Make sure irqs are off
    549  0451
    550  0451		       4c 9e 02    goodExit   jmp	NextIL
    551  0454							;
    552  0454							;=====================================================
    553  0454							; This check if the escape key has been entered
    554  0454							; then changes out of run mode. z Set if esc found
    555  0454				   BreakSet
    556  0454		       20 0f f0 	      jsr	ISCHAR
    557  0457		       f0 06		      beq	BreakNo
    558  0459		       20 20 1a 	      jsr	VGETCH
    559  045c		       c9 1b		      cmp	#$1B
    560  045e		       60		      rts
    561  045f				   BreakNo
    562  045f		       a9 01		      lda	#1
    563  0461		       60		      rts
    564  0462
    565  0462							;
    566  0462
    567  0462							;=====================================================
    568  0462							; Verify there is nothing else on this input line.
    569  0462							; If there is, generate an error.
    570  0462							;
    571  0462		       a4 51	   iDONE      ldy	CUROFF
    572  0464		       b1 4f		      lda	(CURPTR),y
    573  0466		       f0 0e		      beq	doneadv
    574  0468		       c9 e6		      cmp	#oColon	; is it a  ':' or eol
    575  046a		       d0 03		      bne	idoneErr
    576  046c							;		  sty	  CUROFF
    577  046c		       4c 9e 02 	      jmp	NextIL	; continue on this line
    578  046f
    579  046f				   idoneErr
    580  046f		       a2 04		      ldx	#ERR_EXTRA_STUFF
    581  0471		       a9 00		      lda	#0
    582  0473		       4c 6a 06 	      jmp	iErr2
    583  0476							;
    584  0476							; Advance to the next line
    585  0476							;
    586  0476				   doneadv
    587  0476		       4c 9e 02 	      jmp	NextIL
    588  0479							;
    589  0479							;=====================================================
    590  0479							; Print the string until a closing quote
    591  0479							;
    592  0479				   iPRS
    593  0479		       20 a3 21 	      jsr	PrtQuoted
    594  047c		       84 51		      sty	CUROFF
    595  047e		       4c 9e 02 	      jmp	NextIL
    596  0481							;
    597  0481							;=====================================================
    598  0481							; Pop the top off the stack and print it as a signed
    599  0481							; decimal number.
    600  0481							;
    601  0481				   iPRN
    602  0481		       20 80 2d 	      jsr	popR0
    603  0484		       20 af 20 	      jsr	PrintDecimal
    604  0487		       4c 9e 02 	      jmp	NextIL
    605  048a							;
    606  048a							;=====================================================
    607  048a							; Space to next zone.	Currently the code does not
    608  048a							; keep track of which column the output is on, so
    609  048a							; just print a tab.
    610  048a							;
    611  048a				   iSPC
    612  048a		       a9 09		      lda	#TAB
    613  048c		       20 1d 1a 	      jsr	VOUTCH
    614  048f		       4c 9e 02 	      jmp	NextIL
    615  0492							;
    616  0492							;=====================================================
    617  0492							; If in immediate mode, jump to the address following
    618  0492							; the NXT instruction.  Else move to the next line of
    619  0492							; user code and continue.
    620  0492							;
    621  0492		       a5 5b	   iNXT       lda	RunMode
    622  0494		       d0 03		      bne	iNxtRun	;in run mode
    623  0496							;
    624  0496							; Get address and jump to it.
    625  0496							;
    626  0496		       4c 43 09 	      jmp	iJMP
    627  0499							;
    628  0499				   iNxtRun
    629  0499		       a4 51		      ldy	CUROFF
    630  049b		       b1 4f		      lda	(CURPTR),y
    631  049d		       c9 e6		      cmp	#oColon
    632  049f		       d0 06		      bne	iNxtRunGo
    633  04a1		       c8		      iny
    634  04a2		       84 51		      sty	CUROFF
    635  04a4		       4c b2 04 	      jmp	iNxtRun2
    636  04a7
    637  04a7				   iNxtRunGo
    638  04a7		       20 7f 2b 	      jsr	FindNextLine
    639  04aa		       20 93 2b 	      jsr	AtEnd
    640  04ad		       d0 03		      bne	iNxtRun2	;not at end
    641  04af							;
    642  04af							; At the end of the program.  Pretend an END statement
    643  04af							; was found.
    644  04af							;
    645  04af		       4c ef 05    iFINv      jmp	iFIN
    646  04b2							;
    647  04b2		       20 f1 2a    iNxtRun2   jsr	getILWord	;ignore next word
    648  04b5		       4c 9e 02 	      jmp	NextIL
    649  04b8							;=====================================================
    650  04b8							;Repeat the same line against
    651  04b8		       a0 03	   iRepeatLine ldy	#3
    652  04ba		       84 51		      sty	CUROFF
    653  04bc		       4c 9e 02 	      jmp	NextIL
    654  04bf							;
    655  04bf							;=====================================================
    656  04bf							; XFER takes the number on top of the stack and looks
    657  04bf							; for that line in the program, or the next line
    658  04bf							; higher.  Ie, if it's 1 but there is no line 1, then
    659  04bf							; find the next one after that.
    660  04bf							;
    661  04bf				   iFastXfer
    662  04bf		       20 98 2d 	      jsr	popR1	; get type of transfer
    663  04c2		       a5 54		      lda	R1
    664  04c4		       f0 0e		      beq	iXFER
    665  04c6
    666  04c6		       20 80 2d 	      jsr	popR0	; get where to transfer
    667  04c9				   FastFastXfer
    668  04c9		       a5 52		      lda	R0
    669  04cb		       85 4f		      sta	CURPTR
    670  04cd		       a5 53		      lda	R0+1
    671  04cf		       85 50		      sta	CURPTR+1
    672  04d1		       4c da 04 	      jmp	iXFER2
    673  04d4
    674  04d4				   iXFER
    675  04d4		       20 80 2d 	      jsr	popR0
    676  04d7		       20 3a 2b 	      jsr	findLine
    677  04da
    678  04da				   iXFER2
    679  04da		       20 93 2b 	      jsr	AtEnd	;at end of user program?
    680  04dd		       f0 d0		      beq	iFINv
    681  04df
    682  04df		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    683  04e1		       84 51		      sty	CUROFF
    684  04e3
    685  04e3							;		  lda	  #$ff
    686  04e3							;		  sta	  RunMode
    687  04e3							;
    688  04e3							; Transfer IL to STMT.  I don't like having this
    689  04e3							; hard-coded; fix it.
    690  04e3							;
    691  04e3							;		  lda	  #STMT&$ff
    692  04e3							;		  sta	  ILPC
    693  04e3							;		  lda	  #STMT>>8
    694  04e3							;		  sta	  ILPC+1
    695  04e3							;		  jmp	  NextIL
    696  04e3							;
    697  04e3							; Run
    698  04e3							;
    699  04e3				   iXferok
    700  04e3		       a9 ff		      lda	#$ff
    701  04e5		       85 5b		      sta	RunMode	;we're running
    702  04e7							;
    703  04e7							; Need a more elegant way to do this
    704  04e7							;
    705  04e7		       a9 d7		      lda	#STMT&$ff
    706  04e9		       85 43		      sta	ILPC
    707  04eb		       a9 32		      lda	#STMT>>8
    708  04ed		       85 44		      sta	ILPC+1
    709  04ef		       4c 9e 02 	      jmp	NextIL
    710  04f2							;
    711  04f2							;=====================================================
    712  04f2							; Save the pointer to the next line to the call stack.
    713  04f2							;
    714  04f2		       20 f5 2a    iSAV       jsr	getILByte	; load type of gosub
    715  04f5		       20 08 2d 	      jsr	pushLN	; Type passed in A
    716  04f8		       b0 03		      bcs	iSAVErr
    717  04fa		       4c 9e 02 	      jmp	NextIL
    718  04fd
    719  04fd		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    720  04ff		       a9 00	   iSAVErr2   lda	#0
    721  0501		       4c 6a 06 	      jmp	iErr2
    722  0504							;====================================================
    723  0504							; Move stack top to and from temp area
    724  0504				   iStk2Tmp
    725  0504		       20 80 2d 	      jsr	popR0
    726  0507		       a5 52		      lda	R0
    727  0509		       a0 48		      ldy	#TASKEXITCODE	; can also be used as temp
    728  050b		       91 41		      sta	(VARIABLES),y
    729  050d		       c8		      iny
    730  050e		       a5 53		      lda	R0+1
    731  0510		       91 41		      sta	(VARIABLES),y
    732  0512		       4c 9e 02 	      jmp	NextIL
    733  0515
    734  0515		       a0 48	   iTmp2Stk   ldy	#TASKEXITCODE
    735  0517		       b1 41		      lda	(VARIABLES),y
    736  0519		       85 52		      sta	R0
    737  051b		       c8		      iny
    738  051c		       b1 41		      lda	(VARIABLES),y
    739  051e		       85 53		      sta	R0+1
    740  0520		       20 ee 2c 	      jsr	pushR0
    741  0523		       4c 9e 02 	      jmp	NextIL
    742  0526							;
    743  0526							;=====================================================
    744  0526							; Pop the next line from the call stack. IRQ return
    745  0526							;
    746  0526		       20 31 2d    iRET       jsr	popLN
    747  0529		       b0 d2		      bcs	iSAVErr
    748  052b		       a0 03		      ldy	#3
    749  052d		       84 51		      sty	CUROFF
    750  052f		       a9 00		      lda	#0
    751  0531		       8d 80 19 	      sta	IRQPending
    752  0534		       58		      cli
    753  0535		       4c 9e 02 	      jmp	NextIL
    754  0538							;
    755  0538							;=====================================================
    756  0538							; Compare items on stack.  Okay, so on input there are
    757  0538							; three things on the stack
    758  0538							;
    759  0538							;    EXPR2 <- Top of stack
    760  0538							;    OP    <- relational operator, next on stack
    761  0538							;    EXPR1 <- last item on stack
    762  0538							;
    763  0538							; Comparison is: EXPR1 <operator> EXPR2
    764  0538							;
    765  0538							; Operator is one of...
    766  0538							;
    767  0538							;    2 is =
    768  0538							;    1 is <
    769  0538							;    3 is <=
    770  0538							;    5 is <>
    771  0538							;    4 is >
    772  0538							;    6 is >=
    773  0538							;
    774  0538							; Those are bit-mapped:
    775  0538							;
    776  0538							;    xxxxxGEL
    777  0538							;
    778  0538							;    G = Greater than
    779  0538							;    E = Equal
    780  0538							;    L = Less than
    781  0538							;
    782  0538							; If the comparison is false, do a NXT, ie, move to the
    783  0538							; next line and continue.  If true, continue executing
    784  0538							; on this line.
    785  0538							;
    786  0538		       00 01	   REL_LT     equ	%001
    787  0538		       00 02	   REL_EQUAL  equ	%010
    788  0538		       00 04	   REL_GT     equ	%100
    789  0538							;
    790  0538		       20 98 2d    iCMPR      jsr	popR1
    791  053b		       20 af 2d 	      jsr	popMQ	;operator in MQ
    792  053e		       20 80 2d 	      jsr	popR0
    793  0541		       20 4a 05 	      jsr	iCMPRsub
    794  0544		       20 ee 2c 	      jsr	pushR0
    795  0547		       4c 9e 02 	      jmp	NextIL
    796  054a							;
    797  054a							; See if they are equal or not
    798  054a							;
    799  054a				   iCMPRsub		; Called by internal functions
    800  054a
    801  054a		       a5 52		      lda	R0
    802  054c		       c5 54		      cmp	R1
    803  054e		       d0 0a		      bne	iCMPRnoteq	;try not equal
    804  0550		       a5 53		      lda	R0+1
    805  0552		       c5 55		      cmp	R1+1
    806  0554		       d0 04		      bne	iCMPRnoteq
    807  0556							;
    808  0556							; Equal, set the flag in MQ+1
    809  0556							;
    810  0556		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    811  0558		       d0 14		      bne	iCMPcom	;Exit it is equal
    812  055a							;
    813  055a							; See if EXPR1 (R0) < EXPR2 (R1)
    814  055a							; See www.6502.org/tutorials/compare_beyond.html
    815  055a							;
    816  055a				   iCMPRnoteq
    817  055a		       a5 52		      lda	R0
    818  055c		       c5 54		      cmp	R1	; Sets the carry flag
    819  055e		       a5 53		      lda	R0+1
    820  0560		       e5 55		      sbc	R1+1
    821  0562
    822  0562		       50 02		      bvc	iCMPR_2	; branch if N eor V
    823  0564		       49 80		      eor	#$80
    824  0566
    825  0566		       30 04	   iCMPR_2    bmi	iCMPlt
    826  0568		       a9 04		      lda	#REL_GT
    827  056a		       d0 02		      bne	iCMPcom
    828  056c
    829  056c		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    830  056e
    831  056e				   iCMPcom		;ora	    MQ+1	     ; or with original mask MQ+1 is always zero
    832  056e							;
    833  056e							; Now compare the end result with what the caller
    834  056e							; was looking for.
    835  056e							;
    836  056e		       25 56		      and	MQ
    837  0570		       f0 0c		      beq	iCMPno	; no match
    838  0572		       a9 ff		      lda	#$FF	; true is $ffff
    839  0574		       85 52		      sta	R0
    840  0576		       85 53		      sta	R0+1
    841  0578		       d0 0a		      bne	iCMPDone
    842  057a							;
    843  057a							; R0 > R1
    844  057a							;
    845  057a		       a9 04	   iCMPgt     lda	#REL_GT
    846  057c		       d0 f0		      bne	iCMPcom
    847  057e				   iCMPno
    848  057e		       a9 00		      lda	#0
    849  0580		       85 52		      sta	R0
    850  0582		       85 53		      sta	R0+1
    851  0584
    852  0584				   iCMPDone
    853  0584		       60		      rts
    854  0585
    855  0585							;
    856  0585							; if Not a match, so jump to the next line of user program code.
    857  0585							; Branches based upon value on top of the stack
    858  0585				   iBranch
    859  0585		       20 80 2d 	      jsr	popR0
    860  0588		       a5 52		      lda	R0
    861  058a		       05 53		      ora	R0+1
    862  058c		       f0 03		      beq	iBranchFalse	; not true
    863  058e		       4c 9e 02 	      jmp	NextIL	; It is true if any value not zero
    864  0591							;
    865  0591				   iBranchFalse
    866  0591		       20 7f 2b 	      jsr	FindNextLine
    867  0594		       4c da 04 	      jmp	iXFER2
    868  0597							;
    869  0597							;=====================================================
    870  0597							; Start a read of data in background
    871  0597				   iReadStart
    872  0597		       a9 3f		      lda	#'?	; Prompt with question mark
    873  0599		       a6 01		      ldx	1	; Indicate to start read in background
    874  059b		       20 0b 2c 	      jsr	GetLine	; Call the getline to start read
    875  059e		       4c 9e 02 	      jmp	NextIL	; next instruction
    876  05a1							;
    877  05a1							;=====================================================
    878  05a1							; Complete the read and return the curptr, curoff pointing to data
    879  05a1				   iReadComplete
    880  05a1		       a9 01		      lda	#GOSUB_RTN
    881  05a3		       20 08 2d 	      jsr	pushLN
    882  05a6		       90 03		      bcc	iReadOk
    883  05a8		       4c 27 0c    iReadErr   jmp	ErrStkOver	; Check if there was an error
    884  05ab				   iReadOk
    885  05ab		       20 2b 2c 	      jsr	ReadComplete
    886  05ae		       4c 9e 02 	      jmp	NextIL
    887  05b1		       20 31 2d 	      jsr	popLN
    888  05b4		       4c 9e 02 	      jmp	NextIL
    889  05b7							;=====================================================
    890  05b7							; Get a line of text from the user, convert to a
    891  05b7							; number, leave on top of stack.
    892  05b7							;
    893  05b7				   iINNUM
    894  05b7		       a9 01		      lda	#GOSUB_RTN
    895  05b9		       20 08 2d 	      jsr	pushLN
    896  05bc		       b0 ea		      bcs	iReadErr	; Stack over flow error
    897  05be							;
    898  05be		       a9 3f		      lda	#'?
    899  05c0		       a2 00		      ldx	#0	;Wait for complete
    900  05c2		       20 0b 2c 	      jsr	GetLine
    901  05c5		       20 a0 2b 	      jsr	getDecimal
    902  05c8		       20 ee 2c 	      jsr	pushR0	;put onto stack
    903  05cb		       b0 db		      bcs	iReadErr	;StackOverflow error
    904  05cd							;
    905  05cd		       4c e9 05 	      jmp	ExitIn
    906  05d0							;
    907  05d0							;=====================================================
    908  05d0							; Get a line of text from the user, convert to a
    909  05d0							; character value , leave on top of stack. up to 2 characters
    910  05d0							;
    911  05d0				   iINSTR
    912  05d0		       a9 01		      lda	#GOSUB_RTN
    913  05d2		       20 08 2d 	      jsr	pushLN
    914  05d5		       b0 d1		      bcs	iReadErr	; Stack overflow error
    915  05d7		       a9 3f		      lda	#'?
    916  05d9		       a2 00		      ldx	#0	;wait for read complete
    917  05db		       20 0b 2c 	      jsr	GetLine
    918  05de		       b1 4f		      lda	(CURPTR),y
    919  05e0		       85 52		      sta	R0
    920  05e2		       a9 00		      lda	#0
    921  05e4		       85 53		      sta	R0+1
    922  05e6		       20 ee 2c 	      jsr	pushR0	;put onto stack
    923  05e9				   ExitIn
    924  05e9		       20 31 2d 	      jsr	popLN
    925  05ec		       4c 9e 02 	      jmp	NextIL
    926  05ef							;
    927  05ef							;
    928  05ef							;=====================================================
    929  05ef							; Stop the currently running program.	Actually very
    930  05ef							; simple to do... clear the RunMode flag, then set the
    931  05ef							; ILPC to the standard handler and continue running.
    932  05ef							;
    933  05ef		       a9 00	   iFIN       lda	#0
    934  05f1		       85 5b		      sta	RunMode
    935  05f3		       20 34 27 	      jsr	taskReset
    936  05f6							;
    937  05f6		       ad 09 44 	      lda	errGoto
    938  05f9		       85 43		      sta	ILPC
    939  05fb		       ad 0a 44 	      lda	errGoto+1
    940  05fe		       85 44		      sta	ILPC+1
    941  0600		       4c 9e 02 	      jmp	NextIL
    942  0603							;
    943  0603							;=====================================================
    944  0603							; Handle the ERR opcode.  Following the instruction is
    945  0603							; a 16 bit error number.  Print an error message, and
    946  0603							; if we're in run mode, print the line number.  Stop
    947  0603							; program execution and return to the initial state.
    948  0603							;
    949  0603		       ad 16 44    iERR       lda	taskIOPending
    950  0606		       f0 03		      beq	iErrNext
    951  0608		       ce 16 44 	      dec	taskIOPending
    952  060b
    953  060b		       20 f1 2a    iErrNext   jsr	getILWord	;get err code
    954  060e		       20 14 06 	      jsr	DisplayError
    955  0611		       4c 6d 06 	      jmp	iErrComplete
    956  0614							;
    957  0614							; Enter here with the error code in X (LSB) and A (MSB).
    958  0614							;
    959  0614				   DisplayError
    960  0614		       86 52		      stx	R0
    961  0616		       85 53		      sta	R0+1
    962  0618							;
    963  0618		       20 80 21 	      jsr	puts
      0  061b					      db	CR,LF,"Error ",0
      1  061b		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
    965  0624		       20 af 20 	      jsr	PrintDecimal
    966  0627							;
    967  0627		       a5 5b		      lda	RunMode	;running?
    968  0629		       f0 3b		      beq	iERR3	;nope
    969  062b		       20 80 21 	      jsr	puts
      0  062e					      db	" at line ",0
      1  062e		       20 61 74 20*	      .byte.b	" at line ",0
    971  0638		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    972  063a				   iErr2a
    973  063a		       b1 4f		      lda	(CURPTR),y
    974  063c		       85 52		      sta	R0
    975  063e		       c8		      iny
    976  063f		       b1 4f		      lda	(CURPTR),y
    977  0641		       85 53		      sta	R0+1
    978  0643		       20 af 20 	      jsr	PrintDecimal
    979  0646		       20 80 21 	      jsr	puts
      0  0649					      db	":",0
      1  0649		       3a 00		      .byte.b	":",0
    981  064b		       a9 00		      lda	#0
    982  064d		       85 53		      sta	R0+1
    983  064f		       a5 51		      lda	CUROFF
    984  0651		       18		      clc
    985  0652		       e9 03		      sbc	#3
    986  0654		       85 52		      sta	R0
    987  0656		       20 af 20 	      jsr	PrintDecimal
    988  0659		       20 80 21 	      jsr	puts
      0  065c					      db	":",0
      1  065c		       3a 00		      .byte.b	":",0
    990  065e		       ad a3 37 	      lda	taskPtr
    991  0661		       85 52		      sta	R0
    992  0663		       20 63 21 	      jsr	HexToOut
    993  0666							;
    994  0666				   iERR3
    995  0666		       20 39 2e 	      jsr	CRLF
    996  0669		       60		      rts
    997  066a
    998  066a				   iErr2
    999  066a		       20 14 06 	      jsr	DisplayError
   1000  066d
   1001  066d				   iErrComplete
   1002  066d		       20 2c 27 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
   1003  0670		       a9 00		      lda	#0
   1004  0672		       85 5b		      sta	RunMode	; fall through...
   1005  0674							;
   1006  0674							;=====================================================
   1007  0674							; Reset the IL to be back at the idle loop.  Does not
   1008  0674							; clear variables so the user can see what state
   1009  0674							; the program is in.
   1010  0674							;
   1011  0674		       a9 00	   ResetIL    lda	#0
   1012  0676		       85 4f		      sta	CURPTR
   1013  0678		       85 51		      sta	CUROFF
   1014  067a		       85 47		      sta	ILSTACKPTR
   1015  067c		       ad 09 44 	      lda	errGoto
   1016  067f		       85 43		      sta	ILPC
   1017  0681		       ad 0a 44 	      lda	errGoto+1
   1018  0684		       85 44		      sta	ILPC+1
   1019  0686		       a2 ff		      ldx	#$FF	; make sure the stack pointer is reset
   1020  0688		       9a		      txs
   1021  0689		       4c 9e 02 	      jmp	NextIL
   1022  068c
   1023  068c							;
   1024  068c							;=====================================================
   1025  068c							; Pop two items off stack, add them, then place the
   1026  068c							; result back onto the stack.
   1027  068c							;
   1028  068c		       20 80 2d    iADD       jsr	popR0
   1029  068f		       20 98 2d 	      jsr	popR1
   1030  0692				   iADDfast
   1031  0692		       18		      clc
   1032  0693		       a5 52		      lda	R0
   1033  0695		       65 54		      adc	R1
   1034  0697		       85 52		      sta	R0
   1035  0699		       a5 53		      lda	R0+1
   1036  069b		       65 55		      adc	R1+1
   1037  069d		       85 53		      sta	R0+1
   1038  069f		       4c 0a 07 	      jmp	pushR0nextIl
   1039  06a2							;
   1040  06a2							;=====================================================
   1041  06a2							; Pop two items off the stack.  Subtract the top of
   1042  06a2							; stack from the lower entry.
   1043  06a2							;
   1044  06a2		       20 98 2d    iSUB       jsr	popR1
   1045  06a5		       20 80 2d 	      jsr	popR0
   1046  06a8		       38		      sec
   1047  06a9		       a5 52		      lda	R0
   1048  06ab		       e5 54		      sbc	R1
   1049  06ad		       85 52		      sta	R0
   1050  06af		       a5 53		      lda	R0+1
   1051  06b1		       e5 55		      sbc	R1+1
   1052  06b3		       85 53		      sta	R0+1
   1053  06b5		       4c 0a 07 	      jmp	pushR0nextIl
   1054  06b8							;
   1055  06b8							;=====================================================
   1056  06b8							; Negate the top of stack.
   1057  06b8							;
   1058  06b8		       20 80 2d    iNEG       jsr	popR0
   1059  06bb		       a5 52		      lda	R0
   1060  06bd		       49 ff		      eor	#$ff
   1061  06bf		       85 52		      sta	R0
   1062  06c1		       a5 53		      lda	R0+1
   1063  06c3		       49 ff		      eor	#$ff
   1064  06c5		       85 53		      sta	R0+1
   1065  06c7		       e6 52		      inc	R0
   1066  06c9		       d0 02		      bne	iNEG2
   1067  06cb		       e6 53		      inc	R0+1
   1068  06cd		       4c 0a 07    iNEG2      jmp	pushR0nextIl
   1069  06d0							;
   1070  06d0							;=====================================================
   1071  06d0							; Multiply top two items on the stack, put the results
   1072  06d0							; on top.  This uses the algorithm documented on page
   1073  06d0							; 115 of "Microprocessor Programming for Computer
   1074  06d0							; Hobbyists" by Neill Graham.
   1075  06d0							;
   1076  06d0		       20 d6 06    iMUL       jsr	iMultiply
   1077  06d3		       4c 9e 02 	      jmp	NextIL
   1078  06d6
   1079  06d6				   iMultiply
   1080  06d6		       20 80 2d 	      jsr	popR0	;AC
   1081  06d9		       20 98 2d 	      jsr	popR1	;OP
   1082  06dc							;
   1083  06dc		       a5 52		      lda	R0
   1084  06de		       85 56		      sta	MQ
   1085  06e0		       a5 53		      lda	R0+1
   1086  06e2		       85 57		      sta	MQ+1
   1087  06e4		       a9 00		      lda	#0	;clear result
   1088  06e6		       85 52		      sta	R0
   1089  06e8		       85 53		      sta	R0+1
   1090  06ea							;
   1091  06ea		       a2 10		      ldx	#16	;number of bits in value
   1092  06ec		       06 52	   multloop   asl	R0
   1093  06ee		       26 53		      rol	R0+1
   1094  06f0		       06 56		      asl	MQ
   1095  06f2		       26 57		      rol	MQ+1
   1096  06f4		       90 0d		      bcc	multno	;skip add if no carry
   1097  06f6							;
   1098  06f6							; Add R1 back into R0
   1099  06f6							;
   1100  06f6		       18		      clc
   1101  06f7		       a5 52		      lda	R0
   1102  06f9		       65 54		      adc	R1
   1103  06fb		       85 52		      sta	R0
   1104  06fd		       a5 53		      lda	R0+1
   1105  06ff		       65 55		      adc	R1+1
   1106  0701		       85 53		      sta	R0+1
   1107  0703							;
   1108  0703		       ca	   multno     dex		;did all bits yet?
   1109  0704		       d0 e6		      bne	multloop
   1110  0706		       20 ee 2c 	      jsr	pushR0	;OP
   1111  0709		       60		      rts
   1112  070a							;
   1113  070a				   pushR0nextIl
   1114  070a		       20 ee 2c 	      jsr	pushR0	;OP
   1115  070d		       4c 9e 02 	      jmp	NextIL
   1116  0710							;
   1117  0710							;=====================================================
   1118  0710							; Divide the top of stack into the next to top item.
   1119  0710							; Leave results on stack.  Taken from:
   1120  0710							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1121  0710							;
   1122  0710							; R0 = R0 / R1
   1123  0710							; Remainder is in MQ
   1124  0710							;
   1125  0710		       20 2a 07    iDIV       jsr	iDoDiv
   1126  0713		       20 01 2e 	      jsr	RestoreSigns
   1127  0716		       4c 0a 07 	      jmp	pushR0nextIl
   1128  0719
   1129  0719		       20 2a 07    iMOD       jsr	iDoDiv
   1130  071c		       20 01 2e 	      jsr	RestoreSigns
   1131  071f		       a5 56		      lda	MQ
   1132  0721		       85 52		      sta	R0
   1133  0723		       a5 57		      lda	MQ+1
   1134  0725		       85 53		      sta	R0+1
   1135  0727		       4c 0a 07 	      jmp	pushR0nextIl
   1136  072a
   1137  072a				   iDoDiv
   1138  072a		       20 98 2d 	      jsr	popR1
   1139  072d		       20 80 2d 	      jsr	popR0
   1140  0730							;
   1141  0730							; Check for divide by zero
   1142  0730							;
   1143  0730
   1144  0730				   iDivNoPop
   1145  0730		       a5 54		      lda	R1
   1146  0732		       05 55		      ora	R1+1
   1147  0734		       f0 29		      beq	divby0
   1148  0736							;
   1149  0736		       20 c6 2d 	      jsr	SaveSigns
   1150  0739		       a9 00		      lda	#0	;preset remainder to 0
   1151  073b		       85 56		      sta	MQ
   1152  073d		       85 57		      sta	MQ+1
   1153  073f		       a2 10		      ldx	#16	;repeat for each bit: ...
   1154  0741				   divloop
   1155  0741		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1156  0743		       26 53		      rol	R0+1
   1157  0745		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1158  0747		       26 57		      rol	MQ+1
   1159  0749		       a5 56		      lda	MQ
   1160  074b		       38		      sec
   1161  074c		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1162  074e		       a8		      tay		;lb result -> Y, for we may need it later
   1163  074f		       a5 57		      lda	MQ+1
   1164  0751		       e5 55		      sbc	R1+1
   1165  0753		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1166  0755
   1167  0755		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1168  0757		       84 56		      sty	MQ
   1169  0759		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1170  075b
   1171  075b		       ca	   skip       dex
   1172  075c		       d0 e3		      bne	divloop
   1173  075e		       60		      rts
   1174  075f							;
   1175  075f							; Indicate divide-by-zero error
   1176  075f							;
   1177  075f		       68	   divby0     pla		; remove the reyurn from the stack
   1178  0760		       68		      pla
   1179  0761		       a2 06		      ldx	#ERR_DIVIDE_ZERO	; do the error
   1180  0763		       a9 00		      lda	#0
   1181  0765		       4c 6a 06 	      jmp	iErr2
   1182  0768							;
   1183  0768							;=====================================================
   1184  0768							; This pops the top two items off the stack.  The top
   1185  0768							; item is a data value and the other is an ABSOLUTE address.
   1186  0768							; Save the value into that address.
   1187  0768							;
   1188  0768		       98	   iSTORE     tya
   1189  0769		       48		      pha
   1190  076a		       20 80 2d 	      jsr	popR0	;data
   1191  076d		       20 98 2d 	      jsr	popR1	;Storage location
   1192  0770		       a0 01		      ldy	#1
   1193  0772		       a5 58		      lda	R2
   1194  0774		       c9 a2		      cmp	#tByte
   1195  0776		       f0 04		      beq	iStoreB
   1196  0778				   iStoreW
   1197  0778		       a5 53		      lda	R0+1
   1198  077a		       91 54		      sta	(R1),y
   1199  077c				   iStoreB
   1200  077c		       a5 52		      lda	R0
   1201  077e		       88		      dey
   1202  077f		       91 54		      sta	(R1),y
   1203  0781		       68		      pla
   1204  0782		       a8		      tay
   1205  0783		       4c 9e 02 	      jmp	NextIL
   1206  0786							;
   1207  0786							;=====================================================
   1208  0786							; Replaces the top of stack with the Value
   1209  0786							; of the variable  whose absolute address it represents.
   1210  0786							;
   1211  0786
   1212  0786		       98	   iIND       tya
   1213  0787		       48		      pha
   1214  0788		       20 98 2d 	      jsr	popR1
   1215  078b		       a0 01		      ldy	#1
   1216  078d		       a5 58		      lda	R2
   1217  078f		       c9 a4		      cmp	#tInteger
   1218  0791		       f0 04		      beq	iINDW
   1219  0793				   iINDB
   1220  0793		       a9 00		      lda	#0
   1221  0795		       f0 02		      BEQ	iINDC
   1222  0797				   iINDW
   1223  0797		       b1 54		      lda	(R1),y
   1224  0799				   iINDC
   1225  0799		       85 53		      sta	R0+1
   1226  079b		       88		      dey
   1227  079c		       b1 54		      lda	(R1),y
   1228  079e		       85 52		      sta	R0
   1229  07a0		       68		      pla
   1230  07a1		       a8		      tay
   1231  07a2		       4c 0a 07 	      jmp	pushR0nextIl
   1232  07a5
   1233  07a5							;
   1234  07a5							;=====================================================
   1235  07a5							; Check which type of index to use byte or word and jmp to correct
   1236  07a5							; function
   1237  07a5		       98	   iArray     tya
   1238  07a6		       48		      pha
   1239  07a7
   1240  07a7		       20 80 2d 	      jsr	popR0	; Get the array index
   1241  07aa		       20 98 2d 	      jsr	popR1	; Get the Variable address
   1242  07ad
   1243  07ad		       20 f5 2a 	      jsr	getILByte	; Get type of number to process
   1244  07b0		       c9 81		      cmp	#GOSUB_RTN_VALUE	; Are we testing a valid parameter
   1245  07b2		       f0 52		      beq	iArrayFNparm	; process a fn pramater index
   1246  07b4
   1247  07b4		       29 fe		      and	#$FE	; Turn off the unsigned bit
   1248  07b6		       c9 a2		      cmp	#tByte	; Test for a byte index
   1249  07b8		       f0 10		      beq	iArrayB	; yes so branch to process a byte
   1250  07ba							;=====================================================
   1251  07ba							; Process 32 bit index into memory
   1252  07ba		       c9 a6	   iArrayL    cmp	#tLong	; Are we working with 32 bit integers
   1253  07bc		       d0 06		      bne	iArrayW	; Process with sigle shift
   1254  07be		       06 52		      asl	R0	; Do the multiply by 2
   1255  07c0		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1256  07c2		       b0 39		      bcs	iArrayError	; if the carry is set we have an error
   1257  07c4							;=====================================================
   1258  07c4							; Get the array index from top of stack get Current variable
   1259  07c4							; address from next on stack, add the offset
   1260  07c4							; push the result back onto the stack
   1261  07c4				   iArrayW		; pointers, arrays etc all use 16 bit unsigned integers
   1262  07c4		       06 52		      asl	R0	; Do the multiply by 2
   1263  07c6		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1264  07c8		       b0 33		      bcs	iArrayError	; if the carry is set we have an error
   1265  07ca
   1266  07ca							;=====================================================
   1267  07ca							; Get from Byte array not Integer array
   1268  07ca				   iArrayB
   1269  07ca		       18		      clc
   1270  07cb		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1271  07cd		       65 52		      adc	R0
   1272  07cf		       85 52		      sta	R0
   1273  07d1		       a5 55		      lda	R1+1
   1274  07d3		       65 53		      adc	R0+1
   1275  07d5		       85 53		      sta	R0+1	; The new Variable Address is stored in R0
   1276  07d7		       a5 55		      lda	R1+1
   1277  07d9		       cd 1f 44 	      cmp	ProgramEnd+1	; lets check if we are processing an @ buffer pointer to free memory
   1278  07dc		       d0 08		      bne	iArrayCheckVar
   1279  07de				   iArrayExit
   1280  07de		       20 ee 2c 	      jsr	pushR0	; Push R0 assume it is correct
   1281  07e1
   1282  07e1		       68		      pla
   1283  07e2		       a8		      tay
   1284  07e3		       4c 9e 02 	      jmp	NextIL
   1285  07e6							; Check for valis variable and valid index to use
   1286  07e6		       a5 41	   iArrayCheckVar lda	VARIABLES
   1287  07e8		       18		      clc
   1288  07e9		       69 33		      adc	#[25*2]+1	; the number of actual variable valid bytes
   1289  07eb		       85 56		      sta	MQ	; mq contains the last valid byte we can use
   1290  07ed		       a9 00		      lda	#0
   1291  07ef		       65 42		      adc	VARIABLES+1	; Memory past last word R0+1 > A then invalid
   1292  07f1		       c5 53		      cmp	R0+1
   1293  07f3		       90 08		      bcc	iArrayError
   1294  07f5		       a5 52		      lda	R0	; a > m invalid past last byte of variable area
   1295  07f7		       c5 56		      cmp	MQ
   1296  07f9		       f0 e3		      beq	iArrayExit	; If it is equal then it is valid
   1297  07fb		       90 e1		      bcc	iArrayExit	; if it is less it is valid
   1298  07fd
   1299  07fd							; Get here if array index is out of range
   1300  07fd		       68	   iArrayError pla
   1301  07fe		       98		      tya
   1302  07ff		       a9 00		      lda	#0
   1303  0801		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1304  0803		       4c 6a 06 	      jmp	iErr2
   1305  0806							;=====================================================
   1306  0806							; Verify function paramater index is valid
   1307  0806		       20 86 25    iArrayFNparm jsr	GosubFindParms	; Get a pointer to the current functions parameter list info
   1308  0809		       90 f2		      bcc	iArrayError	; There are no paramters for this call, should never be true
   1309  080b		       88		      dey
   1310  080c		       88		      dey		; Points to parameter count
   1311  080d		       a5 52		      lda	R0	; get parm to be accessed
   1312  080f		       d1 4b		      cmp	(GOSUBSTACK),y	; compare to max number allowed
   1313  0811		       b0 ea		      bcs	iArrayError	; the parameter index should be less than the count
   1314  0813		       06 52		      asl	R0	; Do the multiply by 2
   1315  0815		       26 53		      rol	R0+1
   1316  0817
   1317  0817		       18		      clc
   1318  0818		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1319  081a		       65 52		      adc	R0
   1320  081c		       85 52		      sta	R0
   1321  081e		       a5 55		      lda	R1+1
   1322  0820		       65 53		      adc	R0+1
   1323  0822		       85 53		      sta	R0+1	; The new Variable Address is stored in R0
   1324  0824		       4c de 07 	      jmp	iArrayExit	; Get ot we are done
   1325  0827							;
   1326  0827							;=====================================================
   1327  0827							; List the current BASIC program in memory.  Uses R0,
   1328  0827							; tempIly, and dpl.
   1329  0827							;
   1330  0827		       20 82 2f    iLST       jsr	SetOutConsole
   1331  082a		       ad 1c 44    iLST2      lda	ProgramStart
   1332  082d		       85 59		      sta	dpl
   1333  082f		       ad 1d 44 	      lda	ProgramStart+1
   1334  0832		       85 5a		      sta	dpl+1
   1335  0834							;
   1336  0834							; dpl/dph point to the current line.  See if we're at
   1337  0834							; the end of the program.
   1338  0834							;
   1339  0834		       a5 59	   iLSTloop   lda	dpl
   1340  0836		       cd 1e 44 	      cmp	ProgramEnd
   1341  0839		       d0 07		      bne	iLstNotEnd
   1342  083b		       a5 5a		      lda	dpl+1
   1343  083d		       cd 1f 44 	      cmp	ProgramEnd+1
   1344  0840		       f0 15		      beq	iLstdone
   1345  0842							;
   1346  0842		       20 13 22    iLstNotEnd jsr	PrintProgramLine
   1347  0845							;		  ldy	  #1		  ;Change:  Skip first byte length
   1348  0845							;		  lda	  (dpl),y	  ;line number LSB
   1349  0845							;		  sta	  R0
   1350  0845							;		  iny
   1351  0845							;		  lda	  (dpl),y		 ;line number MSB
   1352  0845							;		  sta	  R0+1
   1353  0845							;		  iny
   1354  0845							;		  sty	  tempIlY
   1355  0845							;		  jsr	  PrintDecimal
   1356  0845							;		  lda	  #SPACE
   1357  0845							;		  jsr	  VOUTCH
   1358  0845							;		  ldy	  tempIlY
   1359  0845							;iLSTl2	  lda	  (dpl),y
   1360  0845							;		  beq	  iLST3 	  ;end of this line 0 value
   1361  0845							;		  sty	  tempIlY
   1362  0845							;		  jsr	  VOUTCH
   1363  0845							;		  ldy	  tempIlY
   1364  0845							;		  iny
   1365  0845							;		  bne	  iLSTl2	  ;do next char
   1366  0845							;
   1367  0845							; End of this line.  Print CR/LF, then move to the
   1368  0845							; next line.
   1369  0845							;
   1370  0845		       a0 00	   iLST3      ldy	#0	;Move to next line
   1371  0847		       b1 59		      lda	(dpl),y	;Current line length
   1372  0849		       18		      clc		;Clear the carry flag
   1373  084a							;		  tya
   1374  084a		       65 59		      adc	dpl	;Add the offset to the pointer
   1375  084c		       85 59		      sta	dpl	;Save the new value
   1376  084e		       a5 5a		      lda	dpl+1	;Next byte
   1377  0850		       69 00		      adc	#0	;ad in the carry if any
   1378  0852		       85 5a		      sta	dpl+1	;Save it
   1379  0854							;
   1380  0854							; Have to manually do CR/LF so it uses the vectored
   1381  0854							; output function.
   1382  0854							;
   1383  0854							;		  lda	  #CR
   1384  0854							;		  jsr	  VOUTCH
   1385  0854							;		  lda	  #LF
   1386  0854							;		  jsr	  VOUTCH
   1387  0854		       4c 34 08 	      jmp	iLSTloop	;do next line
   1388  0857							;
   1389  0857		       20 82 2f    iLstdone   jsr	SetOutConsole
   1390  085a		       4c 9e 02 	      jmp	NextIL
   1391  085d							;
   1392  085d							;=====================================================
   1393  085d							; Get a line of text into LINBUF.  Terminate with a
   1394  085d							; null byte.
   1395  085d							;
   1396  085d				   iGETLINE
   1397  085d		       a9 3e		      lda	#'>	;prompt character
   1398  085f		       a6 00		      ldx	0	;Wait for read to complete
   1399  0861		       20 0b 2c 	      jsr	GetLine
   1400  0864							;
   1401  0864		       a9 00		      lda	#0
   1402  0866		       85 5b		      sta	RunMode
   1403  0868				   iGetParseLine
   1404  0868							; lda	   CUROFF
   1405  0868							; pha
   1406  0868		       20 23 1d 	      jsr	ParseInputLine
   1407  086b							; pla
   1408  086b							;  sta     CUROFF
   1409  086b		       a9 20		      lda	#TOKENBUFFER&$FF
   1410  086d		       85 4f		      sta	CURPTR
   1411  086f		       a9 1c		      lda	#TOKENBUFFER>>8
   1412  0871		       85 50		      sta	CURPTR+1
   1413  0873		       a9 01		      lda	#1
   1414  0875		       85 51		      sta	CUROFF
   1415  0877		       4c 9e 02 	      jmp	NextIL
   1416  087a							;
   1417  087a							;=====================================================
   1418  087a							; This is called when the input buffer contains a line
   1419  087a							; typed in by the user that starts with a line number.
   1420  087a							; Insert the line into the program or delete the line
   1421  087a							; if there is nothing after the line number,
   1422  087a							;
   1423  087a				   iINSRT		; On entry here the TOKEBUFFER contains the Parsed input line completely
   1424  087a		       ad 21 1c 	      lda	TOKENBUFFER+1	; Get the first byte of the line number
   1425  087d		       85 52		      sta	R0	; place the number into R0
   1426  087f		       ad 22 1c 	      lda	TOKENBUFFER+2	; Get hi byte of line number
   1427  0882		       85 53		      STA	R0+1	; Place it into
   1428  0884							;
   1429  0884							; Now find the line OR the next higher line OR the
   1430  0884							; end of the program.
   1431  0884							;
   1432  0884		       20 3a 2b 	      jsr	findLine	; Look for the line number in the current program
   1433  0887							; Returns Z and curptr point to the line if found
   1434  0887							; Returns C and curptr at next higher line if not found and there is a higher line
   1435  0887							; Returns ZC clear and curptr to end of program if higher than all other lines
   1436  0887							;
   1437  0887							; If the line exists, it needs to be removed.
   1438  0887							;
   1439  0887		       d0 44		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1440  0889							;
   1441  0889							; Get length of line to be removed, we fall thru to here if we find a matching line
   1442  0889							;
   1443  0889							;		 jsr	 getCURPTRLength ;results in Y , curptr is pointing to point we need to insert the line
   1444  0889		       a0 00		      ldy	#0
   1445  088b		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1446  088d		       a8		      tay
   1447  088e							;If it is equal we delete the line and replace it, get length
   1448  088e							;then adjust all program line after up or down depending on len of line
   1449  088e							;If next higher then just move everythimg down by length bytes
   1450  088e							;This call will return how many bytes in the line we found
   1451  088e		       8c 15 44 	      sty	lineLength	;Save the length of the line we found
   1452  0891							;
   1453  0891							; Compute the new end of the program first.
   1454  0891							;
   1455  0891		       38		      sec		;Set the carry bit
   1456  0892		       ad 1e 44 	      lda	ProgramEnd	;Get low byte of program end
   1457  0895		       ed 15 44 	      sbc	lineLength	;Subtract the length of the current line
   1458  0898		       8d 1e 44 	      sta	ProgramEnd	;save it
   1459  089b		       ad 1f 44 	      lda	ProgramEnd+1
   1460  089e		       e9 00		      sbc	#0	;Process the carry
   1461  08a0		       8d 1f 44 	      sta	ProgramEnd+1	;We now have the new end of program with the line removed
   1462  08a3							;
   1463  08a3							; Copy CURPTR into R1 for working
   1464  08a3							;
   1465  08a3		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1466  08a5		       85 54		      sta	R1
   1467  08a7		       a5 50		      lda	CURPTR+1
   1468  08a9		       85 55		      sta	R1+1
   1469  08ab							;
   1470  08ab							; See if we're at the end.
   1471  08ab							;
   1472  08ab		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1473  08ad		       cd 1e 44 	      cmp	ProgramEnd
   1474  08b0		       d0 07		      bne	InsDelLoop
   1475  08b2		       a5 55		      lda	R1+1
   1476  08b4		       cd 1f 44 	      cmp	ProgramEnd+1
   1477  08b7		       f0 14		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1478  08b9							;
   1479  08b9							; Move one byte, move to next location.
   1480  08b9							;
   1481  08b9		       ac 15 44    InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1482  08bc		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1483  08be		       b1 54		      lda	(R1),y
   1484  08c0		       a0 00		      ldy	#0
   1485  08c2		       91 54		      sta	(R1),y
   1486  08c4		       e6 54		      inc	R1
   1487  08c6		       d0 e3		      bne	InsDelChk
   1488  08c8		       e6 55		      inc	R1+1
   1489  08ca		       4c ab 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1490  08cd							;
   1491  08cd							; Deletion is done.
   1492  08cd							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1493  08cd							;
   1494  08cd				   insert2		; ldy	   offset		; get back ptr	Get the current offset
   1495  08cd		       ad 20 1c 	      lda	TOKENBUFFER	; Get the length
   1496  08d0		       c9 04		      cmp	#4	; empty lines only have 4 bytes { len(1), linenum(2) ,null(1) }
   1497  08d2							;		 lda	 LINBUF,y	      ;next byte     Get the next byte to be stored
   1498  08d2		       f0 54		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1499  08d4							;
   1500  08d4							; CURPTR points to where the line will be inserted.
   1501  08d4							;
   1502  08d4							;		 jsr	 getLineLength	 ;get bytes needed Reload the number of bytes required for the new line
   1503  08d4		       ae 20 1c 	      ldx	TOKENBUFFER
   1504  08d7		       8e 15 44 	      stx	lineLength	; So update, the TOKENBUFFER already has the line length
   1505  08da							;
   1506  08da		       ad 1e 44 	      lda	ProgramEnd	;Load the start address for the copy
   1507  08dd							;At this point curptr still contains the location we will insert data
   1508  08dd		       85 5c		      sta	FROM
   1509  08df		       ad 1f 44 	      lda	ProgramEnd+1
   1510  08e2		       85 5d		      sta	FROM+1
   1511  08e4							;
   1512  08e4		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1513  08e6		       b1 5c		      lda	(FROM),y
   1514  08e8		       ac 15 44 	      ldy	lineLength	;Now load y with new offset downward to store the byte
   1515  08eb		       91 5c		      sta	(FROM),y	;Save the new byte
   1516  08ed							;
   1517  08ed		       a5 5c		      lda	FROM	;Check if we have copied the last byte
   1518  08ef		       c5 4f		      cmp	CURPTR
   1519  08f1		       d0 06		      bne	mvUpMore
   1520  08f3		       a5 5d		      lda	FROM+1
   1521  08f5		       c5 50		      cmp	CURPTR+1
   1522  08f7		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1523  08f9							;
   1524  08f9							; Not done yet
   1525  08f9							;
   1526  08f9		       a5 5c	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1527  08fb		       d0 02		      bne	mvUpMore2
   1528  08fd		       c6 5d		      dec	FROM+1
   1529  08ff		       c6 5c	   mvUpMore2  dec	FROM
   1530  0901		       4c e4 08 	      jmp	mvup1	;Loop until everything is moved
   1531  0904							;
   1532  0904							; All done with copy.
   1533  0904							;
   1534  0904				   mvUpDone
   1535  0904		       18		      clc		;Ok, We are now ready to copy the new line to the program
   1536  0905		       ad 15 44 	      lda	lineLength	;Number of bytes to copy from line buff
   1537  0908		       6d 1e 44 	      adc	ProgramEnd	;Now pdate the end of program address for space we just opened
   1538  090b		       8d 1e 44 	      sta	ProgramEnd
   1539  090e		       ad 1f 44 	      lda	ProgramEnd+1
   1540  0911		       69 00		      adc	#0
   1541  0913		       8d 1f 44 	      sta	ProgramEnd+1	;Program end now points to the correct enpty space
   1542  0916							;
   1543  0916							;===================jlit use length before line newline
   1544  0916
   1545  0916		       a0 00		      ldy	#0	;Set offset of copy
   1546  0918							;		  lda	  lineLength	  ;We will insert the actual length of the line first
   1547  0918							;		  sta	  (CURPTR),y	  ;Store the length
   1548  0918							;		  iny
   1549  0918							;		  lda	  R0		  ;Store the line number next
   1550  0918							;		  sta	  (CURPTR),y
   1551  0918							;		  iny
   1552  0918							;		  lda	  R0+1
   1553  0918							;		  sta	  (CURPTR),y
   1554  0918							;		  iny
   1555  0918							;
   1556  0918							;		  ldx	  offset	 ; Load the offset into line buffer in page zero
   1557  0918		       a2 00		      ldx	#0	; the token buffer is ready to copy
   1558  091a				   mvUpLoop2
   1559  091a							;		  lda	  LINBUF,x	 ;get a byte
   1560  091a		       bd 20 1c 	      lda	TOKENBUFFER,x	;get a byte
   1561  091d		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1562  091f
   1563  091f		       e8		      inx
   1564  0920		       ec 20 1c 	      cpx	TOKENBUFFER	; Check if we have copied all that we need to
   1565  0923		       b0 03		      bcs	mvUpFini	;hit the null at end of line then we are done
   1566  0925		       c8		      iny
   1567  0926		       d0 f2		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1568  0928							;
   1569  0928		       4c 9e 02    mvUpFini   jmp	NextIL
   1570  092b							;
   1571  092b							;=====================================================
   1572  092b							; Pops the top value of the ILPC stack and stores it
   1573  092b							; in ILPC.  Ie, return from an IL subroutine.
   1574  092b							;
   1575  092b		       20 28 2b    iRTN       jsr	popILPC
   1576  092e		       4c 9e 02 	      jmp	NextIL
   1577  0931							;
   1578  0931							;=====================================================
   1579  0931							; NLINE print a newline
   1580  0931							;
   1581  0931		       20 39 2e    iNLINE     jsr	CRLF	;user supplied sub
   1582  0934		       4c 9e 02 	      jmp	NextIL
   1583  0937							;
   1584  0937							;=====================================================
   1585  0937							; This saves the current ILPC value on the stack, then
   1586  0937							; jumps to the address specified by the next two bytes.
   1587  0937							;
   1588  0937		       20 0b 2b    iCALL      jsr	pushILPC	;save ILPC
   1589  093a		       90 07		      bcc	iJMP
   1590  093c
   1591  093c							;If the push failed not enough stack space
   1592  093c		       a2 15	   ErrILStkOver ldx	#ERR_IL_STACK_OVER_FLOW	; Flag any error in line number
   1593  093e		       a9 00		      lda	#0	; stop the execution
   1594  0940		       4c 6a 06 	      jmp	iErr2
   1595  0943							;
   1596  0943							; Jmp to a specific location in the IL code.  The new
   1597  0943							; address immediately follows the opcode.
   1598  0943							;
   1599  0943		       20 f1 2a    iJMP       jsr	getILWord
   1600  0946		       86 43		      stx	ILPC
   1601  0948		       85 44		      sta	ILPC+1
   1602  094a		       4c 9e 02 	      jmp	NextIL
   1603  094d
   1604  094d							;
   1605  094d							;=====================================================
   1606  094d							; Push the next two bytes onto the arithmetic stack.
   1607  094d							;
   1608  094d		       20 f5 2a    iSetR2     jsr	getILByte
   1609  0950		       85 58		      sta	R2
   1610  0952		       4c 9e 02 	      jmp	NextIL
   1611  0955							;
   1612  0955							;=====================================================
   1613  0955							; Push the next two bytes onto the arithmetic stack.
   1614  0955							;
   1615  0955		       20 f1 2a    iLIT       jsr	getILWord
   1616  0958		       86 52		      stx	R0
   1617  095a		       85 53		      sta	R0+1
   1618  095c		       20 ee 2c 	      jsr	pushR0
   1619  095f		       4c 9e 02 	      jmp	NextIL
   1620  0962							;
   1621  0962							;=====================================================
   1622  0962							; Initialize all variables for a single task.	Ie, set to zero.
   1623  0962							; And internal stack pointers
   1624  0962							;
   1625  0962		       98	   subVINIT   tya
   1626  0963		       48		      pha
   1627  0964
   1628  0964		       a9 00		      lda	#0
   1629  0966		       a0 00		      ldy	#0
   1630  0968		       91 41	   Vinit2     sta	(VARIABLES),y
   1631  096a		       c8		      iny
   1632  096b		       c0 48		      cpy	#[[VARIABLESSIZE * 2] - 2]	; skip the old exit code
   1633  096d		       90 f9		      bcc	Vinit2
   1634  096f		       85 4a		      sta	MATHSTACKPTR	; Clear the math stack
   1635  0971		       85 4d		      sta	GOSUBSTACKPTR	; Clear the gosub stack
   1636  0973		       a9 38		      lda	#[[GOSUBSTACKSIZE - 2] * 4]	; Reset the message queue
   1637  0975		       85 4e		      STA	MESSAGEPTR
   1638  0977
   1639  0977		       68		      pla
   1640  0978		       a8		      tay
   1641  0979		       60		      rts
   1642  097a
   1643  097a				   iVINIT
   1644  097a		       20 62 09 	      jsr	subVINIT
   1645  097d		       20 ba 1f 	      jsr	Compile	; compile line numbers to memory pointers
   1646  0980		       4c 9e 02 	      jmp	NextIL
   1647  0983							;
   1648  0983							;=====================================================
   1649  0983							; Set the address of the error handler.  After any
   1650  0983							; error, set to the ILPC to the specified location.
   1651  0983							;
   1652  0983		       20 f1 2a    iERRGOTO   jsr	getILWord
   1653  0986		       8e 09 44 	      stx	errGoto
   1654  0989		       8d 0a 44 	      sta	errGoto+1
   1655  098c		       4c 9e 02 	      jmp	NextIL
   1656  098f							;
   1657  098f							;=====================================================
   1658  098f							; TST is followed by an 8 bit signed offset, then a
   1659  098f							; null terminated string.  Compare the string against
   1660  098f							; the string starting at (CURPTR),CUROFF.  If the
   1661  098f							; strings match, continue executing the next IL
   1662  098f							; opcode.  Else, add the offset to ILPC.
   1663  098f							;
   1664  098f		       20 f5 2a    iTST       jsr	getILByte	;Get the relative jump address
   1665  0992		       8d 14 44 	      sta	offset	;save it to use if test faile
   1666  0995		       20 d8 2c 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1667  0998
   1668  0998		       a4 51		      ldy	CUROFF
   1669  099a		       84 59		      sty	dpl	;save for later
   1670  099c							;
   1671  099c		       20 f5 2a    iTSTloop   jsr	getILByte	;get next char
   1672  099f		       f0 11		      beq	iTSTm	;match!
   1673  09a1		       a4 59		      ldy	dpl
   1674  09a3		       d1 4f		      cmp	(CURPTR),y
   1675  09a5		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1676  09a7		       09 20		      ora	#$20	; lets allow lowercase as well
   1677  09a9		       d1 4f		      cmp	(CURPTR),y
   1678  09ab		       d0 23		      bne	iTSTfail	;mismatch
   1679  09ad		       c8	   iTSTUpper  iny
   1680  09ae		       84 59		      sty	dpl
   1681  09b0		       d0 ea		      bne	iTSTloop
   1682  09b2							;
   1683  09b2							; It's a match!  Clean up a bit.
   1684  09b2							;
   1685  09b2		       a4 59	   iTSTm      ldy	dpl
   1686  09b4		       84 51		      sty	CUROFF
   1687  09b6		       4c 9e 02 	      jmp	NextIL
   1688  09b9
   1689  09b9							; Test for a single quote string
   1690  09b9		       20 f5 2a    iTSTStr    jsr	getILByte
   1691  09bc		       8d 14 44 	      sta	offset
   1692  09bf		       20 d8 2c 	      jsr	saveIL
   1693  09c2		       a4 51		      ldy	CUROFF
   1694  09c4		       a9 22		      lda	#'"
   1695  09c6		       d1 4f		      cmp	(CURPTR),y
   1696  09c8		       d0 06		      bne	iTSTfail
   1697  09ca		       c8		      iny
   1698  09cb		       84 51		      sty	CUROFF
   1699  09cd		       4c c1 02 	      jmp	NextILStr
   1700  09d0							;
   1701  09d0							; Not a match, reset ILPC and then move to the
   1702  09d0							; offset.
   1703  09d0							;
   1704  09d0		       20 e3 2c    iTSTfail   jsr	restoreIL
   1705  09d3		       4c cd 0b 	      jmp	tstBranch
   1706  09d6							;
   1707  09d6							;=================================================JLIT=
   1708  09d6							; Test if we have a let statement without the let keyword
   1709  09d6		       20 f5 2a    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1710  09d9		       8d 14 44 	      sta	offset	; Save the jump offset for fails
   1711  09dc		       20 d8 2c 	      jsr	saveIL	; save to restore when done if fail
   1712  09df
   1713  09df		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1714  09e1		       b1 4f		      lda	(CURPTR),y	; Get the byte
   1715  09e3		       c9 01		      cmp	#kLet	; Is it a let keyword
   1716  09e5		       f0 0a		      beq	iTSTLETGOOD	; We have a good let statement
   1717  09e7		       c9 80		      cmp	#tVa	; lets check for a variable
   1718  09e9		       90 e5		      bcc	iTSTfail	; Less than variable range
   1719  09eb		       c9 9e		      cmp	#tVat+1	; Test if it is greater that the last variable
   1720  09ed		       90 05		      bcc	iTSTGOODVAR	; No it failed get out Fast
   1721  09ef		       b0 df		      bcs	iTSTfail	; return it failed
   1722  09f1
   1723  09f1				   iTSTLETGOOD
   1724  09f1		       c8		      iny
   1725  09f2		       84 51		      sty	CUROFF	; If it was a let then inc past the let word
   1726  09f4				   iTSTGOODVAR
   1727  09f4		       4c 9e 02 	      jmp	NextIL	; Then next instruction
   1728  09f7
   1729  09f7							;=================================================JLIT=
   1730  09f7							; Test a byte at an indirect address
   1731  09f7							; fails if byte is not equal to the value at the address
   1732  09f7							; The tests an indirect byte and branches if true
   1733  09f7		       20 f5 2a    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1734  09fa		       8d 14 44 	      sta	offset	; Save the jump offset for fails
   1735  09fd		       20 d8 2c 	      jsr	saveIL	; save to restore when done if fail
   1736  0a00		       20 f1 2a 	      jsr	getILWord	; Get a word into RO
   1737  0a03		       86 52		      stx	R0
   1738  0a05		       85 53		      sta	R0+1
   1739  0a07		       20 f5 2a 	      jsr	getILByte	; Get byte into A
   1740  0a0a		       a0 00		      ldy	#0
   1741  0a0c		       d1 52		      cmp	(R0),y
   1742  0a0e		       d0 03		      bne	iTSTByteNotEqual
   1743  0a10		       4c d0 09 	      jmp	iTSTfail
   1744  0a13
   1745  0a13				   iTSTByteNotEqual
   1746  0a13		       4c 9e 02 	      jmp	NextIL	; Then next instruction
   1747  0a16
   1748  0a16							;=================================================JLIT=
   1749  0a16							; Test a byte	branch if it fails
   1750  0a16		       20 f5 2a    iTSTB      jsr	getILByte	; Get the relative offset byte
   1751  0a19		       8d 14 44 	      sta	offset	; Save the jump offset for fails
   1752  0a1c		       20 d8 2c 	      jsr	saveIL	; save to restore when done if fail
   1753  0a1f		       20 f5 2a 	      jsr	getILByte	; Get a byte into Acc
   1754  0a22		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1755  0a24		       d1 4f		      cmp	(CURPTR),y
   1756  0a26		       f0 03		      beq	iTSTBMatch	; Yes it matched move on
   1757  0a28		       4c d0 09 	      jmp	iTSTfail	; REcover and move on to next test
   1758  0a2b
   1759  0a2b				   iTSTBMatch
   1760  0a2b		       c8		      iny
   1761  0a2c		       84 51		      sty	CUROFF	; Point to the next byte
   1762  0a2e		       4c 9e 02 	      jmp	NextIL	; Then next instruction
   1763  0a31
   1764  0a31							;=================================================JLIT=
   1765  0a31							; Test a byte	branch if it fails
   1766  0a31		       20 f5 2a    iTSTW      jsr	getILByte	; Get the relative offset byte
   1767  0a34		       8d 14 44 	      sta	offset	; Save the jump offset for fails
   1768  0a37		       20 d8 2c 	      jsr	saveIL	; save to restore when done if fail
   1769  0a3a		       20 f1 2a 	      jsr	getILWord	; Get a word into RO
   1770  0a3d		       86 52		      stx	R0
   1771  0a3f		       85 53		      sta	R0+1
   1772  0a41		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1773  0a43		       8a		      txa
   1774  0a44		       d1 4f		      cmp	(CURPTR),y	; Test if low order byte matches
   1775  0a46		       f0 e3		      beq	iTSTBMatch	; Yes it matched move on
   1776  0a48		       4c d0 09 	      jmp	iTSTfail	; REcover and move on to next test
   1777  0a4b		       c8	   iTSTWM1    iny
   1778  0a4c		       a5 53		      lda	R0+1
   1779  0a4e		       d1 4f		      cmp	(CURPTR),y	; Check high order byte
   1780  0a50		       f0 03		      beq	iTSTWMatch
   1781  0a52		       4c d0 09 	      jmp	iTSTfail
   1782  0a55
   1783  0a55				   iTSTWMatch
   1784  0a55		       c8		      iny
   1785  0a56		       84 51		      sty	CUROFF
   1786  0a58		       4c 9e 02 	      jmp	NextIL	; Then next instruction
   1787  0a5b
   1788  0a5b							;================================================jLIT=
   1789  0a5b							;Test for end of line
   1790  0a5b							;
   1791  0a5b				   iTSTDONE
   1792  0a5b		       20 f5 2a 	      jsr	getILByte
   1793  0a5e		       8d 14 44 	      sta	offset
   1794  0a61		       20 d8 2c 	      jsr	saveIL
   1795  0a64		       a4 51		      ldy	CUROFF
   1796  0a66		       84 59		      sty	dpl
   1797  0a68		       b1 4f		      lda	(CURPTR),y
   1798  0a6a		       f0 0b		      beq	iTSTDONEtrue
   1799  0a6c		       c9 e6		      cmp	#oColon
   1800  0a6e		       f0 07		      beq	iTSTDONEtrue
   1801  0a70		       a4 59		      ldy	dpl
   1802  0a72		       84 51		      sty	CUROFF
   1803  0a74		       4c d0 09 	      jmp	iTSTfail
   1804  0a77							;
   1805  0a77							; Advance to the next line
   1806  0a77							;
   1807  0a77				   iTSTDONEtrue
   1808  0a77		       4c 9e 02 	      jmp	NextIL
   1809  0a7a
   1810  0a7a		       4c cd 0b    tstBranchLink jmp	tstBranch
   1811  0a7d							;
   1812  0a7d							;=====================================================
   1813  0a7d							; Inc and dec a variable , faster than a = a + 1
   1814  0a7d				   iINCVAR
   1815  0a7d		       20 80 2d 	      jsr	popR0
   1816  0a80		       a0 00		      ldy	#0
   1817  0a82		       18		      clc
   1818  0a83		       a9 01		      lda	#1
   1819  0a85		       71 52		      adc	(R0),y
   1820  0a87		       91 52		      sta	(R0),y
   1821  0a89		       90 07		      bcc	iINCDONE
   1822  0a8b		       c8		      iny
   1823  0a8c		       a9 00		      lda	#0
   1824  0a8e		       71 52		      adc	(R0),y
   1825  0a90		       91 52		      sta	(R0),y
   1826  0a92				   iINCDONE
   1827  0a92		       4c 9e 02 	      jmp	NextIL
   1828  0a95
   1829  0a95				   iDECVAR
   1830  0a95		       20 80 2d 	      jsr	popR0
   1831  0a98		       a0 00		      ldy	#0
   1832  0a9a		       38		      sec
   1833  0a9b		       b1 52		      lda	(R0),y
   1834  0a9d		       e9 01		      sbc	#1
   1835  0a9f		       91 52		      sta	(R0),y
   1836  0aa1		       c8		      iny
   1837  0aa2		       b1 52		      lda	(R0),y
   1838  0aa4		       e9 00		      sbc	#0
   1839  0aa6		       91 52		      sta	(R0),y
   1840  0aa8		       4c 9e 02 	      jmp	NextIL
   1841  0aab
   1842  0aab							;
   1843  0aab							;=====================================================
   1844  0aab							; TSTV is followed by an 8 bit signed offset.	If the
   1845  0aab							; value at (CURPTR),CUROFF appears to be a variable
   1846  0aab							; name, move to the next IL statement.  Else, add the
   1847  0aab							; offset to ILPC. Converted to use actual absolute memory addresses
   1848  0aab							; TSTVT Looks for the task context
   1849  0aab							;
   1850  0aab		       20 98 2d    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1851  0aae		       a9 00		      lda	#0
   1852  0ab0		       85 58		      sta	R2
   1853  0ab2		       f0 04		      beq	iTSTVV
   1854  0ab4
   1855  0ab4							; Test for simple variable
   1856  0ab4		       a9 01	   iTSTV      lda	#1	; set a process Flag
   1857  0ab6		       85 58		      sta	R2
   1858  0ab8
   1859  0ab8		       20 f5 2a    iTSTVV     jsr	getILByte	;offset
   1860  0abb		       8d 14 44 	      sta	offset
   1861  0abe							;
   1862  0abe		       a4 51		      ldy	CUROFF	; Get the pointer into the program
   1863  0ac0		       b1 4f		      lda	(CURPTR),y	; Get the next byte to process
   1864  0ac2		       d0 03		      bne	iTSTVnext	; if is not null then process it
   1865  0ac4		       4c 7a 0a 	      jmp	tstBranchLink	; if we are at the end of line just get out with error
   1866  0ac7							;
   1867  0ac7				   iTSTVnext
   1868  0ac7		       c9 9d		      cmp	#tVat	; allow access to all unused memory as an array or integers
   1869  0ac9		       f0 4f		      beq	iTSTVat	; Setup to do a pointer to unused memory
   1870  0acb
   1871  0acb		       c9 9c		      cmp	#tVhash	; parameters passed to this task
   1872  0acd		       f0 5b		      beq	iTSTVParm
   1873  0acf
   1874  0acf		       c9 9b		      cmp	#tVhat	; task exit code
   1875  0ad1		       d0 04		      bne	iTSTV_A2Z
   1876  0ad3		       a9 48		      lda	#TASKEXITCODE
   1877  0ad5		       d0 0b		      bne	iTSTVContinue
   1878  0ad7
   1879  0ad7				   iTSTV_A2Z
   1880  0ad7
   1881  0ad7		       c9 80		      cmp	#tVa
   1882  0ad9		       90 9f		      bcc	tstBranchLink
   1883  0adb		       c9 9a		      cmp	#tVz+1
   1884  0add		       b0 9b		      bcs	tstBranchLink
   1885  0adf
   1886  0adf							;
   1887  0adf							; The condition is true, so convert to an index, push
   1888  0adf							; it onto the stack and continue running.
   1889  0adf							;
   1890  0adf		       29 7f		      and	#%01111111	; Mask off the high bit
   1891  0ae1		       0a		      asl		; multiply by two
   1892  0ae2
   1893  0ae2				   iTSTVContinue
   1894  0ae2		       c8		      iny
   1895  0ae3		       84 51		      sty	CUROFF	; it is a valid variable
   1896  0ae5		       48		      pha		; save the last variable pointer value
   1897  0ae6		       a5 58		      lda	R2
   1898  0ae8		       d0 1e		      bne	iTSTVLocalValue	; Value local to this task
   1899  0aea
   1900  0aea		       20 ca 2a 	      jsr	ipc_ValidateContext	; Lets make sure R1 has a valid context value
   1901  0aed		       90 08		      bcc	iTSTVGOODPID	; Invalid PID provided
   1902  0aef
   1903  0aef		       68		      pla		; We have an invalid pid for getting variable value
   1904  0af0		       a2 10		      ldx	#ERR_INVALID_PID
   1905  0af2		       a9 00		      lda	#0
   1906  0af4		       4c 6a 06 	      jmp	iErr2
   1907  0af7
   1908  0af7				   iTSTVGOODPID
   1909  0af7		       20 b2 2a 	      jsr	ipc_getcontext	; Get the other tasks variables
   1910  0afa		       a0 01		      ldy	#VARIABLEPOS
   1911  0afc		       b1 56		      lda	(MQ),y
   1912  0afe		       85 52		      sta	R0
   1913  0b00		       c8		      iny
   1914  0b01		       b1 56		      lda	(MQ),y
   1915  0b03		       85 53		      sta	R0+1
   1916  0b05		       4c 10 0b 	      jmp	iTSTVAddOffset
   1917  0b08
   1918  0b08				   iTSTVLocalValue
   1919  0b08		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1920  0b0a		       85 52		      sta	R0
   1921  0b0c		       a5 42		      lda	VARIABLES+1
   1922  0b0e		       85 53		      sta	R0+1
   1923  0b10
   1924  0b10				   iTSTVAddOffset
   1925  0b10		       68		      pla
   1926  0b11		       85 54		      sta	R1
   1927  0b13		       a9 00		      lda	#0
   1928  0b15		       85 55		      sta	R1+1
   1929  0b17
   1930  0b17				   iTSTVcontinue
   1931  0b17
   1932  0b17		       4c 92 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1933  0b1a
   1934  0b1a							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1935  0b1a							; an array of integer values or byte.
   1936  0b1a				   iTSTVat
   1937  0b1a		       c8		      iny
   1938  0b1b		       84 51		      sty	CUROFF	;it is a valid variable
   1939  0b1d		       ad 1e 44 	      lda	ProgramEnd	;set flag to let evaluator to use PROGRAMEND as the root
   1940  0b20		       85 52		      sta	R0
   1941  0b22		       ad 1f 44 	      lda	ProgramEnd+1
   1942  0b25		       85 53		      sta	R0+1
   1943  0b27		       4c 0a 07 	      jmp	pushR0nextIl	;place this onto the stack
   1944  0b2a
   1945  0b2a							; When we get parameters passed we can access them using the # variable with[]
   1946  0b2a							; example #[0] #[1] etc, we dont check yet if there is too many
   1947  0b2a		       c8	   iTSTVParm  iny
   1948  0b2b		       84 51		      sty	CUROFF	;it is a valid variable
   1949  0b2d
   1950  0b2d							; upon return the y register  point to the gosub Parms entry value entry
   1951  0b2d		       20 86 25 	      jsr	GosubFindParms
   1952  0b30		       90 21		      bcc	iTSTMissingParms
   1953  0b32
   1954  0b32		       88		      dey
   1955  0b33		       88		      dey
   1956  0b34		       88		      dey		;Point to the actual index of first parameter in math stack
   1957  0b35
   1958  0b35		       a5 48		      lda	MATHSTACK
   1959  0b37		       85 52		      sta	R0
   1960  0b39		       a5 49		      lda	MATHSTACK+1
   1961  0b3b		       85 53		      sta	R0+1
   1962  0b3d		       b1 4b		      lda	(GOSUBSTACK),y	; Get the correct Offset to start of parameters
   1963  0b3f		       f0 0b		      beq	iTSTVindex0	; no math if no offset
   1964  0b41		       18		      clc
   1965  0b42		       65 52		      adc	R0	; Point to the actual address that the variables start, not just top of stack
   1966  0b44		       85 52		      sta	R0
   1967  0b46		       a9 00		      lda	#0
   1968  0b48		       65 53		      adc	R0+1
   1969  0b4a		       85 53		      sta	R0+1
   1970  0b4c				   iTSTVindex0
   1971  0b4c		       a9 81		      lda	#GOSUB_RTN_VALUE
   1972  0b4e		       85 58		      sta	R2	; Set the data type as a parameter to a function
   1973  0b50		       4c 0a 07 	      jmp	pushR0nextIl
   1974  0b53
   1975  0b53				   iTSTMissingParms
   1976  0b53		       a9 00		      lda	#0
   1977  0b55		       a2 19		      ldx	#ERR_FUNCTION_EXPECTED_PARAMETERS
   1978  0b57		       4c 6a 06 	      jmp	iErr2
   1979  0b5a
   1980  0b5a							;
   1981  0b5a							;=====================================================
   1982  0b5a							; TSTL seems basically the same as TSTN, but leave the
   1983  0b5a							; value in R0 instead of pushing onto stack.
   1984  0b5a							; This tests for a valid line number
   1985  0b5a							;
   1986  0b5a		       20 f5 2a    iTSTL      jsr	getILByte
   1987  0b5d		       8d 14 44 	      sta	offset
   1988  0b60							;
   1989  0b60		       a4 51		      ldy	CUROFF
   1990  0b62		       b1 4f		      lda	(CURPTR),y
   1991  0b64		       c8		      iny
   1992  0b65		       11 4f		      ora	(CURPTR),y
   1993  0b67		       f0 06		      beq	iTSTLNotLineNo
   1994  0b69
   1995  0b69							; In Both cases we need to point to the first usefull byte to process.
   1996  0b69		       c8		      iny
   1997  0b6a		       84 51		      sty	CUROFF
   1998  0b6c		       4c 9e 02 	      jmp	NextIL
   1999  0b6f				   iTSTLNotLineNo
   2000  0b6f		       c8		      iny
   2001  0b70		       84 51		      sty	CUROFF
   2002  0b72		       4c cd 0b 	      jmp	tstBranch
   2003  0b75
   2004  0b75							;
   2005  0b75							;=====================================================
   2006  0b75							; TSTN checks for a number.  This is very simplistic;
   2007  0b75							; if the character is a digit, assume it's a number.
   2008  0b75							; Convert to a number and push it onto the stack.
   2009  0b75							;
   2010  0b75		       20 f5 2a    iTSTN      jsr	getILByte
   2011  0b78		       8d 14 44 	      sta	offset
   2012  0b7b							;
   2013  0b7b		       a9 00		      lda	#0
   2014  0b7d		       85 59		      sta	dpl
   2015  0b7f		       a4 51		      ldy	CUROFF
   2016  0b81				   chkType
   2017  0b81		       b1 4f		      lda	(CURPTR),y
   2018  0b83		       c9 a2		      cmp	#tByte
   2019  0b85		       f0 0e		      beq	chkByte
   2020  0b87		       c9 a4		      cmp	#tInteger
   2021  0b89		       f0 16		      beq	chkInteger
   2022  0b8b		       c9 eb		      cmp	#oMinus
   2023  0b8d		       d0 3e		      bne	tstBranch
   2024  0b8f		       e6 59		      inc	dpl
   2025  0b91		       c8		      iny
   2026  0b92		       4c 81 0b 	      jmp	chkType
   2027  0b95
   2028  0b95				   chkByte
   2029  0b95		       a9 00		      lda	#0
   2030  0b97		       85 53		      sta	R0+1
   2031  0b99		       c8		      iny
   2032  0b9a		       b1 4f		      lda	(CURPTR),y
   2033  0b9c		       85 52		      sta	R0
   2034  0b9e		       c8		      iny
   2035  0b9f		       d0 0b		      bne	iTSTN_1
   2036  0ba1
   2037  0ba1				   chkInteger
   2038  0ba1		       c8		      iny
   2039  0ba2		       b1 4f		      lda	(CURPTR),y
   2040  0ba4		       85 52		      sta	R0
   2041  0ba6		       c8		      iny
   2042  0ba7		       b1 4f		      lda	(CURPTR),y
   2043  0ba9		       85 53		      sta	R0+1
   2044  0bab		       c8		      iny
   2045  0bac							;
   2046  0bac							; Check if it is negative and make it so
   2047  0bac							;
   2048  0bac				   iTSTN_1
   2049  0bac		       84 51		      sty	CUROFF
   2050  0bae
   2051  0bae		       a5 59		      lda	dpl
   2052  0bb0		       f0 18		      beq	iTSTN_2	;positive
   2053  0bb2							;
   2054  0bb2		       a5 52		      lda	R0
   2055  0bb4		       05 53		      ora	R0+1
   2056  0bb6		       f0 12		      beq	iTSTN_2	;zero
   2057  0bb8
   2058  0bb8							; Invert all the bits, then add one.
   2059  0bb8							;
   2060  0bb8		       a5 52		      lda	R0
   2061  0bba		       49 ff		      eor	#$ff
   2062  0bbc		       85 52		      sta	R0
   2063  0bbe		       a5 53		      lda	R0+1
   2064  0bc0		       49 ff		      eor	#$ff
   2065  0bc2		       85 53		      sta	R0+1
   2066  0bc4							;
   2067  0bc4		       e6 52		      inc	R0
   2068  0bc6		       d0 02		      bne	iTSTN_2
   2069  0bc8		       e6 53		      inc	R0+1
   2070  0bca				   iTSTN_2
   2071  0bca		       4c 0a 07 	      jmp	pushR0nextIl	;save onto stack
   2072  0bcd
   2073  0bcd							;
   2074  0bcd							; Common jump point for all TSTx instructions that
   2075  0bcd							; fail to meet the requirements.  This takes the
   2076  0bcd							; offset and adds/subtracts to/from ILPC.
   2077  0bcd							;
   2078  0bcd		       ad 14 44    tstBranch  lda	offset	;get signed offset
   2079  0bd0		       10 0e		      bpl	tstPositive
   2080  0bd2							;
   2081  0bd2							; Do negative branch.	Do sign extension.
   2082  0bd2							;
   2083  0bd2		       18	   tstNegative clc
   2084  0bd3		       65 43		      adc	ILPC
   2085  0bd5		       85 43		      sta	ILPC
   2086  0bd7							;		  bcc	  tstBothDone
   2087  0bd7							;		  dec	  ILPC+1
   2088  0bd7							;		  jmp	  NextIL
   2089  0bd7
   2090  0bd7		       a5 44		      lda	ILPC+1
   2091  0bd9		       69 ff		      adc	#$ff
   2092  0bdb		       85 44		      sta	ILPC+1
   2093  0bdd		       4c 9e 02 	      jmp	NextIL	;keep going
   2094  0be0							;
   2095  0be0		       18	   tstPositive clc
   2096  0be1		       65 43		      adc	ILPC
   2097  0be3		       85 43		      sta	ILPC
   2098  0be5		       90 02		      bcc	tstBothDone
   2099  0be7		       e6 44		      inc	ILPC+1
   2100  0be9				   tstBothDone
   2101  0be9		       4c 9e 02 	      jmp	NextIL
   2102  0bec
   2103  0bec							;
   2104  0bec							;====================================================
   2105  0bec							; Test for IRQ pending, and test if a break key pressed
   2106  0bec							; Yes I know but this handles all sorts of irq/break issues
   2107  0bec							;
   2108  0bec		       20 f5 2a    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   2109  0bef		       8d 14 44 	      sta	offset	; Store the not true jump address offset
   2110  0bf2		       ad 80 19    irqNo      lda	IRQPending	; Check if the pending value is set
   2111  0bf5		       f0 20		      beq	tstBreak	; if no irq then check for an escape key pressed
   2112  0bf7		       c9 01		      cmp	#1	; only do this if set to first time
   2113  0bf9		       d0 1c		      bne	tstBreak	; We are in a irq service already
   2114  0bfb				   iTSTProcessIRQ
   2115  0bfb		       78		      sei		; disable the interupt until ireturn resets it
   2116  0bfc		       ee 80 19 	      inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   2117  0bff		       a9 01		      lda	#GOSUB_RTN	; Save as gosub
   2118  0c01		       20 08 2d 	      jsr	pushLN	; Push the next line to be executed
   2119  0c04		       b0 21		      bcs	ErrStkOver	; Check if there was an error
   2120  0c06		       ad 81 19 	      lda	IRQEntry	; Get the line number to branch to
   2121  0c09		       85 4f		      sta	CURPTR	; put line number into r0
   2122  0c0b		       ad 82 19 	      lda	IRQEntry+1
   2123  0c0e		       85 50		      sta	CURPTR+1
   2124  0c10		       a9 03		      lda	#3	; Point to first byte of program text
   2125  0c12		       85 51		      sta	CUROFF
   2126  0c14		       4c 9e 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   2127  0c17
   2128  0c17				   tstBreak
   2129  0c17		       20 54 04 	      jsr	BreakSet	; Check if the escape key was pressed
   2130  0c1a		       d0 b1		      bne	tstBranch	; z not set of no break found
   2131  0c1c		       ad 16 44 	      lda	taskIOPending
   2132  0c1f		       f0 03		      beq	tstBrkComplete
   2133  0c21		       ce 16 44 	      dec	taskIOPending
   2134  0c24		       4c ef 05    tstBrkComplete jmp	iFIN	; Exit out of run mode
   2135  0c27
   2136  0c27		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   2137  0c29		       a9 00		      lda	#0	; stop the execution
   2138  0c2b		       4c 6a 06 	      jmp	iErr2
   2139  0c2e							;
   2140  0c2e
   2141  0c2e							;=====================================================
   2142  0c2e							; This places the number of free bytes on top of the
   2143  0c2e							; stack.
   2144  0c2e							;
   2145  0c2e		       20 94 23    iFREE      jsr	MemFree
   2146  0c31		       4c 0a 07 	      jmp	pushR0nextIl
   2147  0c34							;
   2148  0c34							;=====================================================
   2149  0c34							; Generate a random number from 0-FFFF and then MOD
   2150  0c34							; it with the value on top of stack.  Leaves number on
   2151  0c34							; stack
   2152  0c34							;
   2153  0c34		       20 98 2d    iRANDOM    jsr	popR1	;mod value
   2154  0c37							;
   2155  0c37							; If the value is zero, just return a one.
   2156  0c37							;
   2157  0c37		       a5 54		      lda	R1
   2158  0c39		       05 55		      ora	R1+1
   2159  0c3b		       f0 4a		      beq	irandom1
   2160  0c3d							;
   2161  0c3d		       ad 0f 44 	      lda	random+1
   2162  0c40		       8d 0c 44 	      sta	rtemp1
   2163  0c43		       ad 0e 44 	      lda	random
   2164  0c46		       0a		      asl
   2165  0c47		       2e 0c 44 	      rol	rtemp1
   2166  0c4a		       0a		      asl
   2167  0c4b		       2e 0c 44 	      rol	rtemp1
   2168  0c4e		       18		      clc
   2169  0c4f		       6d 0e 44 	      adc	random
   2170  0c52
   2171  0c52		       48		      pha
   2172  0c53
   2173  0c53		       ad 0c 44 	      lda	rtemp1
   2174  0c56		       6d 0f 44 	      adc	random+1
   2175  0c59		       8d 0f 44 	      sta	random+1
   2176  0c5c
   2177  0c5c		       68		      pla
   2178  0c5d
   2179  0c5d		       69 11		      adc	#$11
   2180  0c5f		       8d 0e 44 	      sta	random
   2181  0c62		       ad 0f 44 	      lda	random+1
   2182  0c65		       69 36		      adc	#$36
   2183  0c67		       8d 0f 44 	      sta	random+1
   2184  0c6a
   2185  0c6a		       ad 0e 44 	      lda	random
   2186  0c6d		       85 52		      sta	R0
   2187  0c6f		       ad 0f 44 	      lda	random+1
   2188  0c72		       29 7f		      and	#$7f	;make positive
   2189  0c74		       85 53		      sta	R0+1
   2190  0c76							;
   2191  0c76							; R0 contains the number and R1 contains the max value.
   2192  0c76							;
   2193  0c76		       20 30 07 	      jsr	iDivNoPop
   2194  0c79		       20 01 2e 	      jsr	RestoreSigns
   2195  0c7c		       a5 56		      lda	MQ
   2196  0c7e		       85 52		      sta	R0
   2197  0c80		       a5 57		      lda	MQ+1
   2198  0c82		       85 53		      sta	R0+1
   2199  0c84		       4c 0a 07 	      jmp	pushR0nextIl
   2200  0c87				   irandom1
   2201  0c87		       a9 00		      lda	#0
   2202  0c89		       85 53		      sta	R0+1
   2203  0c8b		       a9 01		      lda	#1
   2204  0c8d		       85 52		      sta	R0
   2205  0c8f		       4c 0a 07 	      jmp	pushR0nextIl
   2206  0c92
   2207  0c92							; The following replaced by call to division/modulo
   2208  0c92							;iRANDOM_2	lda	R0
   2209  0c92							;		cmp	R1
   2210  0c92							;		bne	iRANDOM_1
   2211  0c92							;		lda	R0+1
   2212  0c92							;		cmp	R1+1
   2213  0c92							;		bne	iRANDOM_1	;need to subtract
   2214  0c92							;
   2215  0c92							; Subtract R1 from R0
   2216  0c92							;
   2217  0c92							;iRANDOM_sub	sec
   2218  0c92							;		lda	R0
   2219  0c92							;		sbc	R1
   2220  0c92							;		sta	R0
   2221  0c92							;		lda	R0+1
   2222  0c92							;		sbc	R1+1
   2223  0c92							;		sta	R0+1
   2224  0c92							;		jmp	iRANDOM_2
   2225  0c92							;
   2226  0c92							; See if R1 > R0.  If so, branch to subtract.
   2227  0c92							;
   2228  0c92							;iRANDOM_1	lda	R0
   2229  0c92							;		cmp	R1
   2230  0c92							;		lda	R0+1
   2231  0c92							;		sbc	R1+1
   2232  0c92							;		bvc	iRANDOM_4
   2233  0c92							;		eor	#$80
   2234  0c92							;iRANDOM_4	bpl	iRANDOM_sub
   2235  0c92							;
   2236  0c92							; All done.  Almost.  Add one, then push the result.
   2237  0c92							;
   2238  0c92							;irandom1	inc	R0
   2239  0c92							;		bne	iRANDOM_3
   2240  0c92							;		inc	R0+1
   2241  0c92							;iRANDOM_3
   2242  0c92							;		  jsr	pushR0	;return value
   2243  0c92							;		jmp	NextIL
   2244  0c92							;
   2245  0c92							; Poke a value into a memory location
   2246  0c92		       8c 10 44    iPOKEMEMORY sty	tempy
   2247  0c95		       20 80 2d 	      jsr	popR0
   2248  0c98		       20 98 2d 	      jsr	popR1
   2249  0c9b		       a0 00		      ldy	#0
   2250  0c9d		       a5 52		      lda	R0
   2251  0c9f		       91 54		      sta	(R1),y
   2252  0ca1		       ac 10 44 	      ldy	tempy
   2253  0ca4		       4c 9e 02 	      jmp	NextIL
   2254  0ca7							;
   2255  0ca7							; Get a value from a memory location
   2256  0ca7							;
   2257  0ca7		       8c 10 44    iPEEKMEMORY sty	tempy
   2258  0caa		       20 80 2d 	      jsr	popR0
   2259  0cad		       a0 00		      ldy	#0
   2260  0caf		       b1 52		      lda	(R0),y
   2261  0cb1		       ac 10 44 	      ldy	tempy
   2262  0cb4		       85 52		      sta	R0
   2263  0cb6		       a9 00		      lda	#0
   2264  0cb8		       85 53		      sta	R0+1
   2265  0cba		       4c 0a 07 	      jmp	pushR0nextIl
   2266  0cbd							;
   2267  0cbd							; Call to address return what ever is in a to the stack
   2268  0cbd							; func2 will load a value into a before the call
   2269  0cbd		       20 98 2d    iCallFunc  jsr	popR1
   2270  0cc0		       a5 54		      lda	R1
   2271  0cc2		       20 ce 0c 	      jsr	iCallRtn
   2272  0cc5		       85 52		      sta	R0
   2273  0cc7		       a9 00		      lda	#0
   2274  0cc9		       85 53		      sta	R0+1
   2275  0ccb		       20 0a 07 	      jsr	pushR0nextIl
   2276  0cce				   iCallRtn
   2277  0cce		       20 80 2d 	      jsr	popR0
   2278  0cd1		       6c 52 00 	      jmp	(R0)
   2279  0cd4
   2280  0cd4							;===========================================jlit======
   2281  0cd4							;Get a character from the terminal convert to value
   2282  0cd4							;leave the number on top of the stack
   2283  0cd4							;
   2284  0cd4				   iGETCHAR
   2285  0cd4		       20 20 1a 	      jsr	VGETCH
   2286  0cd7					      if	CTMON65
   2287  0cd7		       48		      pha
   2288  0cd8		       20 1d 1a 	      jsr	VOUTCH	;echo echo echo
   2289  0cdb		       68		      pla
   2290  0cdc					      endif
   2291  0cdc		       85 52		      sta	R0
   2292  0cde		       a9 00		      lda	#0
   2293  0ce0		       85 53		      sta	R0+1
   2294  0ce2		       20 ee 2c 	      jsr	pushR0
   2295  0ce5							;
   2296  0ce5		       4c 9e 02 	      jmp	NextIL
   2297  0ce8							;===========================================jusilostintim======
   2298  0ce8							;Put a character to the terminal convert to
   2299  0ce8							;
   2300  0ce8		       20 80 2d    iPUTCHAR   jsr	popR0
   2301  0ceb		       a5 52		      lda	R0
   2302  0ced		       20 1d 1a 	      jsr	VOUTCH
   2303  0cf0		       4c 9e 02 	      jmp	NextIL
   2304  0cf3							;=====================================================
   2305  0cf3							; Put the number on the stack out as hex, suppress leading 0
   2306  0cf3				   iHexOut
   2307  0cf3		       20 80 2d 	      jsr	popR0
   2308  0cf6		       a5 53		      lda	R0+1
   2309  0cf8		       f0 03		      beq	iHexSecondByte
   2310  0cfa		       20 63 21 	      jsr	OUTHEX
   2311  0cfd				   iHexSecondByte
   2312  0cfd		       a5 52		      lda	R0
   2313  0cff		       20 63 21 	      jsr	OUTHEX
   2314  0d02		       4c 9e 02 	      jmp	NextIL
   2315  0d05							;
   2316  0d05							;=====================================================
   2317  0d05							; Replace TOS with its absolute value.
   2318  0d05							;
   2319  0d05		       20 80 2d    iABS       jsr	popR0
   2320  0d08		       a5 53		      lda	R0+1
   2321  0d0a		       10 10		      bpl	iABS_1	;already positive
   2322  0d0c		       49 ff		      eor	#$ff
   2323  0d0e		       85 53		      sta	R0+1
   2324  0d10		       a5 52		      lda	R0
   2325  0d12		       49 ff		      eor	#$ff
   2326  0d14		       85 52		      sta	R0
   2327  0d16		       e6 52		      inc	R0
   2328  0d18		       d0 02		      bne	iABS_1
   2329  0d1a		       e6 53		      inc	R0+1
   2330  0d1c		       4c 0a 07    iABS_1     jmp	pushR0nextIl
   2331  0d1f
   2332  0d1f							;
   2333  0d1f							;================================================================
   2334  0d1f							; The set of logical operators
   2335  0d1f				   iLogAnd
   2336  0d1f		       20 80 2d 	      jsr	popR0
   2337  0d22		       20 98 2d 	      jsr	popR1
   2338  0d25		       a5 52		      lda	R0
   2339  0d27		       25 54		      and	R1
   2340  0d29		       85 52		      sta	R0
   2341  0d2b		       a5 53		      lda	R0+1
   2342  0d2d		       25 55		      and	R1+1
   2343  0d2f		       85 53		      sta	R0+1
   2344  0d31		       4c 0a 07 	      jmp	pushR0nextIl
   2345  0d34
   2346  0d34				   iLogOr
   2347  0d34		       20 80 2d 	      jsr	popR0
   2348  0d37		       20 98 2d 	      jsr	popR1
   2349  0d3a		       a5 52		      lda	R0
   2350  0d3c		       05 54		      ora	R1
   2351  0d3e		       85 52		      sta	R0
   2352  0d40		       a5 53		      lda	R0+1
   2353  0d42		       05 55		      ora	R1+1
   2354  0d44		       85 53		      sta	R0+1
   2355  0d46		       4c 0a 07 	      jmp	pushR0nextIl
   2356  0d49				   iLogXor
   2357  0d49		       20 80 2d 	      jsr	popR0
   2358  0d4c		       20 98 2d 	      jsr	popR1
   2359  0d4f		       a5 52		      lda	R0
   2360  0d51		       45 54		      eor	R1
   2361  0d53		       85 52		      sta	R0
   2362  0d55		       a5 53		      lda	R0+1
   2363  0d57		       45 55		      eor	R1+1
   2364  0d59		       85 53		      sta	R0+1
   2365  0d5b		       4c 0a 07 	      jmp	pushR0nextIl
   2366  0d5e				   iLogNot
   2367  0d5e		       20 80 2d 	      jsr	popR0
   2368  0d61		       a5 52		      lda	R0
   2369  0d63		       49 ff		      eor	#$FF
   2370  0d65		       85 52		      sta	R0
   2371  0d67		       a5 53		      lda	R0+1
   2372  0d69		       49 ff		      eor	#$FF
   2373  0d6b		       85 53		      sta	R0+1
   2374  0d6d		       4c 0a 07 	      jmp	pushR0nextIl
   2375  0d70
   2376  0d70				   iTruth
   2377  0d70		       a9 ff		      lda	#$FF
   2378  0d72		       85 52		      sta	R0
   2379  0d74		       85 53		      sta	R0+1
   2380  0d76		       4c 0a 07 	      jmp	pushR0nextIl
   2381  0d79				   iFalse
   2382  0d79		       a9 00		      lda	#$00
   2383  0d7b		       85 52		      sta	R0
   2384  0d7d		       85 53		      sta	R0+1
   2385  0d7f		       4c 0a 07 	      jmp	pushR0nextIl
   2386  0d82							;===============================================================
   2387  0d82							;Shift instruction a is set to right = 1, left = 0
   2388  0d82							;
   2389  0d82		       8a	   iShift     txa
   2390  0d83		       48		      pha
   2391  0d84		       20 80 2d 	      jsr	popR0	; number of places to shift 0 to 16 really
   2392  0d87		       20 98 2d 	      jsr	popR1	; value to shift
   2393  0d8a		       a6 52		      ldx	R0	; get number of times to shift
   2394  0d8c		       20 f5 2a 	      jsr	getILByte	; get direction to shift
   2395  0d8f		       c9 01		      cmp	#1	; Should we be doing left
   2396  0d91		       f0 0a		      beq	iShiftRight
   2397  0d93							;
   2398  0d93							; Shift r1 left n bits
   2399  0d93				   iShiftLeft
   2400  0d93		       18	   iShiftLloop clc
   2401  0d94		       26 54		      rol	R1
   2402  0d96		       26 55		      rol	R1+1
   2403  0d98		       ca		      dex
   2404  0d99		       d0 f8		      bne	iShiftLloop
   2405  0d9b		       f0 07		      beq	iShiftExit
   2406  0d9d							;
   2407  0d9d							; Shift R1 right n bits
   2408  0d9d							;
   2409  0d9d				   iShiftRight
   2410  0d9d		       46 55	   iShiftRloop lsr	R1+1
   2411  0d9f		       46 54		      lsr	R1
   2412  0da1		       ca		      dex
   2413  0da2		       d0 f9		      bne	iShiftRloop
   2414  0da4				   iShiftExit
   2415  0da4		       68		      pla
   2416  0da5		       aa		      tax
   2417  0da6		       20 66 2d 	      jsr	pushR1
   2418  0da9		       4c 9e 02 	      jmp	NextIL
   2419  0dac
   2420  0dac							;================================================================
   2421  0dac							;Set the IRQ service rtn line number
   2422  0dac							;
   2423  0dac		       78	   iSetIrq    sei		; disable the interupts
   2424  0dad		       a9 00		      lda	#0	; Zero the Status flag
   2425  0daf		       8d 7f 19 	      sta	IRQStatus
   2426  0db2		       20 80 2d 	      jsr	popR0	; get the line number
   2427  0db5		       a5 52		      lda	R0
   2428  0db7		       05 53		      ora	R0+1
   2429  0db9		       f0 22		      beq	iSetExt	; if it is zero disable all
   2430  0dbb		       a9 01		      lda	#GOSUB_RTN	; default push type
   2431  0dbd		       20 08 2d 	      jsr	pushLN	; Save the current line pointer
   2432  0dc0		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2433  0dc2		       4c 27 0c 	      jmp	ErrStkOver	; Check if there was an error
   2434  0dc5				   iSetIrqOk
   2435  0dc5		       20 3a 2b 	      jsr	findLine	; Find the IRQ func Line Pointer
   2436  0dc8		       d0 16		      bne	iSetIrqErr	; Error if exact line not found
   2437  0dca		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2438  0dcc		       8d 82 19 	      sta	IRQEntry+1
   2439  0dcf		       a5 4f		      lda	CURPTR
   2440  0dd1		       8d 81 19 	      sta	IRQEntry
   2441  0dd4		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2442  0dd6		       8d 7f 19 	      sta	IRQStatus
   2443  0dd9		       20 31 2d 	      jsr	popLN	; Restore the old line number
   2444  0ddc		       58		      cli		; Enable the interupts
   2445  0ddd		       4c 9e 02    iSetExt    jmp	NextIL
   2446  0de0
   2447  0de0		       20 31 2d    iSetIrqErr jsr	popLN
   2448  0de3		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2449  0de5		       a9 00		      lda	#0
   2450  0de7		       4c 6a 06 	      jmp	iErr2
   2451  0dea							;
   2452  0dea		       20 80 2d    iTRACEPROG jsr	popR0
   2453  0ded		       a5 52		      lda	R0
   2454  0def		       85 40		      sta	ILTrace
   2455  0df1		       4c 9e 02 	      jmp	NextIL
   2456  0df4
   2457  0df4							;=====================================================
   2458  0df4							; Define start of non page zero data
   2459 U4426 ????				      seg.u	TBData
   2460 U3750					      org	PROGEND
   2461 U3750							;=================================================================
   2462 U3750							;
   2463 U3750					      if	IL_DEBUG_TEXT
------- FILE ILKeyText.inc LEVEL 2 PASS 6
      0 U3750					      include	"ILKeyText.inc"
      1  0df4					      seg	Code
      2  0df4					      if	IL_DEBUG_TEXT
      3  0df4				   ILTEXTTABLE
      0  0df4					      db	0,23,"iXINIT		   ",0
      1  0df4		       00 17 69 58*	      .byte.b	0,23,"iXINIT		   ",0
      0  0e0b					      db	1,23,"iDONE		   ",0
      1  0e0b		       01 17 69 44*	      .byte.b	1,23,"iDONE		   ",0
      0  0e22					      db	2,23,"iPRS		   ",0
      1  0e22		       02 17 69 50*	      .byte.b	2,23,"iPRS		   ",0
      0  0e39					      db	3,23,"iPRN		   ",0
      1  0e39		       03 17 69 50*	      .byte.b	3,23,"iPRN		   ",0
      0  0e50					      db	4,23,"iSPC		   ",0
      1  0e50		       04 17 69 53*	      .byte.b	4,23,"iSPC		   ",0
      0  0e67					      db	5,23,"iNLINE		   ",0
      1  0e67		       05 17 69 4e*	      .byte.b	5,23,"iNLINE		   ",0
      0  0e7e					      db	6,23,"iNXT		   ",0
      1  0e7e		       06 17 69 4e*	      .byte.b	6,23,"iNXT		   ",0
      0  0e95					      db	7,23,"iXFER		   ",0
      1  0e95		       07 17 69 58*	      .byte.b	7,23,"iXFER		   ",0
      0  0eac					      db	8,23,"iSAV		   ",0
      1  0eac		       08 17 69 53*	      .byte.b	8,23,"iSAV		   ",0
      0  0ec3					      db	9,23,"iRSTR		   ",0
      1  0ec3		       09 17 69 52*	      .byte.b	9,23,"iRSTR		   ",0
      0  0eda					      db	10,23,"iCMPR		    ",0
      1  0eda		       0a 17 69 43*	      .byte.b	10,23,"iCMPR		    ",0
      0  0ef1					      db	11,23,"iINNUM		    ",0
      1  0ef1		       0b 17 69 49*	      .byte.b	11,23,"iINNUM		    ",0
      0  0f08					      db	12,23,"iFIN		    ",0
      1  0f08		       0c 17 69 46*	      .byte.b	12,23,"iFIN		    ",0
      0  0f1f					      db	13,23,"iERR		    ",0
      1  0f1f		       0d 17 69 45*	      .byte.b	13,23,"iERR		    ",0
      0  0f36					      db	14,23,"iADD		    ",0
      1  0f36		       0e 17 69 41*	      .byte.b	14,23,"iADD		    ",0
      0  0f4d					      db	15,23,"iSUB		    ",0
      1  0f4d		       0f 17 69 53*	      .byte.b	15,23,"iSUB		    ",0
      0  0f64					      db	16,23,"iNEG		    ",0
      1  0f64		       10 17 69 4e*	      .byte.b	16,23,"iNEG		    ",0
      0  0f7b					      db	17,23,"iMUL		    ",0
      1  0f7b		       11 17 69 4d*	      .byte.b	17,23,"iMUL		    ",0
      0  0f92					      db	18,23,"iDIV		    ",0
      1  0f92		       12 17 69 44*	      .byte.b	18,23,"iDIV		    ",0
      0  0fa9					      db	19,23,"iSTORE		    ",0
      1  0fa9		       13 17 69 53*	      .byte.b	19,23,"iSTORE		    ",0
      0  0fc0					      db	20,23,"iIND		    ",0
      1  0fc0		       14 17 69 49*	      .byte.b	20,23,"iIND		    ",0
      0  0fd7					      db	21,23,"iLST		    ",0
      1  0fd7		       15 17 69 4c*	      .byte.b	21,23,"iLST		    ",0
      0  0fee					      db	22,23,"iINIT		    ",0
      1  0fee		       16 17 69 49*	      .byte.b	22,23,"iINIT		    ",0
      0  1005					      db	23,23,"iGETLINE	    ",0
      1  1005		       17 17 69 47*	      .byte.b	23,23,"iGETLINE	    ",0
      0  101c					      db	24,23,"iINSRT		    ",0
      1  101c		       18 17 69 49*	      .byte.b	24,23,"iINSRT		    ",0
      0  1033					      db	25,23,"iRTN		    ",0
      1  1033		       19 17 69 52*	      .byte.b	25,23,"iRTN		    ",0
      0  104a					      db	26,23,"MONITOR 	    ",0
      1  104a		       1a 17 4d 4f*	      .byte.b	26,23,"MONITOR 	    ",0
      0  1061					      db	27,23,"iLIT		    ",0
      1  1061		       1b 17 69 4c*	      .byte.b	27,23,"iLIT		    ",0
      0  1078					      db	28,23,"iCALL		    ",0
      1  1078		       1c 17 69 43*	      .byte.b	28,23,"iCALL		    ",0
      0  108f					      db	29,23,"iJMP		    ",0
      1  108f		       1d 17 69 4a*	      .byte.b	29,23,"iJMP		    ",0
      0  10a6					      db	30,23,"iVINIT		    ",0
      1  10a6		       1e 17 69 56*	      .byte.b	30,23,"iVINIT		    ",0
      0  10bd					      db	31,23,"iERRGOTO	    ",0
      1  10bd		       1f 17 69 45*	      .byte.b	31,23,"iERRGOTO	    ",0
      0  10d4					      db	32,23,"iTST		    ",0
      1  10d4		       20 17 69 54*	      .byte.b	32,23,"iTST		    ",0
      0  10eb					      db	33,23,"iTSTV		    ",0
      1  10eb		       21 17 69 54*	      .byte.b	33,23,"iTSTV		    ",0
      0  1102					      db	34,23,"iTSTL		    ",0
      1  1102		       22 17 69 54*	      .byte.b	34,23,"iTSTL		    ",0
      0  1119					      db	35,23,"iTSTN		    ",0
      1  1119		       23 17 69 54*	      .byte.b	35,23,"iTSTN		    ",0
      0  1130					      db	36,23,"iFREE		    ",0
      1  1130		       24 17 69 46*	      .byte.b	36,23,"iFREE		    ",0
      0  1147					      db	37,23,"iRANDOM 	    ",0
      1  1147		       25 17 69 52*	      .byte.b	37,23,"iRANDOM 	    ",0
      0  115e					      db	38,23,"iABS		    ",0
      1  115e		       26 17 69 41*	      .byte.b	38,23,"iABS		    ",0
     43  1175							;
     44  1175					      if	DISK_ACCESS
      0  1175					      db	39,23,"iOPENREAD	    ",0
      1  1175		       27 17 69 4f*	      .byte.b	39,23,"iOPENREAD	    ",0
      0  118c					      db	40,23,"iOPENWRITE	    ",0
      1  118c		       28 17 69 4f*	      .byte.b	40,23,"iOPENWRITE	    ",0
      0  11a3					      db	41,23,"iDCLOSE 	    ",0
      1  11a3		       29 17 69 44*	      .byte.b	41,23,"iDCLOSE 	    ",0
      0  11ba					      db	42,23,"iDGETLINE	    ",0
      1  11ba		       2a 17 69 44*	      .byte.b	42,23,"iDGETLINE	    ",0
      0  11d1					      db	43,23,"iDLIST		    ",0
      1  11d1		       2b 17 69 44*	      .byte.b	43,23,"iDLIST		    ",0
      0  11e8					      db	44,23,"iDDIR		    ",0
      1  11e8		       2c 17 69 44*	      .byte.b	44,23,"iDDIR		    ",0
      0  11ff					      db	45,23,"iRMFILE 	    ",0
      1  11ff		       2d 17 69 52*	      .byte.b	45,23,"iRMFILE 	    ",0
     52  1216				  -	      else
     53  1216				  -	      db	39,23,"NextIL		    ",0
     54  1216				  -	      db	40,23,"NextIL		    ",0
     55  1216				  -	      db	41,23,"NextIL		    ",0
     56  1216				  -	      db	42,23,"NextIL		    ",0
     57  1216				  -	      db	43,23,"NextIL		    ",0
     58  1216				  -	      db	44,23,"NextIL		    ",0
     59  1216				  -	      db	45,23,"NextIL		    ",0
     60  1216					      endif
     61  1216							;
      0  1216					      db	46,23,"iCLEARSCREEN	    ",0
      1  1216		       2e 17 69 43*	      .byte.b	46,23,"iCLEARSCREEN	    ",0
      0  122d					      db	47,23,"iPOKEMEMORY	    ",0
      1  122d		       2f 17 69 50*	      .byte.b	47,23,"iPOKEMEMORY	    ",0
      0  1244					      db	48,23,"iPEEKMEMORY	    ",0
      1  1244		       30 17 69 50*	      .byte.b	48,23,"iPEEKMEMORY	    ",0
      0  125b					      db	49,23,"iTSTLET 	    ",0
      1  125b		       31 17 69 54*	      .byte.b	49,23,"iTSTLET 	    ",0
      0  1272					      db	50,23,"iTSTDONE	    ",0
      1  1272		       32 17 69 54*	      .byte.b	50,23,"iTSTDONE	    ",0
      0  1289					      db	51,23,"iGETCHAR	    ",0
      1  1289		       33 17 69 47*	      .byte.b	51,23,"iGETCHAR	    ",0
      0  12a0					      db	52,23,"iPUTCHAR	    ",0
      1  12a0		       34 17 69 50*	      .byte.b	52,23,"iPUTCHAR	    ",0
      0  12b7					      db	53,23,"iCallFunc	    ",0
      1  12b7		       35 17 69 43*	      .byte.b	53,23,"iCallFunc	    ",0
      0  12ce					      db	54,23,"iBranch 	    ",0
      1  12ce		       36 17 69 42*	      .byte.b	54,23,"iBranch 	    ",0
      0  12e5					      db	55,23,"iTSTStr 	    ",0
      1  12e5		       37 17 69 54*	      .byte.b	55,23,"iTSTStr 	    ",0
      0  12fc					      db	56,23,"iSetIrq 	    ",0
      1  12fc		       38 17 69 53*	      .byte.b	56,23,"iSetIrq 	    ",0
      0  1313					      db	57,23,"iTstIrq 	    ",0
      1  1313		       39 17 69 54*	      .byte.b	57,23,"iTstIrq 	    ",0
      0  132a					      db	58,23,"iRET		    ",0
      1  132a		       3a 17 69 52*	      .byte.b	58,23,"iRET		    ",0
      0  1341					      db	59,23,"iINSTR		    ",0
      1  1341		       3b 17 69 49*	      .byte.b	59,23,"iINSTR		    ",0
      0  1358					      db	60,23,"iMOD		    ",0
      1  1358		       3c 17 69 4d*	      .byte.b	60,23,"iMOD		    ",0
      0  136f					      db	61,23,"iTaskSet	    ",0
      1  136f		       3d 17 69 54*	      .byte.b	61,23,"iTaskSet	    ",0
      0  1386					      db	62,23,"iETask		    ",0
      1  1386		       3e 17 69 45*	      .byte.b	62,23,"iETask		    ",0
      0  139d					      db	63,23,"iNTask		    ",0
      1  139d		       3f 17 69 4e*	      .byte.b	63,23,"iNTask		    ",0
      0  13b4					      db	64,23,"iArray		    ",0
      1  13b4		       40 17 69 41*	      .byte.b	64,23,"iArray		    ",0
      0  13cb					      db	65,23,"iTaskKill	    ",0
      1  13cb		       41 17 69 54*	      .byte.b	65,23,"iTaskKill	    ",0
      0  13e2					      db	66,23,"iTaskStat	    ",0
      1  13e2		       42 17 69 54*	      .byte.b	66,23,"iTaskStat	    ",0
      0  13f9					      db	67,23,"iHexOut 	    ",0
      1  13f9		       43 17 69 48*	      .byte.b	67,23,"iHexOut 	    ",0
      0  1410					      db	68,23,"iReadComplete	    ",0
      1  1410		       44 17 69 52*	      .byte.b	68,23,"iReadComplete	    ",0
      0  1427					      db	69,23,"iReadStart	    ",0
      1  1427		       45 17 69 52*	      .byte.b	69,23,"iReadStart	    ",0
      0  143e					      db	70,23,"iStartIO	    ",0
      1  143e		       46 17 69 53*	      .byte.b	70,23,"iStartIO	    ",0
      0  1455					      db	71,23,"iEndIO		    ",0
      1  1455		       47 17 69 45*	      .byte.b	71,23,"iEndIO		    ",0
      0  146c					      db	72,23,"iLogNot 	    ",0
      1  146c		       48 17 69 4c*	      .byte.b	72,23,"iLogNot 	    ",0
      0  1483					      db	73,23,"iLogOr		    ",0
      1  1483		       49 17 69 4c*	      .byte.b	73,23,"iLogOr		    ",0
      0  149a					      db	74,23,"iLogAnd 	    ",0
      1  149a		       4a 17 69 4c*	      .byte.b	74,23,"iLogAnd 	    ",0
      0  14b1					      db	75,23,"iLogXor 	    ",0
      1  14b1		       4b 17 69 4c*	      .byte.b	75,23,"iLogXor 	    ",0
      0  14c8					      db	76,23,"iWTASK		    ",0
      1  14c8		       4c 17 69 57*	      .byte.b	76,23,"iWTASK		    ",0
      0  14df					      db	77,23,"iTASKPID	    ",0
      1  14df		       4d 17 69 54*	      .byte.b	77,23,"iTASKPID	    ",0
      0  14f6					      db	78,23,"iTRACEPROG	    ",0
      1  14f6		       4e 17 69 54*	      .byte.b	78,23,"iTRACEPROG	    ",0
      0  150d					      db	79,23,"idbgBasic	    ",0
      1  150d		       4f 17 69 64*	      .byte.b	79,23,"idbgBasic	    ",0
      0  1524					      db	80,23,"iIPCS		    ",0
      1  1524		       50 17 69 49*	      .byte.b	80,23,"iIPCS		    ",0
      0  153b					      db	81,23,"iIPCR		    ",0
      1  153b		       51 17 69 49*	      .byte.b	81,23,"iIPCR		    ",0
      0  1552					      db	82,23,"iIPCC		    ",0
      1  1552		       52 17 69 49*	      .byte.b	82,23,"iIPCC		    ",0
      0  1569					      db	83,23,"iIPCIO		    ",0
      1  1569		       53 17 69 49*	      .byte.b	83,23,"iIPCIO		    ",0
      0  1580					      db	84,23,"iPushMathStack	    ",0
      1  1580		       54 17 69 50*	      .byte.b	84,23,"iPushMathStack	    ",0
      0  1597					      db	85,23,"iPopMathStack	    ",0
      1  1597		       55 17 69 50*	      .byte.b	85,23,"iPopMathStack	    ",0
      0  15ae					      db	86,23,"iSaveMathStack	    ",0
      1  15ae		       56 17 69 53*	      .byte.b	86,23,"iSaveMathStack	    ",0
      0  15c5					      db	87,23,"iRestoreMathStack   ",0
      1  15c5		       57 17 69 52*	      .byte.b	87,23,"iRestoreMathStack   ",0
      0  15dc					      db	88,23,"iIncParmCount	    ",0
      1  15dc		       58 17 69 49*	      .byte.b	88,23,"iIncParmCount	    ",0
      0  15f3					      db	89,23,"iTaskGetMathStack   ",0
      1  15f3		       59 17 69 54*	      .byte.b	89,23,"iTaskGetMathStack   ",0
      0  160a					      db	90,23,"iTaskEnable	    ",0
      1  160a		       5a 17 69 54*	      .byte.b	90,23,"iTaskEnable	    ",0
      0  1621					      db	91,23,"iTaskSuspend	    ",0
      1  1621		       5b 17 69 54*	      .byte.b	91,23,"iTaskSuspend	    ",0
      0  1638					      db	92,23,"iTaskPutMathPtr     ",0
      1  1638		       5c 17 69 54*	      .byte.b	92,23,"iTaskPutMathPtr     ",0
      0  164f					      db	93,23,"iTSTVT		    ",0
      1  164f		       5d 17 69 54*	      .byte.b	93,23,"iTSTVT		    ",0
      0  1666					      db	94,23,"iSetR2		    ",0
      1  1666		       5e 17 69 53*	      .byte.b	94,23,"iSetR2		    ",0
      0  167d					      db	95,23,"iStk2Tmp	    ",0
      1  167d		       5f 17 69 53*	      .byte.b	95,23,"iStk2Tmp	    ",0
      0  1694					      db	96,23,"iTmp2Stk	    ",0
      1  1694		       60 17 69 54*	      .byte.b	96,23,"iTmp2Stk	    ",0
      0  16ab					      db	97,23,"iTSTBYTE	    ",0
      1  16ab		       61 17 69 54*	      .byte.b	97,23,"iTSTBYTE	    ",0
      0  16c2					      db	98,23,"iINCVAR 	    ",0
      1  16c2		       62 17 69 49*	      .byte.b	98,23,"iINCVAR 	    ",0
      0  16d9					      db	99,23,"iDECVAR 	    ",0
      1  16d9		       63 17 69 44*	      .byte.b	99,23,"iDECVAR 	    ",0
      0  16f0					      db	100,23,"iSLICE 	     ",0
      1  16f0		       64 17 69 53*	      .byte.b	100,23,"iSLICE 	     ",0
      0  1707					      db	101,23,"iTSTB		     ",0
      1  1707		       65 17 69 54*	      .byte.b	101,23,"iTSTB		     ",0
      0  171e					      db	102,23,"iTSTW		     ",0
      1  171e		       66 17 69 54*	      .byte.b	102,23,"iTSTW		     ",0
      0  1735					      db	103,23,"iOnGoto	     ",0
      1  1735		       67 17 69 4f*	      .byte.b	103,23,"iOnGoto	     ",0
      0  174c					      db	104,23,"iTSTRELOP	     ",0
      1  174c		       68 17 69 54*	      .byte.b	104,23,"iTSTRELOP	     ",0
      0  1763					      db	105,23,"iRepeatLine	     ",0
      1  1763		       69 17 69 52*	      .byte.b	105,23,"iRepeatLine	     ",0
      0  177a					      db	106,23,"iTSTBRANCH	     ",0
      1  177a		       6a 17 69 54*	      .byte.b	106,23,"iTSTBRANCH	     ",0
      0  1791					      db	107,23,"iFastXfer	     ",0
      1  1791		       6b 17 69 46*	      .byte.b	107,23,"iFastXfer	     ",0
      0  17a8					      db	108,23,"iSetTerminal	     ",0
      1  17a8		       6c 17 69 53*	      .byte.b	108,23,"iSetTerminal	     ",0
      0  17bf					      db	109,23,"iINDB		     ",0
      1  17bf		       6d 17 69 49*	      .byte.b	109,23,"iINDB		     ",0
      0  17d6					      db	110,23,"iSetBlock	     ",0
      1  17d6		       6e 17 69 53*	      .byte.b	110,23,"iSetBlock	     ",0
      0  17ed					      db	111,23,"iCopyBlock	     ",0
      1  17ed		       6f 17 69 43*	      .byte.b	111,23,"iCopyBlock	     ",0
      0  1804					      db	112,23,"iCmpBlock	     ",0
      1  1804		       70 17 69 43*	      .byte.b	112,23,"iCmpBlock	     ",0
      0  181b					      db	113,23,"iShift 	     ",0
      1  181b		       71 17 69 53*	      .byte.b	113,23,"iShift 	     ",0
      0  1832					      db	114,23,"iTimer 	     ",0
      1  1832		       72 17 69 54*	      .byte.b	114,23,"iTimer 	     ",0
      0  1849					      db	115,23,"iJmpEnd	     ",0
      1  1849		       73 17 69 4a*	      .byte.b	115,23,"iJmpEnd	     ",0
      0  1860					      db	116,23,"iJmpStart	     ",0
      1  1860		       74 17 69 4a*	      .byte.b	116,23,"iJmpStart	     ",0
      0  1877					      db	117,23,"iBeginBlock	     ",0
      1  1877		       75 17 69 42*	      .byte.b	117,23,"iBeginBlock	     ",0
      0  188e					      db	118,23,"iIfTrue	     ",0
      1  188e		       76 17 69 49*	      .byte.b	118,23,"iIfTrue	     ",0
      0  18a5					      db	119,23,"iIfFalse	     ",0
      1  18a5		       77 17 69 49*	      .byte.b	119,23,"iIfFalse	     ",0
      0  18bc					      db	$FF,23,"0		     ",0
      1  18bc		       ff 17 30 20*	      .byte.b	$FF,23,"0		     ",0
    137  18d3
    138  18d3							; Search for the il instruction and print the correct text for it
    139  18d3							; on entry a contains the ip instruction to print
    140  18d3
    141 U3750					      seg.u	TBData
    142 U3750		       00 00	   R0TempIL   ds	2
    143 U3752		       00	   ILSTA      ds	1
    144 U3753
    145  18d3					      Seg	Code
    146  18d3
    147  18d3		       8d 52 37    PrintILText sta	ILSTA
    148  18d6		       98		      tya
    149  18d7		       48		      pha
    150  18d8		       8a		      txa
    151  18d9		       48		      pha
    152  18da		       a5 52		      lda	R0
    153  18dc		       8d 50 37 	      sta	R0TempIL
    154  18df		       a5 53		      lda	R0+1
    155  18e1		       8d 50 37 	      sta	R0TempIL
    156  18e4		       a9 f4		      lda	#ILTEXTTABLE&$FF
    157  18e6		       85 52		      sta	R0
    158  18e8		       a9 0d		      LDA	#ILTEXTTABLE>>8
    159  18ea		       85 53		      sta	R0+1
    160  18ec							;Loop Here for each entry
    161  18ec		       a0 00	   PrintILLoop ldy	#0
    162  18ee		       b1 52		      lda	(R0),y
    163  18f0		       c9 ff		      cmp	#$FF
    164  18f2		       f0 2a		      beq	PrintILNotFound
    165  18f4		       cd 52 37 	      cmp	ILSTA
    166  18f7		       f0 11		      beq	PrintILFound
    167  18f9		       c8		      iny
    168  18fa		       b1 52		      lda	(R0),y
    169  18fc		       18		      clc
    170  18fd		       65 52		      adc	R0
    171  18ff		       85 52		      sta	R0
    172  1901		       a9 00		      lda	#0
    173  1903		       65 53		      adc	R0+1
    174  1905		       85 53		      sta	R0+1
    175  1907		       4c ec 18 	      jmp	PrintILLoop
    176  190a							; The text was discovered
    177  190a		       c8	   PrintILFound iny		; point to length of instruction
    178  190b		       c8		      iny		; Point to start of text
    179  190c		       98		      tya
    180  190d		       18		      clc
    181  190e		       65 52		      adc	R0
    182  1910		       a8		      tay		; Low order byte of address
    183  1911		       a9 00		      lda	#0
    184  1913		       65 53		      adc	R0+1
    185  1915		       aa		      tax		; High order byte of address
    186  1916		       a9 00		      lda	#0	; Termination byte of string
    187  1918		       20 be 21 	      jsr	PrtStr	; print the string
    188  191b		       4c 24 19 	      jmp	PrintILDone
    189  191e
    190  191e		       ad 52 37    PrintILNotFound lda	ILSTA
    191  1921		       20 63 21 	      jsr	HexToOut
    192  1924
    193  1924		       ad 50 37    PrintILDone lda	R0TempIL
    194  1927		       85 52		      sta	R0
    195  1929		       ad 51 37 	      lda	R0TempIL+1
    196  192c		       85 52		      sta	R0
    197  192e		       68		      pla
    198  192f		       aa		      tax
    199  1930		       68		      pla
    200  1931		       a8		      tay
    201  1932		       60		      rts
    202  1933					      endif
------- FILE mytb.asm
   2465  1933					      endif
------- FILE time.asm LEVEL 2 PASS 6
      0  1933					      include	"time.asm"
      1  1933							;This is the timer management functions
      2  1933							; a = 0 turn off irq, stop timer
      3  1933							; a = 1 turn on irq, set parm contained in x
      4  1933							; a = 4 get low value
      5  1933							; a = 2 get high value
      6  1933
      7  1933		       e0 10	   timerinterface equ	$E010
      8  1933		       00 1e	   cTimerControl equ	$1E
      9  1933		       00 00	   cTimerStop equ	0
     10  1933		       00 01	   cTimerStart equ	1
     11  1933		       00 02	   cTimerLow  equ	2
     12  1933		       00 04	   cTimerHigh equ	4
     13  1933
     14  1933							; returns	$82 ack    dec(130)
     15  1933							;		$83 Failed dec(131)
     16  1933
     17  1933							; il interface to the timer
     18  1933
     19  1933				   iTimer
     20  1933		       20 80 2d 	      jsr	popR0
     21  1936		       a6 52		      ldx	R0	; Set time parameter
     22  1938		       20 80 2d 	      jsr	popR0
     23  193b		       a5 52		      lda	R0	; control parameter 0-4
     24  193d		       20 47 19 	      jsr	iTimerif
     25  1940		       85 52		      sta	R0
     26  1942		       86 53		      stx	R0+1
     27  1944		       4c 0a 07 	      jmp	pushR0nextIl
     28  1947
     29  1947							; Actual system interface to the timer
     30  1947							; x is value 9 = 1 second, 1-5 = value * 10ms 6 = 100ms, 7=250ms, 8=500ms, 0 = stop timer
     31  1947							; a is 0,1,2,4
     32  1947				   iTimerif
     33  1947
     34  1947		       c9 02		      cmp	#cTimerLow	; Do they want the low byte
     35  1949		       b0 25		      bcs	iTimerValue	; Just get the value we need
     36  194b		       78		      sei		; Disable the interupts
     37  194c		       48		      pha		; save the command
     38  194d		       a9 1e		      lda	#cTimerControl	; Load the timer control command
     39  194f		       8d 10 e0 	      sta	timerinterface	; Write it to the timer port
     40  1952		       8a		      txa		; get value to write, if cmd = 0 stop then x is init to zero
     41  1953		       8d 10 e0 	      sta	timerinterface	; write it to the port the timeout value
     42  1956		       68		      pla		; Get the actual command back
     43  1957		       c9 00		      cmp	#cTimerStop	; if the command was stop timer just get out
     44  1959		       f0 0f		      beq	iTimerAck	; if not then get ack/nak and continue
     45  195b
     46  195b		       a9 00		      lda	#0	; Clear the counter
     47  195d		       8d 18 44 	      sta	timercounter
     48  1960		       8d 19 44 	      sta	timercounter+1
     49  1963		       8d 1a 44 	      sta	timercounter+2
     50  1966		       8d 1b 44 	      sta	timercounter+3
     51  1969		       58		      cli		; enable the interupts, this is start/restart timer
     52  196a
     53  196a				   iTimerAck
     54  196a		       ad 10 e0 	      lda	timerinterface	; get the ack nak
     55  196d		       a2 00		      ldx	#0	; the ack value is single byte so pad with x
     56  196f		       60		      rts		; Get out of here
     57  1970
     58  1970				   iTimerValue		; get the value from the offsets provided
     59  1970		       08		      php		; Save the flags so we can restore irq setting later
     60  1971		       78		      sei		; turn off the interupts
     61  1972		       aa		      tax		; the control is also the value
     62  1973		       bd 16 44 	      lda	[timercounter-2],x	; get the high byte of value
     63  1976		       48		      pha		; Save the value for x set
     64  1977		       bd 17 44 	      lda	[timercounter-1],x	; get the low part of value
     65  197a		       aa		      tax
     66  197b		       68		      pla
     67  197c		       28		      plp		; restore the interupt flag if it was enabled
     68  197d		       60		      rts
     69  197e
     70  197e
     71  197e
------- FILE mytb.asm
------- FILE io.asm LEVEL 2 PASS 6
      0  197e					      include	"io.asm"
      1  197e							; This is the io blocks and function for reading and writing
      2  197e							; to devices attached to this computer.
      3  197e							; This supports devices mapped at e000 thru efff in slot sizes of 16 byte
      4  197e							;
      5  197e							;=====================================================================
      6  197e							; Device configuration equates
      7  197e		       00 00	   ConsoleID  equ	0
      8  197e		       00 08	   SerialID   equ	[1<<3]
      9  197e		       00 10	   ClockID    equ	[2<<3]
     10  197e		       00 18	   TimerID    equ	[3<<3]
     11  197e		       00 20	   DiskID     equ	[4<<3]
     12  197e
     13  197e		       00 0a	   IO_MAX_DEVICES equ	10
     14  197e		       00 06	   IO_VECT_LEN equ	6
     15  197e
     16  197e		       00 01	   IO_DEVICE_CLOSED equ	1	; The device is not open
     17  197e		       00 02	   IO_DEVICE_INVALID equ	2	; The Device number provided is invalid
     18  197e
     19  197e							;========================================================================================
     20  197e							; Uninitialized data segment
     21 U3753					      seg.u	TBData
     22 U3753
     23 U3753		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
     24 U3755		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
     25 U3757		       00 00	   BStatVec   ds	2	; This is used by inteface to read write status/config information
      0 U3759				   BActiveDevice db	1	; the index of the current device block
      1 U3759		       01		      .byte.b	1
      0 U375a				   BActiveDriver db	1	; Index of the device driver block
      1 U375a		       01		      .byte.b	1
     28 U375b
     29 U375b							;============================================================================================
     30  197e					      Seg	Code
     31  197e							; IRQ BASIC Code Service RTN Support
      0  197e				   SaveIrqReg db	0	; Store current setting
      1  197e		       00		      .byte.b	0
      0  197f				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1  197f		       00		      .byte.b	0
      0  1980				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1  1980		       00		      .byte.b	0
      0  1981				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1  1981		       00 00		      .byte.b	0,0
     36  1983
     37  1983							;============================================================================================
     38  1983							; Define the device interface blocks
     39  1983				   DeviceDriverBlocks
     40  1983				   ConsoleDevice		; Block 0
      0  1983					      dw	ConsoleID	; device idenifier Console
      1  1983		       00 00		      .word.w	ConsoleID
      0  1985					      dw	cin	; read function vector
      1  1985		       09 f0		      .word.w	cin
      0  1987					      dw	cout	; write function vector
      1  1987		       0c f0		      .word.w	cout
      0  1989					      dw	cstatus	; Get current Status info/Write config
      1  1989		       0f f0		      .word.w	cstatus
     45  198b
     46  198b				   SerialDevice 		; Block 1
      0  198b					      dw	SerialID	; device idenifier Serial
      1  198b		       08 00		      .word.w	SerialID
      0  198d					      dw	SerialIn	; read function vector
      1  198d		       79 1a		      .word.w	SerialIn
      0  198f					      dw	SerialOut	; write function vector
      1  198f		       79 1a		      .word.w	SerialOut
      0  1991					      dw	SerialStatus	; Get current Status info/Write config
      1  1991		       79 1a		      .word.w	SerialStatus
     51  1993
     52  1993				   ClockDevice		; Block 2
      0  1993					      dw	ClockID	; Day/date Clock
      1  1993		       10 00		      .word.w	ClockID
      0  1995					      dw	ClockRead	; Read the date from clock
      1  1995		       7a 1a		      .word.w	ClockRead
      0  1997					      dw	ClockWrite	; Set the date/time of clock
      1  1997		       7a 1a		      .word.w	ClockWrite
      0  1999					      dw	#0	; No Status/Config Function
      1  1999		       00 00		      .word.w	#0
     57  199b
     58  199b				   TimerDevice		; Block 3
      0  199b					      dw	TimerID	; Timer/interrupt interface
      1  199b		       18 00		      .word.w	TimerID
      0  199d					      dw	TimerStart	; Start the timer
      1  199d		       7b 1a		      .word.w	TimerStart
      0  199f					      dw	TimerStop	; Stop the timer
      1  199f		       7b 1a		      .word.w	TimerStop
      0  19a1					      dw	TimerStatus	; Config/read status
      1  19a1		       7b 1a		      .word.w	TimerStatus
     63  19a3
      0  19a3				   DiskDevice dw	DiskID	; Block 4
      1  19a3		       20 00		      .word.w	DiskID
      0  19a5					      dw	DIN	; Disk Input / read function
      1  19a5		       29 32		      .word.w	DIN
      0  19a7					      dw	DOUT	; Disk Output / write function
      1  19a7		       10 32		      .word.w	DOUT
      0  19a9					      dw	DSTAT	; Disk Status/open/close etc information
      1  19a9		       42 32		      .word.w	DSTAT
     68  19ab							;
     69  19ab							;======================================================================
     70  19ab							; Define the Device/Slot,driver control blocks
     71  19ab							; entry format: ControlWord,DeviceDriver,PortAddress,StatusWord
     72  19ab							; Fixed at 10 devices memory usage is getting pretty big!!!!!!
     73  19ab							; Control word : bit 0 = active 1, Free 0
     74  19ab
     75  19ab				   DeviceIoBlocks
      0  19ab					      dw	1, ConsoleID, $E000, 0	; Console device is 0 file
      1  19ab		       01 00 00 00*	      .word.w	1, ConsoleID, $E000, 0
      0  19b3					      dw	1, ClockID, $E010, 0	; Port for the day/time clock
      1  19b3		       01 00 10 00*	      .word.w	1, ClockID, $E010, 0
      0  19bb					      dw	1, TimerID, $E010, 0	; Timer interface
      1  19bb		       01 00 18 00*	      .word.w	1, TimerID, $E010, 0
      0  19c3					      dw	1, DiskID, $E010, 0	; Disk Driver interface
      1  19c3		       01 00 20 00*	      .word.w	1, DiskID, $E010, 0
      0  19cb					      dw	1, SerialID, $E020, 0	; Second terminal(default Basic debug)
      1  19cb		       01 00 08 00*	      .word.w	1, SerialID, $E020, 0
      0  19d3					      dw	0, SerialID, $E030, 0	; Unused slot
      1  19d3		       00 00 08 00*	      .word.w	0, SerialID, $E030, 0
      0  19db					      dw	0, SerialID, $E040, 0	; Unused slot
      1  19db		       00 00 08 00*	      .word.w	0, SerialID, $E040, 0
      0  19e3					      dw	0, SerialID, $E050, 0	; Unused slot
      1  19e3		       00 00 08 00*	      .word.w	0, SerialID, $E050, 0
      0  19eb					      dw	0, SerialID, $E060, 0	; Unused slot
      1  19eb		       00 00 08 00*	      .word.w	0, SerialID, $E060, 0
      0  19f3					      dw	0, SerialID, $E070, 0	; Unused slot
      1  19f3		       00 00 08 00*	      .word.w	0, SerialID, $E070, 0
     86  19fb							;
     87  19fb							;======================================================================
     88  19fb							;
     89  19fb					      Seg	Code
     90  19fb							;======================================================================
     91  19fb							; This is the Basic IRQ handler, works with task manager, assumes timer interupt
     92  19fb							;
     93  19fb		       48	   ServiceIrq pha
     94  19fc		       8a		      txa
     95  19fd		       48		      pha
     96  19fe		       a2 00		      ldx	#0
     97  1a00				   ServiceLoop
     98  1a00		       fe 18 44 	      inc	timercounter,x
     99  1a03		       d0 05		      bne	ServiceCont
    100  1a05		       e8		      inx
    101  1a06		       e0 04		      cpx	#4
    102  1a08		       d0 f6		      bne	ServiceLoop
    103  1a0a				   ServiceCont
    104  1a0a		       ad 7f 19 	      lda	IRQStatus
    105  1a0d		       f0 0a		      beq	RetIrq
    106  1a0f		       ad 80 19 	      lda	IRQPending
    107  1a12		       d0 05		      bne	RetIrq
    108  1a14		       a9 01		      lda	#1
    109  1a16		       8d 80 19 	      sta	IRQPending
    110  1a19				   RetIrq
    111  1a19		       68		      pla
    112  1a1a		       aa		      tax
    113  1a1b		       68		      pla
    114  1a1c		       40		      rti
    115  1a1d							;======================================================================
    116  1a1d							; Jump to the output/input function in BOutVec/BInVec
    117  1a1d							;
    118  1a1d		       6c 55 37    VOUTCH     jmp	(BOutVec)	; Primary block io vectors
    119  1a20		       6c 53 37    VGETCH     jmp	(BInVec)
    120  1a23		       6c 57 37    VSTAT      jmp	(BStatVec)
    121  1a26							;
    122  1a26							;======================================================================
    123  1a26							; IO Service functions
    124  1a26							; Validate the device index and set x to offest in table
    125  1a26							; does not return to ioInterface if invalid, returns to original caller
    126  1a26							; should be called immediatly after entering the ioInterface call
    127  1a26				   ioValidateDevice
    128  1a26		       e0 0a		      cpx	#IO_MAX_DEVICES
    129  1a28		       90 04		      bcc	ioValidIndex
    130  1a2a		       a2 02		      ldx	#IO_DEVICE_INVALID
    131  1a2c		       b0 13		      bcs	ioInvalidDevice
    132  1a2e				   ioValidIndex
    133  1a2e		       8a		      txa
    134  1a2f		       0a		      asl		; Multiply by 8
    135  1a30		       0a		      asl
    136  1a31		       0a		      asl
    137  1a32		       aa		      tax		; Point to actual offset in the table
    138  1a33		       ec 59 37 	      cpx	BActiveDevice	; is it already active ?
    139  1a36		       f0 0d		      beq	ioValidDevice	; Shortcut if this is the active device already
    140  1a38		       a9 01		      lda	#1	; Active flag
    141  1a3a		       3d ab 19 	      and	DeviceIoBlocks,x	; Check if the device is active
    142  1a3d		       d0 06		      bne	ioValidDevice	; The device is active and valid index
    143  1a3f		       a2 01		      ldx	#IO_DEVICE_CLOSED
    144  1a41
    145  1a41				   ioInvalidDevice
    146  1a41		       68		      pla		; Remove return address of IO interface
    147  1a42		       68		      pla
    148  1a43		       38		      sec		; ensure that carry is set
    149  1a44		       60		      rts
    150  1a45
    151  1a45				   ioValidDevice
    152  1a45		       18		      clc
    153  1a46		       60		      rts
    154  1a47							;
    155  1a47							;===================================================================================
    156  1a47							; Set the io device jmp vectors
    157  1a47							; input x contains the vector to the active Device IO Block
    158  1a47							; output a, x undefined y unchanged
    159  1a47				   ioSetDeviceVectors
    160  1a47		       ec 59 37 	      cpx	BActiveDevice	; Check if already set
    161  1a4a		       f0 1b		      beq	ioSetDevExit	; if already set then do nothing
    162  1a4c
    163  1a4c		       8e 59 37 	      stx	BActiveDevice	; set the active device vector
    164  1a4f		       98		      tya
    165  1a50		       48		      pha
    166  1a51
    167  1a51		       bc ad 19 	      ldy	DeviceIoBlocks+2,x	; Get the device driver index
    168  1a54		       8c 5a 37 	      sty	BActiveDriver	; Pointer to active Device driver
    169  1a57		       a2 00		      ldx	#0	; Transfer the 6 pointers to the Vectors
    170  1a59				   ioSetDevLoop
    171  1a59		       b9 85 19 	      lda	DeviceDriverBlocks+2,y
    172  1a5c		       9d 53 37 	      sta	BInVec,x
    173  1a5f		       e8		      inx
    174  1a60		       c8		      iny
    175  1a61		       e0 06		      cpx	#IO_VECT_LEN	; Transfer the vector length to copy
    176  1a63		       d0 f4		      bne	ioSetDevLoop
    177  1a65
    178  1a65		       68		      pla
    179  1a66		       a8		      tay
    180  1a67				   ioSetDevExit
    181  1a67		       60		      rts
    182  1a68							;
    183  1a68							;======================================================================
    184  1a68							; Generic call interface for devices
    185  1a68							; input x = DeviceIoBlockIndex
    186  1a68							; Carry set if error, x contains the error code
    187  1a68							; all other parameters are dependant upon the actual device interface
    188  1a68							;
    189  1a68							; ioPutCH  a contains the character to send
    190  1a68		       20 26 1a    ioPutCH    jsr	ioValidateDevice
    191  1a6b		       48		      pha
    192  1a6c		       20 47 1a 	      jsr	ioSetDeviceVectors
    193  1a6f		       68		      pla
    194  1a70		       20 1d 1a 	      jsr	VOUTCH
    195  1a73		       18		      clc
    196  1a74		       60		      rts
    197  1a75
    198  1a75							; io Getch returns the character read from device
    199  1a75		       20 26 1a    ioGetCH    jsr	ioValidateDevice
    200  1a78
    201  1a78		       60		      rts
    202  1a79							;
    203  1a79							;======================================================================
    204  1a79							;TTY interface functions,
    205  1a79							;	a contains the character to send
    206  1a79							;	x contains the Device ID (equals index into io blocks)	of the io block to used
    207  1a79							;
    208  1a79				   SerialIn
    209  1a79
    210  1a79				   SerialOut
    211  1a79
    212  1a79				   SerialStatus
    213  1a79		       60		      rts
    214  1a7a							;
    215  1a7a							;======================================================================
    216  1a7a							; Date/Time clock interface
    217  1a7a				   ClockRead
    218  1a7a
    219  1a7a				   ClockWrite
    220  1a7a		       60		      rts
    221  1a7b							;
    222  1a7b							;======================================================================
    223  1a7b							;
    224  1a7b				   TimerStart
    225  1a7b
    226  1a7b				   TimerStop
    227  1a7b
    228  1a7b				   TimerStatus
    229  1a7b		       60		      rts
    230  1a7c
------- FILE mytb.asm
------- FILE tokenizer.asm LEVEL 2 PASS 6
      0  1a7c					      include	"tokenizer.asm"
      1  1a7c					      seg	Code
      2  1a7c		       00 00	   DEBUGPARSER equ	FALSE	; Print debugging information
      3  1a7c
      4  1a7c							; Define the types of tokens found, and identifiers
      5  1a7c		       00 7f	   KeywordsMax equ	$7F	; Allow to be range  1 to 127	key words, high order bit must be 0 for it to be a key word
      6  1a7c		       00 80	   tVa	      equ	$80	; Variable A = 1, .... Z = 26	 ^ = 27
      7  1a7c		       00 81	   tVb	      equ	$81	; Variables 128 - 157	$80-$9D
      8  1a7c		       00 99	   tVz	      equ	tVa+25	; Value of the last variable
      9  1a7c
     10  1a7c		       00 9b	   tVhat      equ	$9B	; Variable ^
     11  1a7c		       00 9c	   tVhash     equ	$9C	; Variable #
     12  1a7c		       00 9d	   tVat       equ	$9D	; Variable @ = 0
     13  1a7c
     14  1a7c							; Base variable type supported by This basic
     15  1a7c							; Unsigned types always have the 0 bit set to 1
     16  1a7c		       00 a0	   tString    equ	$A0	; Strings all start with this byte and end with  byte value 0 strings can be accessed with array slicing
     17  1a7c		       00 a2	   tByte      equ	$A2	; Signed Byte value
     18  1a7c		       00 a4	   tInteger   equ	$A4	; all tokenized integers start with 251 as first byte 16 bit signed number
     19  1a7c		       00 a6	   tLong      equ	$A6	; Signed 32 bit integer
     20  1a7c
     21  1a7c		       00 a1	   tArray     equ	$A1	; Identifies Array Type, the byte following defines the length of each element
     22  1a7c							; Arrays of string are arrays of pointers 2 bytes each
     23  1a7c		       00 a3	   tPointer   equ	$A3	; Pointer  unsigned 16 bit
     24  1a7c		       00 a5	   tIndirect  equ	$A5	; Points to an address that points to the data 16 bits
     25  1a7c		       00 a7	   tuByte     equ	$A7	; Unsigned byte value 8 bit unsigned value
     26  1a7c		       00 a9	   tUint      equ	$A9	; unsigned integer type 16 bit
     27  1a7c		       00 ab	   tUlong     equ	$AB	; Unsigned 32 bit integer
     28  1a7c
     29  1a7c		       3c 3e	   Operators  BYTE.b	"<>"
     30  1a7e		       3c 3d		      BYTE.b	"<="
     31  1a80		       3e 3d		      BYTE.b	">="
     32  1a82		       3c 3c		      Byte.b	"<<"
     33  1a84		       3e 3e		      Byte.b	">>"
     34  1a86		       3c 00		      BYTE.b	"<",0
     35  1a88		       3d 00		      BYTE.b	"=",0
     36  1a8a		       3e 00		      BYTE.b	">",0
     37  1a8c		       2b 2b		      Byte.b	"++"
     38  1a8e		       2b 00		      BYTE.b	"+",0
     39  1a90		       2d 2d		      Byte.b	"--"
     40  1a92		       2d 00		      BYTE.b	"-",0
     41  1a94		       2f 00		      BYTE.b	"/",0
     42  1a96		       25 00		      BYTE.b	"%",0
     43  1a98		       2a 00		      BYTE.b	"*",0
     44  1a9a		       28 00		      BYTE.b	"(",0
     45  1a9c		       29 00		      BYTE.b	")",0
     46  1a9e		       2c 00		      BYTE.b	",",0
     47  1aa0		       3b 00		      BYTE.b	";",0
     48  1aa2		       5b 00		      BYTE.b	"[",0
     49  1aa4		       5d 00		      BYTE.b	"]",0
     50  1aa6		       3a 00		      BYTE.b	":",0
     51  1aa8		       24 00		      BYTE.b	"$",0
     52  1aaa		       21 00		      BYTE.b	"!",0
     53  1aac		       3f 00		      BYTE.b	"?",0
     54  1aae		       2e 00		      BYTE.b	".",0
     55  1ab0		       26 00		      BYTE.b	"&",0
     56  1ab2		       27 00		      Byte.b	"'",0
     57  1ab4		       7c 00		      Byte.b	"|",0
     58  1ab6		       7e 00		      Byte.b	"~",0
     59  1ab8		       00 00		      BYTE.b	0,0
     60  1aba
     61  1aba		       f5 f3 f6 2e*OperValues BYTE.b	oNotEqual,oLessEqual,oGreaterEqual,oSHL,oSHR,oLess,oEqual,oGreater
     62  1ac2		       02 ea 03 eb*	      BYTE.b	oINC, oPlus, oDEC, oMinus, oDivide, oModulo, oMultiply
     63  1ac9		       e0 e1 e2 e3*	      BYTE.b	oLeftBracket, oRightBracket, oComma, oSemiColon, oLeftSQBracket, oRightSQBracket
     64  1acf		       e6 e7 e8 0b*	      BYTE.b	oColon, oDollar, oBang, oQuestion, oPeriod, oAmphistan, oQuote, oBar,oTilde
     65  1ad8
     66  1ad8		       00 0b	   oQuestion  equ	kPrint
     67  1ad8							;    2 is =
     68  1ad8							;    1 is <
     69  1ad8							;    3 is <=
     70  1ad8							;    5 is <>
     71  1ad8							;    4 is >
     72  1ad8							;    6 is >=
     73  1ad8		       00 f1	   oLess      equ	$F1
     74  1ad8		       00 f2	   oEqual     equ	$F2
     75  1ad8		       00 f3	   oLessEqual equ	$F3
     76  1ad8		       00 f4	   oGreater   equ	$F4
     77  1ad8		       00 f5	   oNotEqual  equ	$F5
     78  1ad8		       00 f6	   oGreaterEqual equ	$F6
     79  1ad8
     80  1ad8		       00 e0	   oLeftBracket equ	$E0
     81  1ad8		       00 e1	   oRightBracket equ	$E1
     82  1ad8		       00 e2	   oComma     equ	$E2
     83  1ad8		       00 e3	   oSemiColon equ	$E3
     84  1ad8		       00 e4	   oLeftSQBracket equ	$E4
     85  1ad8		       00 e5	   oRightSQBracket equ	$E5
     86  1ad8		       00 e6	   oColon     equ	$E6
     87  1ad8		       00 e7	   oDollar    equ	$E7
     88  1ad8		       00 e8	   oBang      equ	$E8
     89  1ad8		       00 e9	   oPeriod    equ	$E9
     90  1ad8
     91  1ad8		       00 ea	   oPlus      equ	$EA
     92  1ad8		       00 eb	   oMinus     equ	$EB
     93  1ad8		       00 ec	   oDivide    equ	$EC
     94  1ad8		       00 ed	   oModulo    equ	$ED
     95  1ad8		       00 ee	   oMultiply  equ	$EE
     96  1ad8
     97  1ad8		       00 ed	   oPercent   equ	oModulo
     98  1ad8		       00 2c	   oAmphistan equ	kAnd
     99  1ad8		       00 2a	   oBar       equ	kOr
    100  1ad8		       00 0a	   oQuote     equ	kRem
    101  1ad8		       00 2b	   oTilde     equ	kXor
    102  1ad8		       00 2d	   oSHR       equ	kShr
    103  1ad8		       00 2e	   oSHL       equ	kShl
    104  1ad8		       00 02	   oINC       equ	kInc
    105  1ad8		       00 03	   oDEC       equ	kDec
    106  1ad8
    107  1ad8		       00 f0	   tOperatorX equ	$F0	;+ operator Value  ; stores the value used to do the relational operator compare
    108  1ad8
    109  1ad8		       00 ff	   tError     equ	$FF	; Error should never happen
    110  1ad8							;============================================================================================
    111  1ad8							; Keyword and seperator values
    112  1ad8				   '
    113  1ad8		       00 01	   kBeginKey  equ	kLet
    114  1ad8							;
    115  1ad8		       00 01	   kLet       equ	1
    116  1ad8		       00 02	   kInc       equ	kLet+1
    117  1ad8		       00 03	   kDec       equ	kInc+1
    118  1ad8		       00 04	   kIreturn   equ	kDec+1
    119  1ad8		       00 05	   kIf	      equ	kIreturn+1
    120  1ad8		       00 06	   kThen      equ	kIf+1
    121  1ad8		       00 07	   kGoto      equ	kThen+1
    122  1ad8		       00 08	   kGosub     equ	kGoto+1
    123  1ad8		       00 09	   kReturn    equ	kGosub+1
    124  1ad8		       00 0a	   kRem       equ	kReturn+1
    125  1ad8		       00 0b	   kPrint     equ	kRem+1
    126  1ad8		       00 0c	   kTaske     equ	kPrint+1
    127  1ad8		       00 0d	   kTaskn     equ	kTaske+1
    128  1ad8		       00 0e	   kTaskw     equ	kTaskn+1
    129  1ad8		       00 0f	   kPoke      equ	kTaskw+1
    130  1ad8		       00 10	   kPutch     equ	kPoke+1
    131  1ad8		       00 11	   kCls       equ	kPutch+1
    132  1ad8		       00 12	   kInput     equ	kCls+1
    133  1ad8		       00 13	   kEnd       equ	kInput+1
    134  1ad8		       00 14	   kIrq       equ	kEnd+1
    135  1ad8		       00 15	   kKill      equ	kIrq+1
    136  1ad8		       00 16	   kList      equ	kKill+1
    137  1ad8		       00 17	   kRun       equ	kList+1
    138  1ad8		       00 18	   kNew       equ	kRun+1
    139  1ad8		       00 19	   kSlice     equ	kNew+1
    140  1ad8		       00 1a	   kTrace     equ	kSlice+1
    141  1ad8		       00 1b	   kExit      equ	kTrace+1
    142  1ad8		       00 1c	   kSave      equ	kExit+1
    143  1ad8		       00 1d	   kLoad      equ	kSave+1
    144  1ad8		       00 1e	   kErase     equ	kLoad+1
    145  1ad8		       00 1f	   kDir       equ	kErase+1
    146  1ad8		       00 20	   kSetTerm   equ	kDir+1
    147  1ad8		       00 21	   kSetMemB   equ	kSetTerm+1
    148  1ad8		       00 22	   kSetMemW   equ	kSetMemB+1
    149  1ad8		       00 23	   kCopyMem   equ	kSetMemW+1
    150  1ad8		       00 24	   kWhile     equ	kCopyMem+1
    151  1ad8		       00 25	   kWend      equ	kWhile+1
    152  1ad8		       00 26	   kFor       equ	kWend+1
    153  1ad8		       00 27	   kNext      equ	kFor+1
    154  1ad8		       00 28	   kStep      equ	kNext+1
    155  1ad8							;
    156  1ad8							; End of actual key words
    157  1ad8							;
    158  1ad8		       00 27	   kKeyCount  equ	kStep-kBeginKey
    159  1ad8							;
    160  1ad8							; Logical operators
    161  1ad8							;
    162  1ad8		       00 29	   kNot       equ	kStep+1
    163  1ad8		       00 2a	   kOr	      equ	kNot+1
    164  1ad8		       00 2b	   kXor       equ	kOr+1
    165  1ad8		       00 2c	   kAnd       equ	kXor+1
    166  1ad8							;
    167  1ad8							; Shift operators
    168  1ad8							;
    169  1ad8		       00 2d	   kShr       equ	kAnd+1
    170  1ad8		       00 2e	   kShl       equ	kShr+1
    171  1ad8
    172  1ad8							; numeric functions
    173  1ad8							;
    174  1ad8		       00 2f	   kBeginFunc equ	kTrue
    175  1ad8							;
    176  1ad8							; Truth operators
    177  1ad8							;
    178  1ad8		       00 2f	   kTrue      equ	kShl+1
    179  1ad8		       00 30	   kFalse     equ	kTrue+1
    180  1ad8							; Functions
    181  1ad8		       00 31	   kFree      equ	kFalse+1
    182  1ad8		       00 32	   kGetch     equ	kFree+1
    183  1ad8		       00 33	   kPeek      equ	kGetch+1
    184  1ad8		       00 34	   kTask      equ	kPeek+1
    185  1ad8		       00 35	   kIpcc      equ	kTask+1
    186  1ad8		       00 36	   kIpcs      equ	kIpcc+1
    187  1ad8		       00 37	   kIpcr      equ	kIpcs+1
    188  1ad8		       00 38	   kRnd       equ	kIpcr+1
    189  1ad8		       00 39	   kStat      equ	kRnd+1
    190  1ad8		       00 3a	   kAbs       equ	kStat+1
    191  1ad8		       00 3b	   kCall      equ	kAbs+1
    192  1ad8		       00 3c	   kGofn      equ	kCall+1
    193  1ad8		       00 3d	   kPid       equ	kGofn+1
    194  1ad8		       00 3e	   kAddr      equ	kPid+1
    195  1ad8		       00 3f	   kCmpMem    equ	kAddr+1
    196  1ad8		       00 40	   kTimer     equ	kCmpMem+1
    197  1ad8							;
    198  1ad8		       00 12	   kFuncCount equ	((kTimer - kBeginFunc) + 1)
    199  1ad8
    200  1ad8							;
    201  1ad8							; Keyword table contains 54 keywords
    202  1ad8				   KeyWordTable
      0  1ad8					      db	kLet,"leT"	; 1, we only have 0 at end of program or line
      1  1ad8		       01 6c 65 54	      .byte.b	kLet,"leT"
      0  1adc					      db	kInc,"inC"
      1  1adc		       02 69 6e 43	      .byte.b	kInc,"inC"
      0  1ae0					      db	kDec,"deC"
      1  1ae0		       03 64 65 43	      .byte.b	kDec,"deC"
      0  1ae4					      db	kIreturn,"ireturN"
      1  1ae4		       04 69 72 65*	      .byte.b	kIreturn,"ireturN"
      0  1aec					      db	kIf,"iF"
      1  1aec		       05 69 46 	      .byte.b	kIf,"iF"
      0  1aef					      db	kThen,"theN"
      1  1aef		       06 74 68 65*	      .byte.b	kThen,"theN"
      0  1af4					      db	kGoto,"gotO"
      1  1af4		       07 67 6f 74*	      .byte.b	kGoto,"gotO"
      0  1af9					      db	kGosub,"gosuB"
      1  1af9		       08 67 6f 73*	      .byte.b	kGosub,"gosuB"
      0  1aff					      db	kReturn,"returN"
      1  1aff		       09 72 65 74*	      .byte.b	kReturn,"returN"
      0  1b06					      db	kRem,"reM"
      1  1b06		       0a 72 65 4d	      .byte.b	kRem,"reM"
      0  1b0a					      db	kPrint,"prinT"
      1  1b0a		       0b 70 72 69*	      .byte.b	kPrint,"prinT"
      0  1b10					      db	kTaske,"taskE"
      1  1b10		       0c 74 61 73*	      .byte.b	kTaske,"taskE"
      0  1b16					      db	kTaskn,"taskN"
      1  1b16		       0d 74 61 73*	      .byte.b	kTaskn,"taskN"
      0  1b1c					      db	kTaskw,"taskW"
      1  1b1c		       0e 74 61 73*	      .byte.b	kTaskw,"taskW"
      0  1b22					      db	kPoke,"pokE"
      1  1b22		       0f 70 6f 6b*	      .byte.b	kPoke,"pokE"
      0  1b27					      db	kPutch,"putcH"
      1  1b27		       10 70 75 74*	      .byte.b	kPutch,"putcH"
      0  1b2d					      db	kCls,"clS"
      1  1b2d		       11 63 6c 53	      .byte.b	kCls,"clS"
      0  1b31					      db	kInput,"inpuT"
      1  1b31		       12 69 6e 70*	      .byte.b	kInput,"inpuT"
      0  1b37					      db	kEnd,"enD"
      1  1b37		       13 65 6e 44	      .byte.b	kEnd,"enD"
      0  1b3b					      db	kIrq,"irQ"
      1  1b3b		       14 69 72 51	      .byte.b	kIrq,"irQ"
      0  1b3f					      db	kKill,"kilL"
      1  1b3f		       15 6b 69 6c*	      .byte.b	kKill,"kilL"
      0  1b44					      db	kList,"lisT"
      1  1b44		       16 6c 69 73*	      .byte.b	kList,"lisT"
      0  1b49					      db	kRun,"ruN"
      1  1b49		       17 72 75 4e	      .byte.b	kRun,"ruN"
      0  1b4d					      db	kNew,"neW"
      1  1b4d		       18 6e 65 57	      .byte.b	kNew,"neW"
      0  1b51					      db	kSlice,"slicE"
      1  1b51		       19 73 6c 69*	      .byte.b	kSlice,"slicE"
      0  1b57					      db	kTrace,"tracE"
      1  1b57		       1a 74 72 61*	      .byte.b	kTrace,"tracE"
      0  1b5d					      db	kExit,"exiT"
      1  1b5d		       1b 65 78 69*	      .byte.b	kExit,"exiT"
      0  1b62					      db	kSave,"savE"
      1  1b62		       1c 73 61 76*	      .byte.b	kSave,"savE"
      0  1b67					      db	kLoad,"loaD"
      1  1b67		       1d 6c 6f 61*	      .byte.b	kLoad,"loaD"
      0  1b6c					      db	kErase,"erasE"
      1  1b6c		       1e 65 72 61*	      .byte.b	kErase,"erasE"
      0  1b72					      db	kDir,"diR"
      1  1b72		       1f 64 69 52	      .byte.b	kDir,"diR"
    234  1b76							;Short form for statements:
      0  1b76					      db	kIreturn,"ireT"
      1  1b76		       04 69 72 65*	      .byte.b	kIreturn,"ireT"
      0  1b7b					      db	kReturn,"reT"
      1  1b7b		       09 72 65 54	      .byte.b	kReturn,"reT"
      0  1b7f					      db	kPrint,"pR"	; some dialects of tiny basic use this for print
      1  1b7f		       0b 70 52 	      .byte.b	kPrint,"pR"
      0  1b82					      db	kSetTerm, "setterM"
      1  1b82		       20 73 65 74*	      .byte.b	kSetTerm, "setterM"
      0  1b8a					      db	kSetMemB, "setmemB"
      1  1b8a		       21 73 65 74*	      .byte.b	kSetMemB, "setmemB"
      0  1b92					      db	kSetMemW, "setmemW"
      1  1b92		       22 73 65 74*	      .byte.b	kSetMemW, "setmemW"
      0  1b9a					      db	kCopyMem, "copymeM"
      1  1b9a		       23 63 6f 70*	      .byte.b	kCopyMem, "copymeM"
      0  1ba2					      db	kWhile, "whilE"
      1  1ba2		       24 77 68 69*	      .byte.b	kWhile, "whilE"
      0  1ba8					      db	kWend, "wenD"
      1  1ba8		       25 77 65 6e*	      .byte.b	kWend, "wenD"
    244  1bad
    245  1bad							; Shift operators
      0  1bad					      db	kShr,"shR"
      1  1bad		       2d 73 68 52	      .byte.b	kShr,"shR"
      0  1bb1					      db	kShl,"shL"
      1  1bb1		       2e 73 68 4c	      .byte.b	kShl,"shL"
    248  1bb5
    249  1bb5							;Logical and truth operators
      0  1bb5					      db	kNot,"noT"
      1  1bb5		       29 6e 6f 54	      .byte.b	kNot,"noT"
      0  1bb9					      db	kOr,"oR"
      1  1bb9		       2a 6f 52 	      .byte.b	kOr,"oR"
      0  1bbc					      db	kXor,"xoR"
      1  1bbc		       2b 78 6f 52	      .byte.b	kXor,"xoR"
      0  1bc0					      db	kAnd,"anD"
      1  1bc0		       2c 61 6e 44	      .byte.b	kAnd,"anD"
    254  1bc4
    255  1bc4							; Truth values
      0  1bc4					      db	kTrue,"truE"
      1  1bc4		       2f 74 72 75*	      .byte.b	kTrue,"truE"
      0  1bc9					      db	kFalse,"falsE"
      1  1bc9		       30 66 61 6c*	      .byte.b	kFalse,"falsE"
    258  1bcf
    259  1bcf							;functions returning values
    260  1bcf
      0  1bcf					      db	kFree,"freE"
      1  1bcf		       31 66 72 65*	      .byte.b	kFree,"freE"
      0  1bd4					      db	kGetch,"getcH"
      1  1bd4		       32 67 65 74*	      .byte.b	kGetch,"getcH"
      0  1bda					      db	kPeek,"peeK"
      1  1bda		       33 70 65 65*	      .byte.b	kPeek,"peeK"
      0  1bdf					      db	kTask,"tasK"
      1  1bdf		       34 74 61 73*	      .byte.b	kTask,"tasK"
      0  1be4					      db	kIpcc,"ipcC"
      1  1be4		       35 69 70 63*	      .byte.b	kIpcc,"ipcC"
      0  1be9					      db	kIpcs,"ipcS"
      1  1be9		       36 69 70 63*	      .byte.b	kIpcs,"ipcS"
      0  1bee					      db	kIpcr,"ipcR"
      1  1bee		       37 69 70 63*	      .byte.b	kIpcr,"ipcR"
      0  1bf3					      db	kRnd,"rnD"
      1  1bf3		       38 72 6e 44	      .byte.b	kRnd,"rnD"
      0  1bf7					      db	kStat,"staT"
      1  1bf7		       39 73 74 61*	      .byte.b	kStat,"staT"
      0  1bfc					      db	kAbs,"abS"
      1  1bfc		       3a 61 62 53	      .byte.b	kAbs,"abS"
      0  1c00					      db	kCall,"calL"
      1  1c00		       3b 63 61 6c*	      .byte.b	kCall,"calL"
      0  1c05					      db	kGofn,"fN"
      1  1c05		       3c 66 4e 	      .byte.b	kGofn,"fN"
      0  1c08					      db	kPid,"piD"
      1  1c08		       3d 70 69 44	      .byte.b	kPid,"piD"
      0  1c0c					      db	kAddr,"addR"
      1  1c0c		       3e 61 64 64*	      .byte.b	kAddr,"addR"
      0  1c11					      db	kCmpMem, "cmpmeM"
      1  1c11		       3f 63 6d 70*	      .byte.b	kCmpMem, "cmpmeM"
      0  1c18					      db	kTimer,"timeR"
      1  1c18		       40 74 69 6d*	      .byte.b	kTimer,"timeR"
      0  1c1e					      db	0,0
      1  1c1e		       00 00		      .byte.b	0,0
    278  1c20
    279  1c20		       1c 20	   KeyWordTableEnd equ	*
    280  1c20		       01 48	   KeyWordTableLength equ	* - KeyWordTable
    281  1c20		       00 00 00 00*TOKENBUFFER ds	256	; placed here as temp for testing the Code
    282  1d20		       00 00 00    printStorage ds	3
    283  1d23							;==================================================================================================================
    284  1d23							; Read accross the inputline and output to TOKENBUFFER
    285  1d23							; Format   byte      Description
    286  1d23							;	     0	      length of line 1-255
    287  1d23							;	    0-1       Line Number
    288  1d23							;	    Tokens and litteral values encoded into the line
    289  1d23							;
    290  1d23							;  First test for numbers    for numbers insert type byte plus value 1 or 2 byte, byte, integer, string(pointers)
    291  1d23							;  if fails then test for keywords
    292  1d23							;  if fails then test for variables and arrays
    293  1d23							;  if fails check for operators/seperators  + - < > = % / * () [] , ; : >> <<
    294  1d23
    295  1d23				   ParseInputLine
    296  1d23				  -	      if	DEBUGPARSER
    297  1d23				  -	      jsr	SetOutDebug
    298  1d23				  -	      jsr	DebugClearBuffer
    299  1d23					      endif
    300  1d23		       a5 51		      lda	CUROFF
    301  1d25		       48		      pha
    302  1d26		       8a		      txa
    303  1d27		       48		      pha
    304  1d28		       98		      tya
    305  1d29		       48		      pha
    306  1d2a		       a2 01		      ldx	#1	; point to beginning of Token buffer + 1 reserve space for length byte
    307  1d2c		       20 a0 2b 	      jsr	getDecimal	; Check for a line number, none is ok too
    308  1d2f		       84 51		      sty	CUROFF
    309  1d31		       20 ef 1e 	      jsr	R02TOKEN	; Move R0 to token buffer
    310  1d34
    311  1d34				   ParseInputLoop
    312  1d34		       a4 51		      ldy	CUROFF
    313  1d36		       20 30 2e 	      jsr	SkipSpaces	; Skip any spaces
    314  1d39		       84 51		      sty	CUROFF	; Even if it fails at least remove the spaces
    315  1d3b		       b9 7f 43 	      lda	LINBUF,y	; Check for end of line
    316  1d3e		       f0 25		      beq	ParseComplete	; Finish token buffer and return
    317  1d40
    318  1d40				   ParseForNumber
    319  1d40		       20 43 1e 	      jsr	ParseNumeric	; Check for a numeric value
    320  1d43		       90 ef		      bcc	ParseInputLoop	; Go Back for next element
    321  1d45
    322  1d45				   ParseForString
    323  1d45		       20 19 1e 	      jsr	ParseString	; Check for a string
    324  1d48		       90 ea		      bcc	ParseInputLoop	; It was a string
    325  1d4a
    326  1d4a				   ParseForOp
    327  1d4a		       20 81 1e 	      jsr	ParseForOperator	; Check for operator or punctuation
    328  1d4d		       90 e5		      bcc	ParseInputLoop	; it was an operator/punctuation
    329  1d4f
    330  1d4f				   ParseForKey
    331  1d4f		       20 76 1d 	      jsr	ParseLookupKey	; Check for a keyword value
    332  1d52		       90 e0		      bcc	ParseInputLoop	; Go back for next token, we are not syntax checking
    333  1d54
    334  1d54				   ParseForVar
    335  1d54		       20 b8 1e 	      jsr	ParseForVariable	; Check for variable and convert to Index, as task centric
    336  1d57		       90 db		      bcc	ParseInputLoop
    337  1d59
    338  1d59				   ParseKeepChar		; if it does not parse just keep it safe
    339  1d59		       b9 7f 43 	      lda	LINBUF,y
    340  1d5c		       9d 20 1c 	      sta	TOKENBUFFER,x
    341  1d5f		       e8		      inx
    342  1d60		       c8		      iny
    343  1d61		       84 51		      sty	CUROFF
    344  1d63		       d0 cf		      bne	ParseInputLoop
    345  1d65
    346  1d65				   ParseComplete
    347  1d65		       a9 00		      lda	#0
    348  1d67		       9d 20 1c 	      sta	TOKENBUFFER,x	; null terminate the line of tokens
    349  1d6a		       e8		      inx
    350  1d6b		       8e 20 1c 	      stx	TOKENBUFFER	; Place size including null into buffer start
    351  1d6e
    352  1d6e		       68		      pla
    353  1d6f		       a8		      tay
    354  1d70		       68		      pla
    355  1d71		       aa		      tax
    356  1d72		       68		      pla
    357  1d73		       85 51		      sta	CUROFF
    358  1d75
    359  1d75				  -	      if	DEBUGPARSER
    360  1d75				  -
    361  1d75				  -	      jsr	printTokenBuffer
    362  1d75				  -			;jsr	  DebugPrintProgramLine
    363  1d75				  -	      jsr	SetOutDebugEnd
    364  1d75				  -
    365  1d75					      endif
    366  1d75		       60		      rts
    367  1d76
    368  1d76							;==================================================================================================================
    369  1d76							; Look at curptr, curpos and check for a valid KeyWord
    370  1d76							; A contains the index value. c is clear
    371  1d76							;		     not found c set  A undefined
    372  1d76							; X is prerserved
    373  1d76							;
    374  1d76				   ParseLookupKey
    375  1d76		       86 58		      stx	R2
    376  1d78		       a0 00		      ldy	#0
    377  1d7a		       a9 d8		      lda	#KeyWordTable&$FF	; Key Table longer than 256 bytes
    378  1d7c		       85 54		      sta	R1
    379  1d7e		       a9 1a		      lda	#KeyWordTable>>8
    380  1d80		       85 55		      sta	R1+1	; R1 points to first entry in keyword table
    381  1d82		       b1 54		      lda	(R1),y	; Get the Key Token value for first keyword
    382  1d84		       85 52		      sta	R0	; Save until next keyword
    383  1d86		       c8		      iny		; Point to first character of keyword
    384  1d87		       a6 51		      ldx	CUROFF	; X points to the character in the input buffer
    385  1d89
    386  1d89				  -	      if	DEBUGPARSER
    387  1d89				  -			;    jsr DebugKeyword
    388  1d89					      endif
    389  1d89
    390  1d89				   ParseLookupLoop
    391  1d89		       b1 54		      lda	(R1),y	; Get the first character of the keyword
    392  1d8b		       29 df		      and	#%11011111	; Force Keyword to upper case
    393  1d8d		       dd 7f 43 	      cmp	LINBUF,x	; Check the input buffer
    394  1d90		       f0 07		      beq	ParseNextLetter	; If it equals then do next letter
    395  1d92		       09 20		      ora	#%00100000	; Force Keyword to lowercase
    396  1d94		       dd 7f 43 	      cmp	LINBUF,x	; Compare value to upercase
    397  1d97		       d0 34		      bne	ParseNextEntry	; Not equal then move to next entry in the keyword table
    398  1d99
    399  1d99				   ParseNextLetter
    400  1d99		       b1 54		      lda	(R1),y	; Check if we just processed the last letter is upper
    401  1d9b		       29 20		      and	#%00100000	; if this bit not set then end of keyword, Last char is always uppercase
    402  1d9d		       f0 0b		      beq	ParseKeyFound	; If we are at end of keyword and all match then we found the key
    403  1d9f		       e8		      inx		; Point to next char in the input buffer
    404  1da0		       c8		      iny		; Point to the next character in the Keyword table
    405  1da1		       a9 00		      lda	#0	; Check if we are at the end of the input buffer
    406  1da3		       dd 7f 43 	      cmp	LINBUF,x	; Check if we are at the end of the input buffer
    407  1da6		       f0 25		      beq	ParseNextEntry	; End of buffer but no keyword, ext keyword entry
    408  1da8		       d0 df		      bne	ParseLookupLoop	; Go back and check the next characters
    409  1daa
    410  1daa				   ParseKeyFound
    411  1daa		       a5 52		      lda	R0	; get the keyword index
    412  1dac
    413  1dac				   ParseKeyDone
    414  1dac		       e8		      inx		; point past the last character
    415  1dad		       86 51		      stx	CUROFF	; update to point to next character in the input buffer
    416  1daf		       a6 58		      ldx	R2	; Restore the original x pointer
    417  1db1		       9d 20 1c 	      sta	TOKENBUFFER,x	; store the Token into the compiled buffer
    418  1db4		       e8		      inx		; Point to next position in the output buffer
    419  1db5		       86 58		      stx	R2	; Save next position in buffer
    420  1db7		       c9 0a		      cmp	#kRem	; remark statement
    421  1db9		       f0 3a		      beq	ParseMoveLine	; Move everything until the end of line to the token buffer
    422  1dbb		       c9 07		      cmp	#kGoto
    423  1dbd		       f0 4a		      beq	ParseHandleBranches	; Jump allow space for memory address in token buffer
    424  1dbf		       c9 08		      cmp	#kGosub
    425  1dc1		       f0 46		      beq	ParseHandleBranches	; Handle the gosub branch address
    426  1dc3		       c9 3c		      cmp	#kGofn
    427  1dc5		       f0 42		      beq	ParseHandleBranches	; Handle the gosub branch address
    428  1dc7		       c9 34		      cmp	#kTask
    429  1dc9		       f0 3e		      beq	ParseHandleBranches	; We may have the ability to also compile task vectors Bracket between the space and the value
    430  1dcb
    431  1dcb		       18		      clc		; C flag clear, we found it
    432  1dcc		       60		      rts
    433  1dcd
    434  1dcd							; Move forward to the next entry in table
    435  1dcd				   ParseNextEntry
    436  1dcd		       b1 54		      lda	(R1),y	; Get the next character in the token
    437  1dcf		       29 20		      and	#%00100000	; Is it the last character
    438  1dd1		       f0 03		      beq	ParseEndOfEntry	; Yes then end of this entry found
    439  1dd3		       c8		      iny		; Point to next char in the entry
    440  1dd4		       d0 f7		      bne	ParseNextEntry	; loop until we find the end character
    441  1dd6
    442  1dd6				   ParseEndOfEntry
    443  1dd6		       c8		      iny		; Point to the byte after the last character
    444  1dd7		       98		      tya		; Move into a as we must add this to the pointer in R1, more that 256 keyword characters in table
    445  1dd8		       18		      clc		; table May be longer than 256 so increment r1 to next entry
    446  1dd9		       65 54		      adc	R1
    447  1ddb		       85 54		      sta	R1
    448  1ddd		       a5 55		      lda	R1+1
    449  1ddf		       69 00		      adc	#0
    450  1de1		       85 55		      sta	R1+1	; Now pointing to start of next entry in the table
    451  1de3		       a0 00		      ldy	#0	; Reset the index back to zero
    452  1de5		       b1 54		      lda	(R1),y	; get keyword value
    453  1de7		       f0 08		      beq	ParseNoneFound	; Check for end of the table -> 0
    454  1de9		       85 52		      sta	R0	; save the next token value
    455  1deb		       c8		      iny		; Inc past token value
    456  1dec
    457  1dec				  -	      if	DEBUGPARSER
    458  1dec				  -			;    jsr DebugKeyword
    459  1dec					      endif
    460  1dec		       a6 51		      ldx	CUROFF	; Restore x to last position in the input buffer
    461  1dee		       4c 89 1d 	      jmp	ParseLookupLoop	; branch back for next key word
    462  1df1
    463  1df1				   ParseNoneFound
    464  1df1		       a6 58		      ldx	R2	; it did not find one, restore x to position in output buffer
    465  1df3		       38		      sec		; c clear, not found
    466  1df4		       60		      rts
    467  1df5
    468  1df5							;===============================================================================
    469  1df5							; Move everything from current position until the end of line into the token buffer
    470  1df5							;
    471  1df5		       a4 51	   ParseMoveLine ldy	CUROFF	; next byte to parse
    472  1df7		       a6 58		      ldx	R2	; where to place in the buffer
    473  1df9				   ParseMoveLoop
    474  1df9		       b9 7f 43 	      lda	LINBUF,y	; get the next byte
    475  1dfc		       f0 07		      beq	ParseMoveDone	; if we load a zero then done
    476  1dfe		       9d 20 1c 	      sta	TOKENBUFFER,x	; save the byte
    477  1e01		       c8		      iny
    478  1e02		       e8		      inx
    479  1e03		       d0 f4		      bne	ParseMoveLoop
    480  1e05				   ParseMoveDone
    481  1e05		       84 51		      sty	CUROFF
    482  1e07		       18		      clc
    483  1e08		       60		      rts
    484  1e09							;================================================================================================
    485  1e09							; Add two bytes after the gosub and goto to allow the "compiler" to place mem address, to directly
    486  1e09							; transfer to a memory address
    487  1e09				   ParseHandleBranches
    488  1e09		       a6 58		      ldx	R2
    489  1e0b		       a9 00		      lda	#0
    490  1e0d		       9d 20 1c 	      sta	TOKENBUFFER,x
    491  1e10		       e8		      inx
    492  1e11		       9d 20 1c 	      sta	TOKENBUFFER,x
    493  1e14		       e8		      inx
    494  1e15		       86 58		      stx	R2
    495  1e17		       18		      clc
    496  1e18		       60		      rts
    497  1e19
    498  1e19							;=========================================================================================================
    499  1e19							;ParseString Parse a quotes string
    500  1e19							; on input X = outbuf position
    501  1e19							; y = inbuf position
    502  1e19							; Copies string to output buffer, updates x and y
    503  1e19				   ParseString
    504  1e19		       a4 51		      ldy	CUROFF
    505  1e1b		       a9 a0		      lda	#tString
    506  1e1d		       9d 20 1c 	      sta	TOKENBUFFER,X
    507  1e20		       b9 7f 43 	      lda	LINBUF,y
    508  1e23		       c9 22		      cmp	#'"
    509  1e25		       d0 1a		      bne	ParseStringInvalid
    510  1e27		       e8		      inx
    511  1e28		       9d 20 1c 	      sta	TOKENBUFFER,x
    512  1e2b		       e8		      inx
    513  1e2c		       c8		      iny
    514  1e2d
    515  1e2d				   ParseStringLoop
    516  1e2d		       b9 7f 43 	      lda	LINBUF,y
    517  1e30		       9d 20 1c 	      sta	TOKENBUFFER,x
    518  1e33		       c9 22		      cmp	#'"
    519  1e35		       f0 04		      beq	ParseStringDone
    520  1e37		       c8		      iny
    521  1e38		       e8		      inx
    522  1e39		       d0 f2		      bne	ParseStringLoop
    523  1e3b
    524  1e3b				   ParseStringDone
    525  1e3b		       e8		      inx
    526  1e3c		       c8		      iny
    527  1e3d		       84 51		      sty	CUROFF
    528  1e3f		       18		      clc
    529  1e40		       60		      rts
    530  1e41
    531  1e41				   ParseStringInvalid
    532  1e41		       38		      sec
    533  1e42		       60		      rts
    534  1e43
    535  1e43							;=========================================================================================================
    536  1e43							; Get numeric values and return value in RO and type in a
    537  1e43							;
    538  1e43				   ParseNumeric
    539  1e43		       a4 51		      ldy	CUROFF
    540  1e45		       b9 7f 43 	      lda	LINBUF,y
    541  1e48		       c9 30		      cmp	#'0
    542  1e4a		       90 33		      bcc	ParseNumInvalid
    543  1e4c		       c9 3a		      cmp	#'9+1
    544  1e4e		       b0 2f		      bcs	ParseNumInvalid
    545  1e50		       86 58		      stx	R2
    546  1e52		       20 a0 2b 	      jsr	getDecimal
    547  1e55		       a6 58		      ldx	R2
    548  1e57		       84 51		      sty	CUROFF
    549  1e59		       a5 53		      lda	R0+1
    550  1e5b		       f0 14		      beq	ParseByteValue
    551  1e5d
    552  1e5d				   ParseIntegerValue
    553  1e5d		       a9 a4		      lda	#tInteger
    554  1e5f		       9d 20 1c 	      sta	TOKENBUFFER,x
    555  1e62		       e8		      inx
    556  1e63		       a5 52		      lda	R0
    557  1e65		       9d 20 1c 	      sta	TOKENBUFFER,x
    558  1e68		       e8		      inx
    559  1e69		       a5 53		      lda	R0+1
    560  1e6b		       9d 20 1c 	      sta	TOKENBUFFER,X
    561  1e6e		       e8		      inx
    562  1e6f		       18		      clc
    563  1e70		       60		      rts
    564  1e71
    565  1e71				   ParseByteValue
    566  1e71		       a9 a2		      lda	#tByte
    567  1e73		       9d 20 1c 	      sta	TOKENBUFFER,x
    568  1e76		       e8		      inx
    569  1e77		       a5 52		      lda	R0
    570  1e79		       9d 20 1c 	      sta	TOKENBUFFER,x
    571  1e7c		       e8		      inx
    572  1e7d		       18		      clc
    573  1e7e		       60		      rts
    574  1e7f
    575  1e7f				   ParseNumInvalid		;Not a valid Numeric
    576  1e7f		       38		      sec
    577  1e80		       60		      rts
    578  1e81
    579  1e81							;=========================================================================================================
    580  1e81							;Parse for operators and seperators
    581  1e81							; on exit the A has the oper code, c is clear
    582  1e81							;		 not found then c is set
    583  1e81							;	x is preserved
    584  1e81							;
    585  1e81				   ParseForOperator
    586  1e81		       86 58		      stx	R2
    587  1e83		       a4 51		      ldy	CUROFF
    588  1e85		       a2 00		      ldx	#0
    589  1e87				  -	      if	DEBUGPARSER
    590  1e87				  -			;	jsr    DebugPrintOP
    591  1e87					      endif
    592  1e87
    593  1e87				   ParseOpLoop
    594  1e87		       bd 7c 1a 	      lda	Operators,x	; First byte of operator
    595  1e8a		       f0 28		      beq	ParseOpNotFound	; Last entry os 0,0
    596  1e8c
    597  1e8c		       d9 7f 43 	      cmp	LINBUF,y	; Check the first byte
    598  1e8f		       d0 1c		      bne	ParseOpNext
    599  1e91
    600  1e91		       c8		      iny
    601  1e92
    602  1e92		       bd 7d 1a 	      lda	Operators+1,x
    603  1e95		       f0 06		      beq	ParseOpFoundSingle	; Single Character op
    604  1e97
    605  1e97		       d9 7f 43 	      cmp	LINBUF,y
    606  1e9a		       d0 11		      bne	ParseOpNext
    607  1e9c
    608  1e9c				   ParseOpFound
    609  1e9c		       c8		      iny
    610  1e9d
    611  1e9d				   ParseOpFoundSingle
    612  1e9d		       84 51		      sty	CUROFF
    613  1e9f
    614  1e9f		       8a		      txa
    615  1ea0		       4a		      lsr
    616  1ea1		       aa		      tax
    617  1ea2		       bd ba 1a 	      lda	OperValues,x
    618  1ea5		       a6 58		      ldx	R2
    619  1ea7		       9d 20 1c 	      sta	TOKENBUFFER,x
    620  1eaa		       e8		      inx
    621  1eab		       18		      clc
    622  1eac		       60		      rts
    623  1ead
    624  1ead				   ParseOpNext
    625  1ead		       e8		      inx
    626  1eae		       e8		      inx
    627  1eaf
    628  1eaf				  -	      if	DEBUGPARSER
    629  1eaf				  -			;	 jsr	DebugPrintOP
    630  1eaf					      endif
    631  1eaf		       a4 51		      ldy	CUROFF	; reset the y pointer to beginning
    632  1eb1		       4c 87 1e 	      jmp	ParseOpLoop
    633  1eb4
    634  1eb4				   ParseOpNotFound
    635  1eb4		       a6 58		      ldx	R2
    636  1eb6		       38		      sec
    637  1eb7		       60		      rts
    638  1eb8							;=========================================================================================================
    639  1eb8				  -	      if	DEBUGPARSER
    640  1eb8				  -			;Print the text of a keyword
    641  1eb8				  -			;Input R1    = offset into table
    642  1eb8				  -DebugKeyword
    643  1eb8				  -	      tya
    644  1eb8				  -	      pha
    645  1eb8				  -	      ldy	#1
    646  1eb8				  -DebugKeyLoop
    647  1eb8				  -	      lda	(R1),y
    648  1eb8				  -	      jsr	VOUTCH
    649  1eb8				  -	      and	#%00100000
    650  1eb8				  -	      beq	DebugKeyDone
    651  1eb8				  -	      iny
    652  1eb8				  -	      bne	DebugKeyLoop
    653  1eb8				  -
    654  1eb8				  -DebugKeyDone
    655  1eb8				  -	      jsr	CRLF
    656  1eb8				  -	      pla
    657  1eb8				  -	      tay
    658  1eb8				  -	      rts
    659  1eb8				  -			;========================================
    660  1eb8				  -DebugPrintOP
    661  1eb8				  -	      pha
    662  1eb8				  -	      lda	Operators,x
    663  1eb8				  -	      jsr	VOUTCH
    664  1eb8				  -	      lda	Operators+1,x
    665  1eb8				  -	      beq	DbgPrtOpDone
    666  1eb8				  -	      jsr	VOUTCH
    667  1eb8				  -
    668  1eb8				  -DbgPrtOpDone
    669  1eb8				  -	      jsr	CRLF
    670  1eb8				  -	      pla
    671  1eb8				  -	      rts
    672  1eb8				  -			;=======================================
    673  1eb8				  -DebugClearBuffer
    674  1eb8				  -	      txa
    675  1eb8				  -	      pha
    676  1eb8				  -	      ldx	#$FF
    677  1eb8				  -	      lda	#0
    678  1eb8				  -DebugClrLoop
    679  1eb8				  -	      sta	TOKENBUFFER,x
    680  1eb8				  -	      dex
    681  1eb8				  -	      bne	DebugClrLoop
    682  1eb8				  -	      sta	TOKENBUFFER,x
    683  1eb8				  -	      pla
    684  1eb8				  -	      tax
    685  1eb8				  -	      rts
    686  1eb8				  -
    687  1eb8				  -			;=====================================================
    688  1eb8				  -			; Print the parser buffer as hex values
    689  1eb8				  -printTokenBuffer
    690  1eb8				  -	      stx	printStorage
    691  1eb8				  -	      sty	printStorage+1
    692  1eb8				  -	      sta	printStorage+2
    693  1eb8				  -
    694  1eb8				  -	      ldx	TOKENBUFFER	; get the length of the buffer
    695  1eb8				  -	      inx		; we want to show the last zero byte
    696  1eb8				  -	      ldy	#0
    697  1eb8				  -
    698  1eb8				  -printHexLoop
    699  1eb8				  -	      lda	TOKENBUFFER,y	; get the character
    700  1eb8				  -	      jsr	HexToOut	; print it
    701  1eb8				  -	      lda	#$20
    702  1eb8				  -	      jsr	VOUTCH
    703  1eb8				  -	      iny
    704  1eb8				  -	      dex
    705  1eb8				  -	      cpx	#0
    706  1eb8				  -	      bne	printHexLoop
    707  1eb8				  -	      jsr	CRLF
    708  1eb8				  -
    709  1eb8				  -	      ldy	printStorage+1
    710  1eb8				  -	      ldx	printStorage
    711  1eb8				  -	      lda	printStorage+2
    712  1eb8				  -printHexDone
    713  1eb8				  -	      clc
    714  1eb8				  -	      rts
    715  1eb8					      endif
    716  1eb8
    717  1eb8							;=========================================================================================================
    718  1eb8							; Parse for variables A-Z @, ^  x!x x[op]
    719  1eb8				   ParseForVariable
    720  1eb8		       a4 51		      ldy	CUROFF
    721  1eba		       b9 7f 43 	      lda	LINBUF,y
    722  1ebd		       c9 5e		      cmp	#'^	; is it an exit code
    723  1ebf		       d0 04		      bne	ParseVarMem
    724  1ec1		       a9 9b		      lda	#tVhat	; Mark the index as 27th slot
    725  1ec3		       d0 1f		      bne	ParseVarSpecial
    726  1ec5
    727  1ec5				   ParseVarMem
    728  1ec5		       c9 40		      cmp	#'@	; are we indirect through program end eg. @[0] ..
    729  1ec7		       d0 04		      bne	ParseVarStack
    730  1ec9		       a9 9d		      lda	#tVat
    731  1ecb		       d0 17		      bne	ParseVarSpecial
    732  1ecd
    733  1ecd				   ParseVarStack
    734  1ecd		       c9 23		      cmp	#'#	; Indirect var through top of stack eg. #[0]
    735  1ecf		       d0 04		      bne	ParseVarLetters
    736  1ed1		       a9 9c		      lda	#tVhash
    737  1ed3		       d0 0f		      bne	ParseVarSpecial
    738  1ed5
    739  1ed5				   ParseVarLetters
    740  1ed5		       29 df		      and	#%11011111	; Force upper case
    741  1ed7		       c9 41		      cmp	#'A
    742  1ed9		       90 12		      bcc	ParseVarInvalid
    743  1edb		       c9 5b		      cmp	#'Z+1
    744  1edd		       b0 0e		      bcs	ParseVarInvalid
    745  1edf							;
    746  1edf							; The condition is true, so convert to an index, push
    747  1edf							; it onto the stack and continue running.
    748  1edf							;
    749  1edf		       38		      sec
    750  1ee0		       e9 41		      sbc	#'A	;index is zero based
    751  1ee2		       09 80		      ora	#$80
    752  1ee4
    753  1ee4				   ParseVarSpecial
    754  1ee4		       9d 20 1c 	      sta	TOKENBUFFER,x
    755  1ee7		       e8		      inx
    756  1ee8		       c8		      iny
    757  1ee9		       84 51		      sty	CUROFF
    758  1eeb		       18		      clc
    759  1eec		       60		      rts
    760  1eed
    761  1eed				   ParseVarInvalid
    762  1eed		       38		      sec
    763  1eee		       60		      rts
    764  1eef
    765  1eef							;=========================================================================================================
    766  1eef							; Transfer R0 to the TOKENBUFFER
    767  1eef							;
    768  1eef				   R02TOKEN
    769  1eef		       a5 52		      lda	R0
    770  1ef1		       9d 20 1c 	      sta	TOKENBUFFER,x
    771  1ef4		       e8		      inx
    772  1ef5		       a5 53		      lda	R0+1
    773  1ef7		       9d 20 1c 	      sta	TOKENBUFFER,x
    774  1efa		       e8		      inx
    775  1efb		       18		      clc
    776  1efc		       60		      rts
    777  1efd							;=========================================================================
    778  1efd							; Transfer word in Token Buffer to R0
    779  1efd				   TOKEN2R0
    780  1efd		       b9 20 1c 	      lda	TOKENBUFFER,y
    781  1f00		       85 52		      sta	R0
    782  1f02		       c8		      iny
    783  1f03		       ca		      dex
    784  1f04		       b9 20 1c 	      lda	TOKENBUFFER,y
    785  1f07		       c8		      iny
    786  1f08		       ca		      dex
    787  1f09		       85 53		      sta	R0+1
    788  1f0b		       60		      rts
    789  1f0c							;==========================================================================
    790  1f0c							; Transfer	Display Buffer position to R0
    791  1f0c							;
    792  1f0c				   DPL2R0
    793  1f0c		       b1 59		      lda	(dpl),y
    794  1f0e		       85 52		      sta	R0
    795  1f10		       c8		      iny
    796  1f11		       ca		      dex
    797  1f12		       b1 59		      lda	(dpl),y
    798  1f14		       c8		      iny
    799  1f15		       ca		      dex
    800  1f16		       85 53		      sta	R0+1
    801  1f18		       60		      rts
    802  1f19
    803  1f19							;=========================================================================
    804  1f19							; Read an IL byte lookit up in the table, of words
    805  1f19							; set the next ilpc to point to that address
    806  1f19							; if not found then do ussual filter stuff
    807  1f19							; ongoto ilvectortable, not found address
    808  1f19		       20 f1 2a    iOnGoto    jsr	getILWord	; places the word into r0, pointer to table
    809  1f1c		       86 52		      stx	R0
    810  1f1e		       85 53		      sta	R0+1
    811  1f20
    812  1f20		       a4 51		      ldy	CUROFF
    813  1f22		       b1 4f		      lda	(CURPTR),y	; get the operation byte
    814  1f24		       a0 00		      ldy	#0
    815  1f26		       38		      sec
    816  1f27		       f1 52		      sbc	(R0),y	; Subract the base value
    817  1f29		       c8		      iny
    818  1f2a		       d1 52		      cmp	(R0),y	; Check if we are in range
    819  1f2c		       b0 12		      bcs	iOnGotoInvalid
    820  1f2e		       e6 51		      inc	CUROFF	; Save the offset
    821  1f30
    822  1f30		       0a		      asl
    823  1f31		       a8		      tay		; Turn into vector
    824  1f32		       c8		      iny		; Inc must include the table base and entry count
    825  1f33		       c8		      iny
    826  1f34
    827  1f34		       b1 52		      lda	(R0),y
    828  1f36		       85 43		      sta	ILPC
    829  1f38		       c8		      iny
    830  1f39		       b1 52		      lda	(R0),y
    831  1f3b		       85 44		      sta	ILPC+1
    832  1f3d		       4c 9e 02 	      jmp	NextIL
    833  1f40
    834  1f40				   iOnGotoInvalid
    835  1f40		       20 f1 2a 	      jsr	getILWord
    836  1f43		       86 43		      stx	ILPC
    837  1f45		       85 44		      sta	ILPC+1
    838  1f47		       4c 9e 02 	      jmp	NextIL
    839  1f4a							;
    840  1f4a							;==========================================================================================
    841  1f4a							; Test the token for relop and push the value onto the stack if true
    842  1f4a							;
    843  1f4a				   iTSTRELOP
    844  1f4a		       20 f5 2a 	      jsr	getILByte
    845  1f4d		       8d 14 44 	      sta	offset
    846  1f50
    847  1f50		       a4 51		      ldy	CUROFF
    848  1f52		       b1 4f		      lda	(CURPTR),y
    849  1f54		       48		      pha
    850  1f55		       29 f0		      and	#$F0
    851  1f57		       c9 f0		      cmp	#$F0
    852  1f59		       d0 12		      bne	iTSTRELOPNOT
    853  1f5b		       68		      pla
    854  1f5c		       29 0f		      and	#$0F	; get the actual value
    855  1f5e		       85 52		      sta	R0	; save it for later
    856  1f60		       a9 00		      lda	#0
    857  1f62		       85 53		      sta	R0+1
    858  1f64		       20 ee 2c 	      jsr	pushR0
    859  1f67		       c8		      iny
    860  1f68		       84 51		      sty	CUROFF	; save the y pointer
    861  1f6a		       4c 9e 02 	      jmp	NextIL
    862  1f6d
    863  1f6d				   iTSTRELOPNOT
    864  1f6d		       68		      pla
    865  1f6e		       4c cd 0b 	      jmp	tstBranch
    866  1f71
    867  1f71							;
    868  1f71							;===================================================================================================
    869  1f71							; Test the token and following info for precompiled address information
    870  1f71							; skip it if zero, transfer and skip next integer value if not zero
    871  1f71							; used by both gosub, goto and gofN
    872  1f71							;
    873  1f71				   iTSTBRANCH		; il format TSTBRANCH whereToGoIfFailed
    874  1f71		       20 f5 2a 	      jsr	getILByte	; Get jump address if vector is valid
    875  1f74		       8d 14 44 	      sta	offset	; Mark offset for later if vector found
    876  1f77		       a4 51		      ldy	CUROFF	; get offset of first byte of compiled value
    877  1f79		       88		      dey		; point back to the type of branch
    878  1f7a		       b1 4f		      lda	(CURPTR),y	; get the actual instructions
    879  1f7c		       48		      pha		; Save till needed
    880  1f7d		       c8		      iny		; back to memory vectors
    881  1f7e				   ITSTBRANCHCont
    882  1f7e		       b1 4f		      lda	(CURPTR),y	; Get first byte of compiled value
    883  1f80		       85 52		      sta	R0	; R0 will contain mem pointer of present
    884  1f82		       c8		      iny		; Point to next byte of mem vector
    885  1f83		       b1 4f		      lda	(CURPTR),y	; It was compiled so get the hi byte value
    886  1f85		       85 53		      sta	R0+1	; Move it into R0, R0 now contains vector address
    887  1f87		       c8		      iny		; Point to the byte past memory vector
    888  1f88		       84 51		      sty	CUROFF	; At least point past the memory vector built in
    889  1f8a
    890  1f8a		       05 52		      ora	R0	; Get the second byte of the mem
    891  1f8c		       f0 28		      BEQ	iTSTBRANCHNoCompile	; If both are zero then not compiled
    892  1f8e		       68		      pla
    893  1f8f		       c9 07		      cmp	#kGoto	; Short cut lots if a goto stuff
    894  1f91		       d0 03		      bne	NotGoto
    895  1f93		       4c c9 04 	      jmp	FastFastXfer
    896  1f96				   NotGoto
    897  1f96		       c9 34		      cmp	#kTask	; Task defined with Task() so bypass the first bracket
    898  1f98		       d0 07		      bne	iTSTBRANCHCont
    899  1f9a		       b1 4f		      lda	(CURPTR),y
    900  1f9c		       c9 e0		      cmp	#oLeftBracket
    901  1f9e		       d0 17		      bne	iTSTBRANCHErr	; Well in that case something is very wrong
    902  1fa0		       c8		      iny		; Increment past the bracket
    903  1fa1				   iTSTBRANCHCont
    904  1fa1		       b1 4f		      lda	(CURPTR),y	; We should get a datatype, if not memvector is invalid
    905  1fa3		       c9 a2		      cmp	#tByte	; A byte value is valid
    906  1fa5		       f0 05		      beq	ITSTBRANCHBYTE	; Skip the byte
    907  1fa7		       c9 a4		      cmp	#tInteger	; An integer value is valid
    908  1fa9		       d0 0c		      bne	iTSTBRANCHErr	; If not then we can not use the memory vector
    909  1fab		       c8		      iny		; skip type indicator for
    910  1fac				   ITSTBRANCHBYTE
    911  1fac		       c8		      iny		; skip first byte of value line number
    912  1fad		       c8		      iny		; Skip second byte of line number
    913  1fae
    914  1fae				   iTSTBRANCHVALID
    915  1fae		       84 51		      sty	CUROFF
    916  1fb0		       20 ee 2c 	      jsr	pushR0	; place transfer address on top of stack
    917  1fb3		       4c cd 0b 	      jmp	tstBranch
    918  1fb6
    919  1fb6				   iTSTBRANCHNoCompile
    920  1fb6		       68		      pla
    921  1fb7				   iTSTBRANCHErr
    922  1fb7		       4c 9e 02 	      jmp	NextIL
------- FILE mytb.asm
------- FILE compile.asm LEVEL 2 PASS 6
      0  1fba					      include	"compile.asm"
      1  1fba					      Seg	Code
      2  1fba							;
      3  1fba							;=====================================================================
      4  1fba							; Scan the loaded program just before running and insert memory locations of each
      5  1fba							; line number branched to. goto 100, gosub 100, fn10(), task(100)
      6  1fba							; These have the format  in memory  example 81{key word token} 0000{pointer to memory location} A1{number type} 92 00{byte or integer value line number value}
      7  1fba							; goto 100   : 07 0000 A2 64			 the tokenizer optimizes the literal values to byte or int depending on value
      8  1fba							; gosub 1000 : 08 0000 A4 E803
      9  1fba							; fn 100()   ; 37 0000 A2 64 40 41
     10  1fba							; task(1000) : 2F 0000 40 A4 E803 41
     11  1fba				   Compile
     12  1fba		       a9 00		      lda	#0
     13  1fbc		       85 52		      sta	R0	; keep track of how many errors we find
     14  1fbe		       a5 5b		      lda	RunMode
     15  1fc0		       48		      pha
     16  1fc1		       e6 5b		      inc	RunMode	; force run mode for error reporting
     17  1fc3		       a5 4f		      lda	CURPTR
     18  1fc5		       48		      pha
     19  1fc6		       a5 50		      lda	CURPTR+1
     20  1fc8		       48		      pha
     21  1fc9		       a5 51		      lda	CUROFF
     22  1fcb		       48		      pha
     23  1fcc		       ad 1c 44 	      lda	ProgramStart
     24  1fcf		       85 59		      sta	dpl
     25  1fd1		       ad 1d 44 	      lda	ProgramStart+1
     26  1fd4		       85 5a		      sta	dpl+1
     27  1fd6
     28  1fd6				   CompileLineStart
     29  1fd6		       a5 59		      lda	dpl
     30  1fd8		       cd 1e 44 	      cmp	ProgramEnd
     31  1fdb		       d0 07		      bne	CompileContinue
     32  1fdd		       a5 5a		      lda	dpl+1
     33  1fdf		       cd 1f 44 	      cmp	ProgramEnd+1
     34  1fe2		       f0 3f		      beq	CompileComplete
     35  1fe4
     36  1fe4				   CompileContinue
     37  1fe4		       a0 03		      ldy	#3	; first real character in the line
     38  1fe6
     39  1fe6				   CompileLoop
     40  1fe6		       b1 59		      lda	(dpl),y	; get the byte
     41  1fe8		       f0 27		      beq	CompileEndOfLine	; End of line, so goto next line for scan
     42  1fea		       c8		      iny		; Pass this byte
     43  1feb		       c9 07		      cmp	#kGoto
     44  1fed		       f0 58		      beq	CompileField	; Will update the memory address and move pointer to next value
     45  1fef		       c9 08		      cmp	#kGosub
     46  1ff1		       f0 54		      beq	CompileField	; Will update the memory address and move pointer to next value
     47  1ff3		       c9 3c		      cmp	#kGofn
     48  1ff5		       f0 50		      beq	CompileField	; Will update the memory address and move pointer to next value
     49  1ff7		       c9 34		      cmp	#kTask
     50  1ff9		       f0 4c		      beq	CompileField
     51  1ffb		       c9 0a		      cmp	#kRem
     52  1ffd		       f0 12		      beq	CompileRem	; Skip until end of line
     53  1fff		       c9 a0		      cmp	#tString
     54  2001		       f0 2f		      beq	CompileString
     55  2003		       c9 a4		      cmp	#tInteger
     56  2005		       f0 06		      beq	CompileInteger
     57  2007		       c9 a2		      cmp	#tByte
     58  2009		       f0 03		      beq	CompileByte
     59  200b		       d0 d9		      bne	CompileLoop	; Next character
     60  200d
     61  200d				   CompileInteger
     62  200d		       c8		      iny
     63  200e				   CompileByte
     64  200e		       c8		      iny
     65  200f		       d0 d5		      bne	CompileLoop
     66  2011				   CompileRem
     67  2011				   CompileEndOfLine
     68  2011		       a0 00		      ldy	#0
     69  2013		       b1 59		      lda	(dpl),y
     70  2015		       18		      clc
     71  2016		       65 59		      adc	dpl
     72  2018		       85 59		      sta	dpl
     73  201a		       a9 00		      lda	#0
     74  201c		       65 5a		      adc	dpl+1
     75  201e		       85 5a		      sta	dpl+1
     76  2020
     77  2020		       4c d6 1f 	      jmp	CompileLineStart
     78  2023
     79  2023				   CompileComplete
     80  2023		       68		      pla
     81  2024		       85 51		      sta	CUROFF
     82  2026		       68		      pla
     83  2027		       85 50		      sta	CURPTR+1
     84  2029		       68		      pla
     85  202a		       85 4f		      sta	CURPTR
     86  202c		       68		      pla
     87  202d		       85 5b		      sta	RunMode
     88  202f		       a5 52		      lda	R0	; returning the number of errors
     89  2031		       60		      rts
     90  2032
     91  2032
     92  2032				   CompileString
     93  2032		       c8		      iny		; point past first "
     94  2033				   CompileStringLoop
     95  2033		       b1 59		      lda	(dpl),y
     96  2035		       f0 0d		      beq	CompileStrDone2	; end of line
     97  2037		       c9 22		      cmp	#'"	; end of string
     98  2039		       f0 08		      beq	CompileStrDone
     99  203b		       c9 5c		      cmp	#'\	; escape character
    100  203d		       d0 01		      bne	CompileStrNext
    101  203f		       c8		      iny		; skip the escape character
    102  2040				   CompileStrNext
    103  2040		       c8		      iny		; Next character
    104  2041		       d0 f0		      bne	CompileStringLoop	; test for end
    105  2043				   CompileStrDone
    106  2043		       c8		      iny
    107  2044				   CompileStrDone2
    108  2044		       4c e6 1f 	      Jmp	CompileLoop
    109  2047							;
    110  2047							;===============================================================
    111  2047							; on entry y points to storage location y+2 points to line number
    112  2047							; on exit y points to line number type
    113  2047
    114  2047		       85 52	   CompileField sta	R0
    115  2049		       98		      tya		; save the y pointer to store the memory value
    116  204a		       48		      pha
    117  204b		       c8		      iny		; Skip over the memory vector
    118  204c		       c8		      iny
    119  204d		       a5 52		      lda	R0
    120  204f		       c9 34		      cmp	#kTask	; for a task it is the next byte after a bracket
    121  2051		       d0 07		      bne	CompNoBracket
    122  2053
    123  2053		       b1 59		      lda	(dpl),y	; Lets make sure it is a (
    124  2055		       c9 e0		      cmp	#oLeftBracket
    125  2057		       d0 01		      bne	CompNoBracket	; in case of error
    126  2059		       c8		      iny		; skip the bracket
    127  205a
    128  205a				   CompNoBracket
    129  205a		       a9 00		      lda	#0	; In case the value is a byte
    130  205c		       85 53		      sta	R0+1
    131  205e
    132  205e		       b1 59		      lda	(dpl),Y	; get the type of the next byte txxx something or other
    133  2060		       c9 a2		      cmp	#tByte
    134  2062		       f0 15		      beq	CompByteLoad
    135  2064		       c9 a4		      cmp	#tInteger
    136  2066		       f0 04		      beq	CompIntLoad	; If it is not a number then get out of here
    137  2068		       68		      pla
    138  2069		       4c e6 1f 	      jmp	CompileLoop	; Ignore the saved stack
    139  206c				   CompIntLoad
    140  206c		       c8		      iny
    141  206d		       b1 59		      lda	(dpl),y
    142  206f		       85 52		      sta	R0
    143  2071		       c8		      iny
    144  2072		       b1 59		      lda	(dpl),y
    145  2074		       85 53		      sta	R0+1
    146  2076		       4c 7e 20 	      jmp	CompFindLine
    147  2079				   CompByteLoad
    148  2079		       c8		      iny
    149  207a		       b1 59		      lda	(dpl),y
    150  207c		       85 52		      sta	R0
    151  207e				   CompFindLine
    152  207e		       20 3a 2b 	      jsr	findLine
    153  2081		       f0 1d		      beq	CompFoundLine
    154  2083		       e6 52		      inc	R0	; number of errors
    155  2085
    156  2085		       a5 59		      lda	dpl
    157  2087		       85 4f		      sta	CURPTR
    158  2089		       a5 5a		      lda	dpl+1
    159  208b		       85 50		      sta	CURPTR+1
    160  208d		       84 51		      sty	CUROFF
    161  208f
    162  208f		       a2 14		      ldx	#ERR_LINE_NOT_FOUND
    163  2091		       a9 00		      lda	#0
    164  2093
    165  2093		       20 14 06 	      jsr	DisplayError
    166  2096		       20 13 22 	      jsr	PrintProgramLine
    167  2099
    168  2099		       68		      pla
    169  209a		       a8		      tay
    170  209b		       c8		      iny
    171  209c		       c8		      iny
    172  209d		       4c e6 1f 	      jmp	CompileLoop
    173  20a0
    174  20a0				   CompFoundLine
    175  20a0		       68		      pla
    176  20a1		       a8		      tay
    177  20a2		       a5 4f		      lda	CURPTR
    178  20a4		       91 59		      sta	(dpl),y
    179  20a6		       c8		      iny
    180  20a7		       a5 50		      lda	CURPTR+1
    181  20a9		       91 59		      sta	(dpl),y
    182  20ab		       c8		      iny
    183  20ac		       4c e6 1f 	      jmp	CompileLoop
    184  20af
    185  20af
    186  20af
    187  20af
    188  20af
    189  20af
    190  20af
    191  20af
    192  20af
    193  20af
    194  20af
    195  20af
    196  20af
    197  20af
    198  20af
    199  20af
    200  20af
    201  20af
    202  20af
    203  20af
    204  20af
    205  20af
    206  20af
    207  20af
    208  20af
    209  20af
    210  20af
    211  20af
    212  20af
    213  20af
    214  20af
    215  20af
    216  20af
    217  20af
    218  20af
    219  20af
    220  20af
    221  20af
    222  20af
    223  20af
    224  20af
------- FILE mytb.asm
------- FILE print.asm LEVEL 2 PASS 6
      0  20af					      include	"print.asm"
      1  20af					      Seg	Code
      2  20af							;---------------------------
      3  20af							; Print 24-bit decimal number or  16bit unsigned
      4  20af							; ---------------------------
      5  20af							; On entry, R0=number to print
      6  20af							;	     Defaults to pad=0 , y=21 default
      7  20af							;	     R2 = 1 unsigned 16 bit
      8  20af							;	     R2 = 0 Signed   16 bit
      9  20af
     10  20af							; On entry at PrintDecPadded:
     11  20af							;	     X = padding, Y=(number of digits)*3-3, eg 21 for 8 digits
     12  20af
     13  20af							; On exit,  A,X,Y,num,pad corrupted
     14  20af							; Size      129 bytes, Table 24 bytes	--- total 153
     15  20af							; -----------------------------------------------------------------
     16  20af
     17  20af				   PrintDecimal
     18  20af		       8a		      TXA
     19  20b0		       48		      pha
     20  20b1		       98		      tya
     21  20b2		       48		      pha
     22  20b3		       a9 00		      lda	#0
     23  20b5		       8d 4a 21 	      sta	pad
     24  20b8		       a0 15		      LDY	#21	; Offset to powers of ten
     25  20ba		       4c c0 20 	      JMP	PrintDo
     26  20bd
     27  20bd				   PrintDecPadded
     28  20bd		       8e 4a 21 	      stx	pad
     29  20c0
     30  20c0				   PrintDo
     31  20c0		       a9 00		      lda	#0
     32  20c2		       85 54		      sta	R1
     33  20c4
     34  20c4		       a5 58		      lda	R2
     35  20c6		       c9 a9		      cmp	#tUint
     36  20c8		       f0 29		      beq	PrintPos
     37  20ca
     38  20ca		       a5 53		      lda	R0+1	;MSB has sign
     39  20cc		       10 25		      bpl	PrintPos	;it's a positive number;
     40  20ce
     41  20ce							; Negative numbers need more work.  Invert all the bits,
     42  20ce							; then add one.
     43  20ce
     44  20ce		       a9 2d		      lda	#'-
     45  20d0		       20 1d 1a 	      jsr	VOUTCH	;print the negative sign
     46  20d3
     47  20d3		       a9 ff		      lda	#$FF
     48  20d5		       85 54		      sta	R1
     49  20d7		       a5 52		      lda	R0	;invert bits
     50  20d9		       49 ff		      eor	#$ff
     51  20db		       85 52		      sta	R0
     52  20dd		       a5 53		      lda	R0+1
     53  20df		       49 ff		      eor	#$ff
     54  20e1		       85 53		      sta	R0+1
     55  20e3		       a5 54		      lda	R1
     56  20e5		       49 ff		      eor	#$ff
     57  20e7		       85 54		      sta	R1
     58  20e9		       e6 52		      inc	R0	;add one
     59  20eb		       d0 06		      bne	PrintPos
     60  20ed		       e6 53		      inc	R0+1
     61  20ef		       d0 02		      bne	PrintPos
     62  20f1		       e6 54		      inc	R1
     63  20f3				   PrintPos
     64  20f3
     65  20f3				   PrDec24Lp1
     66  20f3		       a2 ff		      LDX	#$FF
     67  20f5		       38		      SEC		; Start with digit=-1
     68  20f6				   PrDec24Lp2
     69  20f6		       a5 52		      LDA	R0+0
     70  20f8		       f9 4b 21 	      SBC	PrDec24Tens+0,Y
     71  20fb		       85 52		      STA	R0+0	; Subtract current tens
     72  20fd		       a5 53		      LDA	R0+1
     73  20ff		       f9 4c 21 	      SBC	PrDec24Tens+1,Y
     74  2102		       85 53		      STA	R0+1
     75  2104		       a5 54		      LDA	R0+2
     76  2106		       f9 4d 21 	      SBC	PrDec24Tens+2,Y
     77  2109		       85 54		      STA	R0+2
     78  210b		       e8		      INX
     79  210c		       b0 e8		      BCS	PrDec24Lp2	; Loop until <0
     80  210e		       a5 52		      LDA	R0+0
     81  2110		       79 4b 21 	      ADC	PrDec24Tens+0,Y
     82  2113		       85 52		      STA	R0+0	; Add current tens back in
     83  2115		       a5 53		      LDA	R0+1
     84  2117		       79 4c 21 	      ADC	PrDec24Tens+1,Y
     85  211a		       85 53		      STA	R0+1
     86  211c		       a5 54		      LDA	R0+2
     87  211e		       79 4d 21 	      ADC	PrDec24Tens+2,Y
     88  2121		       85 54		      STA	R0+2
     89  2123		       8a		      TXA
     90  2124		       d0 07		      BNE	PrDec24Digit	; Not zero, print it
     91  2126		       ad 4a 21 	      LDA	pad
     92  2129		       d0 09		      BNE	PrDec24Print
     93  212b		       f0 0a		      BEQ	PrDec24Next	; pad<>0, use it
     94  212d				   PrDec24Digit
     95  212d		       a2 30		      LDX	#'0
     96  212f		       8e 4a 21 	      STX	pad	; No more zero padding
     97  2132		       09 30		      ORA	#'0	; Print this digit
     98  2134				   PrDec24Print
     99  2134		       20 1d 1a 	      JSR	VOUTCH
    100  2137				   PrDec24Next
    101  2137		       88		      DEY
    102  2138		       88		      DEY
    103  2139		       88		      DEY
    104  213a		       f0 07		      beq	PrDec24LastDigit
    105  213c		       10 b5		      BPL	PrDec24Lp1	; Loop for next digit
    106  213e		       68		      pla
    107  213f		       a8		      tay
    108  2140		       68		      pla
    109  2141		       aa		      tax
    110  2142		       60		      RTS
    111  2143				   PrDec24LastDigit
    112  2143		       a2 30		      LDX	#'0
    113  2145		       8e 4a 21 	      STX	pad	; No more zero padding
    114  2148		       d0 a9		      BNE	PrDec24Lp1	; Loop for last digit
    115  214a
      0  214a				   pad	      db	0
      1  214a		       00		      .byte.b	0
    117  214b
    118  214b				   PrDec24Tens
      0  214b					      dw	1
      1  214b		       01 00		      .word.w	1
      0  214d					      db	(1 / 65536)
      1  214d		       00		      .byte.b	(1 / 65536)
      0  214e					      dw	10
      1  214e		       0a 00		      .word.w	10
      0  2150					      db	(10 / 65536)
      1  2150		       00		      .byte.b	(10 / 65536)
      0  2151					      dw	100
      1  2151		       64 00		      .word.w	100
      0  2153					      db	(100 / 65536)
      1  2153		       00		      .byte.b	(100 / 65536)
      0  2154					      dw	1000
      1  2154		       e8 03		      .word.w	1000
      0  2156					      db	(1000 / 65536)
      1  2156		       00		      .byte.b	(1000 / 65536)
      0  2157					      dw	10000
      1  2157		       10 27		      .word.w	10000
      0  2159					      db	(10000 / 65536)
      1  2159		       00		      .byte.b	(10000 / 65536)
      0  215a					      dw	100000
      1  215a		       a0 86		      .word.w	100000
      0  215c					      db	(100000 / 65536)
      1  215c		       01		      .byte.b	(100000 / 65536)
      0  215d					      dw	1000000
      1  215d		       40 42		      .word.w	1000000
      0  215f					      db	(1000000 / 65536)
      1  215f		       0f		      .byte.b	(1000000 / 65536)
      0  2160					      dw	10000000
      1  2160		       80 96		      .word.w	10000000
      0  2162					      db	(10000000 / 65536)
      1  2162		       98		      .byte.b	(10000000 / 65536)
    135  2163							;=====================================================
    136  2163							; Print character in A as two hex digits to the Console
    137  2163
    138  2163		       48	   HexToOut   pha		;save return value
    139  2164		       48		      pha
    140  2165		       4a		      lsr		;a  ;move top nibble to bottom
    141  2166		       4a		      lsr		;a
    142  2167		       4a		      lsr		;a
    143  2168		       4a		      lsr		;a
    144  2169		       20 72 21 	      jsr	hexta	;output nibble
    145  216c		       68		      pla
    146  216d		       20 72 21 	      jsr	hexta
    147  2170		       68		      pla		;restore
    148  2171		       60		      rts
    149  2172							;
    150  2172		       29 0f	   hexta      and	#%0001111
    151  2174		       c9 0a		      cmp	#$0a
    152  2176		       18		      clc
    153  2177		       30 02		      bmi	hexta1
    154  2179		       69 07		      adc	#7
    155  217b		       69 30	   hexta1     adc	#'0	;then fall into...
    156  217d		       4c 1d 1a 	      jmp	VOUTCH
    157  2180							;
    158  2180							;=====================================================
    159  2180							; Print the string that immediately follows the JSR to
    160  2180							; this function.  Stops when a null byte is found,
    161  2180							; then returns to the instruction immediately
    162  2180							; following the null.
    163  2180							;
    164  2180							; Thanks to Ross Archer for this code.
    165  2180							; http://www.6502.org/source/io/primm.htm
    166  2180							;
    167  2180
    168  2180		       68	   tbputs     pla		;Get the low part of "return" address
    169  2181							;(data start address)
    170  2181		       85 5e		      sta	PrtFrom
    171  2183		       68		      pla
    172  2184		       85 5f		      sta	PrtFrom+1	;Get the high part of "return" address
    173  2186							;(data start address)
    174  2186							;Note: actually we're pointing one short
    175  2186		       a0 01	   PSINB      ldy	#1
    176  2188		       b1 5e		      lda	(PrtFrom),y	;Get the next string character
    177  218a		       e6 5e		      inc	PrtFrom	;update the pointer
    178  218c		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
    179  218e		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    180  2190		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
    181  2192							;   Accumulator
    182  2192		       f0 06		      beq	PSIX1	;don't print the final NULL
    183  2194		       20 1d 1a 	      jsr	VOUTCH	;write it out
    184  2197		       4c 86 21 	      jmp	PSINB	;back around
    185  219a		       e6 5e	   PSIX1      inc	PrtFrom
    186  219c		       d0 02		      bne	PSIX2
    187  219e		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    188  21a0		       6c 5e 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
    189  21a3
    190  21a3							;+
    191  21a3							;====================================================
    192  21a3		       44 10	   PrtTerm    equ	tempy
    193  21a3
    194  21a3							; on exit Print Y has the offset to use
    195  21a3							; input y =	 addr low
    196  21a3							;	 x =	 addr high
    197  21a3							;	 a =	 termination string
    198  21a3
    199  21a3				   PrtQuoted		; Print a quoted string from the current program space
    200  21a3		       a9 22		      lda	#'"
    201  21a5		       a4 51		      ldy	CUROFF
    202  21a7		       d1 4f		      cmp	(CURPTR),y	; the opening quote, can to " or ' so long as they match
    203  21a9		       d0 03		      bne	PrtNoInc
    204  21ab		       c8		      iny
    205  21ac		       84 51		      sty	CUROFF
    206  21ae				   PrtNoInc
    207  21ae		       8d 10 44 	      sta	PrtTerm
    208  21b1
    209  21b1				   PrtPrgString 		; Print a terminated string from the static program space
    210  21b1		       a4 51		      ldy	CUROFF
    211  21b3		       a5 4f		      lda	CURPTR
    212  21b5		       85 5e		      sta	PrtFrom
    213  21b7		       a5 50		      lda	CURPTR+1
    214  21b9		       85 5f		      sta	PrtFrom+1
    215  21bb		       4c c7 21 	      jmp	PrtLoop
    216  21be
    217  21be							; Print a string pointed to by x= h, y=l terminated by value in  accumulator
    218  21be							; Return y as the length
    219  21be
    220  21be		       86 5f	   PrtStr     stx	PrtFrom+1
    221  21c0		       84 5e		      sty	PrtFrom
    222  21c2		       8d 10 44 	      sta	PrtTerm
    223  21c5		       a0 00		      ldy	#0
    224  21c7							;
    225  21c7							; On entry here ptrfrom and prtterm point to area to print
    226  21c7							;
    227  21c7		       b1 5e	   PrtLoop    lda	(PrtFrom),y
    228  21c9		       cd 10 44 	      cmp	PrtTerm
    229  21cc		       f0 0b		      beq	PrtEnd
    230  21ce		       c9 00		      cmp	#0	; always end if 0 is found
    231  21d0		       f0 07		      beq	PrtEnd
    232  21d2		       20 1d 1a 	      jsr	VOUTCH
    233  21d5		       c8		      iny
    234  21d6		       4c c7 21 	      jmp	PrtLoop
    235  21d9		       c8	   PrtEnd     iny		;return byte after the write
    236  21da		       60		      rts
    237  21db
    238  21db							;
    239  21db							;=======================================================
    240  21db							; Print all Variables
    241  21db				   PrintAllVars
    242  21db		       a0 00		      ldy	#0
    243  21dd		       84 58		      sty	R2
    244  21df				   PrintAllVarsLoop
    245  21df		       b1 41		      lda	(VARIABLES),y	; get the value into R0
    246  21e1		       85 52		      sta	R0
    247  21e3		       c8		      iny
    248  21e4		       b1 41		      lda	(VARIABLES),y
    249  21e6		       85 53		      sta	R0+1
    250  21e8		       98		      tya		; get the count
    251  21e9		       48		      pha
    252  21ea		       4a		      lsr
    253  21eb		       18		      clc
    254  21ec		       69 41		      adc	#'A
    255  21ee		       20 1d 1a 	      jsr	VOUTCH
    256  21f1		       20 80 21 	      jsr	puts
      0  21f4					      db	"=",0
      1  21f4		       3d 00		      .byte.b	"=",0
    258  21f6
    259  21f6		       20 af 20 	      jsr	PrintDecimal
    260  21f9		       20 80 21 	      jsr	puts
      0  21fc					      db	" ",0
      1  21fc		       20 00		      .byte.b	" ",0
    262  21fe		       68		      pla
    263  21ff		       a8		      tay
    264  2200		       c8		      iny
    265  2201		       c0 34		      cpy	#52	; A-Z 2 bytes each
    266  2203		       d0 da		      bne	PrintAllVarsLoop
    267  2205		       20 39 2e 	      jsr	CRLF
    268  2208
    269  2208		       60		      rts
    270  2209							;==========================================================================================================
    271  2209							;Debug   Print a Program Line from compile buffer
    272  2209							;
    273  2209				   DebugPrintProgramLine
    274  2209		       48		      pha
    275  220a		       a9 20		      lda	#TOKENBUFFER&$FF
    276  220c		       85 59		      sta	dpl
    277  220e		       a9 1c		      lda	#TOKENBUFFER>>8
    278  2210		       85 5a		      sta	dpl+1
    279  2212		       68		      pla
    280  2213
    281  2213							; Decode and print a line of program text
    282  2213							; on entry	 dpl points to line of code to print
    283  2213							; on exit	 no change in reg or dpl
    284  2213							;
    285  2213				   PrintProgramLine
    286  2213
    287  2213		       8e 20 1d 	      stx	printStorage
    288  2216		       8c 21 1d 	      sty	printStorage+1
    289  2219		       48		      pha
    290  221a
    291  221a		       a0 01		      ldy	#1	; index into the token buffer
    292  221c		       84 58		      sty	R2	; print unsigned decimal
    293  221e		       a0 00		      ldy	#0
    294  2220		       b1 59		      lda	(dpl),y	; get number of bytes
    295  2222		       aa		      tax		; place pointer into x
    296  2223		       c8		      iny
    297  2224		       ca		      dex		; Deduct the length byte
    298  2225		       20 0c 1f 	      jsr	DPL2R0	; Print the line number
    299  2228		       20 af 20 	      jsr	PrintDecimal
    300  222b		       a9 20		      lda	#$20
    301  222d		       20 1d 1a 	      jsr	VOUTCH
    302  2230
    303  2230				   PrintProgLoop
    304  2230		       b1 59		      lda	(dpl),y	; Get a character
    305  2232		       f0 4a		      beq	PrintProgramComplete	; If zero then at end of line
    306  2234		       29 80		      and	#%10000000	; check for Keyword or Variable/operator
    307  2236		       f0 76		      beq	PrintKeyword	; It uses the index in a to find a keyword
    308  2238
    309  2238				   PrintProgVars
    310  2238		       b1 59		      lda	(dpl),y
    311  223a		       29 e0		      and	#$E0	; Check for operators and punctuation
    312  223c		       c9 e0		      cmp	#$E0
    313  223e		       f0 6b		      beq	PrintProgOperatorVect
    314  2240
    315  2240		       b1 59		      lda	(dpl),y	; Get char back again and check for var
    316  2242		       c9 9e		      cmp	#$9D+1
    317  2244		       90 62		      bcc	PrintProgVariableVec
    318  2246		       29 a0		      and	#$A0	; Check for a valid datatype
    319  2248		       c9 a0		      cmp	#$A0
    320  224a		       f0 06		      beq	PrintDataType	; if not just print the character
    321  224c		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    322  224e		       ca		      dex		; Ok we are processing it
    323  224f		       c8		      iny
    324  2250		       d0 25		      bne	PrintContinue	; Print and do the next character
    325  2252
    326  2252				   PrintDataType
    327  2252		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    328  2254		       c9 a0		      cmp	#tString
    329  2256		       f0 31		      beq	PrintStringVariable
    330  2258
    331  2258				   PrintProgNumber
    332  2258		       c8		      iny		; we have a numerical integer value
    333  2259		       ca		      dex
    334  225a		       48		      pha
    335  225b		       a9 00		      lda	#0
    336  225d		       85 53		      sta	R0+1
    337  225f		       85 58		      sta	R2	; Set to print signed number
    338  2261		       b1 59		      lda	(dpl),y
    339  2263		       85 52		      sta	R0
    340  2265		       68		      pla
    341  2266		       c9 a4		      cmp	#tInteger
    342  2268		       d0 06		      bne	PrintProgNumDone
    343  226a		       c8		      iny
    344  226b		       ca		      dex
    345  226c		       b1 59		      lda	(dpl),y
    346  226e		       85 53		      sta	R0+1
    347  2270
    348  2270				   PrintProgNumDone
    349  2270		       c8		      iny
    350  2271		       ca		      dex
    351  2272		       20 af 20 	      jsr	PrintDecimal
    352  2275
    353  2275				   PrintProgNext
    354  2275		       a9 20		      lda	#$20
    355  2277				   PrintContinue
    356  2277		       20 1d 1a 	      jsr	VOUTCH
    357  227a				   PrintProgSkipSpace
    358  227a		       e0 00		      cpx	#0
    359  227c		       d0 b2		      bne	PrintProgLoop
    360  227e				   PrintProgramComplete
    361  227e		       20 39 2e 	      jsr	CRLF
    362  2281
    363  2281		       ae 20 1d 	      ldx	printStorage
    364  2284		       ac 21 1d 	      ldy	printStorage+1
    365  2287		       68		      pla
    366  2288
    367  2288		       60		      rts
    368  2289							;=================================================================================================================
    369  2289							; Print a string variable including the quotes
    370  2289							; On Input	 y is offset into buffer
    371  2289							; On Exit	 y is updated to new offset
    372  2289
    373  2289				   PrintStringVariable
    374  2289		       c8		      iny
    375  228a		       a9 22		      lda	#'"
    376  228c		       20 1d 1a 	      jsr	VOUTCH
    377  228f		       c8		      iny
    378  2290		       a5 59		      lda	dpl
    379  2292		       85 5e		      sta	PrtFrom
    380  2294		       a5 5a		      lda	dpl+1
    381  2296		       85 5f		      sta	PrtFrom+1
    382  2298		       a9 22		      lda	#'"
    383  229a		       8d 10 44 	      sta	PrtTerm
    384  229d		       20 c7 21 	      jsr	PrtLoop
    385  22a0		       a9 22		      lda	#'"
    386  22a2		       20 1d 1a 	      jsr	VOUTCH
    387  22a5		       4c 75 22 	      jmp	PrintProgNext
    388  22a8
    389  22a8				   PrintProgVariableVec
    390  22a8		       4c 48 23 	      jmp	PrintProgVariable
    391  22ab
    392  22ab				   PrintProgOperatorVect
    393  22ab		       4c 1f 23 	      jmp	PrintProgOperator
    394  22ae							;===============================================================================================================
    395  22ae							; On entry dpl points to the buffer we are printing from
    396  22ae							;	    y	current offset into the dpl buffer
    397  22ae							; all registers preserved
    398  22ae							;
    399  22ae				   PrintKeyword
    400  22ae
    401  22ae		       b1 59		      lda	(dpl),y	; Get the Keyword token to lookup
    402  22b0		       85 52		      sta	R0	; The value we are looking for
    403  22b2		       c9 07		      cmp	#kGoto	; Test if we must skip an extra two bytes for branch type instructions
    404  22b4		       f0 0c		      beq	PrintKeyBranch
    405  22b6		       c9 08		      cmp	#kGosub
    406  22b8		       f0 08		      beq	PrintKeyBranch
    407  22ba		       c9 34		      cmp	#kTask
    408  22bc		       f0 04		      beq	PrintKeyBranch
    409  22be		       c9 3c		      cmp	#kGofn
    410  22c0		       d0 04		      bne	PrintKeySkipped
    411  22c2				   PrintKeyBranch
    412  22c2		       c8		      iny		; Skip the compiled memory address
    413  22c3		       c8		      iny
    414  22c4		       ca		      dex		; Change number of bytes to print
    415  22c5		       ca		      dex		; Remove the bytes to print
    416  22c6
    417  22c6				   PrintKeySkipped
    418  22c6		       c8		      iny		; Inc y to point to the next char to be printed
    419  22c7		       ca		      dex		; Reduce number of bytes to print
    420  22c8		       98		      tya		; Save y and x for the return
    421  22c9		       48		      pha
    422  22ca		       8a		      txa
    423  22cb		       48		      pha
    424  22cc
    425  22cc		       a9 d8		      lda	#KeyWordTable&$FF	; R1 to point to the entry in the keyword table
    426  22ce		       85 54		      sta	R1
    427  22d0		       a9 1a		      lda	#KeyWordTable>>8
    428  22d2		       85 55		      sta	R1+1
    429  22d4
    430  22d4				   PrintKeyLoop
    431  22d4		       a0 00		      ldy	#0	; Index into the keyword entry
    432  22d6		       b1 54		      lda	(R1),y	; Get token value for this entry
    433  22d8		       c8		      iny		; Point to first byte of key
    434  22d9		       c5 52		      cmp	R0	; Compare to the token we are looking for
    435  22db		       f0 16		      Beq	PrintKeyFound	; We have the correct Token, now print it
    436  22dd
    437  22dd				   PrintKeyNext
    438  22dd		       b1 54		      lda	(R1),y	; Get key letter
    439  22df		       c8		      iny		; Point to next byte always
    440  22e0		       29 20		      and	#%00100000	; Check for last character in key work
    441  22e2		       d0 f9		      bne	PrintKeyNext	; If it is not set then get next character
    442  22e4
    443  22e4		       98		      tya		; Trabsfer y to a for the addition
    444  22e5		       18		      clc		; Table > 256 bytes
    445  22e6		       65 54		      adc	R1
    446  22e8		       85 54		      sta	R1
    447  22ea		       a9 00		      lda	#0
    448  22ec		       65 55		      adc	R1+1
    449  22ee		       85 55		      sta	R1+1
    450  22f0		       4c d4 22 	      jmp	PrintKeyLoop
    451  22f3
    452  22f3				   PrintKeyFound
    453  22f3		       b1 54		      lda	(R1),y	; letter from key table
    454  22f5		       48		      pha		; Save it for later check
    455  22f6		       09 20		      ora	#%00100000	; Force it to lower case
    456  22f8		       20 1d 1a 	      jsr	VOUTCH	; Print it out
    457  22fb		       c8		      iny		; Point to next character
    458  22fc		       68		      pla		; Restore the value
    459  22fd		       29 20		      and	#%00100000	; Check if it was last char in keyword
    460  22ff		       d0 f2		      bne	PrintKeyFound	; Yes, then goto all done printing
    461  2301
    462  2301		       68		      pla		; Restore the x and y values
    463  2302		       aa		      tax
    464  2303		       68		      pla
    465  2304		       a8		      tay
    466  2305
    467  2305				   PrintChkRem
    468  2305		       a9 0a		      lda	#kRem
    469  2307		       c5 52		      cmp	R0
    470  2309		       d0 11		      bne	PrintKeyDone
    471  230b				   PrintKeyRem
    472  230b		       a5 59		      lda	dpl	; if it is a rem then we must print the entire line
    473  230d		       85 5e		      sta	PrtFrom
    474  230f		       a5 5a		      lda	dpl+1
    475  2311		       85 5f		      sta	PrtFrom+1
    476  2313		       a9 00		      lda	#0
    477  2315		       8d 10 44 	      sta	PrtTerm
    478  2318		       20 c7 21 	      jsr	PrtLoop
    479  231b		       88		      dey		; point back to the terminating null value
    480  231c				   PrintKeyDone
    481  231c		       4c 75 22 	      jmp	PrintProgNext
    482  231f							;==================================================================================================================
    483  231f							;Print Variable, number or operator
    484  231f				   PrintProgOperator
    485  231f		       b1 59		      lda	(dpl),y
    486  2321		       c8		      iny
    487  2322		       ca		      dex
    488  2323		       8e 22 1d 	      stx	printStorage+2
    489  2326		       a2 00		      ldx	#0
    490  2328				   PrintOprLoop
    491  2328		       dd ba 1a 	      cmp	OperValues,x
    492  232b		       f0 03		      beq	PrintOprFound
    493  232d		       e8		      inx
    494  232e		       d0 f8		      bne	PrintOprLoop
    495  2330				   PrintOprFound
    496  2330		       8a		      txa
    497  2331		       0a		      asl
    498  2332		       aa		      tax
    499  2333		       bd 7c 1a 	      lda	Operators,x
    500  2336		       20 1d 1a 	      jsr	VOUTCH
    501  2339		       e8		      inx
    502  233a		       bd 7c 1a 	      lda	Operators,x
    503  233d		       f0 03		      beq	PrintOprDone
    504  233f		       20 1d 1a 	      jsr	VOUTCH
    505  2342				   PrintOprDone
    506  2342		       ae 22 1d 	      ldx	printStorage+2
    507  2345		       4c 75 22 	      jmp	PrintProgNext
    508  2348
    509  2348							;=================================================================================================================
    510  2348							;KeywordsMax	    equ     128 		   ; Allow to be range	1 to 127  key words, high order bit must be 0 for it to be a key word
    511  2348							;tVa		    equ     128 		   ; Variable A = 1, .... Z = 26   ^ = 27
    512  2348							;tVb		    equ     130 		   ; Variables 128 - 157  $80-$9D
    513  2348							;tVhat 	    equ     155 		   ; Variable ^
    514  2348							;tVhash	    equ     156 		   ; Variable #
    515  2348							;tVat		    equ     157 		   ; Variable @ = 0
    516  2348				   PrintProgVariable
    517  2348		       b1 59		      lda	(dpl),y
    518  234a		       c8		      iny
    519  234b		       ca		      dex
    520  234c		       c9 9b		      cmp	#tVhat
    521  234e		       d0 04		      bne	PrintProgChkHash
    522  2350		       a9 5e		      lda	#'^
    523  2352		       d0 15		      bne	PrintTheVar
    524  2354				   PrintProgChkHash
    525  2354		       c9 9c		      cmp	#tVhash
    526  2356		       d0 04		      bne	PrintProgChkAt
    527  2358		       a9 23		      lda	#'#
    528  235a		       d0 0d		      bne	PrintTheVar
    529  235c				   PrintProgChkAt
    530  235c		       c9 9d		      cmp	#tVat
    531  235e		       d0 04		      bne	PrintProgVarLetter
    532  2360		       a9 40		      lda	#'@
    533  2362		       d0 05		      bne	PrintTheVar
    534  2364				   PrintProgVarLetter
    535  2364		       29 7f		      and	#%01111111
    536  2366		       18		      clc
    537  2367		       69 41		      adc	#'A
    538  2369				   PrintTheVar
    539  2369		       20 1d 1a 	      jsr	VOUTCH
    540  236c		       4c 75 22 	      jmp	PrintProgNext
    541  236f
    542  236f							;==================================================================================================
    543  236f							; Size of print functions
    544  236f		       02 c0	   PrintFunctionsSize equ	* - PrintDecimal	; should use label of first fuction in file
------- FILE mytb.asm
------- FILE mem.asm LEVEL 2 PASS 6
      0  236f					      include	"mem.asm"
      1  236f							;===================================================================
      2  236f							;This file contains the memory allocation and free functions
      3  236f							; This is the management of free memory in the system
      4  236f							; the interface to these functions
      5  236f							; a,x returns or provides the low hi bytes of the managed addresses
      6  236f							; This uses the programend, to memory end as the area to manage
      7  236f							;===================================================================
      8 U375b					      Seg.u	TBData
      9 U375b							;
     10 U375b							;=====================================================
     11 U375b							;Pointers for memory Management
     12 U375b							;Allocated block are not chained but can be followed for all memory by the associated length
     13 U375b							; Mem block format is
     14 U375b							;	 0-1   pointer to next block for free blocks
     15 U375b							;	 0-1   for allocated blocks
     16 U375b							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
     17 U375b							;	   1   refrence counter ... lol only up to 256 but it is something
     18 U375b							;	 2-3   length constant for exevy type of memory block
     19 U375b							; Memory is recombined as it is released
     20 U375b							; The memory manager is not interupted durring allocation
     21 U375b							; or freeing of memory
     22 U375b							;====================================================
     23 U375b		       00 00	   MemFreeList ds	2	; list of free blocks of memory
     24 U375d		       00 00	   MemR0      ds	2	; source for copy/move/Init
     25 U375f		       00 00	   MemR1      ds	2	; Destination for copy/move
     26 U3761							;=====================================================
     27  236f					      Seg	Code
     28  236f							;=====================================================
     29  236f				   MemInit
     30  236f		       a9 26		      lda	#FreeMemStart&$FF
     31  2371		       8d 1c 44 	      sta	ProgramStart
     32  2374		       8d 1e 44 	      sta	ProgramEnd
     33  2377		       a9 44		      lda	#FreeMemStart>>8
     34  2379		       8d 1d 44 	      sta	ProgramStart+1
     35  237c		       8d 1f 44 	      sta	ProgramEnd+1
     36  237f
     37  237f		       20 89 23 	      jsr	GetSizes
     38  2382		       20 94 23 	      jsr	MemFree
     39  2385		       20 ac 23 	      jsr	MemUsed
     40  2388				   MemInitEnd
     41  2388		       60		      rts
     42  2389
     43  2389
     44  2389							;
     45  2389							;=====================================================
     46  2389							; This function might go away eventually, but was
     47  2389							; added to provide data for other pieces of code.
     48  2389							; It has some ties to the operating environment that
     49  2389							; will need to be customized for the target system.
     50  2389							;
     51  2389				   GetSizes
     52  2389							;
     53  2389							; Here is machine specific code to get the highest
     54  2389							; memory location that can be used by BASIC.
     55  2389							;
     56  2389				  -	      if	ProgramStart < $2000
     57  2389				  -	      lda	#$ff
     58  2389				  -	      sta	HighMem	;$13ff for KIM-1
     59  2389				  -	      sta	MemFreeList
     60  2389				  -	      lda	#$DE	;#$13
     61  2389				  -	      sta	HighMem+1
     62  2389				  -	      sta	MemFreeList+1
     63  2389					      else
     64  2389		       a9 ff		      lda	#$ff
     65  238b		       8d 20 44 	      sta	HighMem	;$CFFF otherwise
     66  238e		       a9 cf		      lda	#$cf
     67  2390		       8d 21 44 	      sta	HighMem+1
     68  2393					      endif
     69  2393		       60		      rts
     70  2394							;
     71  2394							; This computes the available memory remaining.
     72  2394							;
     73  2394				   MemFree
     74  2394		       38		      sec
     75  2395		       ad 20 44 	      lda	HighMem
     76  2398		       ed 1e 44 	      sbc	ProgramEnd
     77  239b		       8d 24 44 	      sta	FreeMem
     78  239e		       85 52		      sta	R0
     79  23a0		       ad 21 44 	      lda	HighMem+1
     80  23a3		       ed 1f 44 	      sbc	ProgramEnd+1
     81  23a6		       8d 25 44 	      sta	FreeMem+1
     82  23a9		       85 53		      sta	R0+1
     83  23ab		       60		      rts
     84  23ac							;
     85  23ac							; This computes the size of the current user program.
     86  23ac							;
     87  23ac				   MemUsed
     88  23ac		       38		      sec
     89  23ad		       ad 1e 44 	      lda	ProgramEnd
     90  23b0		       ed 1c 44 	      sbc	ProgramStart
     91  23b3		       8d 22 44 	      sta	UsedMem
     92  23b6		       85 52		      sta	R0
     93  23b8		       ad 1f 44 	      lda	ProgramEnd+1
     94  23bb		       ed 1d 44 	      sbc	ProgramStart+1
     95  23be		       8d 23 44 	      sta	UsedMem+1
     96  23c1		       85 53		      sta	R0+1
     97  23c3							;
     98  23c3		       60		      rts
     99  23c4							;
    100  23c4							;=====================================================
    101  23c4							; Set a block of memory to a value
    102  23c4		       8a	   iSetBlock  txa
    103  23c5		       48		      pha
    104  23c6		       98		      tya
    105  23c7		       48		      pha
    106  23c8		       20 80 2d 	      jsr	popR0	; the address to write to
    107  23cb		       a5 52		      lda	R0
    108  23cd		       85 59		      sta	dpl
    109  23cf		       a5 53		      lda	R0+1
    110  23d1		       85 5a		      sta	dpl+1
    111  23d3		       20 98 2d 	      jsr	popR1	; Number of bytes to write
    112  23d6		       20 80 2d 	      jsr	popR0	; Get the value to store into memory
    113  23d9		       20 f5 2a 	      jsr	getILByte
    114  23dc		       85 58		      sta	R2	; store the data type into R2
    115  23de		       c9 a4		      cmp	#tInteger
    116  23e0		       f0 08		      beq	memset	; skip this if we have an integer
    117  23e2		       a5 52		      lda	R0	; Revers the order so they can be copied in correct order
    118  23e4		       a6 53		      ldx	R0+1
    119  23e6		       86 52		      stx	R0
    120  23e8		       85 53		      sta	R0+1
    121  23ea
    122  23ea				   memset
    123  23ea		       a0 00		      ldy	#0	; Set for length of block to copy
    124  23ec		       a2 00		      ldx	#0	; set for number of block of 256 to copy
    125  23ee
    126  23ee		       a5 58	   iSetBlockLoop lda	R2	; Get Datatype
    127  23f0		       c9 a2		      cmp	#tByte
    128  23f2		       f0 09		      beq	iSetBlockB
    129  23f4
    130  23f4		       a5 52	   iSetBlockW lda	R0
    131  23f6		       91 59		      sta	(dpl),y
    132  23f8		       20 0d 24 	      jsr	iSetBlockEnd
    133  23fb		       f0 09		      beq	iSetBlockComplete
    134  23fd
    135  23fd		       a5 53	   iSetBlockB lda	R0+1
    136  23ff		       91 59		      sta	(dpl),y
    137  2401		       20 0d 24 	      jsr	iSetBlockEnd
    138  2404		       d0 e8		      bne	iSetBlockLoop
    139  2406
    140  2406				   iSetBlockComplete
    141  2406		       68		      pla
    142  2407		       a8		      tay
    143  2408		       68		      pla
    144  2409		       aa		      tax
    145  240a		       4c 9e 02 	      jmp	NextIL
    146  240d							;
    147  240d							; Check if we have reached the end of the initialization/Copy
    148  240d							;
    149  240d		       c8	   iSetBlockEnd iny
    150  240e		       d0 03		      bne	iSetBlockEndChk
    151  2410		       e8		      inx
    152  2411		       e6 5a		      inc	dpl+1
    153  2413				   iSetBlockEndChk
    154  2413		       c4 54		      cpy	R1
    155  2415		       d0 02		      bne	iSetBlockEndExit
    156  2417		       e4 55		      cpx	R1+1
    157  2419				   iSetBlockEndExit
    158  2419		       60		      rts
    159  241a							;
    160  241a							;================================================================
    161  241a							; Copy a block of memory from one location to another
    162  241a							;
    163  241a		       8a	   iCopyBlock txa
    164  241b		       48		      pha
    165  241c		       98		      tya
    166  241d		       48		      pha
    167  241e		       20 80 2d 	      jsr	popR0	; get the source address
    168  2421		       20 98 2d 	      jsr	popR1	; Destination address
    169  2424		       a5 54		      lda	R1
    170  2426		       85 59		      sta	dpl
    171  2428		       a5 55		      lda	R1+1
    172  242a		       85 5a		      sta	dpl+1
    173  242c		       20 98 2d 	      jsr	popR1	; Number of bytes to copy
    174  242f				   memcpy
    175  242f		       a2 00		      ldx	#0
    176  2431		       a0 00		      ldy	#0
    177  2433				   iCopyBlockLoop
    178  2433		       b1 52		      lda	(R0),y	;  Get the byte to copy
    179  2435		       91 59		      sta	(dpl),y	;  Store the byte
    180  2437		       c8		      iny
    181  2438		       d0 05		      bne	iCopyChkEnd
    182  243a		       e8		      inx
    183  243b		       e6 53		      inc	R0+1
    184  243d		       e6 5a		      inc	dpl+1
    185  243f		       c4 54	   iCopyChkEnd cpy	R1
    186  2441		       d0 f0		      bne	iCopyBlockLoop
    187  2443		       e4 55		      cpx	R1+1
    188  2445		       d0 ec		      bne	iCopyBlockLoop
    189  2447				   iCopyBlockDone
    190  2447		       68		      pla
    191  2448		       a8		      tay
    192  2449		       68		      pla
    193  244a		       aa		      tax
    194  244b		       4c 9e 02 	      jmp	NextIL
    195  244e							;
    196  244e							;=============================================================================
    197  244e							; Compare memory block location
    198  244e							; returns on the stack
    199  244e							; 0 - equals
    200  244e							; -1 - s1  <  s2
    201  244e							; 1   s1  >  s2
    202  244e		       8a	   iCmpBlock  txa
    203  244f		       48		      pha
    204  2450		       98		      tya
    205  2451		       48		      pha
    206  2452		       20 98 2d 	      jsr	popR1	; Get the Source 2 pointer
    207  2455		       a5 54		      lda	R1
    208  2457		       85 59		      sta	dpl	; store the secon source in dpl
    209  2459		       a5 55		      lda	R1+1
    210  245b		       85 5a		      sta	dpl+1
    211  245d		       20 80 2d 	      jsr	popR0	; Get the Source 1 pointer
    212  2460		       20 98 2d 	      jsr	popR1	; Get the length of the compare to do
    213  2463		       a0 00		      ldy	#0
    214  2465		       a2 00		      ldx	#0
    215  2467		       4c 74 24 	      jmp	iCmpCheckEnd
    216  246a
    217  246a		       b1 59	   iCmpLoop   lda	(dpl),y
    218  246c		       d1 52		      cmp	(R0),y
    219  246e		       d0 19		      bne	iCmpDone
    220  2470		       c8		      iny
    221  2471		       d0 01		      bne	iCmpCheckEnd
    222  2473		       e8		      inx
    223  2474				   iCmpCheckEnd
    224  2474		       c4 54		      cpy	R1
    225  2476		       d0 f2		      bne	iCmpLoop
    226  2478		       e4 55		      cpx	R1+1
    227  247a		       d0 ee		      bne	iCmpLoop
    228  247c		       a5 00		      lda	0
    229  247e		       85 53		      sta	R0+1
    230  2480		       85 52		      sta	R0
    231  2482				   iCmpReturn
    232  2482		       68		      pla
    233  2483		       a8		      tay
    234  2484		       68		      pla
    235  2485		       aa		      tax
    236  2486		       4c 0a 07 	      jmp	pushR0nextIl
    237  2489
    238  2489				   iCmpDone
    239  2489		       90 0a		      bcc	iCmpGreater
    240  248b				   iCmpLess
    241  248b		       a9 00		      lda	#0
    242  248d		       85 53		      sta	R0+1
    243  248f		       a9 01		      lda	#1
    244  2491		       85 52		      sta	R0
    245  2493		       d0 ed		      bne	iCmpReturn
    246  2495				   iCmpGreater
    247  2495		       a9 ff		      lda	#-1
    248  2497		       85 52		      sta	R0
    249  2499		       85 53		      sta	R0+1
    250  249b		       d0 e5		      bne	iCmpReturn
    251  249d
------- FILE mytb.asm
------- FILE gosub_def.inc LEVEL 2 PASS 6
      0  249d					      include	"gosub_def.inc"
      1  249d							; Gosub stack definitions and structure information
      2  249d							; The gosub stack is used by, while, for, gosub, function parameters
      3  249d							; Task parameter passing as well, math stack frame info
      4  249d							;
      5  249d							;==================================================================
      6  249d							; gosub stack entry formats, always contains a typw identifier
      7  249d							; gosub: no return value, no parameters
      8  249d							; byte 0   : Math Stack pointer
      9  249d							; byte 1   : The number of parameters being passed on the math stack always 0
     10  249d							; byte 2   : Not used always 0
     11  249d							; byte 3   : type of entry #GOSUB_STACK_FRAME
     12  249d							;
     13  249d							; gosub with parameters, no return value
     14  249d							; byte 0   : Math Stack pointer
     15  249d							; byte 1   : The number of parameters being passed on the math stack 1-255
     16  249d							; byte 2   : Not used always 0
     17  249d							; byte 3   : type of entry #GOSUB_STACK_FRAME
     18  249d
     19  249d							; gosub with parameters, return value
     20  249d							; byte 0   : Math Stack pointer
     21  249d							; byte 1   : The number of parameters being passed on the math stack 1-255
     22  249d							; byte 2   : Not used always 0
     23  249d							; byte 3   : type of entry #GOSUB_STACK_FRAME
     24  249d							; Value is return in R0
     25  249d							;
     26  249d							; Task with parameters, return value always in variable array
     27  249d							;  For tasks just like gosub calls, the parameters are stored onto the match stack
     28  249d							;  and the parameter stack frame is stored onto the gosub stack
     29  249d
     30  249d							; For next step, continue, break
     31  249d							; byte: 0,1  pc counter to return to test
     32  249d							; byte: 2,3  pc counter to exit to
     33  249d							; byte: 4    type of entry #GOSUB_FOR
     34  249d
     35  249d							; while..wend, continue, break
     36  249d							; byte: 0,1  pc counter to return to test
     37  249d							; byte: 2.3  pc counter to exit to
     38  249d							; byte: 4    type of entry #GOSUB_WHILE
     39  249d
     40  249d							;
     41  249d							; Gosub entry types
     42  249d
     43  249d		       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
     44  249d		       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
     45  249d		       00 02	   GOSUB_FOR  equ	2	; Return point for FOR..Next
     46  249d		       00 03	   GOSUB_While equ	3	; Return point for the While.. wend
     47  249d		       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
     48  249d		       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
     49  249d							; 0 byte is the original stack offset, byte 1 is the parameter count
     50  249d							; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
     51  249d		       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
     52  249d		       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
     53  249d
------- FILE mytb.asm
------- FILE gosub.asm LEVEL 2 PASS 6
      0  249d					      include	"gosub.asm"
      1  249d					      seg	Code
      2  249d
      3  249d							; Gosub and return related functions, While ..  Wend
      4  249d							;==========================================================
      5  249d							; Push the current math stack frame onto the gosub stack
      6  249d							;   the frame is really just the information about the area on the
      7  249d							;   math stack that contains the passed values as parameters
      8  249d				   iPushMathStack
      9  249d		       98		      tya
     10  249e		       48		      pha
     11  249f		       a4 4d		      ldy	GOSUBSTACKPTR
     12  24a1		       a5 4a		      lda	MATHSTACKPTR
     13  24a3		       91 4b		      sta	(GOSUBSTACK),y	; place the current Math stack ptr onto the stack
     14  24a5		       a9 00		      lda	#0
     15  24a7		       c8		      iny
     16  24a8		       91 4b		      sta	(GOSUBSTACK),y	; place a zero for the number of current parameters
     17  24aa		       c8		      iny
     18  24ab		       91 4b		      sta	(GOSUBSTACK),y	; Place a zero for the next byte
     19  24ad		       c8		      iny
     20  24ae		       a9 05		      lda	#GOSUB_STACK_FRAME
     21  24b0		       91 4b		      sta	(GOSUBSTACK),y	; store the type of entry on the stack as the last byte
     22  24b2		       c8		      iny
     23  24b3		       84 4d		      sty	GOSUBSTACKPTR	; save the pointer into the gosub stack
     24  24b5		       68		      pla
     25  24b6		       a8		      tay
     26  24b7		       4c 9e 02 	      jmp	NextIL
     27  24ba							;
     28  24ba							;==========================================================
     29  24ba							; Increment parameter count. Assume Stack frame is top of stack
     30  24ba				   iIncParmCount
     31  24ba		       98		      tya
     32  24bb		       48		      pha
     33  24bc
     34  24bc		       a4 4d		      ldy	GOSUBSTACKPTR	; get the pointer to update the stack entry
     35  24be		       88		      dey		; point to the type of entry #GOSUB_STACK_FRAME
     36  24bf		       88		      dey		; point to the previous byte
     37  24c0		       88		      dey		; point to the count of parameters up to 255
     38  24c1		       b1 4b		      lda	(GOSUBSTACK),y	; get the count
     39  24c3		       18		      clc
     40  24c4		       69 01		      adc	#1	; increment the count
     41  24c6		       91 4b		      sta	(GOSUBSTACK),y	; save the updated count
     42  24c8
     43  24c8		       68		      pla
     44  24c9		       a8		      tay
     45  24ca		       4c 9e 02 	      jmp	NextIL
     46  24cd							;
     47  24cd							;==========================================================
     48  24cd							;Restore the math stack frame, removing parameters from stop
     49  24cd							;of the math stack
     50  24cd							;
     51  24cd		       20 d3 24    iPopMathStack jsr	PopMathStackNow
     52  24d0		       4c 9e 02 	      jmp	NextIL
     53  24d3
     54  24d3				   PopMathStackNow
     55  24d3		       98		      tya
     56  24d4		       48		      pha
     57  24d5
     58  24d5		       a4 4d		      ldy	GOSUBSTACKPTR
     59  24d7		       88		      dey
     60  24d8		       b1 4b		      lda	(GOSUBSTACK),y
     61  24da		       c9 05		      cmp	#GOSUB_STACK_FRAME
     62  24dc		       d0 09		      bne	iPopMathStackNoFrame
     63  24de		       88		      dey
     64  24df		       88		      dey
     65  24e0		       88		      dey
     66  24e1		       b1 4b		      lda	(GOSUBSTACK),y
     67  24e3		       85 4a		      sta	MATHSTACKPTR
     68  24e5		       84 4d		      sty	GOSUBSTACKPTR
     69  24e7
     70  24e7				   iPopMathStackNoFrame
     71  24e7
     72  24e7		       68		      pla
     73  24e8		       a8		      tay
     74  24e9		       60		      rts
     75  24ea
     76  24ea							;==========================================================
     77  24ea							; Push the current math stack information onto the gosub stack
     78  24ea				   iSaveMathStack
     79  24ea		       98		      tya
     80  24eb		       48		      pha
     81  24ec
     82  24ec		       a4 4d		      ldy	GOSUBSTACKPTR
     83  24ee		       a5 4a		      lda	MATHSTACKPTR
     84  24f0		       91 4b		      sta	(GOSUBSTACK),y
     85  24f2		       a5 48		      lda	MATHSTACK
     86  24f4		       c8		      iny
     87  24f5
     88  24f5		       91 4b		      sta	(GOSUBSTACK),y
     89  24f7		       c8		      iny
     90  24f8
     91  24f8		       a5 49		      lda	MATHSTACK+1
     92  24fa		       91 4b		      sta	(GOSUBSTACK),y
     93  24fc		       c8		      iny
     94  24fd
     95  24fd		       a9 06		      lda	#GOSUB_STACK_SAVE
     96  24ff		       91 4b		      sta	(GOSUBSTACK),y
     97  2501		       c8		      iny
     98  2502
     99  2502		       84 4d		      sty	GOSUBSTACKPTR
    100  2504
    101  2504		       68		      pla
    102  2505		       a8		      tay
    103  2506		       4c 9e 02 	      jmp	NextIL
    104  2509							;
    105  2509							;==========================================================
    106  2509							;Restore the math stack information from the gosub stack
    107  2509				   iRestoreMathStack
    108  2509		       98		      tya
    109  250a		       48		      pha
    110  250b
    111  250b		       a5 4a		      lda	MATHSTACKPTR
    112  250d		       85 58		      sta	R2	; save the current offset for whatever task to R2
    113  250f
    114  250f		       a4 4d		      ldy	GOSUBSTACKPTR
    115  2511		       88		      dey
    116  2512		       b1 4b		      lda	(GOSUBSTACK),y
    117  2514		       c9 06		      cmp	#GOSUB_STACK_SAVE
    118  2516		       d0 16		      bne	iPopMathStack_Err
    119  2518		       88		      dey
    120  2519		       b1 4b		      lda	(GOSUBSTACK),y
    121  251b		       85 49		      sta	MATHSTACK+1
    122  251d		       88		      dey
    123  251e		       b1 4b		      lda	(GOSUBSTACK),y
    124  2520		       85 48		      sta	MATHSTACK
    125  2522		       88		      dey
    126  2523		       b1 4b		      lda	(GOSUBSTACK),y
    127  2525		       85 4a		      sta	MATHSTACKPTR
    128  2527		       84 4d		      sty	GOSUBSTACKPTR
    129  2529
    130  2529		       68		      pla
    131  252a		       a8		      tay
    132  252b		       4c 9e 02 	      jmp	NextIL
    133  252e
    134  252e				   iPopMathStack_Err
    135  252e		       68		      pla
    136  252f		       a8		      tay
    137  2530		       a9 00		      lda	#0
    138  2532		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    139  2534		       4c 6a 06 	      jmp	iErr2
    140  2537							;===========================================================
    141  2537							; For functions and tasks the variable address of # means
    142  2537							; a passed parameter so #[0] is the first parameter etc
    143  2537							; will try for a better way later
    144  2537							;============================================================
    145  2537							; On entry il, branch to if function
    146  2537							;	    il+1, value to be returned or not true or false
    147  2537							;
    148  2537							; Return from GOSUB  or function function
    149  2537							; format   RSTR 0   --- return form gosub
    150  2537							;	    RSTR 1   --- return from Function
    151  2537							;
    152  2537		       20 f5 2a    iRSTR      jsr	getILByte	; get where to go if 0 = gosub/1=function call
    153  253a		       8d 14 44 	      sta	offset
    154  253d		       20 d8 2c 	      jsr	saveIL	; for later jump if needed add extra entry to	the return stack
    155  2540
    156  2540		       20 31 2d 	      jsr	popLN	; get the next item from the stack into curptr and curroff, returns call type func or stmt
    157  2543		       85 54		      sta	R1	; keep the type of call returning from
    158  2545		       b0 2b		      bcs	iRSTRErr	; stack underflow error possible
    159  2547
    160  2547		       20 f5 2a 	      jsr	getILByte	; get if a value is being returned
    161  254a
    162  254a		       48		      pha		; save if a value was passed to be returned
    163  254b
    164  254b		       c9 00		      cmp	#0	; yes attemping to return a value
    165  254d		       f0 03		      beq	iRSTRPOP	; no value to return
    166  254f		       20 80 2d 	      jsr	popR0	; Get the value from the stack save if needed
    167  2552
    168  2552				   iRSTRPOP
    169  2552		       20 d3 24 	      jsr	PopMathStackNow	; adjust the stack frame from the call
    170  2555		       a5 54		      lda	R1	; called as a statement ?
    171  2557		       c9 01		      cmp	#GOSUB_RTN	; Called as a statement
    172  2559		       f0 13		      beq	iRSTRExit
    173  255b
    174  255b		       68		      pla		; get back if value returned or not
    175  255c		       c9 01		      cmp	#1	; we have a value to return
    176  255e		       f0 05		      beq	iRSTRVALUE
    177  2560
    178  2560		       a2 13		      ldx	#ERR_NO_RETURN_VALUE_PROVIDED	; well no value provided and we need one
    179  2562		       4c ff 04 	      jmp	iSAVErr2	; jump to general error reporting function
    180  2565
    181  2565				   iRSTRVALUE
    182  2565		       20 ee 2c 	      jsr	pushR0	; return value back to top of stack
    183  2568		       20 e3 2c 	      jsr	restoreIL	; get the correct il
    184  256b		       4c cd 0b 	      jmp	tstBranch	; And called as a function
    185  256e
    186  256e				   iRSTRExit
    187  256e		       68		      pla		; throw away gosub/func flag
    188  256f		       4c 9e 02 	      jmp	NextIL
    189  2572
    190  2572				   iRSTRNORETURNVALUE
    191  2572
    192  2572		       ad a3 37    iRSTRErr   lda	taskPtr	; Check if this is task zero
    193  2575		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    194  2577		       a5 56		      lda	MQ
    195  2579		       d0 03		      bne	taskRet
    196  257b		       20 bd 2f 	      jsr	pushFalse	; the result code by default is 0
    197  257e				   taskRet
    198  257e		       4c ee 28 	      jmp	iETask	; not task zero then do a task end instead
    199  2581				   taskZeroEnd
    200  2581		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    201  2583		       4c ff 04 	      jmp	iSAVErr2
    202  2586							;
    203  2586							;==========================================================================================
    204  2586							; Find the next gosub function parameter info	position on the stack
    205  2586							; Returns y = index and c set if found clear c otherwise
    206  2586		       a4 4d	   GosubFindParms ldy	GOSUBSTACKPTR	;Get the Pointer to the top of stack
    207  2588		       88		      dey		;Point to stack entry type
    208  2589
    209  2589							;Veryify the stack size and position for the call
    210  2589							;Loops here until it finds a GOSUB with value entry or gosub-rtn entry
    211  2589
    212  2589		       c0 00	   GosubFindLoop cpy	#0	;If we reach the top of the stack then no parametrs
    213  258b		       f0 2d		      beq	GosubNotFunc
    214  258d		       c0 10		      cpy	#GOSUBSTACKSIZE	;Tst if we are outside the stack size
    215  258f		       b0 29		      bcs	GosubNotFunc	;Not valid
    216  2591
    217  2591							;Look for the	 GOSUB_RTN_VALUE stack position
    218  2591		       b1 4b		      lda	(GOSUBSTACK),y	;Get the type of call - if it is not a fn call error
    219  2593		       c9 01		      cmp	#GOSUB_RTN	;if we find this then this function had no parameters
    220  2595		       f0 0f		      beq	GosubParmFnd	;We can pass parameters to a function that returns nothing
    221  2597
    222  2597		       c9 81		      cmp	#GOSUB_RTN_VALUE	;Parameters with the gosub call
    223  2599		       f0 0b		      beq	GosubParmFnd	;Skip any non Gosub related entries
    224  259b
    225  259b		       c9 05		      cmp	#GOSUB_STACK_FRAME	;Stack frame pointer So should contain the start position of Variables
    226  259d		       f0 13		      beq	GosubParmSkip	;We have a stackframe good
    227  259f
    228  259f		       88		      dey
    229  25a0		       88		      dey
    230  25a1		       88		      dey
    231  25a2		       88		      dey
    232  25a3		       4c 89 25 	      jmp	GosubFindLoop
    233  25a6
    234  25a6		       c0 03	   GosubParmFnd cpy	#3	; Check if we are outside the stack
    235  25a8		       90 10		      bcc	GosubNotFunc	; if y < 3 then error not found
    236  25aa		       c0 10		      cpy	#GOSUBSTACKSIZE	; Largest value
    237  25ac		       b0 0c		      bcs	GosubNotFunc	; no parameters passed
    238  25ae
    239  25ae		       88		      dey		; Point to hopefully Math Stack frame information
    240  25af		       88		      dey
    241  25b0		       88		      dey
    242  25b1		       88		      dey
    243  25b2				   GosubParmSkip
    244  25b2		       b1 4b		      lda	(GOSUBSTACK),y	;This should be a stack frame pointer
    245  25b4		       c9 05		      cmp	#GOSUB_STACK_FRAME	;Stack frame pointer So should contain the start position of Variables
    246  25b6		       d0 02		      bne	GosubNotFunc	;No parameters passed but expected
    247  25b8		       38		      sec
    248  25b9		       60		      rts
    249  25ba
    250  25ba		       18	   GosubNotFunc clc
    251  25bb		       60		      rts
    252  25bc
    253  25bc							;==========================================================================
    254  25bc							; This section support while..wend, for x = <expr> to <expr> [ step <expr> ] ... next
    255  25bc							;
    256  25bc							;===========================================================================
    257  25bc							; Begin a block of code, while, if endif, for next etc
    258  25bc							; on entry x contains the type of block being created
    259  25bc							; format WendPtr.wendptr,curptr,curptr+1,curoff,type
    260  25bc				   iBeginBlock
    261  25bc		       98		      tya
    262  25bd		       48		      pha
    263  25be		       20 f5 2a 	      jsr	getILByte	; get the type of block we are starting
    264  25c1		       85 54		      sta	R1
    265  25c3		       20 f5 2a 	      jsr	getILByte	; get the closing block marker
    266  25c6		       85 55		      sta	R1+1
    267  25c8		       20 e8 25 	      jsr	FindEndBlock	; push the endblock onto the stack
    268  25cb
    269  25cb		       a4 4d		      ldy	GOSUBSTACKPTR	; get the top of stack
    270  25cd		       a5 4f		      lda	CURPTR	; get the first byte of the program line
    271  25cf		       91 4b		      sta	(GOSUBSTACK),y	; place the current Math stack ptr onto the stack
    272  25d1		       c8		      iny		; Next byte to save
    273  25d2		       a5 50		      lda	CURPTR+1	; get the second byte of the program line
    274  25d4		       91 4b		      sta	(GOSUBSTACK),y	; place the current Math stack ptr onto the stack
    275  25d6		       c8		      iny
    276  25d7		       a5 51		      lda	CUROFF	; get the offset on the line
    277  25d9		       91 4b		      sta	(GOSUBSTACK),y	; place a zero for the number of current parameters
    278  25db		       c8		      iny
    279  25dc		       a5 54		      lda	R1	; get the type of block to save
    280  25de		       91 4b		      sta	(GOSUBSTACK),y	; store the type of entry on the stack as the last byte
    281  25e0		       c8		      iny
    282  25e1		       84 4d		      sty	GOSUBSTACKPTR	; save the pointer into the gosub stack
    283  25e3		       68		      pla
    284  25e4		       a8		      tay
    285  25e5		       4c 9e 02 	      jmp	NextIL
    286  25e8							;=================================================================================
    287  25e8							;find the end block, account for nested begin types
    288  25e8							;stores the address of the memory location to the next two byte on the gosub stack
    289  25e8							;return cleared carry if good, sets the carry if failed
    290  25e8							;R1 = begin block value, R1+1 = end block value, r2 is the balanced counter
    291  25e8							;
    292  25e8		       a5 4f	   FindEndBlock lda	CURPTR	; preserve the current line number
    293  25ea		       48		      pha
    294  25eb		       a5 50		      lda	CURPTR+1
    295  25ed		       48		      pha
    296  25ee		       a5 51		      lda	CUROFF
    297  25f0		       48		      pha
    298  25f1		       a9 00		      lda	#0
    299  25f3		       85 58		      sta	R2
    300  25f5				   FindEndBlkLoop
    301  25f5		       20 7f 2b 	      jsr	FindNextLine	; CURPTR now points to the next line, CUROFF is location of first char
    302  25f8		       20 93 2b 	      jsr	AtEnd	; At end of program
    303  25fb		       f0 36		      beq	FindEof	; Branch out if at end of program
    304  25fd		       a4 51		      ldy	CUROFF	; this is where the kwhend or kwhile will be stored for example
    305  25ff		       a5 54		      lda	R1	; get the start block value
    306  2601		       d1 4f		      cmp	(CURPTR),y	; test for a match
    307  2603		       f0 11		      beq	Findincr2	; inc it and continue
    308  2605		       a5 55		      lda	R1+1	; get the end of block value
    309  2607		       d1 4f		      cmp	(CURPTR),y	; is it end block
    310  2609		       d0 ea		      bne	FindEndBlkLoop	; check the next line
    311  260b		       a5 58		      lda	R2	; check if we are at level 0
    312  260d		       c9 00		      cmp	#0
    313  260f		       f0 0a		      beq	FindFound
    314  2611		       c6 58		      dec	R2	; reduce it by one
    315  2613		       4c f5 25 	      jmp	FindEndBlkLoop	; do the next one
    316  2616				   Findincr2
    317  2616		       e6 58		      inc	R2
    318  2618		       4c f5 25 	      jmp	FindEndBlkLoop
    319  261b				   FindFound
    320  261b		       a4 4d		      ldy	GOSUBSTACKPTR	; place the location of end block onto the gosub stack
    321  261d		       a5 4f		      lda	CURPTR
    322  261f		       91 4b		      sta	(GOSUBSTACK),y
    323  2621		       c8		      iny
    324  2622		       a5 50		      lda	CURPTR+1
    325  2624		       91 4b		      sta	(GOSUBSTACK),y
    326  2626		       c8		      iny
    327  2627		       84 4d		      sty	GOSUBSTACKPTR
    328  2629
    329  2629		       68		      pla
    330  262a		       85 51		      sta	CUROFF
    331  262c		       68		      pla		; restore the original line pointer
    332  262d		       85 50		      sta	CURPTR+1
    333  262f		       68		      pla
    334  2630		       85 4f		      sta	CURPTR
    335  2632
    336  2632		       60		      rts
    337  2633				   FindEof		; the matching closing block id not found
    338  2633		       a2 1c		      ldx	#ERR_NO_MATCHING_END_BLOCK
    339  2635		       4c ff 04 	      jmp	iSAVErr2
    340  2638							;
    341  2638							;==================================================================================
    342  2638							;Find end of block and set the user pc to it
    343  2638							;
    344  2638		       20 f5 2a    iJmpEnd    jsr	getILByte	; get the type of loop
    345  263b		       48		      pha
    346  263c		       a4 4d		      ldy	GOSUBSTACKPTR	; get the top of stack
    347  263e		       c0 00		      cpy	#0	; empty stack?
    348  2640		       f0 47		      beq	iJmpErrNoEntry
    349  2642		       88		      dey
    350  2643		       68		      pla
    351  2644		       d1 4b		      cmp	(GOSUBSTACK),y	; check if it is the correct type of entry
    352  2646		       d0 3c		      bne	iJmpErrInvalid	; Wrong type of entry
    353  2648		       88		      dey		; remove the entry from the stack
    354  2649		       88		      dey
    355  264a		       88		      dey
    356  264b		       88		      dey
    357  264c		       b1 4b		      lda	(GOSUBSTACK),y	; get the byte of curptr
    358  264e		       85 50		      sta	CURPTR+1
    359  2650		       88		      dey
    360  2651		       b1 4b		      lda	(GOSUBSTACK),y	; get the byte of curptr
    361  2653		       85 4f		      sta	CURPTR
    362  2655		       84 4d		      sty	GOSUBSTACKPTR
    363  2657		       a9 03		      lda	#3
    364  2659		       85 51		      sta	CUROFF
    365  265b
    366  265b		       4c 9e 02 	      jmp	NextIL	; if true then
    367  265e
    368  265e							;===========================================================================
    369  265e							; Jump back to the start of a block, look onto gosub stack for the while entry
    370  265e							; get the next il byte to determin which kind of block to process, while,for,if endif
    371  265e		       98	   iJmpStart  tya
    372  265f		       48		      pha
    373  2660		       20 f5 2a 	      jsr	getILByte	; get the type of block we are looking for
    374  2663		       48		      pha
    375  2664		       a4 4d		      ldy	GOSUBSTACKPTR	; the single byte offset to be used
    376  2666		       c0 00		      cpy	#0	; if it is zero bad juju
    377  2668		       f0 1f		      beq	iJmpErrNoEntry	; if it is zero then stack is empty get out
    378  266a		       88		      dey		; point to entry type on the stack
    379  266b		       68		      pla		; get type we are looking for
    380  266c		       d1 4b		      cmp	(GOSUBSTACK),y	; Check if it is the correct type of entry
    381  266e		       d0 14		      BNE	iJmpErrInvalid	; not the expected block type
    382  2670		       88		      dey
    383  2671		       b1 4b		      lda	(GOSUBSTACK),y	; get the correct offset of user program
    384  2673		       85 51		      sta	CUROFF	; offset on text line
    385  2675		       88		      dey
    386  2676		       b1 4b		      lda	(GOSUBSTACK),y	; get line start
    387  2678		       85 50		      sta	CURPTR+1
    388  267a		       88		      dey
    389  267b		       b1 4b		      lda	(GOSUBSTACK),y	; part of line start
    390  267d		       85 4f		      sta	CURPTR
    391  267f		       68		      pla
    392  2680		       a8		      tay
    393  2681		       4c 9e 02 	      jmp	NextIL	; ignore for now
    394  2684
    395  2684		       a2 1b	   iJmpErrInvalid ldx	#ERR_NO_MATCHING_BEGIN_BLOCK
    396  2686		       4c ff 04 	      jmp	iSAVErr2
    397  2689
    398  2689		       68	   iJmpErrNoEntry pla
    399  268a		       68		      pla
    400  268b		       a8		      tay
    401  268c		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    402  268e		       4c ff 04 	      jmp	iSAVErr2
    403  2691							;
    404  2691							;=======================================================================================
    405  2691							;Branch types
    406  2691				   iIfTrue
    407  2691		       20 f5 2a 	      jsr	getILByte
    408  2694		       8d 14 44 	      sta	offset
    409  2697		       20 80 2d 	      jsr	popR0
    410  269a		       a5 52		      lda	R0
    411  269c		       05 53		      ora	R0+1
    412  269e		       f0 15		      beq	iftestfailed
    413  26a0		       4c cd 0b 	      jmp	tstBranch
    414  26a3				   iIfFalse
    415  26a3		       20 f5 2a 	      jsr	getILByte
    416  26a6		       8d 14 44 	      sta	offset
    417  26a9		       20 80 2d 	      jsr	popR0
    418  26ac		       a5 52		      lda	R0
    419  26ae		       05 53		      ora	R0+1
    420  26b0		       d0 03		      bne	iftestfailed
    421  26b2		       4c cd 0b 	      jmp	tstBranch
    422  26b5				   iftestfailed
    423  26b5		       4c 9e 02 	      jmp	NextIL
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  26b8					      include	"tasks.asm"
      1  26b8							;=====================================================
      2  26b8							; Tiny Basic IL task management
      3  26b8							; Data required by task management
      4  26b8							; currently each context is about 30 bytes and is swapped
      5  26b8							; into and out of page zero on each task switch....
      6  26b8							; LOL yes it is slow, but works for this iteration.
      7  26b8							;
      8  26b8
      9  26b8					      Seg	Code
     10  26b8							;=====================================================
     11  26b8							; Sets the pointers to the math,IL and gosub stacks
     12  26b8							; Creates the initial Context for each task slot
     13  26b8				   taskSetStacks
     14  26b8		       a9 a3		      lda	#mathStack&$FF
     15  26ba		       85 48		      sta	MATHSTACK
     16  26bc		       a9 38		      lda	#mathStack>>8
     17  26be		       85 49		      sta	MATHSTACK+1
     18  26c0
     19  26c0		       a9 33		      lda	#ilStack&$ff
     20  26c2		       85 45		      sta	ILSTACK
     21  26c4		       a9 3a		      lda	#ilStack>>8
     22  26c6		       85 46		      sta	ILSTACK+1
     23  26c8
     24  26c8		       a9 1b		      lda	#gosubStack&$FF
     25  26ca		       85 4b		      sta	GOSUBSTACK
     26  26cc		       a9 3e		      lda	#gosubStack>>8
     27  26ce		       85 4c		      sta	GOSUBSTACK+1
     28  26d0
     29  26d0		       a9 9b		      lda	#variableStack&$FF
     30  26d2		       85 41		      sta	VARIABLES
     31  26d4		       a9 40		      lda	#variableStack>>8
     32  26d6		       85 42		      sta	VARIABLES+1
     33  26d8		       a2 0a		      ldx	#TASKCOUNT
     34  26da		       a0 00		      ldy	#0
     35  26dc		       20 ac 29 	      jsr	ContextSave	; Save the Task 0 context
     36  26df
     37  26df		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  26e1		       b0 3a		      bcs	taskSetDone
     39  26e3
     40  26e3		       a5 4b		      lda	GOSUBSTACK
     41  26e5		       18		      clc
     42  26e6		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  26e8		       85 4b		      sta	GOSUBSTACK
     44  26ea		       a5 4c		      lda	GOSUBSTACK+1
     45  26ec		       69 00		      adc	#0
     46  26ee		       85 4c		      sta	GOSUBSTACK+1
     47  26f0
     48  26f0		       a5 45		      lda	ILSTACK	; must be less than 256
     49  26f2		       18		      clc
     50  26f3		       69 64		      adc	#ILSTACKSIZE*2
     51  26f5		       85 45		      sta	ILSTACK
     52  26f7		       a5 46		      lda	ILSTACK+1
     53  26f9		       69 00		      adc	#0
     54  26fb		       85 46		      sta	ILSTACK+1
     55  26fd
     56  26fd		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  26ff		       18		      clc
     58  2700		       69 28		      adc	#MATHSTACKSIZE*2
     59  2702		       85 48		      sta	MATHSTACK
     60  2704		       a5 49		      lda	MATHSTACK+1
     61  2706		       69 00		      adc	#0
     62  2708		       85 49		      sta	MATHSTACK+1
     63  270a
     64  270a		       a5 41		      lda	VARIABLES	; must be less than 256
     65  270c		       18		      clc
     66  270d		       69 4a		      adc	#VARIABLESSIZE*2
     67  270f		       85 41		      sta	VARIABLES
     68  2711		       a5 42		      lda	VARIABLES+1
     69  2713		       69 00		      adc	#0
     70  2715		       85 42		      sta	VARIABLES+1
     71  2717		       20 ac 29 	      jsr	ContextSave
     72  271a		       4c df 26 	      jmp	taskSetLoop
     73  271d
     74  271d				   taskSetDone
     75  271d		       a0 00		      ldy	#0	; reload the main loop context
     76  271f		       20 bb 29 	      jsr	ContextLoad
     77  2722		       60		      rts
     78  2723							;
     79  2723							;============================================================
     80  2723							; Saves the io block to the context
     81  2723
     82  2723
     83  2723		       98	   SaveIOblock tya
     84  2724		       48		      pha
     85  2725		       8a		      txa
     86  2726		       48		      pha
     87  2727
     88  2727
     89  2727
     90  2727		       68		      pla
     91  2728		       aa		      tax
     92  2729		       68		      pla
     93  272a		       a8		      tay
     94  272b		       60		      rts
     95  272c
     96  272c							;
     97  272c							;=====================================================
     98  272c							; In some error cases the math stacks may be left pointing to the wrong stack
     99  272c							; This function will reset those stack addresses but not the actual pointer
    100  272c				   taskResetStacks
    101  272c		       a0 00		      ldy	#0
    102  272e		       20 bb 29 	      jsr	ContextLoad
    103  2731		       4c b8 26 	      jmp	taskSetStacks
    104  2734							;
    105  2734							;=====================================================
    106  2734							; Clear all task entries and task stacks
    107  2734		       98	   taskReset  tya		; Save Y
    108  2735		       48		      pha
    109  2736		       a9 01		      lda	#1
    110  2738		       8d a2 38 	      sta	taskCounter	; Set number of active tasks to 1
    111  273b		       ac a3 37 	      ldy	taskPtr	; Set the active task to 0 MAIN
    112  273e		       c0 00		      cpy	#0	; check if we are the main context
    113  2740		       f0 08		      beq	taskResetCont	; if we are just continue
    114  2742
    115  2742		       a0 00		      ldy	#0	; else we need to switch to the main context
    116  2744		       8c a3 37 	      sty	taskPtr
    117  2747		       20 bb 29 	      jsr	ContextLoad	; load the System Task context
    118  274a				   taskResetCont
    119  274a		       a0 19		      ldy	#CONTEXTLEN	; Start at the second task +1 account for task control byte
    120  274c
    121  274c				   taskResetLoop
    122  274c		       a9 00		      lda	#TASKINACTIVE
    123  274e		       99 a4 37 	      sta	taskTable,y	; Ensure that the task is made inactive
    124  2751		       18		      clc
    125  2752		       98		      tya
    126  2753		       69 19		      adc	#CONTEXTLEN
    127  2755		       a8		      tay
    128  2756		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    129  2758		       90 f2		      bcc	taskResetLoop	; Go for more
    130  275a
    131  275a				   taskResetComplete
    132  275a
    133  275a		       68		      pla		; Restore y
    134  275b		       a8		      tay
    135  275c		       60		      rts
    136  275d
    137  275d							;
    138  275d							;======================================================
    139  275d							; iTaskSwitch	 switch to new task if not interrupt and
    140  275d							;		 count is exceded for task time slice gets here
    141  275d							;		 when time slice has reached zero
    142  275d							;
    143  275d		       98	   iTaskSwitch tya
    144  275e		       48		      pha
    145  275f
    146  275f		       ad a0 38 	      lda	taskResetValue	; Always reset the counter value
    147  2762		       8d 9e 38 	      sta	taskCurrentCycles	; Update the counter with the new value
    148  2765		       ce 9f 38 	      dec	taskCurrentCycles+1	; dec high order byte
    149  2768		       d0 44		      bne	iTaskSwitchDone	; Exit if not zero
    150  276a
    151  276a		       ad a1 38 	      lda	taskResetValue+1
    152  276d		       8d 9f 38 	      sta	taskCurrentCycles+1
    153  2770
    154  2770		       ad 80 19 	      lda	IRQPending	; Skip this if we are processing an irq
    155  2773		       0d 16 44 	      ora	taskIOPending	; If set then don't switch
    156  2776		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    157  2778
    158  2778		       ad a2 38    iTaskMain  lda	taskCounter	; Number of tasks
    159  277b		       c9 01		      cmp	#1	; if there is only one task must be main
    160  277d		       d0 07		      bne	itasknext	; if it some other number continue to next
    161  277f
    162  277f		       ac a3 37 	      ldy	taskPtr	; check if we have not just ended some other task
    163  2782		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    164  2784		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    165  2786							;
    166  2786							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    167  2786							;
    168  2786				   itasknext
    169  2786		       ac a3 37 	      ldy	taskPtr
    170  2789		       20 ac 29 	      jsr	ContextSave	; Save the current context, y points to next context
    171  278c				   itaskLoop
    172  278c		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    173  278e		       90 04		      bcc	iTaskNextChk
    174  2790
    175  2790		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    176  2792		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    177  2794
    178  2794				   iTaskNextChk
    179  2794		       b9 a4 37 	      lda	taskTable,y	; there is always at least one entry in table
    180  2797		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    181  2799		       18	   iTaskNext  clc
    182  279a		       98		      tya
    183  279b		       69 19		      adc	#CONTEXTLEN	; Next Table entry
    184  279d		       a8		      tay
    185  279e		       4c 8c 27 	      jmp	itaskLoop	; Check for busy entry
    186  27a1
    187  27a1		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    188  27a3		       59 a4 37 	      eor	taskTable,y	; Check for anything waiting io
    189  27a6		       d0 f1		      bne	iTaskNext
    190  27a8		       20 bb 29 	      jsr	ContextLoad	; load the next context
    191  27ab		       8c a3 37 	      sty	taskPtr	; update the task pointer
    192  27ae
    193  27ae				   iTaskSwitchDone
    194  27ae		       68		      pla
    195  27af		       a8		      tay
    196  27b0		       60		      rts
    197  27b1							;
    198  27b1							;================================================================
    199  27b1							; Task Set task number to line number to start
    200  27b1							; on entry stack contains, type of line description and  memvector or linenumber
    201  27b1							; Task Table structure:
    202  27b1							;    byte 0	-   Active inactive
    203  27b1							;    byte 1-2	-   Basic code line pointer
    204  27b1							;    byte 3	-   Offset on current line
    205  27b1		       98	   iTaskSet   tya		;preserve Y
    206  27b2		       48		      pha		; push a
    207  27b3		       20 98 2d 	      jsr	popR1	; Get if compiled or line number expression
    208  27b6		       20 80 2d 	      jsr	popR0	; Get the line number to be saved
    209  27b9
    210  27b9
    211  27b9
    212  27b9		       ac a3 37 	      ldy	taskPtr	; find out where we are
    213  27bc		       20 ac 29 	      jsr	ContextSave	; Save the current context
    214  27bf
    215  27bf							;Find the pointer to the line we need to start at
    216  27bf		       a5 54		      lda	R1
    217  27c1		       f0 0b		      beq	iTaskLineNum
    218  27c3		       a5 52		      lda	R0
    219  27c5		       85 4f		      sta	CURPTR
    220  27c7		       a5 53		      lda	R0+1
    221  27c9		       85 50		      sta	CURPTR+1
    222  27cb		       4c de 27 	      jmp	iTaskCont
    223  27ce
    224  27ce				   iTaskLineNum
    225  27ce		       20 3a 2b 	      jsr	findLine	; Get the offset of the line to start task at
    226  27d1		       f0 0b		      beq	iTaskCont
    227  27d3
    228  27d3		       ac a3 37 	      ldy	taskPtr	; Restore the original Context Error Exit
    229  27d6		       20 bb 29 	      jsr	ContextLoad
    230  27d9
    231  27d9		       68		      pla		; pop a - exit
    232  27da		       a8		      tay
    233  27db		       4c e0 0d 	      jmp	iSetIrqErr	; Bad line number provided
    234  27de
    235  27de				   iTaskCont
    236  27de		       20 7e 29 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    237  27e1		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    238  27e3
    239  27e3		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    240  27e5		       99 a4 37 	      sta	taskTable,y	; new task as active
    241  27e8
    242  27e8		       a5 4f		      lda	CURPTR
    243  27ea		       48		      pha		; push a
    244  27eb		       a5 50		      lda	CURPTR+1
    245  27ed		       48		      pha		; push a
    246  27ee
    247  27ee		       20 bb 29 	      jsr	ContextLoad	; load the context of the new task
    248  27f1
    249  27f1		       68		      pla		; pop a
    250  27f2		       85 50		      sta	CURPTR+1
    251  27f4		       68		      pla		; pop a
    252  27f5		       85 4f		      sta	CURPTR
    253  27f7		       a9 03		      lda	#3	; Offset to first instruction
    254  27f9		       85 51		      sta	CUROFF
    255  27fb
    256  27fb		       a9 00		      lda	#0
    257  27fd		       85 47		      sta	ILSTACKPTR
    258  27ff		       85 4a		      sta	MATHSTACKPTR
    259  2801		       85 4d		      sta	GOSUBSTACKPTR
    260  2803		       a9 40		      lda	#GOSUBSTACKSIZE*4
    261  2805		       85 4e		      sta	MESSAGEPTR
    262  2807
    263  2807		       20 62 09 	      jsr	subVINIT	; Clear the variables
    264  280a
    265  280a		       a9 d7		      lda	#STMT&$FF
    266  280c		       85 43		      sta	ILPC
    267  280e		       a9 32		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    268  2810		       85 44		      sta	ILPC+1
    269  2812
    270  2812		       98		      tya		; Save the new context offset to return to user
    271  2813		       48		      pha		; push a
    272  2814
    273  2814		       20 ac 29    itaskSetSave jsr	ContextSave	; save the updated context
    274  2817		       ee a2 38 	      inc	taskCounter	; Update the number of Tasks running
    275  281a
    276  281a		       ac a3 37 	      ldy	taskPtr
    277  281d		       20 bb 29 	      jsr	ContextLoad	; restore the original context
    278  2820
    279  2820		       a9 00		      lda	#0	; Set the R0 upper to zero
    280  2822		       85 53		      sta	R0+1
    281  2824		       68		      pla		; Get the task pid we stored				 ; pop a
    282  2825		       85 52		      sta	R0	; Get the table entry value
    283  2827
    284  2827		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    285  2828		       a8		      tay
    286  2829
    287  2829		       4c 0a 07 	      jmp	pushR0nextIl	; Push R0 and continue
    288  282c				   iTaskNoEmpty
    289  282c		       ac a3 37 	      ldy	taskPtr
    290  282f		       20 bb 29 	      jsr	ContextLoad
    291  2832
    292  2832		       68		      pla		; pop a    -- exit
    293  2833		       a8		      tay
    294  2834
    295  2834		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    296  2836		       a9 00		      lda	#0
    297  2838		       4c 6a 06 	      jmp	iErr2
    298  283b							;
    299  283b							;===============================================================
    300  283b							; Run the task whos PID is on the stack, preserve the stack
    301  283b							;
    302  283b				   iTaskEnable
    303  283b		       98		      tya
    304  283c		       48		      pha
    305  283d		       20 98 2d 	      jsr	popR1
    306  2840		       20 66 2d 	      jsr	pushR1
    307  2843		       20 b2 2a 	      jsr	ipc_getcontext	; get context pointer into mq
    308  2846		       a0 00		      ldy	#0
    309  2848		       b1 56		      lda	(MQ),y
    310  284a		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    311  284c		       09 80		      ora	#TASKACTIVE
    312  284e		       91 56		      sta	(MQ),y
    313  2850		       68		      pla
    314  2851		       a8		      tay
    315  2852		       4c 9e 02 	      jmp	NextIL
    316  2855
    317  2855							;
    318  2855							;===============================================================
    319  2855							; Suspend the task whos PID  is on the stack, preserve the stack
    320  2855							;
    321  2855				   iTaskSuspend
    322  2855		       98		      tya
    323  2856		       48		      pha
    324  2857		       20 98 2d 	      jsr	popR1
    325  285a		       20 66 2d 	      jsr	pushR1
    326  285d		       20 b2 2a 	      jsr	ipc_getcontext	; get context pointer into mq
    327  2860		       a0 00		      ldy	#0
    328  2862		       b1 56		      lda	(MQ),y
    329  2864		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    330  2866		       09 80		      ora	#TASKACTIVE
    331  2868		       68		      pla
    332  2869		       a8		      tay
    333  286a		       4c 9e 02 	      jmp	NextIL
    334  286d
    335  286d							;================================================================
    336  286d							; Returns task Status
    337  286d				   iTaskStat
    338  286d		       98		      tya
    339  286e		       48		      pha
    340  286f		       20 81 28 	      jsr	iTaskValid	; returns pointer to task entry
    341  2872		       b9 a4 37 	      lda	taskTable,y
    342  2875		       f0 05		      beq	iTaskStatExit
    343  2877		       68		      pla
    344  2878		       a8		      tay
    345  2879		       4c 70 0d 	      jmp	iTruth
    346  287c				   iTaskStatExit
    347  287c		       68		      pla
    348  287d		       a8		      tay
    349  287e		       4c 79 0d 	      jmp	iFalse
    350  2881
    351  2881							;
    352  2881							;================================================================
    353  2881							; Validate the task number on top of the stack
    354  2881							; on exit y points to the requested task entry
    355  2881							;
    356  2881		       20 80 2d    iTaskValid jsr	popR0	; get result of the multiply
    357  2884		       a5 53		      lda	R0+1
    358  2886		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    359  2888		       a5 52		      lda	R0
    360  288a		       c9 fa		      cmp	#TASKTABLELEN
    361  288c		       90 09		      bcc	iTaskIsValid
    362  288e
    363  288e		       68	   iTaskValidErr pla		;remove return address
    364  288f		       68		      pla
    365  2890		       a2 10		      ldx	#ERR_INVALID_PID
    366  2892		       a9 00		      lda	#0
    367  2894		       4c 6a 06 	      jmp	iErr2
    368  2897
    369  2897		       a8	   iTaskIsValid tay
    370  2898		       60		      rts
    371  2899							;
    372  2899							;================================================================
    373  2899							; Kill a running task, do nothing if already stopped
    374  2899		       20 81 28    iTaskKill  jsr	iTaskValid
    375  289c		       a9 00		      lda	#0
    376  289e		       99 a4 37 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    377  28a1							;
    378  28a1							;================================================================
    379  28a1							;Skip to next task
    380  28a1				   iNTask
    381  28a1		       a9 01		      lda	#1
    382  28a3		       8d 9e 38 	      sta	taskCurrentCycles
    383  28a6		       8d 9f 38 	      sta	taskCurrentCycles+1
    384  28a9		       4c 9e 02 	      jmp	NextIL
    385  28ac							;
    386  28ac							;=======================================================
    387  28ac							; Wait for a task to complete
    388  28ac				   iWTASK
    389  28ac		       20 f5 2a 	      jsr	getILByte
    390  28af		       8d 14 44 	      sta	offset
    391  28b2							;
    392  28b2		       20 d8 2c 	      jsr	saveIL	;in case of failure
    393  28b5
    394  28b5		       20 81 28 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    395  28b8		       b9 a4 37 	      lda	taskTable,y
    396  28bb		       d0 03		      bne	iWTASKWAIT
    397  28bd				   iWTASKEXITED
    398  28bd		       4c 9e 02 	      jmp	NextIL
    399  28c0				   iWTASKWAIT
    400  28c0		       20 ee 2c 	      jsr	pushR0	; Push R0 back onto the stack
    401  28c3		       a9 01		      lda	#1
    402  28c5		       8d 9e 38 	      sta	taskCurrentCycles	; Give up the cycles
    403  28c8		       8d 9f 38 	      sta	taskCurrentCycles+1
    404  28cb		       20 e3 2c 	      jsr	restoreIL
    405  28ce		       4c cd 0b 	      jmp	tstBranch
    406  28d1							;
    407  28d1							;=======================================================
    408  28d1							; Set task io lock
    409  28d1		       ee 16 44    iStartIO   inc	taskIOPending
    410  28d4		       4c 9e 02 	      jmp	NextIL
    411  28d7							;
    412  28d7							;=======================================================
    413  28d7							; Release the io lock
    414  28d7		       ad 16 44    iEndIO     lda	taskIOPending
    415  28da		       f0 03		      beq	iEndIOExit
    416  28dc		       ce 16 44 	      dec	taskIOPending
    417  28df		       4c 9e 02    iEndIOExit jmp	NextIL
    418  28e2							;
    419  28e2							;===============================================================
    420  28e2							; Return the task PID
    421  28e2				   iTASKPID
    422  28e2		       a9 00		      lda	#0
    423  28e4		       85 53		      sta	R0+1
    424  28e6		       ad a3 37 	      lda	taskPtr
    425  28e9		       85 52		      sta	R0
    426  28eb		       4c 0a 07 	      jmp	pushR0nextIl
    427  28ee							;
    428  28ee							;================================================================
    429  28ee							; Terminate a task
    430  28ee		       ac a3 37    iETask     ldy	taskPtr
    431  28f1		       c0 00		      cpy	#0
    432  28f3		       d0 03		      bne	iETaskCont
    433  28f5		       4c ef 05 	      jmp	iFIN	; if the main task does a ETASK then stop
    434  28f8				   iETaskCont
    435  28f8		       a9 00		      lda	#TASKINACTIVE
    436  28fa		       99 a4 37 	      sta	taskTable,y	; mark entry as free
    437  28fd		       ce a2 38 	      dec	taskCounter	; reduce the number of active tasks
    438  2900		       a9 01		      lda	#1
    439  2902		       8d 9e 38 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    440  2905		       8d 9f 38 	      sta	taskCurrentCycles+1
    441  2908		       20 99 29 	      jsr	TaskSetExitCode
    442  290b				   iETaskExit
    443  290b		       4c 9e 02 	      jmp	NextIL
    444  290e							;================================================================
    445  290e							; make the current tasks math stack equal another tasks stack
    446  290e							; The task to get is stored on the math stack
    447  290e
    448  290e				   iTaskGetMathStack
    449  290e		       20 c1 2f 	      jsr	CopyStackR1	; Get the top of stack to R1
    450  2911		       20 b2 2a 	      jsr	ipc_getcontext	; MQ now has the context address
    451  2914		       a0 0a		      ldy	#MATHSTACKPTRPOS
    452  2916		       b1 56		      lda	(MQ),y
    453  2918		       85 4a		      sta	MATHSTACKPTR
    454  291a		       a0 08		      ldy	#MATHSTACKPOS
    455  291c		       b1 56		      lda	(MQ),y
    456  291e		       85 48		      sta	MATHSTACK
    457  2920		       c8		      iny
    458  2921		       b1 56		      lda	(MQ),y
    459  2923		       85 49		      sta	MATHSTACK+1
    460  2925		       4c 9e 02 	      jmp	NextIL
    461  2928							;==================================================================
    462  2928							; Updates the tasks math stack pointer with contents of R2
    463  2928							; PID is on top of the stack
    464  2928				   iTaskPutMathPtr
    465  2928		       20 c1 2f 	      jsr	CopyStackR1	; Get the top of stack to R1
    466  292b		       20 b2 2a 	      jsr	ipc_getcontext	; MQ now has the context address
    467  292e		       a5 58		      lda	R2	; R2 contains the number of parameters/offset
    468  2930		       a0 0a		      ldy	#MATHSTACKPTRPOS	; Pointer to new tasks stack pointer
    469  2932		       91 56		      sta	(MQ),y	; update it to point to the free space on stack
    470  2934							;if parm count > 0 then we need to create a parameter block on the tasks gosubStack
    471  2934		       c9 00		      cmp	#0	; if no parameters then
    472  2936		       f0 26		      beq	iTaskPutMathPtrExit	; just get out of here
    473  2938
    474  2938		       a0 0b		      ldy	#GOSUBSTKPOS
    475  293a		       b1 56		      lda	(MQ),y	; get the address of the new tasks gosub stack into R1
    476  293c		       85 54		      sta	R1
    477  293e		       c8		      iny
    478  293f		       b1 56		      lda	(MQ),y
    479  2941		       85 55		      sta	R1+1
    480  2943
    481  2943		       a9 00		      lda	#0	; Store the math stack offset into new gosub stack, always 0
    482  2945		       91 54		      sta	(R1),y
    483  2947
    484  2947		       c8		      iny
    485  2948		       18		      clc		; We need to turn stack ptr to actual parm count
    486  2949		       e9 01		      sbc	#1	; Stack pointer always point to next free byte
    487  294b		       0a		      asl
    488  294c		       91 54		      sta	(R1),y
    489  294e
    490  294e		       c8		      iny
    491  294f		       a9 ff		      lda	#$FF	; Dummy field, not used
    492  2951		       91 54		      sta	(R1),y
    493  2953		       c8		      iny
    494  2954		       a9 05		      lda	#GOSUB_STACK_FRAME	; Tell its a stack frame, ie identify param cnt etc
    495  2956		       91 54		      sta	(R1),y
    496  2958		       c8		      iny
    497  2959		       98		      tya
    498  295a		       a0 0d		      ldy	#GOSUBPTRPOS
    499  295c		       91 56		      sta	(MQ),y	; update the new tasks gosub stk pointer
    500  295e
    501  295e				   iTaskPutMathPtrExit
    502  295e		       4c 9e 02 	      jmp	NextIL
    503  2961							;
    504  2961							;================================================================
    505  2961							; Set the time slice for each task
    506  2961				   iSLICE
    507  2961		       20 80 2d 	      jsr	popR0
    508  2964		       a5 52		      lda	R0
    509  2966		       8d a0 38 	      sta	taskResetValue
    510  2969		       a5 53		      lda	R0+1
    511  296b		       8d a1 38 	      sta	taskResetValue+1
    512  296e		       d0 0b		      bne	iSliceSet
    513  2970		       ee a1 38 	      inc	taskResetValue+1	; must be at least 1 high counter
    514  2973		       a9 01		      lda	#1
    515  2975		       8d 9e 38 	      sta	taskCurrentCycles
    516  2978		       8d 9f 38 	      sta	taskCurrentCycles+1
    517  297b				   iSliceSet
    518  297b		       4c 9e 02 	      jmp	NextIL
    519  297e							;================================================================
    520  297e							; Find an empty slot in the taskTable
    521  297e							; Return the index in y
    522  297e							; on exit   c set if an empty slot is found
    523  297e							;	     c clear if not found
    524  297e							;================================================================
    525  297e							;
    526  297e		       ad a2 38    TaskEmpty  lda	taskCounter
    527  2981		       c9 0a		      cmp	#TASKCOUNT
    528  2983		       b0 10		      bcs	TaskNoSlot
    529  2985		       a0 19		      ldy	#CONTEXTLEN	;The first slot is always the main line SKIP
    530  2987				   TaskLoop
    531  2987		       b9 a4 37 	      lda	taskTable,y
    532  298a		       f0 0b		      beq	TaskEmptyFnd
    533  298c		       98		      tya
    534  298d		       18		      clc
    535  298e		       69 19		      adc	#CONTEXTLEN
    536  2990		       a8		      tay
    537  2991		       c0 fa		      cpy	#TASKTABLELEN
    538  2993		       90 f2		      bcc	TaskLoop	; Y is never zero
    539  2995				   TaskNoSlot
    540  2995		       18		      clc
    541  2996		       60		      rts
    542  2997				   TaskEmptyFnd
    543  2997		       38		      sec
    544  2998		       60		      rts
    545  2999							;====================================================
    546  2999							; Set the task exit code called from the return command
    547  2999							; on entry stack top hold exit value
    548  2999				   TaskSetExitCode
    549  2999		       98		      tya
    550  299a		       48		      pha
    551  299b		       20 80 2d 	      jsr	popR0
    552  299e		       a0 48		      ldy	#TASKEXITCODE
    553  29a0		       a5 52		      lda	R0
    554  29a2		       91 41		      sta	(VARIABLES),y
    555  29a4		       c8		      iny
    556  29a5		       a5 53		      lda	R0+1
    557  29a7		       91 41		      sta	(VARIABLES),y
    558  29a9		       68		      pla
    559  29aa		       98		      tya
    560  29ab		       60		      rts
    561  29ac
    562  29ac							;
    563  29ac							;=====================================================
    564  29ac							; Save Context Store the context to the TASK Table
    565  29ac							; on entry y contains the task table entry to save to
    566  29ac							; on exit y points to next task table entry
    567  29ac							;	   x contains the number of bytes copied
    568  29ac		       a2 00	   ContextSave ldx	#0
    569  29ae		       c8		      iny		;inc past the task flags
    570  29af		       b5 41	   ContextSvLoop lda	CONTEXT,x
    571  29b1		       99 a4 37 	      sta	taskTable,y
    572  29b4		       c8		      iny
    573  29b5		       e8		      inx
    574  29b6		       e0 18		      cpx	#[CONTEXTLEN-1]
    575  29b8		       90 f5		      bcc	ContextSvLoop
    576  29ba		       60		      rts
    577  29bb							;
    578  29bb							; Load Context transfer context from task table to the Current Context
    579  29bb							; on entry y contains the task table entry to transfer
    580  29bb							; on exit y points to the original task table entry
    581  29bb							;	   x contains the number of bytes copied
    582  29bb		       98	   ContextLoad tya
    583  29bc		       48		      pha
    584  29bd		       a2 00		      ldx	#0
    585  29bf		       c8		      iny		;inc past the task flags
    586  29c0		       b9 a4 37    ContextLDLoop lda	taskTable,y
    587  29c3		       95 41		      sta	CONTEXT,x
    588  29c5		       c8		      iny
    589  29c6		       e8		      inx
    590  29c7		       e0 18		      cpx	#[CONTEXTLEN-1]
    591  29c9		       90 f5		      bcc	ContextLDLoop
    592  29cb		       68		      pla
    593  29cc		       a8		      tay
    594  29cd		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  29ce					      include	"ipc.asm"
      1  29ce							;======================================================
      2  29ce							; Inter process communications.
      3  29ce							; Tasks may write/read integer messages among
      4  29ce							; them selves.
      5  29ce							; This uses each tasks gosub stack as a message queue
      6  29ce							; Gosub calls start at the highest address and the
      7  29ce							; msg queue starts at the highest address.
      8  29ce							;
      9  29ce							;======================================================
     10  29ce							; ipcs   - Send msg to another task or many tasks
     11  29ce							; on entry  math stack contains the  top PID
     12  29ce							;				      2ND Message value
     13  29ce							; on exit   math stack contain top True-good or False-failed
     14  29ce							;
     15  29ce							; it may not be sent if queue is full
     16  29ce							;
     17  29ce							; a = ipcs(<message-expression>,<task PID-expression>)
     18  29ce							;
     19  29ce				   iIPCS
     20  29ce		       98		      tya
     21  29cf		       48		      pha
     22  29d0		       20 37 2a 	      jsr	ipc_enqueue
     23  29d3		       b0 08		      bcs	iIPC_BAD
     24  29d5		       20 b3 2f 	      jsr	pushTrue
     25  29d8		       68		      pla
     26  29d9		       a8		      tay
     27  29da		       4c 9e 02 	      jmp	NextIL
     28  29dd				   iIPC_BAD
     29  29dd		       68		      pla
     30  29de		       a8		      tay
     31  29df		       20 bd 2f 	      jsr	pushFalse
     32  29e2		       4c 9e 02 	      jmp	NextIL
     33  29e5
     34  29e5							;======================================================
     35  29e5							; ipcr   - Recieve msg from task
     36  29e5							; on exit  the message value is returned from message queue
     37  29e5							;	    message -1	is reserved meaning no entry found
     38  29e5							; The provided variable contains the pid of the sending
     39  29e5							; task. This is optional. This always waits for a message
     40  29e5							; before returning.
     41  29e5							;
     42  29e5							; a = ipcr(<variable name>)
     43  29e5							;
     44  29e5				   iIPCR
     45  29e5		       98		      tya
     46  29e6		       48		      pha
     47  29e7		       20 79 2a 	      jsr	ipc_dequeue
     48  29ea		       b0 05		      bcs	iIPCR_Q_Empty
     49  29ec		       68		      pla
     50  29ed		       a8		      tay
     51  29ee		       4c 9e 02 	      jmp	NextIL
     52  29f1				   iIPCR_Q_Empty
     53  29f1		       68		      pla
     54  29f2		       a8		      tay
     55  29f3		       20 b3 2f 	      jsr	pushTrue	; puts -1 on the stack
     56  29f6		       4c 9e 02 	      jmp	NextIL
     57  29f9
     58  29f9							;=======================================================
     59  29f9							; ipcc   - Check if message available
     60  29f9							; on exit  Stack contains number of messages
     61  29f9							;
     62  29f9							; a = ipcc()
     63  29f9							;
     64  29f9				   iIPCC
     65  29f9		       98		      tya
     66  29fa		       48		      pha
     67  29fb		       20 24 2a 	      jsr	ipc_queue_count
     68  29fe		       20 ee 2c 	      jsr	pushR0	; return the count
     69  2a01		       68		      pla
     70  2a02		       a8		      tay
     71  2a03		       4c 9e 02 	      jmp	NextIL
     72  2a06
     73  2a06							;=======================================================
     74  2a06							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  2a06				   iIPCIO
     76  2a06		       98		      tya
     77  2a07		       48		      pha
     78  2a08		       20 24 2a 	      jsr	ipc_queue_count
     79  2a0b		       a5 52		      lda	R0
     80  2a0d		       d0 10		      bne	iIPCIO_No_Halt
     81  2a0f		       a9 01		      lda	#1
     82  2a11		       8d 9e 38 	      sta	taskCurrentCycles	; force a task switch
     83  2a14		       a9 01		      lda	#TASKWAITIPC
     84  2a16		       ac a3 37 	      ldy	taskPtr
     85  2a19		       19 a4 37 	      ora	taskTable,y
     86  2a1c		       99 a4 37 	      sta	taskTable,y
     87  2a1f
     88  2a1f				   iIPCIO_No_Halt
     89  2a1f		       68		      pla
     90  2a20		       a8		      tay
     91  2a21		       4c 9e 02 	      jmp	NextIL
     92  2a24							;======================================================
     93  2a24							;ipc_queue_count returns number of entries on the queue
     94  2a24							; waiting to be recieved
     95  2a24							;======================================================
     96  2a24				   ipc_queue_count
     97  2a24		       a5 4e		      lda	MESSAGEPTR
     98  2a26		       18		      clc
     99  2a27		       4a		      lsr		; divide by 4
    100  2a28		       4a		      lsr
    101  2a29		       85 52		      sta	R0	; store into R0
    102  2a2b		       a9 10		      lda	#GOSUBSTACKSIZE
    103  2a2d		       38		      sec
    104  2a2e		       e5 52		      sbc	R0	; Get how many entries on queue
    105  2a30		       85 52		      sta	R0
    106  2a32		       a9 00		      lda	#0
    107  2a34		       85 53		      sta	R0+1
    108  2a36		       60		      rts
    109  2a37							;=======================================================
    110  2a37							; Support functions for messaging
    111  2a37							;
    112  2a37							; Enqueue message -> onto PID's MSG Q
    113  2a37							; on entry top of stack contains the PID
    114  2a37							;	    second contains the Message of the task
    115  2a37							; on exit contains c set if failed
    116  2a37							;		    c cleared if success
    117  2a37							;		    PID's MSG Q PTR points to the message
    118  2a37							;===========================================================
    119  2a37				   ipc_enqueue
    120  2a37		       20 98 2d 	      jsr	popR1	; Get the pid
    121  2a3a		       20 b2 2a 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    122  2a3d
    123  2a3d		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    124  2a3f		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    125  2a41		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    126  2a43		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    127  2a45		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    128  2a47
    129  2a47
    130  2a47							; Get the PID'S stack address into R0
    131  2a47		       a0 0b		      ldy	#GOSUBSTKPOS
    132  2a49		       b1 56		      lda	(MQ),y
    133  2a4b		       85 52		      sta	R0
    134  2a4d		       c8		      iny
    135  2a4e		       b1 56		      lda	(MQ),y
    136  2a50		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    137  2a52
    138  2a52							; Set y to point to the msg q entry
    139  2a52		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    140  2a54		       b1 56		      lda	(MQ),y	; Get the index
    141  2a56		       a8		      tay		; Set y to queue offset
    142  2a57
    143  2a57							; enqueue the message
    144  2a57		       88		      dey		; First byte to save to
    145  2a58		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    146  2a5a		       91 52		      sta	(R0),y	; Set the entry type
    147  2a5c
    148  2a5c		       88		      dey
    149  2a5d		       ad a3 37 	      lda	taskPtr	; Store the PID into queue
    150  2a60		       91 52		      sta	(R0),y
    151  2a62		       20 98 2d 	      jsr	popR1	; Get the actual message value
    152  2a65		       20 e6 2a 	      jsr	ipc_pushR1	; Store Message value into queue
    153  2a68
    154  2a68		       98		      tya		; Save the new q ptr
    155  2a69		       a0 0e		      ldy	#MSGPTRPOS
    156  2a6b		       91 56		      sta	(MQ),y	; Update the message stack pointer
    157  2a6d		       a0 00		      ldy	#0	; points to context root
    158  2a6f		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    159  2a71		       51 56		      eor	(MQ),y	; Turn off the bit
    160  2a73		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    161  2a75		       18		      clc
    162  2a76		       60		      rts
    163  2a77				   ipc_enq_full
    164  2a77		       38		      sec
    165  2a78		       60		      rts
    166  2a79							;=============================================================
    167  2a79							; De-queue for message stack -> local tasks msg q
    168  2a79							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    169  2a79							;  message into
    170  2a79							;  on exit   math stack contains value of message
    171  2a79							;				  Variable if provided is pid
    172  2a79				   ipc_dequeue
    173  2a79		       20 af 2d 	      jsr	popMQ	; Variable address to put PID into
    174  2a7c
    175  2a7c		       a4 4e		      ldy	MESSAGEPTR
    176  2a7e		       c0 38		      cpy	#[[GOSUBSTACKSIZE - 2] * 4]	; see if anything to pop from stack
    177  2a80		       b0 2e		      bcs	ipc_deq_empty
    178  2a82		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    179  2a84		       85 52		      sta	R0
    180  2a86		       c8		      iny
    181  2a87		       b1 4b		      lda	(GOSUBSTACK),y
    182  2a89		       85 53		      sta	R0+1
    183  2a8b		       c8		      iny
    184  2a8c		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    185  2a8e		       85 54		      sta	R1
    186  2a90		       c8		      iny
    187  2a91		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    188  2a93		       c8		      iny
    189  2a94		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    190  2a96
    191  2a96		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    192  2a98		       d0 16		      bne	ipc_deq_empty
    193  2a9a
    194  2a9a		       20 ee 2c 	      jsr	pushR0	; place value on stack
    195  2a9d
    196  2a9d		       a5 56		      lda	MQ
    197  2a9f		       05 57		      ora	MQ+1
    198  2aa1		       f0 0b		      beq	ipc_deq_done
    199  2aa3		       a5 54		      lda	R1
    200  2aa5		       a0 00		      ldy	#0
    201  2aa7		       91 56		      sta	(MQ),y
    202  2aa9		       c8		      iny
    203  2aaa		       a9 00		      lda	#0
    204  2aac		       91 56		      sta	(MQ),y
    205  2aae				   ipc_deq_done
    206  2aae		       18		      clc
    207  2aaf		       60		      rts
    208  2ab0
    209  2ab0				   ipc_deq_empty
    210  2ab0		       38		      sec
    211  2ab1		       60		      rts
    212  2ab2
    213  2ab2							;=============================================
    214  2ab2							;  Get the context address into MQ from R1 with
    215  2ab2							;  context/index/pid
    216  2ab2				   ipc_getcontext
    217  2ab2		       18		      clc		; Get pointer to Task context
    218  2ab3		       a9 a4		      lda	#taskTable&$FF	; change ptr to address
    219  2ab5		       65 54		      adc	R1
    220  2ab7		       85 56		      sta	MQ
    221  2ab9		       a9 37		      lda	#taskTable>>8
    222  2abb		       65 55		      adc	R1+1
    223  2abd		       85 57		      sta	MQ+1	; We now have a pointer into the context
    224  2abf		       60		      rts
    225  2ac0							;
    226  2ac0							;==============================================
    227  2ac0							; on entry R1 has a context value,
    228  2ac0							; on exit c is set if fails
    229  2ac0							;
    230  2ac0				   ipc_CONTEXTVALUES
      0  2ac0					      db	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      1  2ac0		       00 19 32 4b	      .byte.b	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      0  2ac4					      db	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      1  2ac4		       64 7d 96 af	      .byte.b	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      0  2ac8					      db	(CONTEXTLEN*8),(CONTEXTLEN*9)
      1  2ac8		       c8 e1		      .byte.b	(CONTEXTLEN*8),(CONTEXTLEN*9)
    234  2aca
    235  2aca				   ipc_ValidateContext
    236  2aca		       48		      pha
    237  2acb		       8a		      txa
    238  2acc		       48		      pha
    239  2acd		       a5 55		      lda	R1+1
    240  2acf		       d0 0e		      bne	ipc_Validate_Fail
    241  2ad1		       a2 00		      ldx	#0
    242  2ad3		       a5 54		      lda	R1
    243  2ad5				   ipc_ValidateLoop
    244  2ad5		       dd c0 2a 	      cmp	ipc_CONTEXTVALUES,x
    245  2ad8		       f0 09		      beq	ipc_Valid_Context
    246  2ada		       e8		      inx
    247  2adb		       e0 0a		      cpx	#TASKCOUNT
    248  2add		       90 f6		      bcc	ipc_ValidateLoop
    249  2adf
    250  2adf				   ipc_Validate_Fail
    251  2adf		       68		      pla
    252  2ae0		       aa		      tax
    253  2ae1		       68		      pla
    254  2ae2		       60		      rts
    255  2ae3
    256  2ae3				   ipc_Valid_Context
    257  2ae3		       18		      clc
    258  2ae4		       90 f9		      bcc	ipc_Validate_Fail
    259  2ae6							;
    260  2ae6							;==============================================
    261  2ae6							;Push R1 onto the stack
    262  2ae6							;on entry y = next entry
    263  2ae6							;R0 points to the stack space
    264  2ae6							;on exit y points to next free byte
    265  2ae6				   ipc_pushR1
    266  2ae6		       88		      dey
    267  2ae7		       a5 55		      lda	R1+1	; PID first
    268  2ae9		       91 52		      sta	(R0),y
    269  2aeb		       88		      dey
    270  2aec		       a5 54		      lda	R1
    271  2aee		       91 52		      sta	(R0),y
    272  2af0		       60		      rts
    273  2af1
    274  2af1
    275  2af1
    276  2af1
    277  2af1
    278  2af1
    279  2af1
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  2af1					      include	"support.asm"
      1  2af1							;
      2  2af1							;=====================================================
      3  2af1							;=====================================================
      4  2af1							;=====================================================
      5  2af1							; This marks the start of support functions used by
      6  2af1							; the IL opcodes.  These are support functions, NOT
      7  2af1							; the IL code.
      8  2af1							;=====================================================
      9  2af1							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  2af1							;=====================================================
     11  2af1					      Seg	Code
     12  2af1							;=====================================================
     13  2af1							; This gets the next two bytes pointed to by ILPC and
     14  2af1							; returns them; X contains LSB, A contains MSB.  ILPC
     15  2af1							; is advanced by two, and Y contains 0 on return.
     16  2af1
     17  2af1							;
     18  2af1		       20 f5 2a    getILWord  jsr	getILByte	;LSB
     19  2af4		       aa		      tax
     20  2af5							;
     21  2af5							;=====================================================
     22  2af5							; This gets the next byte pointed to by ILPC and
     23  2af5							; returns it in A.  On return, X is unchanged but Y
     24  2af5							; contains 0.
     25  2af5							;
     26  2af5		       a0 00	   getILByte  ldy	#0
     27  2af7		       b1 43		      lda	(ILPC),y	;get byte
     28  2af9		       08		      php		;save status
     29  2afa		       e6 43		      inc	ILPC	;inc LSB
     30  2afc		       d0 02		      bne	getILb2	;branch if no overflow
     31  2afe		       e6 44		      inc	ILPC+1	;inc MSB
     32  2b00		       28	   getILb2    plp		;restore status
     33  2b01		       60		      rts
     34  2b02							;
     35  2b02							;=====================================================
     36  2b02							; Decrement ILPC by one.
     37  2b02							;
     38  2b02		       a5 43	   decIL      lda	ILPC
     39  2b04		       d0 02		      bne	decIL2
     40  2b06		       c6 44		      dec	ILPC+1
     41  2b08		       c6 43	   decIL2     dec	ILPC
     42  2b0a		       60		      rts
     43  2b0b							;
     44  2b0b							;=====================================================
     45  2b0b							; Push the ILPC onto the return stack.  Actually, this
     46  2b0b							; pushes the address of ILPC+2 since that's the next
     47  2b0b							; address to execute.
     48  2b0b							;
     49  2b0b		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  2b0d		       c0 64		      cpy	#ILSTACKSIZE<<1
     51  2b0f		       b0 15		      bcs	pushErr
     52  2b11		       a5 43		      lda	ILPC
     53  2b13		       18		      clc
     54  2b14		       69 02		      adc	#2
     55  2b16		       91 45		      sta	(ILSTACK),y
     56  2b18		       08		      php		;save C bit
     57  2b19		       c8		      iny
     58  2b1a		       a5 44		      lda	ILPC+1
     59  2b1c		       28		      plp		;restore C
     60  2b1d		       69 00		      adc	#0
     61  2b1f		       91 45		      sta	(ILSTACK),y
     62  2b21		       c8		      iny
     63  2b22		       84 47		      sty	ILSTACKPTR
     64  2b24		       18		      clc
     65  2b25		       60		      rts
     66  2b26				   pushErr
     67  2b26		       38		      sec
     68  2b27		       60		      rts
     69  2b28							;
     70  2b28							;=====================================================
     71  2b28							; Pull the top entry from return stack and put into
     72  2b28							; ILPC.
     73  2b28							;
     74  2b28		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  2b2a		       f0 fa		      beq	pushErr
     76  2b2c		       88		      dey
     77  2b2d		       b1 45		      lda	(ILSTACK),y
     78  2b2f		       85 44		      sta	ILPC+1
     79  2b31		       88		      dey
     80  2b32		       b1 45		      lda	(ILSTACK),y
     81  2b34		       85 43		      sta	ILPC
     82  2b36		       84 47		      sty	ILSTACKPTR
     83  2b38		       18		      clc
     84  2b39		       60		      rts
     85  2b3a							;
     86  2b3a							;=====================================================
     87  2b3a							; This searches for a specific line number that is in
     88  2b3a							; R0.	There are three possible return conditions:
     89  2b3a							; Line numbers are now the third byte, the first byte is now
     90  2b3a							; a pointer to the next line, of course no longer than 255 byte
     91  2b3a							; per line.
     92  2b3a							;
     93  2b3a							; Exact match was found:
     94  2b3a							;    * Z set
     95  2b3a							;    * CURPTR points to two-byte line number for that
     96  2b3a							;	line.
     97  2b3a							;
     98  2b3a							; Next highest line found:
     99  2b3a							;    * Z cleared
    100  2b3a							;    * C set
    101  2b3a							;    * CURPTR points to two-byte line number for that
    102  2b3a							;	line.
    103  2b3a							;
    104  2b3a							; End of program reached:
    105  2b3a							;    * Z cleared
    106  2b3a							;    * C cleared
    107  2b3a							;    * CURPTR points to first free byte at end of
    108  2b3a							;	program.  Ie, it has save value as PROGRAMEND.
    109  2b3a							;
    110  2b3a							; A, X, and Y are all undefined on return.
    111  2b3a							;
    112  2b3a
    113  2b3a				   findLine
    114  2b3a		       ad 1c 44 	      lda	ProgramStart	;Start of program -> CURPTR
    115  2b3d		       85 4f		      sta	CURPTR
    116  2b3f		       ad 1d 44 	      lda	ProgramStart+1
    117  2b42		       85 50		      sta	CURPTR+1
    118  2b44							;
    119  2b44							; At end of code?
    120  2b44							;
    121  2b44				   iXFER1
    122  2b44		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  2b46		       cd 1e 44 	      cmp	ProgramEnd	; at end of program then stop run
    124  2b49		       d0 0b		      bne	xfer2	; not end
    125  2b4b		       a5 50		      lda	CURPTR+1
    126  2b4d		       cd 1f 44 	      cmp	ProgramEnd+1
    127  2b50		       d0 04		      bne	xfer2	;Not at end
    128  2b52							;
    129  2b52							; Line not found and the end of the program was
    130  2b52							; reached.  Return Z and C both clear.
    131  2b52							;
    132  2b52		       a9 01		      lda	#1	;clear Z
    133  2b54		       18		      clc		;clear C
    134  2b55		       60		      rts
    135  2b56							;
    136  2b56							; Check for an exact line number match
    137  2b56							;
    138  2b56		       a5 52	   xfer2      lda	R0
    139  2b58		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  2b5a		       d1 4f		      cmp	(CURPTR),y
    141  2b5c		       d0 08		      bne	xfernotit
    142  2b5e		       c8		      iny
    143  2b5f		       a5 53		      lda	R0+1
    144  2b61		       d1 4f		      cmp	(CURPTR),y
    145  2b63		       d0 01		      bne	xfernotit	; not a matching line number
    146  2b65							;
    147  2b65							; This is exactly the line we want.
    148  2b65							;
    149  2b65		       60		      rts		;it matches exactly
    150  2b66							;
    151  2b66							; See if this line is greater than the one we're
    152  2b66							; searching for.
    153  2b66							;
    154  2b66		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and least significat digit
    155  2b68		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  2b6a		       c5 53		      cmp	R0+1
    157  2b6c		       90 0b		      bcc	xfer3
    158  2b6e		       d0 07		      bne	xfer4
    159  2b70		       88		      dey
    160  2b71		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  2b73		       c5 52		      cmp	R0
    162  2b75		       90 02		      bcc	xfer3
    163  2b77							;
    164  2b77							; This line is greater than the one we want, so
    165  2b77							; return Z clear and C set.
    166  2b77							;
    167  2b77		       38	   xfer4      sec		;We found a line number greater
    168  2b78		       60		      rts		;both conditions set
    169  2b79							;
    170  2b79							; Not the line (or droid) we're looking for.  Move to
    171  2b79							; the next line.
    172  2b79							;
    173  2b79		       20 7f 2b    xfer3      jsr	FindNextLine
    174  2b7c		       4c 44 2b 	      jmp	iXFER1
    175  2b7f							;
    176  2b7f							;=====================================================
    177  2b7f							; This advances CURPTR to the next line.  If there
    178  2b7f							; are no more lines, this leaves CURPTR equal to
    179  2b7f							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  2b7f							; CURPTR is pointing to a valid line on entry.  This
    181  2b7f							; pointer points to the two-byte line number.
    182  2b7f							; Update this points to the 1 byte line length  ****************
    183  2b7f							;
    184  2b7f				   FindNextLine
    185  2b7f		       a0 03		      ldy	#3	;skip line number and length byte
    186  2b81		       84 51		      sty	CUROFF	;this is the new offset
    187  2b83		       a0 00		      ldy	#0
    188  2b85		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  2b87		       18		      clc
    190  2b88		       65 4f		      adc	CURPTR
    191  2b8a		       85 4f		      sta	CURPTR
    192  2b8c		       a5 50		      lda	CURPTR+1
    193  2b8e		       69 00		      adc	#0
    194  2b90		       85 50		      sta	CURPTR+1
    195  2b92		       60	   FindNext4  rts
    196  2b93							;
    197  2b93							;=====================================================
    198  2b93							; This compares CURPTR to PROGRAMEND and returns Z set
    199  2b93							; if they are equal, Z clear if not.
    200  2b93							;
    201  2b93		       a5 4f	   AtEnd      lda	CURPTR
    202  2b95		       cd 1e 44 	      cmp	ProgramEnd
    203  2b98		       d0 05		      bne	atendexit
    204  2b9a		       a5 50		      lda	CURPTR+1
    205  2b9c		       cd 1f 44 	      cmp	ProgramEnd+1
    206  2b9f		       60	   atendexit  rts
    207  2ba0							;
    208  2ba0
    209  2ba0							;
    210  2ba0							;=====================================================
    211  2ba0							; Convert an ASCII string to a number.  On input,
    212  2ba0							; (CURPTR),Y points to the first digit.  This gets
    213  2ba0							; digit-by-digit until finding a non-number.  Returns
    214  2ba0							; Y pointing to the non-digit, and R0 contains the
    215  2ba0							; number.  This does NOT check for valid ranges, so
    216  2ba0							; a value like "123456789" will produce something,
    217  2ba0							; but not what you had expected.
    218  2ba0							;
    219  2ba0		       a9 00	   getDecimal lda	#0
    220  2ba2		       85 52		      sta	R0
    221  2ba4		       85 53		      sta	R0+1
    222  2ba6		       85 59		      sta	dpl	;temporary negative flag
    223  2ba8							;
    224  2ba8							; See if it's negative...
    225  2ba8							;
    226  2ba8							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    227  2ba8		       b1 4f		      lda	(CURPTR),y
    228  2baa		       c9 2d		      cmp	#'-
    229  2bac		       d0 02		      bne	getDecLoop
    230  2bae		       e6 59		      inc	dpl	;it's negative
    231  2bb0							;
    232  2bb0		       b1 4f	   getDecLoop lda	(CURPTR),y
    233  2bb2		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    234  2bb4		       c9 30		      cmp	#'0
    235  2bb6		       90 36		      bcc	getDdone
    236  2bb8		       c9 3a		      cmp	#'9+1
    237  2bba		       b0 32		      bcs	getDdone
    238  2bbc		       38		      sec
    239  2bbd		       e9 30		      sbc	#'0	;convert to binary
    240  2bbf		       48		      pha
    241  2bc0							;
    242  2bc0							; Now multiply R0 by 10.  Remember that
    243  2bc0							; 2*N + 8*N = 10*N.
    244  2bc0							;
    245  2bc0		       06 52		      asl	R0
    246  2bc2		       26 53		      rol	R0+1	;*2
    247  2bc4		       a5 52		      lda	R0
    248  2bc6		       85 54		      sta	R1
    249  2bc8		       a5 53		      lda	R0+1
    250  2bca		       85 55		      sta	R1+1
    251  2bcc		       06 52		      asl	R0
    252  2bce		       26 53		      rol	R0+1	;*4
    253  2bd0		       06 52		      asl	R0
    254  2bd2		       26 53		      rol	R0+1	;*8
    255  2bd4		       18		      clc		;now add the partial sums...
    256  2bd5		       a5 52		      lda	R0	;...to get *10
    257  2bd7		       65 54		      adc	R1
    258  2bd9		       85 52		      sta	R0
    259  2bdb		       a5 53		      lda	R0+1
    260  2bdd		       65 55		      adc	R1+1
    261  2bdf		       85 53		      sta	R0+1
    262  2be1							;
    263  2be1							; Add in the new digit
    264  2be1							;
    265  2be1		       68		      pla
    266  2be2		       18		      clc
    267  2be3		       65 52		      adc	R0
    268  2be5		       85 52		      sta	R0
    269  2be7		       90 02		      bcc	getD2
    270  2be9		       e6 53		      inc	R0+1
    271  2beb							;
    272  2beb							; Move to next character
    273  2beb							;
    274  2beb		       c8	   getD2      iny
    275  2bec		       d0 c2		      bne	getDecLoop
    276  2bee							;
    277  2bee							; All done with digits, so now deal with it being
    278  2bee							; negative.  If zero, then don't check for negative
    279  2bee							; flag.  Ie, -0 is stored as 0.
    280  2bee							;
    281  2bee		       a5 52	   getDdone   lda	R0
    282  2bf0		       05 53		      ora	R0+1
    283  2bf2		       f0 16		      beq	getDone2	;zero
    284  2bf4		       a5 59		      lda	dpl
    285  2bf6		       f0 12		      beq	getDone2	;positive
    286  2bf8							;
    287  2bf8							; Invert all the bits, then add one.
    288  2bf8							;
    289  2bf8		       a5 52		      lda	R0
    290  2bfa		       49 ff		      eor	#$ff
    291  2bfc		       85 52		      sta	R0
    292  2bfe		       a5 53		      lda	R0+1
    293  2c00		       49 ff		      eor	#$ff
    294  2c02		       85 53		      sta	R0+1
    295  2c04							;
    296  2c04		       e6 52		      inc	R0
    297  2c06		       d0 02		      bne	getDone2
    298  2c08		       e6 53		      inc	R0+1
    299  2c0a				   getDone2
    300  2c0a							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    301  2c0a							;lda	  R0
    302  2c0a							;sta	  $0010
    303  2c0a							;lda	  R0+1
    304  2c0a							;sta	  $0011
    305  2c0a							;lda	  dpl
    306  2c0a							;sta	  $012
    307  2c0a
    308  2c0a		       60		      rts
    309  2c0b
    310  2c0b							;=====================================================
    311  2c0b							; Gets a line of input into LINBUF.
    312  2c0b							;
    313  2c0b							; On entry:
    314  2c0b							;    A contains the prompt character, or 0 if none.
    315  2c0b							;    X = 1 Background read
    316  2c0b							;    x = 0 Forground read with wait
    317  2c0b							;
    318  2c0b							; On exit:
    319  2c0b							;    CURPTR points to LINBUF
    320  2c0b							;    LINBUF contains the line with 0 at the end.
    321  2c0b							;    Y has offset to first non-space character
    322  2c0b							;    CURROFF has the same as Y.
    323  2c0b							;
    324  2c0b		       20 5a 2c    GetLine    jsr	ReadPrompt
    325  2c0e		       e0 00		      cpx	#0
    326  2c10		       f0 14		      beq	GetLineRetry
    327  2c12		       ae a3 37 	      ldx	taskPtr
    328  2c15		       bd a4 37 	      lda	taskTable,x
    329  2c18		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    330  2c1a		       d0 3d		      bne	taskWaitingIO
    331  2c1c		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    332  2c1e		       9d a4 37 	      sta	taskTable,x	;Mark the state for task as waiting io
    333  2c21		       ce 59 2c 	      dec	taskWaitingIO	;Start polling the input and make task wait
    334  2c24		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    335  2c26
    336  2c26							;
    337  2c26							; Now read a line and wait for the CR
    338  2c26							;
    339  2c26				   GetLineRetry
    340  2c26		       a9 00		      lda	#0	;Wait for input to complete
    341  2c28		       20 72 2c 	      jsr	ReadLine
    342  2c2b
    343  2c2b							;
    344  2c2b							; Point to the line we just read
    345  2c2b							; Set the current pointer to point to the input line
    346  2c2b							;
    347  2c2b		       a0 00	   ReadComplete ldy	#0
    348  2c2d		       84 51		      sty	CUROFF
    349  2c2f		       a2 7f		      ldx	#LINBUF&$ff
    350  2c31		       86 4f		      stx	CURPTR
    351  2c33		       a2 43		      ldx	#LINBUF>>8
    352  2c35		       86 50		      stx	CURPTR+1
    353  2c37							;
    354  2c37							; Output a CR/LF
    355  2c37							;
    356  2c37		       20 39 2e 	      jsr	CRLF
    357  2c3a							;
    358  2c3a							; If a blank line, prompt again.
    359  2c3a							;
    360  2c3a		       20 30 2e 	      jsr	SkipSpaces
    361  2c3d		       b1 4f		      lda	(CURPTR),y
    362  2c3f		       d0 10		      bne	GetLineDone	;We have data then exit
    363  2c41		       20 5d 2c 	      jsr	ReadPromptRetry
    364  2c44		       ae a3 37 	      ldx	taskPtr	;if this task is waiting for IO
    365  2c47		       bd a4 37 	      lda	taskTable,x	;then get out, wait for line to
    366  2c4a		       29 40		      and	#TASKWAITIO	;Complete again
    367  2c4c		       d0 0b		      bne	taskWaitingIO
    368  2c4e		       4c 26 2c 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    369  2c51
    370  2c51				   GetLineDone
    371  2c51		       ae a3 37 	      ldx	taskPtr
    372  2c54		       a9 80		      lda	#TASKACTIVE
    373  2c56		       9d a4 37 	      sta	taskTable,x	;IO is complete
    374  2c59
    375  2c59				   taskWaitingIO
    376  2c59		       60		      rts
    377  2c5a
    378  2c5a							;
    379  2c5a							;=======================================================================
    380  2c5a							; Display the prompt character
    381  2c5a							; On entry
    382  2c5a							;	    A contains the prompt character
    383  2c5a							; On exit
    384  2c5a							;	    The readbuffer index is reset to 0
    385  2c5a							;
    386  2c5a		       8d 06 44    ReadPrompt sta	promptChar
    387  2c5d
    388  2c5d							;
    389  2c5d							; Prompt
    390  2c5d							;
    391  2c5d
    392  2c5d		       ad 06 44    ReadPromptRetry lda	promptChar
    393  2c60		       09 00		      ora	#0	;any prompt?
    394  2c62		       f0 08		      beq	getlinenp
    395  2c64		       20 1d 1a 	      jsr	VOUTCH
    396  2c67		       a9 20		      lda	#$20
    397  2c69		       20 1d 1a 	      jsr	VOUTCH	;Space after prompt
    398  2c6c							;
    399  2c6c		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    400  2c6e		       8e 03 44 	      stx	getlinx
    401  2c71		       60		      rts
    402  2c72							;
    403  2c72							;===============================================================
    404  2c72							; This fuction is the driver for the line input
    405  2c72							; on call if a = 0 then it waits for all input
    406  2c72							;	      a = 1 then nowait for input
    407  2c72							; On exit
    408  2c72							;		       c clear if not complete line
    409  2c72							;		       c set if it was a complete line
    410  2c72
    411  2c72				   ReadLine
    412  2c72		       8d 05 44 	      sta	inputNoWait
    413  2c75		       c9 00		      cmp	#0
    414  2c77		       f0 05		      beq	getline1
    415  2c79		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    416  2c7c		       f0 2b		      beq	GetLineNoWait
    417  2c7e		       20 20 1a    getline1   jsr	VGETCH
    418  2c81					      if	CTMON65
    419  2c81		       48		      pha
    420  2c82		       20 1d 1a 	      jsr	VOUTCH	;echo echo echo
    421  2c85		       68		      pla
    422  2c86					      endif
    423  2c86		       c9 0d		      cmp	#CR
    424  2c88		       f0 15		      beq	getlind	;end of line
    425  2c8a		       c9 08		      cmp	#BS	;backspace?
    426  2c8c		       f0 1d		      beq	getlinebs
    427  2c8e		       ae 03 44 	      ldx	getlinx
    428  2c91		       9d 7f 43 	      sta	LINBUF,x
    429  2c94		       e8		      inx
    430  2c95		       8e 03 44 	      stx	getlinx
    431  2c98		       ad 05 44 	      lda	inputNoWait
    432  2c9b		       f0 e1		      beq	getline1
    433  2c9d		       d0 0a		      bne	GetLineNoWait
    434  2c9f							;
    435  2c9f							; CR was hit
    436  2c9f							;
    437  2c9f		       a9 00	   getlind    lda	#0	; set the end pf buffer
    438  2ca1		       ae 03 44 	      ldx	getlinx
    439  2ca4		       9d 7f 43 	      sta	LINBUF,x
    440  2ca7
    441  2ca7		       38		      sec		; Carry set then cr received
    442  2ca8		       60		      rts
    443  2ca9
    444  2ca9				   GetLineNoWait
    445  2ca9		       18		      clc		; Carry clear no end of line
    446  2caa		       60		      rts
    447  2cab							;
    448  2cab							; Backspace was hit
    449  2cab							;
    450  2cab		       ae 03 44    getlinebs  ldx	getlinx
    451  2cae		       f0 0e		      beq	getlineEOL	;at start of line
    452  2cb0		       ca		      dex
    453  2cb1		       8e 03 44 	      stx	getlinx
    454  2cb4		       20 80 21    getlinepbs jsr	puts
      0  2cb7					      db	27,"[K",0
      1  2cb7		       1b 5b 4b 00	      .byte.b	27,"[K",0
    456  2cbb		       4c 7e 2c 	      jmp	getline1
    457  2cbe		       a9 20	   getlineEOL lda	#SPACE
    458  2cc0		       20 1d 1a 	      jsr	VOUTCH
    459  2cc3		       d0 ef		      bne	getlinepbs
    460  2cc5							;
    461  2cc5							;=====================================================
    462  2cc5							; Count the length of the line currently in LINBUF
    463  2cc5							; starting at offset Y.  Returns the length in X.  The
    464  2cc5							; starting offset in Y should point past the ASCII
    465  2cc5							; line number.  Also counts the trailing NULL and two
    466  2cc5							; extra bytes for where the line number will be.
    467  2cc5							; Update must now include leading length byte not the null at end ****************
    468  2cc5							;
    469  2cc5				   getLineLength
    470  2cc5		       a2 00		      ldx	#0	;size
    471  2cc7		       b9 7f 43    getLineL2  lda	LINBUF,y
    472  2cca		       f0 04		      beq	getLineL3
    473  2ccc		       c8		      iny
    474  2ccd		       e8		      inx
    475  2cce		       d0 f7		      bne	getLineL2
    476  2cd0		       e8	   getLineL3  inx		;count null at end
    477  2cd1		       e8		      inx		;line number LSB
    478  2cd2		       e8		      inx		;MSB
    479  2cd3		       e8		      inx		;change: count new leading line length
    480  2cd4		       8e 15 44 	      stx	lineLength
    481  2cd7		       60		      rts
    482  2cd8							;
    483  2cd8							;=====================================================
    484  2cd8							; Count the length of the line pointed to by CURPTR.
    485  2cd8							; This also counts the line number and the terminating
    486  2cd8							; null.  Ie, this string returns 8:
    487  2cd8							;
    488  2cd8							; <lineLow><lineHi>Hello<null>
    489  2cd8							;
    490  2cd8							; Another way of looking at it: add the return value
    491  2cd8							; to the CURPTR and it'll point to the next line's
    492  2cd8							; line number.  Returns the value in Y.
    493  2cd8							; Update to ject get the leading byte length ********************
    494  2cd8							;
    495  2cd8							;getCURPTRLength
    496  2cd8							;		ldy	CURPTR
    497  2cd8							;		ldy	#3	;change: skip line number and leading length byte
    498  2cd8							;getCLineL2	lda	(CURPTR),y
    499  2cd8							;		beq	getCLineL3
    500  2cd8							;		iny
    501  2cd8							;		bne	getCLineL2
    502  2cd8							;getCLineL3	iny		;count null at end
    503  2cd8							;		rts
    504  2cd8
    505  2cd8							;
    506  2cd8							;=====================================================
    507  2cd8							; This saves ILPC.  This saves to a single save area,
    508  2cd8							; so it can't be called more than once.
    509  2cd8							;
    510  2cd8		       a5 43	   saveIL     lda	ILPC
    511  2cda		       8d 11 44 	      sta	tempIL
    512  2cdd		       a5 44		      lda	ILPC+1
    513  2cdf		       8d 12 44 	      sta	tempIL+1
    514  2ce2		       60		      rts
    515  2ce3							;
    516  2ce3							;=====================================================
    517  2ce3							; This restores ILPC.
    518  2ce3							;
    519  2ce3		       ad 11 44    restoreIL  lda	tempIL
    520  2ce6		       85 43		      sta	ILPC
    521  2ce8		       ad 12 44 	      lda	tempIL+1
    522  2ceb		       85 44		      sta	ILPC+1
    523  2ced		       60		      rts
    524  2cee							;
    525  2cee							;=====================================================
    526  2cee							; This pushes R0 onto the stack.
    527  2cee							;
    528  2cee		       8c 0c 44    pushR0     sty	rtemp1
    529  2cf1		       a4 4a		      ldy	MATHSTACKPTR
    530  2cf3		       c0 28		      cpy	#MATHSTACKSIZE<<1
    531  2cf5		       b0 38		      bcs	pusherr
    532  2cf7		       a5 52		      lda	R0
    533  2cf9		       91 48		      sta	(MATHSTACK),y
    534  2cfb		       c8		      iny
    535  2cfc		       a5 53		      lda	R0+1
    536  2cfe		       91 48		      sta	(MATHSTACK),y
    537  2d00		       c8		      iny
    538  2d01		       84 4a		      sty	MATHSTACKPTR
    539  2d03		       ac 0c 44 	      ldy	rtemp1
    540  2d06		       18		      clc
    541  2d07		       60		      rts
    542  2d08
    543  2d08							;=====================================================
    544  2d08							; This pushes curptr basic current line onto the call stack.
    545  2d08							; and CUROFF. Also marks entry type as 1 = GOSUB
    546  2d08
    547  2d08				   pushLN
    548  2d08		       8d 0d 44 	      STA	rtemp1+1	; Store type of push being done
    549  2d0b		       8c 0c 44 	      sty	rtemp1
    550  2d0e		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    551  2d10		       c5 4d		      cmp	GOSUBSTACKPTR
    552  2d12		       90 1b		      bcc	pusherr	; No error
    553  2d14		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    554  2d16		       a2 00		      ldx	#0	; Start of bytes to copy
    555  2d18				   pushLoop
    556  2d18		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    557  2d1a		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    558  2d1c		       c8		      iny		; Next destination
    559  2d1d		       e8		      inx		; Next Source byte
    560  2d1e		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    561  2d20		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    562  2d22
    563  2d22		       ad 0d 44    pushDone   lda	rtemp1+1	; Type of stack entry
    564  2d25		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    565  2d27		       c8		      iny		; Next entry
    566  2d28
    567  2d28		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    568  2d2a		       ac 0c 44 	      ldy	rtemp1
    569  2d2d		       18		      clc
    570  2d2e		       60		      rts
    571  2d2f				   pusherr
    572  2d2f		       38		      sec
    573  2d30		       60		      rts
    574  2d31							;=====================================================
    575  2d31							; This pops Top Off gosub call Stack and
    576  2d31							; places it in CURPTR/CUROFF.
    577  2d31							; This checks if the type = 1 GOSUB
    578  2d31							; if not it removes what ever is on the stack
    579  2d31							; until it finds the next return. Allowing
    580  2d31							; a return from within a for/next
    581  2d31							; on exit a contains the type of return from, gosub_rtn, gosub_rtn_value....
    582  2d31		       8c 0c 44    popLN      sty	rtemp1
    583  2d34		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    584  2d36		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    585  2d38
    586  2d38				   popContinue
    587  2d38		       c0 04		      cpy	#4	; if less than 4 on stack then error
    588  2d3a		       90 22		      bcc	poperr	; Process an error
    589  2d3c
    590  2d3c		       88		      dey		; Position to read entry type
    591  2d3d		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    592  2d3f		       8d 0d 44 	      sta	rtemp1+1	; Save to be returned
    593  2d42		       c9 01		      cmp	#GOSUB_RTN	; Type is a gosub entry
    594  2d44		       f0 04		      beq	popLoop	; Restore the line
    595  2d46		       c9 81		      cmp	#GOSUB_RTN_VALUE	; Also restore the line
    596  2d48		       d0 16		      bne	popSkipEntry	; No then just skip this
    597  2d4a
    598  2d4a				   popLoop
    599  2d4a		       88		      dey
    600  2d4b		       ca		      dex
    601  2d4c		       b1 4b		      lda	(GOSUBSTACK),y
    602  2d4e		       95 4f		      sta	CURPTR,x
    603  2d50		       e0 00		      cpx	#0
    604  2d52		       d0 f6		      bne	popLoop	; Loop until all moved
    605  2d54
    606  2d54		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    607  2d56		       ac 0c 44 	      ldy	rtemp1
    608  2d59		       ad 0d 44 	      lda	rtemp1+1	; get the type of return
    609  2d5c		       18		      clc
    610  2d5d		       60		      rts
    611  2d5e
    612  2d5e		       38	   poperr     sec
    613  2d5f		       60		      rts
    614  2d60
    615  2d60		       88	   popSkipEntry dey
    616  2d61		       88		      dey
    617  2d62		       88		      dey
    618  2d63		       4c 38 2d 	      jmp	popContinue
    619  2d66
    620  2d66							;
    621  2d66							;=====================================================
    622  2d66							; This pushes R1 onto the stack
    623  2d66							;
    624  2d66		       8c 0c 44    pushR1     sty	rtemp1
    625  2d69		       a4 4a		      ldy	MATHSTACKPTR
    626  2d6b		       c0 28		      cpy	#MATHSTACKSIZE<<1
    627  2d6d		       b0 ef		      bcs	poperr
    628  2d6f		       a5 54		      lda	R1
    629  2d71		       91 48		      sta	(MATHSTACK),y
    630  2d73		       c8		      iny
    631  2d74		       a5 55		      lda	R1+1
    632  2d76		       91 48		      sta	(MATHSTACK),y
    633  2d78		       c8		      iny
    634  2d79		       84 4a		      sty	MATHSTACKPTR
    635  2d7b		       ac 0c 44 	      ldy	rtemp1
    636  2d7e		       18		      clc
    637  2d7f		       60		      rts
    638  2d80							;
    639  2d80							;=====================================================
    640  2d80							; This pops Top Of Stack and places it in R0.
    641  2d80							;
    642  2d80		       8c 0c 44    popR0      sty	rtemp1
    643  2d83		       a4 4a		      ldy	MATHSTACKPTR
    644  2d85		       f0 d7		      beq	poperr
    645  2d87		       88		      dey
    646  2d88		       b1 48		      lda	(MATHSTACK),y
    647  2d8a		       85 53		      sta	R0+1
    648  2d8c		       88		      dey
    649  2d8d		       b1 48		      lda	(MATHSTACK),y
    650  2d8f		       85 52		      sta	R0
    651  2d91		       84 4a		      sty	MATHSTACKPTR
    652  2d93		       ac 0c 44 	      ldy	rtemp1
    653  2d96		       18		      clc
    654  2d97		       60		      rts
    655  2d98
    656  2d98							;
    657  2d98							;=====================================================
    658  2d98							; This pops TOS and places it in R1.
    659  2d98							;
    660  2d98		       8c 0c 44    popR1      sty	rtemp1
    661  2d9b		       a4 4a		      ldy	MATHSTACKPTR
    662  2d9d		       f0 bf		      beq	poperr
    663  2d9f		       88		      dey
    664  2da0		       b1 48		      lda	(MATHSTACK),y
    665  2da2		       85 55		      sta	R1+1
    666  2da4		       88		      dey
    667  2da5		       b1 48		      lda	(MATHSTACK),y
    668  2da7		       85 54		      sta	R1
    669  2da9		       84 4a		      sty	MATHSTACKPTR
    670  2dab		       ac 0c 44 	      ldy	rtemp1
    671  2dae		       60		      rts
    672  2daf							;
    673  2daf							;=====================================================
    674  2daf							; This pops TOS and places it in MQ.
    675  2daf							;
    676  2daf		       8c 0c 44    popMQ      sty	rtemp1
    677  2db2		       a4 4a		      ldy	MATHSTACKPTR
    678  2db4		       f0 a8		      beq	poperr
    679  2db6		       88		      dey
    680  2db7		       b1 48		      lda	(MATHSTACK),y
    681  2db9		       85 57		      sta	MQ+1
    682  2dbb		       88		      dey
    683  2dbc		       b1 48		      lda	(MATHSTACK),y
    684  2dbe		       85 56		      sta	MQ
    685  2dc0		       84 4a		      sty	MATHSTACKPTR
    686  2dc2		       ac 0c 44 	      ldy	rtemp1
    687  2dc5		       60		      rts
    688  2dc6							;
    689  2dc6							;=====================================================
    690  2dc6							; This assists with multiplication and division by
    691  2dc6							; looking at R0 and R1 and saving a flag as to what
    692  2dc6							; sign the result will be.  Math is always done on
    693  2dc6							; positive numbers, so this converts negative numbers
    694  2dc6							; into positives.  On exit, R0 and R1 are both
    695  2dc6							; positive.  If the signs were different then 'signs'
    696  2dc6							; will be non-zero.
    697  2dc6							;
    698  2dc6		       a9 00	   SaveSigns  lda	#0
    699  2dc8		       8d 0b 44 	      sta	sign	;assume positive
    700  2dcb		       a5 53		      lda	R0+1	;MSB
    701  2dcd		       10 13		      bpl	SaveSigns1
    702  2dcf		       ee 0b 44 	      inc	sign	;it's negative
    703  2dd2		       49 ff		      eor	#$ff	;flip bits
    704  2dd4		       85 53		      sta	R0+1
    705  2dd6		       a5 52		      lda	R0
    706  2dd8		       49 ff		      eor	#$ff
    707  2dda		       85 52		      sta	R0
    708  2ddc		       e6 52		      inc	R0
    709  2dde		       d0 02		      bne	SaveSigns1
    710  2de0		       e6 53		      inc	R0+1
    711  2de2		       a5 55	   SaveSigns1 lda	R1+1
    712  2de4		       10 1a		      bpl	SaveSigns2
    713  2de6		       48		      pha
    714  2de7		       ad 0b 44 	      lda	sign
    715  2dea		       49 01		      eor	#1
    716  2dec		       8d 0b 44 	      sta	sign
    717  2def		       68		      pla
    718  2df0		       49 ff		      eor	#$ff	;flip bits
    719  2df2		       85 55		      sta	R1+1
    720  2df4		       a5 54		      lda	R1
    721  2df6		       49 ff		      eor	#$ff
    722  2df8		       85 54		      sta	R1
    723  2dfa		       e6 54		      inc	R1
    724  2dfc		       d0 02		      bne	SaveSigns2
    725  2dfe		       e6 55		      inc	R1+1
    726  2e00		       60	   SaveSigns2 rts
    727  2e01							;
    728  2e01							;=====================================================
    729  2e01							; This looks at the value of 'signs' and will convert
    730  2e01							; both R0 and R1 to negative if set.
    731  2e01							;
    732  2e01				   RestoreSigns
    733  2e01		       ad 0b 44 	      lda	sign
    734  2e04		       f0 28		      beq	restoresigns2
    735  2e06							;
    736  2e06		       a5 52		      lda	R0
    737  2e08		       d0 02		      bne	restoresigns3
    738  2e0a		       c6 53		      dec	R0+1
    739  2e0c				   restoresigns3
    740  2e0c		       c6 52		      dec	R0
    741  2e0e		       a5 52		      lda	R0
    742  2e10		       49 ff		      eor	#$ff
    743  2e12		       85 52		      sta	R0
    744  2e14		       a5 53		      lda	R0+1
    745  2e16		       49 ff		      eor	#$ff
    746  2e18		       85 53		      sta	R0+1
    747  2e1a							;
    748  2e1a		       a5 54		      lda	R1
    749  2e1c		       d0 02		      bne	restoresigns4
    750  2e1e		       c6 55		      dec	R1+1
    751  2e20				   restoresigns4
    752  2e20		       c6 54		      dec	R1
    753  2e22		       a5 54		      lda	R1
    754  2e24		       49 ff		      eor	#$ff
    755  2e26		       85 54		      sta	R1
    756  2e28		       a5 55		      lda	R1+1
    757  2e2a		       49 ff		      eor	#$ff
    758  2e2c		       85 55		      sta	R1+1
    759  2e2e							;
    760  2e2e				   restoresigns2
    761  2e2e		       60		      rts
    762  2e2f							;
    763  2e2f							;=====================================================
    764  2e2f							; Skip over spaces.  Returns Y with the offset to
    765  2e2f							; either the last character in the line, or the first
    766  2e2f							; non-space character.
    767  2e2f							;
    768  2e2f
    769  2e2f		       c8	   skipsp2    iny
    770  2e30		       b1 4f	   SkipSpaces lda	(CURPTR),y
    771  2e32		       f0 04		      beq	Skip3	;end of line
    772  2e34		       c9 20		      cmp	#SPACE
    773  2e36		       f0 f7		      beq	skipsp2
    774  2e38		       60	   Skip3      rts
    775  2e39							;*********************************************************
    776  2e39							; Output a CR/LF combination to the console.  Preserves
    777  2e39							; all registers.
    778  2e39							;
    779  2e39		       48	   tbcrlf     pha
    780  2e3a		       a9 0d		      lda	#CR
    781  2e3c		       20 1d 1a 	      jsr	VOUTCH
    782  2e3f		       a9 0a		      lda	#LF
    783  2e41		       20 1d 1a 	      jsr	VOUTCH
    784  2e44		       68		      pla
    785  2e45		       60		      rts
    786  2e46							;
    787  2e46							;=====================================================
    788  2e46							; Some logic to print the Line of basic code being executed
    789  2e46		       24 40	   idbgBasic  bit	ILTrace
    790  2e48		       50 77		      bvc	dbgBasicNone
    791  2e4a		       98		      tya
    792  2e4b		       48		      pha
    793  2e4c		       20 d6 2f 	      jsr	SetOutDebug
    794  2e4f
    795  2e4f		       a5 4f		      lda	CURPTR
    796  2e51		       85 59		      sta	dpl
    797  2e53		       a5 50		      lda	CURPTR+1
    798  2e55		       85 5a		      sta	dpl+1
    799  2e57
    800  2e57		       20 13 22 	      jsr	PrintProgramLine
    801  2e5a
    802  2e5a		       a5 40		      lda	ILTrace
    803  2e5c		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    804  2e5e		       f0 5c		      beq	dbgBasicDone
    805  2e60		       20 ed 2f 	      jsr	SetInDebug
    806  2e63		       20 80 21 	      jsr	puts
      0  2e66					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  2e66		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    808  2ea3				   dbgBasicLoop
    809  2ea3		       20 20 1a 	      jsr	VGETCH
    810  2ea6		       48		      pha
    811  2ea7		       20 39 2e 	      jsr	CRLF
    812  2eaa		       20 11 30 	      jsr	SetInDebugEnd
    813  2ead
    814  2ead		       68		      pla
    815  2eae				   dbgTestPoint
    816  2eae		       c9 73		      cmp	#'s	; Quit program
    817  2eb0		       f0 12		      beq	dbgBasicStop
    818  2eb2
    819  2eb2		       c9 64		      cmp	#'d	; Display Variables
    820  2eb4		       d0 06		      bne	dbgBasicDone
    821  2eb6
    822  2eb6		       20 db 21 	      jsr	PrintAllVars
    823  2eb9		       18		      clc
    824  2eba		       90 e7		      bcc	dbgBasicLoop	; Next char
    825  2ebc
    826  2ebc		       20 04 30    dbgBasicDone jsr	SetOutDebugEnd
    827  2ebf		       68		      pla
    828  2ec0		       a8		      tay
    829  2ec1		       4c 9e 02    dbgBasicNone jmp	NextIL
    830  2ec4
    831  2ec4				   dbgBasicStop
    832  2ec4		       20 04 30 	      jsr	SetOutDebugEnd
    833  2ec7		       68		      pla
    834  2ec8		       a8		      tay
    835  2ec9		       4c ef 05 	      jmp	iFIN
    836  2ecc							;
    837  2ecc							;=====================================================
    838  2ecc							; This is some debug logic which displays the current
    839  2ecc							; value of the ILPC and the line buffer.
    840  2ecc							;
    841  2ecc		       24 40	   dbgLine    bit	ILTrace
    842  2ece		       30 01		      bmi	dbgPrt
    843  2ed0		       60		      rts
    844  2ed1				   dbgPrt
    845  2ed1		       20 d6 2f 	      jsr	SetOutDebug
    846  2ed4		       20 80 21 	      jsr	puts
      0  2ed7					      db	"ILPC:",0
      1  2ed7		       49 4c 50 43*	      .byte.b	"ILPC:",0
    848  2edd		       a5 44		      lda	ILPC+1
    849  2edf		       20 63 21 	      jsr	OUTHEX
    850  2ee2		       a5 43		      lda	ILPC
    851  2ee4		       20 63 21 	      jsr	OUTHEX
    852  2ee7		       a9 20		      lda	#SPACE
    853  2ee9		       20 1d 1a 	      jsr	VOUTCH
    854  2eec
    855  2eec		       a0 00		      ldy	#0
    856  2eee		       b1 43		      lda	(ILPC),y	;Get the il pcode value
    857  2ef0					      if	IL_DEBUG_TEXT
    858  2ef0		       20 d3 18 	      jsr	PrintILText
    859  2ef3				  -	      else
    860  2ef3				  -	      jsr	OUTHEX
    861  2ef3					      endif
    862  2ef3		       20 80 21 	      jsr	puts
      0  2ef6					      db	" ILSP:",0
      1  2ef6		       20 49 4c 53*	      .byte.b	" ILSP:",0
    864  2efd		       a5 47		      lda	ILSTACKPTR
    865  2eff		       20 63 21 	      jsr	OUTHEX
    866  2f02		       a9 20		      lda	#SPACE
    867  2f04		       20 1d 1a 	      jsr	VOUTCH
    868  2f07
    869  2f07							; Display the CURPTR value and offset
    870  2f07							;
    871  2f07		       20 80 21 	      jsr	puts
      0  2f0a					      db	", CURPTR: ",0
      1  2f0a		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    873  2f15		       a5 50		      lda	CURPTR+1
    874  2f17		       20 63 21 	      jsr	OUTHEX
    875  2f1a		       a5 4f		      lda	CURPTR
    876  2f1c		       20 63 21 	      jsr	OUTHEX
    877  2f1f		       a9 2b		      lda	#'+
    878  2f21		       20 1d 1a 	      jsr	VOUTCH
    879  2f24		       a5 51		      lda	CUROFF
    880  2f26		       20 63 21 	      jsr	OUTHEX
    881  2f29							;
    882  2f29		       20 39 2e 	      jsr	CRLF
    883  2f2c		       20 04 30 	      jsr	SetOutDebugEnd
    884  2f2f		       20 62 2f 	      jsr	ILChkRange
    885  2f32		       b0 02		      bcs	dbgLineErr
    886  2f34		       18		      clc
    887  2f35		       60		      rts
    888  2f36
    889  2f36				   dbgLineErr
    890  2f36		       20 d6 2f 	      jsr	SetOutDebug
    891  2f39		       20 80 21 	      jsr	puts
      0  2f3c					      db	"Outside Valid IL Address Range",CR,LF,0
      1  2f3c		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    893  2f5d		       20 04 30 	      jsr	SetOutDebugEnd
    894  2f60		       38		      sec
    895  2f61		       60		      rts
    896  2f62
    897  2f62		       a5 44	   ILChkRange lda	ILPC+1
    898  2f64		       c9 32		      cmp	#IL>>8
    899  2f66		       90 18		      bcc	ILBadRange
    900  2f68		       d0 06		      bne	ILChkHigh
    901  2f6a
    902  2f6a		       a5 43		      lda	ILPC
    903  2f6c		       c9 c9		      cmp	#IL&$ff
    904  2f6e		       90 10		      bcc	ILBadRange
    905  2f70
    906  2f70		       a5 44	   ILChkHigh  lda	ILPC+1
    907  2f72		       c9 37		      cmp	#ILEND>>8
    908  2f74		       90 08		      bcc	ILGoodRange
    909  2f76		       d0 08		      bne	ILBadRange
    910  2f78
    911  2f78		       a5 43		      lda	ILPC
    912  2f7a		       c9 50		      cmp	#ILEND&$ff
    913  2f7c		       b0 02		      bcs	ILBadRange
    914  2f7e
    915  2f7e		       18	   ILGoodRange clc
    916  2f7f		       60		      rts
    917  2f80				   ILBadRange
    918  2f80		       38		      sec
    919  2f81		       60		      rts
    920  2f82
    921  2f82							;=====================================================
    922  2f82							; Set output vector to the console output function
    923  2f82							;
    924  2f82				   SetOutConsole
    925  2f82		       48		      pha
    926  2f83		       a9 0c		      lda	#OUTCH&$ff
    927  2f85		       8d 55 37 	      sta	BOutVec
    928  2f88		       a9 f0		      lda	#OUTCH>>8
    929  2f8a		       8d 56 37 	      sta	BOutVec+1
    930  2f8d		       68		      pla
    931  2f8e		       60		      rts
    932  2f8f
    933  2f8f				   SetInConsole
    934  2f8f		       48		      pha
    935  2f90		       a9 09		      lda	#GETCH&$ff
    936  2f92		       8d 53 37 	      sta	BInVec
    937  2f95		       a9 f0		      lda	#GETCH>>8
    938  2f97		       8d 54 37 	      sta	BInVec+1
    939  2f9a		       68		      pla
    940  2f9b		       60		      rts
    941  2f9c
    942  2f9c							;====================================================
    943  2f9c							;Clear the terminal assume it is ansii or vt100
    944  2f9c							;
    945  2f9c				   iCLEARSCREEN
    946  2f9c		       20 80 21 	      jsr	puts
      0  2f9f					      db	$1b,'[,'2,'J,$1b,'[,'1,';,'1,'H,$1b,'[,'?,'2,'5,'h,0
      1  2f9f		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,$1b,'[,'1,';,'1,'H,$1b,'[,'?,'2,'5,'h,0
    948  2fb0		       4c 9e 02 	      jmp	NextIL
    949  2fb3
    950  2fb3							;====================================================
    951  2fb3							; Push true and false onto math stack
    952  2fb3				   pushTrue
    953  2fb3		       a9 ff		      lda	#$ff
    954  2fb5		       85 52	   pushTF     sta	R0
    955  2fb7		       85 53		      sta	R0+1
    956  2fb9		       20 ee 2c 	      jsr	pushR0
    957  2fbc		       60		      rts
    958  2fbd		       a9 00	   pushFalse  lda	#0
    959  2fbf		       f0 f4		      beq	pushTF
    960  2fc1
    961  2fc1							;======================================================
    962  2fc1							; Copy stack top to R1
    963  2fc1				   CopyStackR1
    964  2fc1		       98		      tya
    965  2fc2		       48		      pha
    966  2fc3		       a4 4a		      ldy	MATHSTACKPTR
    967  2fc5		       88		      dey
    968  2fc6		       b1 48		      lda	(MATHSTACK),y
    969  2fc8		       85 55		      sta	R1+1
    970  2fca		       88		      dey
    971  2fcb		       b1 48		      lda	(MATHSTACK),y
    972  2fcd		       85 54		      sta	R1
    973  2fcf		       68		      pla
    974  2fd0		       a8		      tay
    975  2fd1		       60		      rts
    976  2fd2
    977  2fd2							;====================================================
    978  2fd2							;Swap the out debug call for standard calls
    979  2fd2		       00 00	   DebugIOSave ds	2
    980  2fd4		       00 00	   DebugInSave ds	2
    981  2fd6				   SetOutDebug
    982  2fd6		       ad 55 37 	      lda	BOutVec
    983  2fd9		       8d d2 2f 	      sta	DebugIOSave
    984  2fdc		       ad 56 37 	      lda	BOutVec+1
    985  2fdf		       8d d3 2f 	      sta	DebugIOSave+1
    986  2fe2		       a9 6a		      lda	#OUTDEBUG&$ff	; Put the Debug output
    987  2fe4		       8d 55 37 	      sta	BOutVec
    988  2fe7		       a9 30		      lda	#OUTDEBUG>>8
    989  2fe9		       8d 56 37 	      sta	BOutVec+1
    990  2fec		       60		      rts
    991  2fed				   SetInDebug
    992  2fed		       ad 53 37 	      lda	BInVec
    993  2ff0		       8d d4 2f 	      sta	DebugInSave
    994  2ff3		       ad 54 37 	      lda	BInVec+1
    995  2ff6		       8d d5 2f 	      sta	DebugInSave+1
    996  2ff9		       a9 6e		      lda	#INDEBUG&$ff
    997  2ffb		       8d 53 37 	      sta	BInVec
    998  2ffe		       a9 30		      lda	#INDEBUG>>8
    999  3000		       8d 54 37 	      sta	BInVec+1
   1000  3003		       60		      rts
   1001  3004				   SetOutDebugEnd
   1002  3004		       ad d2 2f 	      lda	DebugIOSave
   1003  3007		       8d 55 37 	      sta	BOutVec
   1004  300a		       ad d3 2f 	      lda	DebugIOSave+1
   1005  300d		       8d 56 37 	      sta	BOutVec+1
   1006  3010		       60		      rts
   1007  3011				   SetInDebugEnd
   1008  3011		       ad d4 2f 	      lda	DebugInSave
   1009  3014		       8d 53 37 	      sta	BInVec
   1010  3017		       ad d5 2f 	      lda	DebugInSave+1
   1011  301a		       8d 54 37 	      sta	BInVec+1
   1012  301d		       60		      rts
   1013  301e							;
   1014  301e							;====================================================
   1015  301e							; Set the input and output terminal address
   1016  301e							; The math stack stack byte is the output io slot
   1017  301e							; The math stack  is the input io slot
   1018  301e
   1019  301e				   iSetTerminal
   1020  301e		       20 80 2d 	      jsr	popR0	; Process the output io addresses
   1021  3021		       20 4b 30 	      jsr	CalcSlot
   1022  3024		       a5 52		      lda	R0
   1023  3026		       09 01		      ora	#1
   1024  3028		       8d 6b 30 	      sta	TerminalOutputPort
   1025  302b		       a5 53		      lda	R0+1
   1026  302d		       8d 6c 30 	      sta	TerminalOutputPort+1
   1027  3030
   1028  3030		       20 80 2d 	      jsr	popR0	; Process the input io address
   1029  3033		       20 4b 30 	      jsr	CalcSlot
   1030  3036		       a5 52		      lda	R0
   1031  3038		       8d 6f 30 	      sta	TerminalStatusPort
   1032  303b		       09 01		      ora	#1
   1033  303d		       8d 76 30 	      sta	TerminalInputPort
   1034  3040		       a5 53		      lda	R0+1
   1035  3042		       8d 77 30 	      sta	TerminalInputPort+1
   1036  3045		       8d 70 30 	      sta	TerminalStatusPort+1
   1037  3048		       4c 9e 02 	      jmp	NextIL
   1038  304b
   1039  304b							;===================================================
   1040  304b							; Calculate the slot address the the slot number
   1041  304b							; R0 contains the slot number 0-255
   1042  304b
   1043  304b				   CalcSlot
   1044  304b		       8a		      txa
   1045  304c		       48		      pha
   1046  304d
   1047  304d		       a2 04		      ldx	#4
   1048  304f				   CalcSlotLoop
   1049  304f		       18		      clc
   1050  3050		       26 52		      rol	R0
   1051  3052		       26 53		      rol	R0+1
   1052  3054		       ca		      dex
   1053  3055		       d0 f8		      bne	CalcSlotLoop
   1054  3057
   1055  3057		       a9 e0		      lda	#$E0
   1056  3059		       05 53		      ora	R0+1
   1057  305b		       85 53		      sta	R0+1
   1058  305d		       68		      pla
   1059  305e
   1060  305e		       aa		      tax
   1061  305f		       60		      rts
   1062  3060							;
   1063  3060							;====================================================
   1064  3060							; Output to the Terminal/Debug console
   1065  3060							;     x = high address byte
   1066  3060							;     y = low address byte
   1067  3060							;     a = Terminator for string
   1068  3060				   TerminalWrite
   1069  3060				   DebugWrite
   1070  3060		       20 d6 2f 	      jsr	SetOutDebug
   1071  3063		       20 be 21 	      jsr	PrtStr
   1072  3066		       20 04 30 	      jsr	SetOutDebugEnd
   1073  3069		       60		      rts
   1074  306a
   1075  306a				   TerminalIOblock
   1076  306a				   OUTDEBUG
   1077  306a		       8d		      .byte.b	$8D	; STA
   1078  306b				   TerminalOutputPort
   1079  306b		       21 e0	   DEBUGPORT  .word.w	$E021	; Dont check anything just output the byte
   1080  306d		       60		      RTS
   1081  306e
   1082  306e				   TerminalRead
   1083  306e				   INDEBUG
   1084  306e		       ad		      .byte.b	$AD	; LDA
   1085  306f				   TerminalStatusPort
   1086  306f		       20 e0	   DEBUGPORTSTATUS .word.w	$E020
   1087  3071
   1088  3071		       29 01		      and	#$01
   1089  3073		       f0 f9		      beq	INDEBUG
   1090  3075
   1091  3075		       ad		      .byte.b	$AD	; LDA
   1092  3076				   TerminalInputPort
   1093  3076		       21 e0	   DEBUGPORTIN .word.w	$E021
   1094  3078		       60		      rts
   1095  3079				   TerminalIOblockEnd
   1096  3079							;======================================================================
   1097  3079							;Copy Quoted string to buffer, terminate with 0 byte
   1098  3079							; R0  Source tring points to tString type
   1099  3079							; x is terminator
   1100  3079							; R1 points to destinition location
   1101  3079							; On exit R0 contains length of copy Plus Term and leading bytes
   1102  3079
   1103  3079				   qstrcpy
   1104  3079		       20 ee 2c 	      jsr	pushR0
   1105  307c		       20 c9 30 	      jsr	IncR0	; point past the tString
   1106  307f		       20 c9 30 	      jsr	IncR0	; Point Past the opening "
   1107  3082		       a2 22		      ldx	#'"	; copy Termination
   1108  3084		       20 9e 30 	      jsr	pstrcpy
   1109  3087		       20 c9 30 	      jsr	IncR0	; point to "
   1110  308a		       20 c9 30 	      jsr	IncR0	; Point to next free byte
   1111  308d		       20 98 2d 	      jsr	popR1
   1112  3090		       38		      sec
   1113  3091		       a5 52		      lda	R0
   1114  3093		       e5 54		      sbc	R1
   1115  3095		       85 52		      sta	R0
   1116  3097		       a5 53		      lda	R0+1
   1117  3099		       e5 55		      sbc	R1+1
   1118  309b		       85 53		      sta	R0+1
   1119  309d		       60		      rts
   1120  309e
   1121  309e							;=========================================================================
   1122  309e							;Copy string from R0 to R1, terminator in x
   1123  309e							; On exit    R0 contains the length of the copy
   1124  309e				   pstrcpy
   1125  309e		       a0 00		      ldy	#0
   1126  30a0		       86 58		      stx	R2
   1127  30a2
   1128  30a2				   strcpyLoop
   1129  30a2		       b1 52		      lda	(R0),y
   1130  30a4		       c5 58		      cmp	R2
   1131  30a6		       f0 0a		      beq	strcpyDone
   1132  30a8		       91 54		      sta	(R1),y
   1133  30aa		       20 c9 30 	      jsr	IncR0
   1134  30ad		       20 b7 30 	      jsr	IncR1
   1135  30b0		       90 f0		      bcc	strcpyLoop
   1136  30b2				   strcpyDone
   1137  30b2		       a9 00		      lda	#0
   1138  30b4		       91 54		      sta	(R1),y
   1139  30b6
   1140  30b6		       60		      rts
   1141  30b7
   1142  30b7							;=========================================================================
   1143  30b7							; on exit c is set on overflow
   1144  30b7				   IncR1
   1145  30b7		       48		      pha
   1146  30b8		       18		      clc
   1147  30b9		       a9 01		      lda	#1
   1148  30bb		       65 54		      adc	R1
   1149  30bd		       85 54		      sta	R1
   1150  30bf		       90 06		      bcc	IncR1Done
   1151  30c1		       a9 00		      lda	#0
   1152  30c3		       65 55		      adc	R1+1
   1153  30c5		       85 55		      sta	R1+1
   1154  30c7				   IncR1Done
   1155  30c7		       68		      pla
   1156  30c8		       60		      rts
   1157  30c9							;=========================================================================
   1158  30c9							; on exit c is set on overflow
   1159  30c9				   IncR0
   1160  30c9		       48		      pha
   1161  30ca		       18		      clc
   1162  30cb		       a9 01		      lda	#1
   1163  30cd		       65 52		      adc	R0
   1164  30cf		       85 52		      sta	R0
   1165  30d1		       90 06		      bcc	IncR0Done
   1166  30d3		       a9 00		      lda	#0
   1167  30d5		       65 53		      adc	R0+1
   1168  30d7		       85 53		      sta	R0+1
   1169  30d9				   IncR0Done
   1170  30d9		       68		      pla
   1171  30da		       60		      rts
------- FILE mytb.asm
   2477  30db
   2478  30db					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  30db					      include	"storage.asm"
      1  30db							;
      2  30db							;=====================================================
      3  30db							;=====================================================
      4  30db							;=====================================================
      5  30db							; This file contains the functions for saving and
      6  30db							; restoring programs from some sort of mass storage
      7  30db							; device.  This particular version is for using the
      8  30db							; Corsham Tech SD Card System.
      9  30db							;=====================================================
     10  30db							;=====================================================
     11  30db							;=====================================================
     12  30db
     13 U3761					      seg.u	TBData
     14 U3761		       00	   diskBufLength ds	1
     15 U3762		       00	   diskBufOffset ds	1
     16 U3763		       00 00 00 00*DiskFileName ds	64
     17 U37a3
     18  30db					      SEG	Code
     19  30db
     20  30db							;
     21  30db							;=====================================================
     22  30db							; Open a file for reading as a program.  The next
     23  30db							; thing on the line should be the filename.
     24  30db							;
     25  30db				   iOPENREAD
     26  30db					      if	XKIM || CTMON65
     27  30db		       20 f5 30 	      jsr	setFileName	;Set the file name to open
     28  30de		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     29  30e1		       90 07		      bcc	Ropenok	;branch if opened ok
     30  30e3							;
     31  30e3							; Open failed
     32  30e3							;
     33  30e3		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     34  30e5		       a9 00	   Rdfail2    lda	#0
     35  30e7		       4c 6a 06 	      jmp	iErr2
     36  30ea							;
     37  30ea							; Clear counts and offsets so the next read will
     38  30ea							; cause the file to be read.
     39  30ea							;
     40  30ea		       a9 00	   Ropenok    lda	#0
     41  30ec		       8d 62 37 	      sta	diskBufOffset
     42  30ef		       8d 61 37 	      sta	diskBufLength
     43  30f2		       4c 9e 02 	      jmp	NextIL
     44  30f5					      endif
     45  30f5
     46  30f5							;===============================================================
     47  30f5							; Set file name
     48  30f5				   setFileName
     49  30f5		       a4 51		      ldy	CUROFF
     50  30f7		       b1 4f		      lda	(CURPTR),y
     51  30f9		       c9 a0		      cmp	#tString	;Must be a quoted string
     52  30fb		       d0 24		      bne	setFileNameNotFound	;Must be a filename
     53  30fd
     54  30fd		       18		      clc
     55  30fe		       98		      tya
     56  30ff		       65 4f		      adc	CURPTR
     57  3101		       85 52		      sta	R0	;LSB
     58  3103		       a5 50		      lda	CURPTR+1
     59  3105		       69 00		      adc	#0
     60  3107		       85 53		      sta	R0+1
     61  3109		       a9 63		      lda	#DiskFileName&$ff
     62  310b		       85 54		      sta	R1
     63  310d		       a9 37		      lda	#DiskFileName>>8
     64  310f		       85 55		      sta	R1+1
     65  3111		       20 79 30 	      jsr	qstrcpy	; on exit R0 contains the total copy length index accross source not dest
     66  3114		       a5 52		      lda	R0
     67  3116		       18		      clc
     68  3117		       65 51		      adc	CUROFF	; add the current offset
     69  3119		       85 51		      sta	CUROFF	; Update the buffer pointer after complete
     70  311b				   ResetFileName
     71  311b		       a0 63		      ldy	#DiskFileName&$ff
     72  311d		       a2 37		      ldx	#DiskFileName>>8
     73  311f		       18		      clc
     74  3120		       60		      rts
     75  3121
     76  3121				   setFileNameNotFound
     77  3121		       68		      pla
     78  3122		       68		      pla		; remove the return address from the stack
     79  3123		       a9 00		      lda	#0
     80  3125		       a2 09		      ldx	#ERR_NO_FILENAME
     81  3127		       4c 6a 06 	      jmp	iErr2
     82  312a
     83  312a							;
     84  312a							;==============================JUSTLOSTINTIME 08/02/2022========
     85  312a							;Remove a file from the disk
     86  312a				   iRMFILE
     87  312a					      if	XKIM || CTMON65
     88  312a		       20 f5 30 	      jsr	setFileName
     89  312d		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     90  3130		       90 07		      bcc	wrmOk	;branch if removed ok
     91  3132		       a9 00		      lda	#0
     92  3134		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     93  3136		       4c 6a 06 	      jmp	iErr2
     94  3139				   wrmOk
     95  3139		       4c 9e 02 	      jmp	NextIL
     96  313c
     97  313c					      endif
     98  313c							;
     99  313c							;=====================================================
    100  313c				   iOPENWRITE
    101  313c					      if	XKIM || CTMON65
    102  313c		       20 f5 30 	      jsr	setFileName
    103  313f		       20 f5 2a 	      jsr	getILByte	;get the append or create byte
    104  3142		       c9 01		      cmp	#1	;create/truncate
    105  3144		       d0 06		      bne	iopencont
    106  3146		       20 1b 31 	      jsr	ResetFileName	;point back to the file name
    107  3149		       20 45 f0 	      jsr	DiskRmFile	;by default files opened for write are append
    108  314c
    109  314c				   iopencont
    110  314c		       20 1b 31 	      jsr	ResetFileName	;point back to the file name
    111  314f		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    112  3152		       90 07		      bcc	Wopenok	;branch if opened ok
    113  3154							;
    114  3154							; Open failed
    115  3154							;
    116  3154		       a9 00	   Wdfail     lda	#0
    117  3156		       a2 08		      ldx	#ERR_WRITE_FAIL
    118  3158		       4c 6a 06 	      jmp	iErr2
    119  315b							;
    120  315b		       4c 9e 02    Wopenok    jmp	NextIL
    121  315e					      endif
    122  315e							;
    123  315e							;=====================================================
    124  315e							; Gets a line of input from the disk file and puts it
    125  315e							; into LINBUF.
    126  315e							;
    127  315e							; On exit:
    128  315e							;    CURPTR points to LINBUF
    129  315e							;    LINBUF contains the line with 0 at the end.
    130  315e							;    Y has offset to first non-space character
    131  315e							;    CURROFF has the same as Y.
    132  315e							;
    133  315e				   iDGETLINE
    134  315e					      if	XKIM || CTMON65
    135  315e		       a2 7f		      ldx	#LINBUF&$ff
    136  3160		       86 4f		      stx	CURPTR
    137  3162		       a2 43		      ldx	#LINBUF>>8
    138  3164		       86 50		      stx	CURPTR+1
    139  3166							;
    140  3166		       a2 00		      ldx	#0	;offset
    141  3168		       8e 03 44    iDgetLoop  stx	getlinx
    142  316b		       20 d6 31 	      jsr	getNextFileByte
    143  316e		       b0 16		      bcs	iGetEOF
    144  3170		       c9 0d		      cmp	#CR
    145  3172		       f0 0d		      beq	iGetEOL
    146  3174		       c9 0a		      cmp	#LF
    147  3176		       f0 09		      beq	iGetEOL
    148  3178		       ae 03 44 	      ldx	getlinx
    149  317b		       9d 7f 43 	      sta	LINBUF,x
    150  317e		       e8		      inx
    151  317f		       d0 e7		      bne	iDgetLoop
    152  3181							;
    153  3181							; Handle end of line.	If the line has nothing, loop
    154  3181							; back and get another line.
    155  3181							;
    156  3181		       ae 03 44    iGetEOL    ldx	getlinx	;blank line?
    157  3184		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    158  3186							;
    159  3186							; This can fall through when there is a line, or
    160  3186							; called directly when EOF is encountered.
    161  3186							;
    162  3186		       ae 03 44    iGetEOF    ldx	getlinx
    163  3189		       a9 00		      lda	#0
    164  318b		       9d 7f 43 	      sta	LINBUF,x
    165  318e		       a0 00		      ldy	#0
    166  3190		       20 30 2e 	      jsr	SkipSpaces
    167  3193		       20 23 1d 	      jsr	ParseInputLine
    168  3196		       a9 20		      lda	#TOKENBUFFER&$ff
    169  3198		       85 4f		      sta	CURPTR
    170  319a		       a9 1c		      lda	#TOKENBUFFER>>8
    171  319c		       85 50		      sta	CURPTR+1
    172  319e		       a9 01		      lda	#1
    173  31a0		       85 51		      sta	CUROFF
    174  31a2		       4c 9e 02 	      jmp	NextIL
    175  31a5					      endif
    176  31a5
    177  31a5							;
    178  31a5							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    179  31a5							; DISK
    180  31a5							;
    181  31a5				   iDDIR
    182  31a5					      if	XKIM || CTMON65
    183  31a5		       20 30 f0 	      jsr	DiskDir
    184  31a8							;
    185  31a8							; Get/Display each entry
    186  31a8							;
    187  31a8		       a2 37	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    188  31aa		       a0 63		      ldy	#DiskFileName&$ff
    189  31ac		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    190  31af		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    191  31b1		       20 80 21 	      jsr	puts
      0  31b4					      db	"   ",0
      1  31b4		       20 20 20 00	      .byte.b	"   ",0
    193  31b8							; Print the line to the console
    194  31b8		       a2 37		      ldx	#DiskFileName>>8	;pointer to buffer
    195  31ba		       a0 63		      ldy	#DiskFileName&$ff
    196  31bc		       a5 00		      lda	0
    197  31be		       20 be 21 	      jsr	PrtStr	;else print name
    198  31c1		       20 18 f0 	      jsr	crlf
    199  31c4
    200  31c4		       4c a8 31 	      jmp	DiskDirLoop	;do next entry
    201  31c7
    202  31c7		       4c 9e 02    DiskDirEnd jmp	NextIL
    203  31ca					      endif
    204  31ca							;
    205  31ca							;=====================================================
    206  31ca							; Does a LIST to a Disk file.
    207  31ca							;
    208  31ca				   iDLIST
    209  31ca					      if	XKIM || CTMON65
    210  31ca		       20 05 32 	      jsr	SetOutDisk
    211  31cd		       4c 2a 08 	      jmp	iLST2
    212  31d0					      endif
    213  31d0							;
    214  31d0							;=====================================================
    215  31d0							; Closes any pending disk file.  Okay to call if there
    216  31d0							; is no open file.
    217  31d0							;
    218  31d0				   iDCLOSE
    219  31d0					      if	XKIM || CTMON65
    220  31d0		       20 42 f0 	      jsr	DiskClose
    221  31d3		       4c 9e 02 	      jmp	NextIL
    222  31d6					      endif
    223  31d6							;
    224  31d6							;=====================================================
    225  31d6							; This gets the next byte from an open disk file.  If
    226  31d6							; there are no more bytes left, this returns C set.
    227  31d6							; Else, C is clear and A contains the character.
    228  31d6							;
    229  31d6				   getNextFileByte
    230  31d6					      if	XKIM || CTMON65
    231  31d6		       ae 62 37 	      ldx	diskBufOffset
    232  31d9		       ec 61 37 	      cpx	diskBufLength
    233  31dc		       d0 14		      bne	hasdata	;branch if still data
    234  31de							;
    235  31de							; There is no data left in the buffer, so read a
    236  31de							; block from the SD system.
    237  31de							;
    238  31de		       a9 84		      lda	#BUFFER_SIZE
    239  31e0		       a2 df		      ldx	#buffer>>8
    240  31e2		       a0 0a		      ldy	#buffer&$ff
    241  31e4		       20 3c f0 	      jsr	DiskRead
    242  31e7		       b0 12		      bcs	getNextEof
    243  31e9							;
    244  31e9							; A contains the number of bytes actually read.
    245  31e9							;
    246  31e9		       8d 61 37 	      sta	diskBufLength	;save length
    247  31ec		       c9 00		      cmp	#0	;shouldn't happen
    248  31ee		       f0 0b		      beq	getNextEof
    249  31f0							;
    250  31f0		       a2 00		      ldx	#0
    251  31f2		       bd 0a df    hasdata    lda	buffer,x
    252  31f5		       e8		      inx
    253  31f6		       8e 62 37 	      stx	diskBufOffset
    254  31f9		       18		      clc
    255  31fa		       60		      rts
    256  31fb							;
    257  31fb		       a9 00	   getNextEof lda	#0
    258  31fd		       8d 62 37 	      sta	diskBufOffset
    259  3200		       8d 61 37 	      sta	diskBufLength
    260  3203		       38		      sec
    261  3204		       60		      rts
    262  3205							;
    263  3205							;=====================================================
    264  3205							; Set output vector to the disk output function
    265  3205							;
    266  3205		       a9 10	   SetOutDisk lda	#DOUT&$ff
    267  3207		       8d 55 37 	      sta	BOutVec
    268  320a		       a9 32		      lda	#DOUT/256
    269  320c		       8d 56 37 	      sta	BOutVec+1
    270  320f		       60		      rts
    271  3210							;
    272  3210							;=====================================================
    273  3210							; input a contains charater to write to open file
    274  3210							; output:
    275  3210							;	    C flag clear if no error
    276  3210							;
    277  3210		       8e 63 37    DOUT       stx	DiskFileName	; Save the x value, fulename not used
    278  3213		       8c 64 37 	      sty	DiskFileName+1	; Save the y value  filename not actually used
    279  3216		       8d 0a df 	      sta	buffer	; Store the byte to send into the buffer
    280  3219		       a9 01		      lda	#1	; set number of bytes to send to 1
    281  321b		       a0 0a		      ldy	#buffer&$ff	; Load the low order address of buffer to y
    282  321d		       a2 df		      ldx	#buffer>>8	; Load the high order address of buffer to x
    283  321f		       20 3f f0 	      jsr	DiskWrite	; Place the character to disk if a file is open
    284  3222		       ae 63 37 	      ldx	DiskFileName	; Restore the x value that was saved
    285  3225		       ac 64 37 	      ldy	DiskFileName+1	; Restore the y value saved
    286  3228		       60		      rts
    287  3229							;=======================================================
    288  3229							; output:
    289  3229							;	  c flag is clear if no error, a contains bytes read
    290  3229							;	  c flag set Reached eof, a undefined
    291  3229							;
    292  3229		       8e 63 37    DIN	      stx	DiskFileName	; Save the x value, filename not used just storage
    293  322c		       8c 64 37 	      sty	DiskFileName+1	; Save the y value  filename not actually used
    294  322f		       a9 01		      lda	#1	; set number of bytes to read to 1
    295  3231		       a0 0a		      ldy	#buffer&$ff	; Load the low order address of buffer to y
    296  3233		       a2 df		      ldx	#buffer>>8	; Load the high order address of buffer to x
    297  3235		       20 3c f0 	      jsr	DiskRead
    298  3238		       ad 0a df 	      lda	buffer	; Get the byte just read
    299  323b		       ae 63 37 	      ldx	DiskFileName
    300  323e		       ac 64 37 	      ldy	DiskFileName+1
    301  3241		       60		      rts
    302  3242
    303  3242							;========================================================
    304  3242							; Dstat / open/close/stat files
    305  3242				   DSTAT
    306  3242		       60		      rts
    307  3243							;========================================================
    308  3243					      endif
------- FILE mytb.asm
   2480  3243					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  3243					      include	"IL.inc"
      1  3243
      2  3243							;=====================================================
      3  3243							; IL.inc
      4  3243							; These are macros for IL instructions
      5  3243							;
      6  3243					      mac	dw
      7  3243					      .word	{0}
      8  3243					      endm
      9  3243					      mac	db
     10  3243					      .byte	{0}
     11  3243					      endm
     12  3243					      macro	xinit
     13  3243					      db	0
     14  3243					      endm		;reset the il to start clear all
     15  3243							;
     16  3243					      macro	done
     17  3243					      db	1
     18  3243					      endm		;print an error if not end of line
     19  3243							;
     20  3243					      macro	prs
     21  3243					      db	2
     22  3243					      endm		;print a quoted string
     23  3243							;
     24  3243					      macro	prn
     25  3243					      db	3
     26  3243					      endm		;print a number
     27  3243							;
     28  3243					      macro	spc
     29  3243					      db	4
     30  3243					      endm		;print space til new tabstop
     31  3243							;
     32  3243					      macro	nline
     33  3243					      db	5
     34  3243					      endm		;print a new line crlf
     35  3243							;
     36  3243							; My NXT is a bit different in that it takes one
     37  3243							; parameter, which is an address.  If the BASIC
     38  3243							; program is currently running then move to the
     39  3243							; next line and continue execution.  However, if
     40  3243							; in direct mode, jump to the specified IL label.
     41  3243							;
     42  3243					      macro	nxt
     43  3243					      db	6
     44  3243					      dw	{1}	; addr
     45  3243					      endm		; addr
     46  3243							;
     47  3243					      macro	xfer
     48  3243					      db	7
     49  3243					      endm
     50  3243							;
     51  3243					      macro	sav
     52  3243					      db	8
     53  3243					      db	{1}
     54  3243					      endm
     55  3243							;
     56  3243							;  Passed jump if function called, and true false value returned
     57  3243					      macro	rstr
     58  3243					      db	9
     59  3243					      db	({1}-*)-1	;(addr-*)-1
     60  3243					      db	{2}
     61  3243					      endm
     62  3243							;
     63  3243					      macro	cmpr
     64  3243					      db	10
     65  3243					      endm
     66  3243							;
     67  3243					      macro	innum
     68  3243					      db	11
     69  3243					      endm
     70  3243							;
     71  3243					      macro	fin
     72  3243					      db	12
     73  3243					      endm
     74  3243							;
     75  3243							; ERR is followed by an error number.	The error
     76  3243							; code is printed along with the line number.
     77  3243							; Control is passed to the statement set with
     78  3243							; the ERRGOTO statement.
     79  3243							;
     80  3243					      macro	errmsg
     81  3243					      db	13
     82  3243					      dw	{1}	;ecode
     83  3243					      endm		;ecode
     84  3243							;
     85  3243					      macro	add
     86  3243					      db	14
     87  3243					      endm
     88  3243							;
     89  3243					      macro	sub
     90  3243					      db	15
     91  3243					      endm
     92  3243							;
     93  3243					      macro	neg
     94  3243					      db	16
     95  3243					      endm
     96  3243							;
     97  3243					      macro	mul
     98  3243					      db	17
     99  3243					      endm
    100  3243							;
    101  3243					      macro	div
    102  3243					      db	18
    103  3243					      endm
    104  3243							;
    105  3243					      macro	store
    106  3243					      db	19
    107  3243					      endm
    108  3243							;
    109  3243					      macro	ind
    110  3243					      db	20
    111  3243					      endm
    112  3243							;
    113  3243					      macro	lst
    114  3243					      db	21
    115  3243					      endm
    116  3243							;
    117  3243					      macro	init
    118  3243					      db	22
    119  3243					      endm
    120  3243							;
    121  3243					      macro	getline
    122  3243					      db	23
    123  3243					      endm
    124  3243							;
    125  3243					      macro	insert
    126  3243					      db	24
    127  3243					      endm
    128  3243							;
    129  3243					      macro	rtn
    130  3243					      db	25
    131  3243					      endm
    132  3243							;
    133  3243					      macro	exit
    134  3243					      db	26
    135  3243					      endm
    136  3243							;
    137  3243					      macro	lit
    138  3243					      db	27
    139  3243					      dw	{1}	;value
    140  3243					      endm		; value LIT
    141  3243							;
    142  3243					      macro	call
    143  3243					      db	28
    144  3243					      dw	{1}	;addr
    145  3243					      endm		;addr
    146  3243							;
    147  3243							; IJMP will set the IL PC to the specified value.
    148  3243							;
    149  3243					      macro	ijmp
    150  3243					      db	29
    151  3243					      dw	{1}	;addr
    152  3243					      endm		;addr
    153  3243							;
    154  3243					      macro	vinit
    155  3243					      db	30
    156  3243					      endm
    157  3243							;
    158  3243							; ERRGOTO sets the point in the code where the IL
    159  3243							; interpreter will go after any error.
    160  3243							;
    161  3243					      macro	errgoto
    162  3243					      db	31
    163  3243					      dw	{1}	;addr
    164  3243					      endm		;addr
    165  3243							;
    166  3243					      macro	tst
    167  3243					      db	32
    168  3243					      db	({1}-*)-1	;(addr-*)-1
    169  3243					      db	{2},0	;string,0
    170  3243					      endm		;addr,string
    171  3243							;
    172  3243					      macro	tstv
    173  3243					      db	33
    174  3243					      db	({1}-*)-1	;(addr-*)-1
    175  3243					      endm		;addr
    176  3243							;
    177  3243					      macro	tstl
    178  3243					      db	34
    179  3243					      db	({1}-*)-1	;(addr-*)-1
    180  3243					      endm		;addr
    181  3243							;
    182  3243					      macro	tstn
    183  3243					      db	35
    184  3243					      db	({1}-*)-1	;(addr-*)-1
    185  3243					      endm		;addr
    186  3243							;
    187  3243							; FREE returns the amount of free RAM on top of
    188  3243							; the stack.  This is the amount of room the user
    189  3243							; program has available.
    190  3243							;
    191  3243					      macro	free
    192  3243					      db	36
    193  3243					      endm
    194  3243							;
    195  3243							; RANDOM takes the top item off the stack and
    196  3243							; replaces it with a random number that is
    197  3243							; MOD the initial value.  Ie, if the TOS is
    198  3243							; 42 then RANDOM returns a value from 0 to 41.
    199  3243							;
    200  3243					      macro	random
    201  3243					      db	37
    202  3243					      endm
    203  3243							;
    204  3243							; ABS will replace the top of stack with the
    205  3243							; absolute value.
    206  3243							;
    207  3243					      macro	abs
    208  3243					      db	38
    209  3243					      endm
    210  3243							;
    211  3243							; OPENREAD opens a file for reading, as in getting
    212  3243							; statements from it.
    213  3243							;
    214  3243					      macro	openread
    215  3243					      db	39
    216  3243					      endm
    217  3243							;
    218  3243							; OPENWRITE opens a file for writing, as in saving
    219  3243							; the current program to it.
    220  3243							;
    221  3243					      macro	openwrite
    222  3243					      db	40
    223  3243					      db	{1}	; 0= append 1 = create/truncate
    224  3243					      endm
    225  3243							;
    226  3243							; DCLOSE closes any open disk file.
    227  3243							;
    228  3243					      macro	dclose
    229  3243					      db	41
    230  3243					      endm
    231  3243							;
    232  3243							; DGETLINE gets one line from the disk file and puts it
    233  3243							; into LINBUFF.
    234  3243							;
    235  3243					      macro	dgetline
    236  3243					      db	42
    237  3243					      endm
    238  3243							;
    239  3243							; DLIST saves the program to an open disk file.
    240  3243							;
    241  3243					      macro	dlist
    242  3243					      db	43
    243  3243					      endm
    244  3243							; DDIR list the current directory
    245  3243							;
    246  3243					      macro	ddir
    247  3243					      db	44
    248  3243					      endm
    249  3243
    250  3243							; RMFILE remove a fle from disk
    251  3243					      macro	rmfile
    252  3243					      db	45
    253  3243					      endm
    254  3243
    255  3243							; CLEARSCREEN clear the screen
    256  3243					      macro	clearscreen
    257  3243					      db	46
    258  3243					      endm
    259  3243							; POKEMEM Poke value into memory
    260  3243					      macro	pokemem
    261  3243					      db	47
    262  3243					      endm
    263  3243							; PEEKMEM peek at value in memory
    264  3243					      macro	peekmem
    265  3243					      db	48
    266  3243					      endm
    267  3243							; TSTLET Test if the statement is a let without the keyword let
    268  3243					      macro	tstlet
    269  3243					      db	49
    270  3243					      db	({1}-*)-1	;(addr-*)-1
    271  3243					      endm		;addr
    272  3243							; TSTDONE if we reach the end of a statement
    273  3243					      macro	tstdone
    274  3243					      db	50
    275  3243					      db	({1}-*)-1	;(addr-*)-1
    276  3243					      endm		;addr
    277  3243							; GETCHAR	get a character from the input line leave it in RO
    278  3243					      macro	getchar
    279  3243					      db	51
    280  3243					      endm
    281  3243							; PUTCHAR	Put a character to the terminal
    282  3243					      macro	putchar
    283  3243					      db	52
    284  3243					      endm
    285  3243							; Call		Call a machine function return a to stack
    286  3243					      macro	callfunc
    287  3243					      db	53
    288  3243					      endm
    289  3243
    290  3243							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    291  3243					      macro	ibranch
    292  3243					      db	54
    293  3243					      endm
    294  3243
    295  3243							; TSTSTR	 Tests for the open quote in a string
    296  3243					      macro	tststr
    297  3243					      db	55
    298  3243					      db	({1}-*)-1	;(addr-*)-1
    299  3243					      endm
    300  3243							; SETIRQ	Sets the line number to run when an irq happens irq 550
    301  3243					      macro	setirq
    302  3243					      db	56
    303  3243					      endm
    304  3243
    305  3243							; TSTIRQ	Test for irq pending,
    306  3243							;		if so push the IRQ LINE NUMBER into RO, onto stack
    307  3243					      macro	tstirq
    308  3243					      db	57
    309  3243					      db	({1}-*)-1	;(addr-*)-1
    310  3243					      endm
    311  3243
    312  3243							; IRET    return from interupt service
    313  3243					      macro	iret
    314  3243					      db	58
    315  3243					      endm
    316  3243
    317  3243							; INSTR   read a string from the input
    318  3243					      macro	instr
    319  3243					      db	59
    320  3243					      endm
    321  3243
    322  3243							; MODULO Returns the remainder of the division
    323  3243					      macro	modulo
    324  3243					      db	60
    325  3243					      endm
    326  3243							; Set a task line
    327  3243					      macro	taskcreate
    328  3243					      db	61
    329  3243					      endm
    330  3243							; End a task
    331  3243					      macro	etask
    332  3243					      db	62
    333  3243					      endm
    334  3243							; Skip to next task
    335  3243					      macro	ntask
    336  3243					      db	63
    337  3243					      endm
    338  3243							; Subscript
    339  3243					      macro	subscript
    340  3243					      db	64
    341  3243					      db	{1}
    342  3243					      endm
    343  3243							; KILL Task
    344  3243					      macro	taskkill
    345  3243					      db	65
    346  3243					      endm
    347  3243							; STAT Task
    348  3243					      macro	taskstat
    349  3243					      db	66
    350  3243					      endm
    351  3243							;  output value as hex
    352  3243					      macro	hexprt
    353  3243					      db	67
    354  3243					      endm
    355  3243							;  Read in background has completed
    356  3243					      macro	readcomplete
    357  3243					      db	68
    358  3243					      endm
    359  3243							;  ReadInput line
    360  3243					      macro	readstart
    361  3243					      db	69
    362  3243					      endm
    363  3243							; Startio request
    364  3243					      macro	startio
    365  3243					      db	70
    366  3243					      endm
    367  3243							; Endio
    368  3243					      macro	endio
    369  3243					      db	71
    370  3243					      endm
    371  3243							; Logical not
    372  3243					      macro	lognot
    373  3243					      db	72
    374  3243					      endm
    375  3243							; Logical OR
    376  3243					      macro	logor
    377  3243					      db	73
    378  3243					      endm
    379  3243							;Logical and
    380  3243					      macro	logand
    381  3243					      db	74
    382  3243					      endm
    383  3243							;Logical XOR
    384  3243					      macro	logxor
    385  3243					      db	75
    386  3243					      endm
    387  3243							;Wait for task to complete, or list of tasks
    388  3243					      macro	wtask
    389  3243					      db	76
    390  3243					      db	({1}-*)-1	;(addr-*)-1
    391  3243					      endm
    392  3243							;Get the current task id
    393  3243					      MACRO	taskpid
    394  3243					      db	77
    395  3243					      endm
    396  3243							;Trace the basic execution
    397  3243					      Macro	traceprogram
    398  3243					      db	78
    399  3243					      endm
    400  3243							;Do a basic program Trace
    401  3243					      Macro	debugbasic
    402  3243					      db	79
    403  3243					      endm
    404  3243
    405  3243							; Inter Process communications instructions
    406  3243					      Macro	ipcsend
    407  3243					      db	80
    408  3243					      endm
    409  3243					      Macro	ipcreceive
    410  3243					      db	81
    411  3243					      endm
    412  3243					      Macro	ipccheck
    413  3243					      db	82
    414  3243					      endm
    415  3243					      Macro	ipcio
    416  3243					      db	83
    417  3243					      endm
    418  3243					      Macro	pushmathstack
    419  3243					      db	84
    420  3243					      endm
    421  3243					      Macro	popmathstack
    422  3243					      db	85
    423  3243					      endm
    424  3243					      Macro	savemathstack
    425  3243					      db	86
    426  3243					      endm
    427  3243					      Macro	restoremathstack
    428  3243					      db	87
    429  3243					      endm
    430  3243					      Macro	incparmcount
    431  3243					      db	88
    432  3243					      endm
    433  3243					      Macro	taskgetmathstack
    434  3243					      db	89
    435  3243					      endm
    436  3243					      Macro	taskenable
    437  3243					      db	90
    438  3243					      endm
    439  3243					      Macro	tasksuspend
    440  3243					      db	91
    441  3243					      endm
    442  3243					      Macro	taskputmathptr
    443  3243					      db	92
    444  3243					      endm
    445  3243							; Test for an extension type of variable that allows access to a tasks variables
    446  3243							; Using  PID!<Var name>
    447  3243					      Macro	tstvt
    448  3243					      db	93
    449  3243					      db	({1}-*)-1	;(addr-*)-1
    450  3243					      endm
    451  3243
    452  3243							; Provide access to R2 for the IL program
    453  3243					      Macro	setr2
    454  3243					      db	94
    455  3243					      db	{1}	; R2 is only one byte
    456  3243					      endm
    457  3243
    458  3243							;Move stack top to temp
    459  3243					      Macro	stk2tmp
    460  3243					      db	95
    461  3243					      endm
    462  3243
    463  3243					      Macro	tmp2stk
    464  3243					      db	96
    465  3243					      endm
    466  3243
    467  3243					      Macro	tstbyte
    468  3243					      db	97
    469  3243					      db	({1}-*)-1	; (addr-*)-1 goto if match
    470  3243					      dw	{2}	; address to check
    471  3243					      db	{3}	; Value to compare
    472  3243					      endm
    473  3243
    474  3243					      Macro	incvar
    475  3243					      db	98
    476  3243					      endm
    477  3243					      Macro	decvar
    478  3243					      db	99
    479  3243					      endm
    480  3243
    481  3243					      Macro	slice
    482  3243					      db	100
    483  3243					      endm
    484  3243
    485  3243					      Macro	tstb
    486  3243					      db	101
    487  3243					      db	({1}-*)-1
    488  3243					      db	{2}
    489  3243					      endm
    490  3243
    491  3243					      Macro	tstw
    492  3243					      db	102
    493  3243					      db	({1}-*)-1
    494  3243					      dw	{2}
    495  3243					      endm
    496  3243
    497  3243					      Macro	ongoto
    498  3243					      db	103
    499  3243					      dw	{1}
    500  3243					      dw	{2}
    501  3243					      endm
    502  3243
    503  3243					      Macro	tstrelop
    504  3243					      db	104
    505  3243					      db	({1}-*)-1
    506  3243					      endm
    507  3243
    508  3243					      Macro	repeatline
    509  3243					      db	105
    510  3243					      endm
    511  3243
    512  3243							; Check for a precompiled branch, will take branch if precompiled value present
    513  3243					      Macro	tstbranch
    514  3243					      db	106
    515  3243					      db	({1}-*)-1
    516  3243					      endm
    517  3243
    518  3243					      Macro	fastxfer
    519  3243					      db	107
    520  3243					      endm
    521  3243
    522  3243							; Set all io to to a terminal for input output
    523  3243							; SETTERMINAL outterm,interm	 ; the numbers corrispond to the ct65 slot number each slot id 16 bytes,
    524  3243							; so 0 = 0, 1 = io address 16, 2 = io address 32 .... etc
    525  3243					      Macro	setterminal
    526  3243					      db	108
    527  3243					      endm
    528  3243
    529  3243							;Fetch a single byte from memory
    530  3243					      Macro	indb
    531  3243					      db	109
    532  3243					      endm
    533  3243
    534  3243							; Set a block of memory to a fixed value, byte or word
    535  3243							; Stack must contain destiniation address, length to set in bytes, value {byte of word} to initialize to
    536  3243					      Macro	setblock
    537  3243					      db	110
    538  3243					      db	{1}	; the data type to initialize	tByte or tInteger
    539  3243					      endm
    540  3243
    541  3243							; Copy a block of memory
    542  3243							; Stack must contain source address, destination address, length in bytes
    543  3243					      Macro	copyblock
    544  3243					      db	111
    545  3243					      endm
    546  3243
    547  3243							; Compare one block of memory to another
    548  3243							; Stack contains Length, Source1 Source 2
    549  3243							; Place on stack 0 equal, 1 s1>s2, -1 s1 < s2
    550  3243					      Macro	cmpmem
    551  3243					      db	112
    552  3243					      endm
    553  3243
    554  3243							; Shift Left and Right
    555  3243					      Macro	shift
    556  3243					      db	113
    557  3243					      db	{1}	; direction  0 = left 1 = right
    558  3243					      endm
    559  3243
    560  3243							; set of timer macros
    561  3243					      Macro	timerset
    562  3243					      db	114,1
    563  3243					      db	{1}	; value 9 = 1 second, 1-5 = value * 10ms 6 = 10ms, 7=250ms, 8=500ms
    564  3243					      endm
    565  3243
    566  3243					      Macro	timerstop
    567  3243					      db	114,0,0
    568  3243					      endm
    569  3243
    570  3243					      Macro	timervaluelow
    571  3243					      db	114,2,0
    572  3243					      endm
    573  3243
    574  3243					      Macro	timervaluehigh
    575  3243					      db	114,3,0
    576  3243					      endm
    577  3243
    578  3243					      Macro	timer
    579  3243					      db	114
    580  3243					      endm
    581  3243
    582  3243							; jump to end of block if false
    583  3243					      Macro	jmpend
    584  3243					      db	115
    585  3243					      db	{1}
    586  3243					      endm
    587  3243
    588  3243							; Jump to start of block, while, for, if endif
    589  3243					      Macro	jmpstart
    590  3243					      db	116
    591  3243					      db	{1}
    592  3243					      endm
    593  3243
    594  3243							; Begin a block, while, for, if endif
    595  3243					      Macro	beginblock
    596  3243					      db	117
    597  3243					      db	{1},{2}
    598  3243					      endm
    599  3243
    600  3243					      Macro	iftrue
    601  3243					      db	118
    602  3243					      db	({1}-*)-1
    603  3243					      endm
    604  3243
    605  3243					      Macro	iffalse
    606  3243					      db	119
    607  3243					      db	({1}-*)-1
    608  3243					      endm
------- FILE mytb.asm
   2482  3243							;
   2483  3243				  -	      if	FIXED
   2484  3243				  -	      org	$1000
   2485  3243					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  3243					      include	"basic.il"
      1  3243					      seg	Code
      2  3243							; on goto table
      3  3243							; format :   first byte is value Base, subtracted from value found
      4  3243							;	      second byte is the number of entries in the table max is 128... always a limit somewhere... lol
      5  3243				   BasicStmts
      0  3243					      db	kBeginKey,(kKeyCount+1)	; Base address of table, length of table
      1  3243		       01 28		      .byte.b	kBeginKey,(kKeyCount+1)
      0  3245					      dw	ekLet
      1  3245		       dc 32		      .word.w	ekLet
      0  3247					      dw	ekInc
      1  3247		       0e 33		      .word.w	ekInc
      0  3249					      dw	ekDec
      1  3249		       1b 33		      .word.w	ekDec
      0  324b					      dw	ekIreturn
      1  324b		       28 33		      .word.w	ekIreturn
      0  324d					      dw	ekIf
      1  324d		       2d 33		      .word.w	ekIf
      0  324f					      dw	ekThen
      1  324f		       33 33		      .word.w	ekThen
      0  3251					      dw	ekGoto
      1  3251		       37 33		      .word.w	ekGoto
      0  3253					      dw	ekGosub
      1  3253		       f7 36		      .word.w	ekGosub
      0  3255					      dw	ekReturn
      1  3255		       05 37		      .word.w	ekReturn
      0  3257					      dw	ekRem
      1  3257		       4b 33		      .word.w	ekRem
      0  3259					      dw	ekPrint	; should be entry for print
      1  3259		       61 33		      .word.w	ekPrint
      0  325b					      dw	ekTaske
      1  325b		       ae 33		      .word.w	ekTaske
      0  325d					      dw	ekTaskn
      1  325d		       c4 33		      .word.w	ekTaskn
      0  325f					      dw	ekTaskw
      1  325f		       cb 33		      .word.w	ekTaskw
      0  3261					      dw	ekPoke
      1  3261		       e6 33		      .word.w	ekPoke
      0  3263					      dw	ekPutch
      1  3263		       48 34		      .word.w	ekPutch
      0  3265					      dw	ekCls
      1  3265		       53 34		      .word.w	ekCls
      0  3267					      dw	ekInput
      1  3267		       5a 34		      .word.w	ekInput
      0  3269					      dw	ekEnd
      1  3269		       88 34		      .word.w	ekEnd
      0  326b					      dw	ekIrq
      1  326b		       8c 34		      .word.w	ekIrq
      0  326d					      dw	ekKill
      1  326d		       97 34		      .word.w	ekKill
      0  326f					      dw	ekList
      1  326f		       a2 34		      .word.w	ekList
      0  3271					      dw	ekRun
      1  3271		       a7 34		      .word.w	ekRun
      0  3273					      dw	ekNew
      1  3273		       b0 34		      .word.w	ekNew
      0  3275					      dw	ekSlice
      1  3275		       b4 34		      .word.w	ekSlice
      0  3277					      dw	ekTrace
      1  3277		       bf 34		      .word.w	ekTrace
      0  3279					      dw	ekExit
      1  3279		       d0 34		      .word.w	ekExit
      0  327b					      dw	ekSave
      1  327b		       d1 34		      .word.w	ekSave
      0  327d					      dw	ekLoad
      1  327d		       d8 34		      .word.w	ekLoad
      0  327f					      dw	ekErase
      1  327f		       e8 34		      .word.w	ekErase
      0  3281					      dw	ekDir
      1  3281		       e4 34		      .word.w	ekDir
      0  3283					      dw	ekSetTerm
      1  3283		       51 33		      .word.w	ekSetTerm
      0  3285					      dw	ekSetMemB
      1  3285		       fd 33		      .word.w	ekSetMemB
      0  3287					      dw	ekSetMemW
      1  3287		       09 34		      .word.w	ekSetMemW
      0  3289					      dw	ekCopyMem
      1  3289		       2b 34		      .word.w	ekCopyMem
      0  328b					      dw	ekWhile
      1  328b		       da 36		      .word.w	ekWhile
      0  328d					      dw	ekWend
      1  328d		       e9 36		      .word.w	ekWend
      0  328f					      dw	ekFor
      1  328f		       f7 36		      .word.w	ekFor
      0  3291					      dw	ekNext
      1  3291		       f7 36		      .word.w	ekNext
      0  3293					      dw	ekStep
      1  3293		       f7 36		      .word.w	ekStep
     47  3295							;
     48  3295							; Logical operators
      0  3295				   BasicLogical db	kOr,3
      1  3295		       2a 03		      .byte.b	kOr,3
      0  3297					      dw	ekOr
      1  3297		       1d 35		      .word.w	ekOr
      0  3299					      dw	ekXor
      1  3299		       22 35		      .word.w	ekXor
      0  329b					      dw	ekAnd
      1  329b		       18 35		      .word.w	ekAnd
     53  329d
      0  329d				   BasicShift db	kShr,2
      1  329d		       2d 02		      .byte.b	kShr,2
      0  329f					      dw	ekShiftRight
      1  329f		       0d 35		      .word.w	ekShiftRight
      0  32a1					      dw	ekShiftLeft
      1  32a1		       07 35		      .word.w	ekShiftLeft
     57  32a3
     58  32a3							;functions returning values
     59  32a3
      0  32a3				   BasicFuncs db	kBeginFunc,kFuncCount
      1  32a3		       2f 12		      .byte.b	kBeginFunc,kFuncCount
      0  32a5					      dw	ekTrue
      1  32a5		       77 35		      .word.w	ekTrue
      0  32a7					      dw	ekFalse
      1  32a7		       7b 35		      .word.w	ekFalse
      0  32a9					      dw	ekFree
      1  32a9		       7f 35		      .word.w	ekFree
      0  32ab					      dw	ekGetch
      1  32ab		       87 35		      .word.w	ekGetch
      0  32ad					      dw	ekPeek
      1  32ad		       cc 35		      .word.w	ekPeek
      0  32af					      dw	ekTask
      1  32af		       d7 35		      .word.w	ekTask
      0  32b1					      dw	ekIpcc
      1  32b1		       23 36		      .word.w	ekIpcc
      0  32b3					      dw	ekIpcs
      1  32b3		       fe 35		      .word.w	ekIpcs
      0  32b5					      dw	ekIpcr
      1  32b5		       0f 36		      .word.w	ekIpcr
      0  32b7					      dw	ekRnd
      1  32b7		       2e 36		      .word.w	ekRnd
      0  32b9					      dw	ekStat
      1  32b9		       4c 36		      .word.w	ekStat
      0  32bb					      dw	ekAbs
      1  32bb		       41 36		      .word.w	ekAbs
      0  32bd					      dw	ekCall
      1  32bd		       59 36		      .word.w	ekCall
      0  32bf					      dw	ekGofn
      1  32bf		       fe 36		      .word.w	ekGofn
      0  32c1					      dw	ekPid
      1  32c1		       57 36		      .word.w	ekPid
      0  32c3					      dw	ekAddr
      1  32c3		       8f 35		      .word.w	ekAddr
      0  32c5					      dw	ekCmpMem
      1  32c5		       9e 35		      .word.w	ekCmpMem
      0  32c7					      dw	eKTimer
      1  32c7		       b5 35		      .word.w	eKTimer
     79  32c9							;
     80  32c9							;====================================================
     81  32c9							; file constants
     82  32c9		       00 00	   OPEN_APPEND equ	0	; append to file
     83  32c9		       00 01	   OPEN_CREATE equ	1	; truncate/create file
     84  32c9
     85  32c9							;=====================================================
     86  32c9							; This is the IL of the BASIC (or whatever) language.
     87  32c9							; Because of the way macros are implemented by as65,
     88  32c9							; labels can't be on the same line as a macro
     89  32c9							; invocation, so that's why labels are on separate
     90  32c9							; lines.
     91  32c9							;
     92  32c9		       32 c9	   IL	      equ	*
     93  32c9
     94  32c9							;THE IL CONTROL SECTION
     95  32c9
     96  32c9				   START
      0  32c9					      INIT		;INITIALIZE
      0  32c9					      db	22
      1  32c9		       16		      .byte.b	22
      0  32ca					      NLINE		;WRITE CRLF
      0  32ca					      db	5
      1  32ca		       05		      .byte.b	5
      0  32cb					      ERRGOTO	CO	;where to go after an error
      0  32cb					      db	31
      1  32cb		       1f		      .byte.b	31
      0  32cc					      dw	CO
      1  32cc		       cf 32		      .word.w	CO
      0  32ce					      VINIT		;clear all variables
      0  32ce					      db	30
      1  32ce		       1e		      .byte.b	30
    101  32cf							;
    102  32cf							; This is where we jump to get a line of commands or
    103  32cf							; a program from the user.
    104  32cf							;
    105  32cf				   CO
      0  32cf					      GETLINE		;WRITE PROMPT AND GET LINE
      0  32cf					      db	23
      1  32cf		       17		      .byte.b	23
      0  32d0					      TSTL	XEC	;TEST FOR LINE NUMBER, if none then execute the line
      0  32d0					      db	34
      1  32d0		       22		      .byte.b	34
      0  32d1					      db	(XEC-*)-1
      1  32d1		       04		      .byte.b	(XEC-*)-1
      0  32d2					      INSERT		;INSERT IT (MAY BE DELETE)
      0  32d2					      db	24
      1  32d2		       18		      .byte.b	24
      0  32d3					      IJMP	CO
      0  32d3					      db	29
      1  32d3		       1d		      .byte.b	29
      0  32d4					      dw	CO
      1  32d4		       cf 32		      .word.w	CO
    110  32d6				   XEC
      0  32d6					      XINIT		;INITIALIZE
      0  32d6					      db	0
      1  32d6		       00		      .byte.b	0
    112  32d7							;============================================================================
    113  32d7							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
    114  32d7							;
    115  32d7				   STMT
      0  32d7					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  32d7					      db	57
      1  32d7		       39		      .byte.b	57
      0  32d8					      db	(notirq-*)-1
      1  32d8		       00		      .byte.b	(notirq-*)-1
    117  32d9							;==========================================================================================
    118  32d9							; Process a let statement implied or explicit.
    119  32d9							;
    120  32d9				   notirq
      0  32d9					      DEBUGBASIC		; Check if we are doing a debug for this session
      0  32d9					      db	79
      1  32d9		       4f		      .byte.b	79
      0  32da					      TSTLET	DoVector	; Test if Let keyword or a variable
      0  32da					      db	49
      1  32da		       31		      .byte.b	49
      0  32db					      db	(DoVector-*)-1
      1  32db		       2d		      .byte.b	(DoVector-*)-1
    123  32dc				   ekLet
      0  32dc					      TSTV	DoVector	; Test for variable
      0  32dc					      db	33
      1  32dc		       21		      .byte.b	33
      0  32dd					      db	(DoVector-*)-1
      1  32dd		       2b		      .byte.b	(DoVector-*)-1
      0  32de					      CALL	FactVarPtrNoTst	; get a pointer to the variable
      0  32de					      db	28
      1  32de		       1c		      .byte.b	28
      0  32df					      dw	FactVarPtrNoTst
      1  32df		       a0 36		      .word.w	FactVarPtrNoTst
    126  32e1
    127  32e1				   LETINDEX_ALL
      0  32e1					      TSTB	ERRMissingEquals,oEqual	; (This line originally omitted)
      0  32e1					      db	101
      1  32e1		       65		      .byte.b	101
      0  32e2					      db	(ERRMissingEquals-*)-1
      1  32e2		       20		      .byte.b	(ERRMissingEquals-*)-1
      0  32e3					      db	oEqual
      1  32e3		       f2		      .byte.b	oEqual
    129  32e4				   LETBE
      0  32e4					      TSTBYTE	LETAssignByte,R2,tByte	; Check for a byte conversion
      0  32e4					      db	97
      1  32e4		       61		      .byte.b	97
      0  32e5					      db	(LETAssignByte-*)-1
      1  32e5		       10		      .byte.b	(LETAssignByte-*)-1
      0  32e6					      dw	R2
      1  32e6		       58 00		      .word.w	R2
      0  32e8					      db	tByte
      1  32e8		       a2		      .byte.b	tByte
      0  32e9					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  32e9					      db	28
      1  32e9		       1c		      .byte.b	28
      0  32ea					      dw	EXPR
      1  32ea		       f0 34		      .word.w	EXPR
      0  32ec					      DONE		; REPORT ERROR IF NOT NEXT
      0  32ec					      db	1
      1  32ec		       01		      .byte.b	1
      0  32ed					      SETR2	tInteger	; Store an integer type
      0  32ed					      db	94
      1  32ed		       5e		      .byte.b	94
      0  32ee					      db	tInteger
      1  32ee		       a4		      .byte.b	tInteger
      0  32ef					      STORE		; STORE RESULT at variable address
      0  32ef					      db	19
      1  32ef		       13		      .byte.b	19
      0  32f0					      NXT	CO	; AND SEQUENCE TO NEXT
      0  32f0					      db	6
      1  32f0		       06		      .byte.b	6
      0  32f1					      dw	CO
      1  32f1		       cf 32		      .word.w	CO
      0  32f3					      IJMP	STMT	; Next statement
      0  32f3					      db	29
      1  32f3		       1d		      .byte.b	29
      0  32f4					      dw	STMT
      1  32f4		       d7 32		      .word.w	STMT
    137  32f6
    138  32f6				   LETAssignByte
      0  32f6					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  32f6					      db	28
      1  32f6		       1c		      .byte.b	28
      0  32f7					      dw	EXPR
      1  32f7		       f0 34		      .word.w	EXPR
      0  32f9					      DONE		; REPORT ERROR IF NOT NEXT
      0  32f9					      db	1
      1  32f9		       01		      .byte.b	1
      0  32fa					      SETR2	tByte	; Set to store a byte value
      0  32fa					      db	94
      1  32fa		       5e		      .byte.b	94
      0  32fb					      db	tByte
      1  32fb		       a2		      .byte.b	tByte
      0  32fc					      STORE		; STORE RESULT at variable address
      0  32fc					      db	19
      1  32fc		       13		      .byte.b	19
      0  32fd					      NXT	CO	; AND SEQUENCE TO NEXT
      0  32fd					      db	6
      1  32fd		       06		      .byte.b	6
      0  32fe					      dw	CO
      1  32fe		       cf 32		      .word.w	CO
      0  3300					      IJMP	STMT	; Next statement
      0  3300					      db	29
      1  3300		       1d		      .byte.b	29
      0  3301					      dw	STMT
      1  3301		       d7 32		      .word.w	STMT
    145  3303
    146  3303				   ERRMissingEquals
      0  3303					      ERRMSG	ERR_MISSINGEQUALSIGN	; Missing asignment
      0  3303					      db	13
      1  3303		       0d		      .byte.b	13
      0  3304					      dw	ERR_MISSINGEQUALSIGN
      1  3304		       18 00		      .word.w	ERR_MISSINGEQUALSIGN
    148  3306
    149  3306				   ERRVEC2
      0  3306					      IJMP	UNKNOWN
      0  3306					      db	29
      1  3306		       1d		      .byte.b	29
      0  3307					      dw	UNKNOWN
      1  3307		       ec 34		      .word.w	UNKNOWN
    151  3309							;=============================================================
    152  3309							;Branch on a valid statement start
    153  3309				   DoVector
      0  3309					      OnGoto	BasicStmts,UNKNOWN	; use the table provided if not in table branch to unknown
      0  3309					      db	103
      1  3309		       67		      .byte.b	103
      0  330a					      dw	BasicStmts
      1  330a		       43 32		      .word.w	BasicStmts
      0  330c					      dw	UNKNOWN
      1  330c		       ec 34		      .word.w	UNKNOWN
    155  330e							;This will never return here!
    156  330e							;=============================================================
    157  330e							; Inc or dec a variable
    158  330e				   ekInc
      0  330e					      TSTV	ERRVEC2	; Verify we have a variable
      0  330e					      db	33
      1  330e		       21		      .byte.b	33
      0  330f					      db	(ERRVEC2-*)-1
      1  330f		       f6		      .byte.b	(ERRVEC2-*)-1
      0  3310					      CALL	FactVarPtrNoTst	; Get a pointer to the memory location to increment
      0  3310					      db	28
      1  3310		       1c		      .byte.b	28
      0  3311					      dw	FactVarPtrNoTst
      1  3311		       a0 36		      .word.w	FactVarPtrNoTst
    161  3313							;	  TSTB	     eDoInc,oBang		    ; Allow to inc or dec other tasks variables
    162  3313							;	  IND					    ; we just got a pid
    163  3313							;	  TSTVT      ERRVEC2			    ; if it is not another variabe then error, Call test var. task
    164  3313				   eDoInc
      0  3313					      INCVAR		; Do the increment of the variable
      0  3313					      db	98
      1  3313		       62		      .byte.b	98
      0  3314					      DONE		; Test for end of line or end of statement ":"
      0  3314					      db	1
      1  3314		       01		      .byte.b	1
      0  3315					      NXT	CO	; Get the next statement, branch CO if end of program
      0  3315					      db	6
      1  3315		       06		      .byte.b	6
      0  3316					      dw	CO
      1  3316		       cf 32		      .word.w	CO
      0  3318					      IJMP	STMT	; Process the next statement
      0  3318					      db	29
      1  3318		       1d		      .byte.b	29
      0  3319					      dw	STMT
      1  3319		       d7 32		      .word.w	STMT
    169  331b							;S1Dec:
    170  331b							;	  TSTB	     S1Iret,kDec		    ; Dec variable
    171  331b				   ekDec
      0  331b					      TSTV	ERRVEC2	; Must be followed by a variable
      0  331b					      db	33
      1  331b		       21		      .byte.b	33
      0  331c					      db	(ERRVEC2-*)-1
      1  331c		       e9		      .byte.b	(ERRVEC2-*)-1
      0  331d					      CALL	FactVarPtrNoTst	; Get a pointer to the variable to update
      0  331d					      db	28
      1  331d		       1c		      .byte.b	28
      0  331e					      dw	FactVarPtrNoTst
      1  331e		       a0 36		      .word.w	FactVarPtrNoTst
    174  3320							;	  TSTB	     eDoDec,oBang		    ; Allow to inc or dec other tasks variables
    175  3320							;	  IND					    ; we just got a pid
    176  3320							;	  TSTVT      ERRVEC2			    ; if it is not another variabe then error, Call test var. task
    177  3320				   eDoDec
      0  3320					      DECVAR		; Decrement the actual variable
      0  3320					      db	99
      1  3320		       63		      .byte.b	99
      0  3321					      DONE		; Test if end of line or : statement
      0  3321					      db	1
      1  3321		       01		      .byte.b	1
      0  3322					      NXT	CO	; If at end of program then got the console
      0  3322					      db	6
      1  3322		       06		      .byte.b	6
      0  3323					      dw	CO
      1  3323		       cf 32		      .word.w	CO
      0  3325					      IJMP	STMT	; Process the next statement of command line
      0  3325					      db	29
      1  3325		       1d		      .byte.b	29
      0  3326					      dw	STMT
      1  3326		       d7 32		      .word.w	STMT
    182  3328							;=============================================================================================================================
    183  3328							; iret or ireturn, Return from interupt process
    184  3328							;
    185  3328							;S1Iret:
    186  3328							;	  TSTB	     S1S1,kIreturn		 ; test return from interupt
    187  3328							;S1Sa:
    188  3328				   ekIreturn
      0  3328					      DONE		; Must be only thing on the line
      0  3328					      db	1
      1  3328		       01		      .byte.b	1
      0  3329					      IRET		; RESTORE LINE NUMBER OF CALL
      0  3329					      db	58
      1  3329		       3a		      .byte.b	58
      0  332a					      IJMP	STMT
      0  332a					      db	29
      1  332a		       1d		      .byte.b	29
      0  332b					      dw	STMT
      1  332b		       d7 32		      .word.w	STMT
    192  332d							;==============================================================================================================================
    193  332d							;Process if statement, if true then process all statements until end of line reached
    194  332d							;S1S1:
    195  332d							;	  TSTB	     S1Z,kIf			      ; IF STATEMENT
    196  332d				   ekIf
      0  332d					      CALL	EXPR	; GET EXPRESSION rel ops now valid expression 0 false, everything else true
      0  332d					      db	28
      1  332d		       1c		      .byte.b	28
      0  332e					      dw	EXPR
      1  332e		       f0 34		      .word.w	EXPR
      0  3330					      TSTB	ekThen,kThen	; (This line originally omitted) not required
      0  3330					      db	101
      1  3330		       65		      .byte.b	101
      0  3331					      db	(ekThen-*)-1
      1  3331		       01		      .byte.b	(ekThen-*)-1
      0  3332					      db	kThen
      1  3332		       06		      .byte.b	kThen
    199  3333				   ekThen
      0  3333					      IBRANCH		; PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  3333					      db	54
      1  3333		       36		      .byte.b	54
      0  3334					      IJMP	STMT
      0  3334					      db	29
      1  3334		       1d		      .byte.b	29
      0  3335					      dw	STMT
      1  3335		       d7 32		      .word.w	STMT
    202  3337							;===============================================================================================================================
    203  3337							; Test for GOTO
    204  3337							;S1Z:
    205  3337							;	  TSTB	     S2,kGoto			    ; YES...TO, OR...SUB
    206  3337							;
    207  3337				   ekGoto
      0  3337					      TSTBRANCH	ekGotoCompiled	; test the two byte vector following the goto if zero then normal line lookup
      0  3337					      db	106
      1  3337		       6a		      .byte.b	106
      0  3338					      db	(ekGotoCompiled-*)-1
      1  3338		       0e		      .byte.b	(ekGotoCompiled-*)-1
    209  3339							; Else we have the address and just goto that address
      0  3339					      TSTB	ekGotoLine,oPeriod	; If it is a period, then just go to start of this line
      0  3339					      db	101
      1  3339		       65		      .byte.b	101
      0  333a					      db	(ekGotoLine-*)-1
      1  333a		       05		      .byte.b	(ekGotoLine-*)-1
      0  333b					      db	oPeriod
      1  333b		       e9		      .byte.b	oPeriod
      0  333c					      REPEATLINE		; Repeat the same line again
      0  333c					      db	105
      1  333c		       69		      .byte.b	105
      0  333d					      IJMP	STMT	; Go do the statement
      0  333d					      db	29
      1  333d		       1d		      .byte.b	29
      0  333e					      dw	STMT
      1  333e		       d7 32		      .word.w	STMT
    213  3340
    214  3340				   ekGotoLine
      0  3340					      CALL	EXPR	; GET LABEL
      0  3340					      db	28
      1  3340		       1c		      .byte.b	28
      0  3341					      dw	EXPR
      1  3341		       f0 34		      .word.w	EXPR
      0  3343					      lit	0	; Place indicator for line num on stack
      0  3343					      db	27
      1  3343		       1b		      .byte.b	27
      0  3344					      dw	0
      1  3344		       00 00		      .word.w	0
      0  3346					      FASTXFER
      0  3346					      db	107
      1  3346		       6b		      .byte.b	107
    218  3347				   ekGotoCompiled
      0  3347					      lit	1	; tell it that mempointer on the stack
      0  3347					      db	27
      1  3347		       1b		      .byte.b	27
      0  3348					      dw	1
      1  3348		       01 00		      .word.w	1
      0  334a					      FASTXFER		; put top of stack into curptr
      0  334a					      db	107
      1  334a		       6b		      .byte.b	107
    221  334b
    222  334b							;==================================================================================================================================
    223  334b							; Process REM statement
    224  334b							;
    225  334b							;S2a:
    226  334b							;	  TSTB	     S3,kRem			    ; REMark.  Skip rest of line
    227  334b				   ekRem
      0  334b					      NXT	CO	; The rest of the line is ignored
      0  334b					      db	6
      1  334b		       06		      .byte.b	6
      0  334c					      dw	CO
      1  334c		       cf 32		      .word.w	CO
      0  334e					      IJMP	STMT	; Process the next statement
      0  334e					      db	29
      1  334e		       1d		      .byte.b	29
      0  334f					      dw	STMT
      1  334f		       d7 32		      .word.w	STMT
    230  3351							;====================================================================================================================================
    231  3351							; Set the Task input output slot each slot is 16 byte starting at e000
    232  3351							; so 0,1,...
    233  3351				   ekSetTerm
      0  3351					      CALL	EXPR
      0  3351					      db	28
      1  3351		       1c		      .byte.b	28
      0  3352					      dw	EXPR
      1  3352		       f0 34		      .word.w	EXPR
      0  3354					      TSTB	ERRVEC,oComma
      0  3354					      db	101
      1  3354		       65		      .byte.b	101
      0  3355					      db	(ERRVEC-*)-1
      1  3355		       2f		      .byte.b	(ERRVEC-*)-1
      0  3356					      db	oComma
      1  3356		       e2		      .byte.b	oComma
      0  3357					      CALL	EXPR
      0  3357					      db	28
      1  3357		       1c		      .byte.b	28
      0  3358					      dw	EXPR
      1  3358		       f0 34		      .word.w	EXPR
      0  335a					      SETTERMINAL
      0  335a					      db	108
      1  335a		       6c		      .byte.b	108
      0  335b					      NXT	CO	;Next statement to execute
      0  335b					      db	6
      1  335b		       06		      .byte.b	6
      0  335c					      dw	CO
      1  335c		       cf 32		      .word.w	CO
      0  335e					      IJMP	STMT
      0  335e					      db	29
      1  335e		       1d		      .byte.b	29
      0  335f					      dw	STMT
      1  335f		       d7 32		      .word.w	STMT
    240  3361							;==================================================================================================================================
    241  3361							; Print statement
    242  3361							;
    243  3361							;S3:
    244  3361							;	  TSTB	     S8,kPrint			    ; ? or Print symonym for print
    245  3361				   ekPrint
      0  3361					      STARTIO		; Lock task until io completes
      0  3361					      db	70
      1  3361		       46		      .byte.b	70
    247  3362				   S4
      0  3362					      TSTDONE	S4a	; Test if we just want crlf printed
      0  3362					      db	50
      1  3362		       32		      .byte.b	50
      0  3363					      db	(S4a-*)-1
      1  3363		       03		      .byte.b	(S4a-*)-1
      0  3364					      IJMP	S6
      0  3364					      db	29
      1  3364		       1d		      .byte.b	29
      0  3365					      dw	S6
      1  3365		       7c 33		      .word.w	S6
    250  3367
    251  3367				   S4a
      0  3367					      TSTB	S7,tString	; TEST FOR QUOTED String
      0  3367					      db	101
      1  3367		       65		      .byte.b	101
      0  3368					      db	(S7-*)-1
      1  3368		       1f		      .byte.b	(S7-*)-1
      0  3369					      db	tString
      1  3369		       a0		      .byte.b	tString
      0  336a					      PRS		; PRINT STRING
      0  336a					      db	2
      1  336a		       02		      .byte.b	2
    254  336b				   S5
      0  336b					      TSTB	S6A,oComma	; IS THERE MORE?
      0  336b					      db	101
      1  336b		       65		      .byte.b	101
      0  336c					      db	(S6A-*)-1
      1  336c		       07		      .byte.b	(S6A-*)-1
      0  336d					      db	oComma
      1  336d		       e2		      .byte.b	oComma
      0  336e					      SPC		; SPACE TO NEXT ZONE
      0  336e					      db	4
      1  336e		       04		      .byte.b	4
      0  336f					      TSTDONE	S4	; Not end of line jump back
      0  336f					      db	50
      1  336f		       32		      .byte.b	50
      0  3370					      db	(S4-*)-1
      1  3370		       f1		      .byte.b	(S4-*)-1
      0  3371					      IJMP	S6Z	; YES JUMP BACK
      0  3371					      db	29
      1  3371		       1d		      .byte.b	29
      0  3372					      dw	S6Z
      1  3372		       7e 33		      .word.w	S6Z
    259  3374
    260  3374							;
    261  3374							; If a semicolon, don't do anything.
    262  3374							;
    263  3374				   S6A
      0  3374					      TSTB	S6,oSemiColon	; IF semicolon also check if end of line
      0  3374					      db	101
      1  3374		       65		      .byte.b	101
      0  3375					      db	(S6-*)-1
      1  3375		       06		      .byte.b	(S6-*)-1
      0  3376					      db	oSemiColon
      1  3376		       e3		      .byte.b	oSemiColon
      0  3377					      TSTDONE	S4	; Jump Back if not end of line
      0  3377					      db	50
      1  3377		       32		      .byte.b	50
      0  3378					      db	(S4-*)-1
      1  3378		       e9		      .byte.b	(S4-*)-1
      0  3379					      IJMP	S6Z
      0  3379					      db	29
      1  3379		       1d		      .byte.b	29
      0  337a					      dw	S6Z
      1  337a		       7e 33		      .word.w	S6Z
    267  337c
    268  337c				   S6
    269  337c
      0  337c					      DONE		; ERROR IF CR NOT NEXT
      0  337c					      db	1
      1  337c		       01		      .byte.b	1
      0  337d					      NLINE
      0  337d					      db	5
      1  337d		       05		      .byte.b	5
    272  337e				   S6Z
      0  337e					      ENDIO		; release task io completed
      0  337e					      db	71
      1  337e		       47		      .byte.b	71
      0  337f					      NXT	CO	; exit here if , or ; at end of print
      0  337f					      db	6
      1  337f		       06		      .byte.b	6
      0  3380					      dw	CO
      1  3380		       cf 32		      .word.w	CO
      0  3382					      IJMP	STMT
      0  3382					      db	29
      1  3382		       1d		      .byte.b	29
      0  3383					      dw	STMT
      1  3383		       d7 32		      .word.w	STMT
    276  3385							;
    277  3385							; A jump for code too far away for relative branch
    278  3385							;
    279  3385				   ERRVEC
      0  3385					      IJMP	UNKNOWN
      0  3385					      db	29
      1  3385		       1d		      .byte.b	29
      0  3386					      dw	UNKNOWN
      1  3386		       ec 34		      .word.w	UNKNOWN
    281  3388							;
    282  3388							; Get here if there is an expression to print
    283  3388				   S7
      0  3388					      TSTB	S7AUnsigned,oDollar	; Print the value in Hex format
      0  3388					      db	101
      1  3388		       65		      .byte.b	101
      0  3389					      db	(S7AUnsigned-*)-1
      1  3389		       08		      .byte.b	(S7AUnsigned-*)-1
      0  338a					      db	oDollar
      1  338a		       e7		      .byte.b	oDollar
      0  338b					      CALL	EXPR
      0  338b					      db	28
      1  338b		       1c		      .byte.b	28
      0  338c					      dw	EXPR
      1  338c		       f0 34		      .word.w	EXPR
      0  338e					      HEXPRT
      0  338e					      db	67
      1  338e		       43		      .byte.b	67
      0  338f					      IJMP	S5
      0  338f					      db	29
      1  338f		       1d		      .byte.b	29
      0  3390					      dw	S5
      1  3390		       6b 33		      .word.w	S5
    288  3392
    289  3392				   S7AUnsigned
    290  3392
      0  3392					      TSTB	S7A,oPercent	; Print the value as an unsigned number
      0  3392					      db	101
      1  3392		       65		      .byte.b	101
      0  3393					      db	(S7A-*)-1
      1  3393		       0a		      .byte.b	(S7A-*)-1
      0  3394					      db	oPercent
      1  3394		       ed		      .byte.b	oPercent
      0  3395					      CALL	EXPR
      0  3395					      db	28
      1  3395		       1c		      .byte.b	28
      0  3396					      dw	EXPR
      1  3396		       f0 34		      .word.w	EXPR
      0  3398					      SETR2	tUint
      0  3398					      db	94
      1  3398		       5e		      .byte.b	94
      0  3399					      db	tUint
      1  3399		       a9		      .byte.b	tUint
      0  339a					      PRN
      0  339a					      db	3
      1  339a		       03		      .byte.b	3
      0  339b					      IJMP	S5
      0  339b					      db	29
      1  339b		       1d		      .byte.b	29
      0  339c					      dw	S5
      1  339c		       6b 33		      .word.w	S5
    296  339e
    297  339e				   S7A
    298  339e
      0  339e					      CALL	EXPR
      0  339e					      db	28
      1  339e		       1c		      .byte.b	28
      0  339f					      dw	EXPR
      1  339f		       f0 34		      .word.w	EXPR
      0  33a1					      TSTB	S7B,oDollar	; Print the value as a single character
      0  33a1					      db	101
      1  33a1		       65		      .byte.b	101
      0  33a2					      db	(S7B-*)-1
      1  33a2		       05		      .byte.b	(S7B-*)-1
      0  33a3					      db	oDollar
      1  33a3		       e7		      .byte.b	oDollar
      0  33a4					      PUTCHAR
      0  33a4					      db	52
      1  33a4		       34		      .byte.b	52
      0  33a5					      IJMP	S5
      0  33a5					      db	29
      1  33a5		       1d		      .byte.b	29
      0  33a6					      dw	S5
      1  33a6		       6b 33		      .word.w	S5
    303  33a8
    304  33a8				   S7B
      0  33a8					      SETR2	tInteger	; Print the value as a signed number
      0  33a8					      db	94
      1  33a8		       5e		      .byte.b	94
      0  33a9					      db	tInteger
      1  33a9		       a4		      .byte.b	tInteger
      0  33aa					      PRN		; PRINT IT
      0  33aa					      db	3
      1  33aa		       03		      .byte.b	3
      0  33ab					      IJMP	S5	; IS THERE MORE?
      0  33ab					      db	29
      1  33ab		       1d		      .byte.b	29
      0  33ac					      dw	S5
      1  33ac		       6b 33		      .word.w	S5
    308  33ae							;
    309  33ae							;===========================================================
    310  33ae							; PROCESS ALL THE TASK STATEMENTS
    311  33ae							;
    312  33ae							;S8:
    313  33ae							;	  TSTB	      S8G,kTaske		 ; End Task
    314  33ae				   ekTaske
      0  33ae					      TSTB	S8NoParm,oLeftBracket
      0  33ae					      db	101
      1  33ae		       65		      .byte.b	101
      0  33af					      db	(S8NoParm-*)-1
      1  33af		       0c		      .byte.b	(S8NoParm-*)-1
      0  33b0					      db	oLeftBracket
      1  33b0		       e0		      .byte.b	oLeftBracket
      0  33b1					      CALL	EXPR
      0  33b1					      db	28
      1  33b1		       1c		      .byte.b	28
      0  33b2					      dw	EXPR
      1  33b2		       f0 34		      .word.w	EXPR
      0  33b4					      TSTB	UNKNOWNLnk,oRightBracket
      0  33b4					      db	101
      1  33b4		       65		      .byte.b	101
      0  33b5					      db	(UNKNOWNLnk-*)-1
      1  33b5		       2d		      .byte.b	(UNKNOWNLnk-*)-1
      0  33b6					      db	oRightBracket
      1  33b6		       e1		      .byte.b	oRightBracket
      0  33b7					      ETASK
      0  33b7					      db	62
      1  33b7		       3e		      .byte.b	62
      0  33b8					      DONE
      0  33b8					      db	1
      1  33b8		       01		      .byte.b	1
      0  33b9					      IJMP	STMT
      0  33b9					      db	29
      1  33b9		       1d		      .byte.b	29
      0  33ba					      dw	STMT
      1  33ba		       d7 32		      .word.w	STMT
    321  33bc				   S8NoParm
      0  33bc					      LIT	0
      0  33bc					      db	27
      1  33bc		       1b		      .byte.b	27
      0  33bd					      dw	0
      1  33bd		       00 00		      .word.w	0
      0  33bf					      ETASK
      0  33bf					      db	62
      1  33bf		       3e		      .byte.b	62
      0  33c0					      DONE		; Must be last thing on a line
      0  33c0					      db	1
      1  33c0		       01		      .byte.b	1
      0  33c1					      IJMP	STMT
      0  33c1					      db	29
      1  33c1		       1d		      .byte.b	29
      0  33c2					      dw	STMT
      1  33c2		       d7 32		      .word.w	STMT
    326  33c4							;
    327  33c4							;===========================================================
    328  33c4							; The task gives up the rest of the cycles
    329  33c4							;S8G:
    330  33c4							;	  TSTB	      S8a,kTaskn	 ;Next task
    331  33c4				   ekTaskn
      0  33c4					      NTASK
      0  33c4					      db	63
      1  33c4		       3f		      .byte.b	63
      0  33c5					      NXT	CO	;Next statement to execute
      0  33c5					      db	6
      1  33c5		       06		      .byte.b	6
      0  33c6					      dw	CO
      1  33c6		       cf 32		      .word.w	CO
      0  33c8					      IJMP	STMT
      0  33c8					      db	29
      1  33c8		       1d		      .byte.b	29
      0  33c9					      dw	STMT
      1  33c9		       d7 32		      .word.w	STMT
    335  33cb							;
    336  33cb							;===========================================================
    337  33cb							; Waits for a task or list of tasks to complete
    338  33cb
    339  33cb				   ekTaskw
      0  33cb					      TSTB	UNKNOWNLnk,oLeftBracket
      0  33cb					      db	101
      1  33cb		       65		      .byte.b	101
      0  33cc					      db	(UNKNOWNLnk-*)-1
      1  33cc		       16		      .byte.b	(UNKNOWNLnk-*)-1
      0  33cd					      db	oLeftBracket
      1  33cd		       e0		      .byte.b	oLeftBracket
    341  33ce				   S8TSK
      0  33ce					      Call	EXPR	;Gets the PID of task to wait for
      0  33ce					      db	28
      1  33ce		       1c		      .byte.b	28
      0  33cf					      dw	EXPR
      1  33cf		       f0 34		      .word.w	EXPR
    343  33d1				   S8LOOP
      0  33d1					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  33d1					      db	76
      1  33d1		       4c		      .byte.b	76
      0  33d2					      db	(S8LOOP-*)-1
      1  33d2		       fe		      .byte.b	(S8LOOP-*)-1
      0  33d3					      TSTB	S8aa,oComma	;Checks for more tasks
      0  33d3					      db	101
      1  33d3		       65		      .byte.b	101
      0  33d4					      db	(S8aa-*)-1
      1  33d4		       04		      .byte.b	(S8aa-*)-1
      0  33d5					      db	oComma
      1  33d5		       e2		      .byte.b	oComma
      0  33d6					      IJMP	S8TSK	;Go for the next task number
      0  33d6					      db	29
      1  33d6		       1d		      .byte.b	29
      0  33d7					      dw	S8TSK
      1  33d7		       ce 33		      .word.w	S8TSK
    347  33d9				   S8aa
      0  33d9					      TSTB	UNKNOWNLnk,oRightBracket	;end of list
      0  33d9					      db	101
      1  33d9		       65		      .byte.b	101
      0  33da					      db	(UNKNOWNLnk-*)-1
      1  33da		       08		      .byte.b	(UNKNOWNLnk-*)-1
      0  33db					      db	oRightBracket
      1  33db		       e1		      .byte.b	oRightBracket
      0  33dc					      DONE
      0  33dc					      db	1
      1  33dc		       01		      .byte.b	1
      0  33dd					      NXT	CO
      0  33dd					      db	6
      1  33dd		       06		      .byte.b	6
      0  33de					      dw	CO
      1  33de		       cf 32		      .word.w	CO
      0  33e0					      IJMP	STMT	;Next Statement
      0  33e0					      db	29
      1  33e0		       1d		      .byte.b	29
      0  33e1					      dw	STMT
      1  33e1		       d7 32		      .word.w	STMT
    352  33e3
    353  33e3				   UNKNOWNLnk
      0  33e3					      iJMP	UNKNOWN
      0  33e3					      db	29
      1  33e3		       1d		      .byte.b	29
      0  33e4					      dw	UNKNOWN
      1  33e4		       ec 34		      .word.w	UNKNOWN
    355  33e6
    356  33e6							;
    357  33e6							;===========================================================
    358  33e6							; Update a memory location with a value
    359  33e6							;  Use @[offset] to write a word value to memory
    360  33e6							;
    361  33e6							;S8a1:
    362  33e6							;	  TSTB	      S8b,kPoke 			  ; Poke a value into memory
    363  33e6				   ekPoke
      0  33e6					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  33e6					      db	101
      1  33e6		       65		      .byte.b	101
      0  33e7					      db	(UNKNOWNV-*)-1
      1  33e7		       a1		      .byte.b	(UNKNOWNV-*)-1
      0  33e8					      db	oLeftBracket
      1  33e8		       e0		      .byte.b	oLeftBracket
      0  33e9					      CALL	EXPR	; Get address to write to
      0  33e9					      db	28
      1  33e9		       1c		      .byte.b	28
      0  33ea					      dw	EXPR
      1  33ea		       f0 34		      .word.w	EXPR
      0  33ec					      TSTB	UNKNOWNV,oComma	; Must have a coma
      0  33ec					      db	101
      1  33ec		       65		      .byte.b	101
      0  33ed					      db	(UNKNOWNV-*)-1
      1  33ed		       9b		      .byte.b	(UNKNOWNV-*)-1
      0  33ee					      db	oComma
      1  33ee		       e2		      .byte.b	oComma
      0  33ef					      CALL	EXPR	; Get the value to poke
      0  33ef					      db	28
      1  33ef		       1c		      .byte.b	28
      0  33f0					      dw	EXPR
      1  33f0		       f0 34		      .word.w	EXPR
      0  33f2					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  33f2					      db	101
      1  33f2		       65		      .byte.b	101
      0  33f3					      db	(UNKNOWNV-*)-1
      1  33f3		       95		      .byte.b	(UNKNOWNV-*)-1
      0  33f4					      db	oRightBracket
      1  33f4		       e1		      .byte.b	oRightBracket
      0  33f5					      POKEMEM
      0  33f5					      db	47
      1  33f5		       2f		      .byte.b	47
      0  33f6					      DONE
      0  33f6					      db	1
      1  33f6		       01		      .byte.b	1
      0  33f7					      NXT	CO	;AND SEQUENCE TO NEXT
      0  33f7					      db	6
      1  33f7		       06		      .byte.b	6
      0  33f8					      dw	CO
      1  33f8		       cf 32		      .word.w	CO
      0  33fa					      IJMP	STMT
      0  33fa					      db	29
      1  33fa		       1d		      .byte.b	29
      0  33fb					      dw	STMT
      1  33fb		       d7 32		      .word.w	STMT
    373  33fd							;
    374  33fd							;================================================================
    375  33fd							; Set a block of memory to a value word or byte
    376  33fd							; SetMem(Value, Length, Destination)
    377  33fd				   ekSetMemB
      0  33fd					      CALL	ekSetMem
      0  33fd					      db	28
      1  33fd		       1c		      .byte.b	28
      0  33fe					      dw	ekSetMem
      1  33fe		       15 34		      .word.w	ekSetMem
      0  3400					      SETBLOCK	tByte	; set value as byte
      0  3400					      db	110
      1  3400		       6e		      .byte.b	110
      0  3401					      db	tByte
      1  3401		       a2		      .byte.b	tByte
      0  3402					      DONE
      0  3402					      db	1
      1  3402		       01		      .byte.b	1
      0  3403					      NXT	CO
      0  3403					      db	6
      1  3403		       06		      .byte.b	6
      0  3404					      dw	CO
      1  3404		       cf 32		      .word.w	CO
      0  3406					      IJMP	STMT
      0  3406					      db	29
      1  3406		       1d		      .byte.b	29
      0  3407					      dw	STMT
      1  3407		       d7 32		      .word.w	STMT
    383  3409
    384  3409				   ekSetMemW
      0  3409					      CALL	ekSetMem
      0  3409					      db	28
      1  3409		       1c		      .byte.b	28
      0  340a					      dw	ekSetMem
      1  340a		       15 34		      .word.w	ekSetMem
      0  340c					      SETBLOCK	tInteger	; set value as byte
      0  340c					      db	110
      1  340c		       6e		      .byte.b	110
      0  340d					      db	tInteger
      1  340d		       a4		      .byte.b	tInteger
      0  340e					      DONE
      0  340e					      db	1
      1  340e		       01		      .byte.b	1
      0  340f					      NXT	CO
      0  340f					      db	6
      1  340f		       06		      .byte.b	6
      0  3410					      dw	CO
      1  3410		       cf 32		      .word.w	CO
      0  3412					      IJMP	STMT
      0  3412					      db	29
      1  3412		       1d		      .byte.b	29
      0  3413					      dw	STMT
      1  3413		       d7 32		      .word.w	STMT
    390  3415
    391  3415				   ekSetMem
      0  3415					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  3415					      db	101
      1  3415		       65		      .byte.b	101
      0  3416					      db	(UNKNOWNV-*)-1
      1  3416		       72		      .byte.b	(UNKNOWNV-*)-1
      0  3417					      db	oLeftBracket
      1  3417		       e0		      .byte.b	oLeftBracket
      0  3418					      CALL	EXPR	; Value to set
      0  3418					      db	28
      1  3418		       1c		      .byte.b	28
      0  3419					      dw	EXPR
      1  3419		       f0 34		      .word.w	EXPR
      0  341b					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  341b					      db	101
      1  341b		       65		      .byte.b	101
      0  341c					      db	(UNKNOWNV-*)-1
      1  341c		       6c		      .byte.b	(UNKNOWNV-*)-1
      0  341d					      db	oComma
      1  341d		       e2		      .byte.b	oComma
      0  341e					      CALL	EXPR	; Get The Length
      0  341e					      db	28
      1  341e		       1c		      .byte.b	28
      0  341f					      dw	EXPR
      1  341f		       f0 34		      .word.w	EXPR
      0  3421					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  3421					      db	101
      1  3421		       65		      .byte.b	101
      0  3422					      db	(UNKNOWNV-*)-1
      1  3422		       66		      .byte.b	(UNKNOWNV-*)-1
      0  3423					      db	oComma
      1  3423		       e2		      .byte.b	oComma
      0  3424					      CALL	EXPR	; GET the address to start at
      0  3424					      db	28
      1  3424		       1c		      .byte.b	28
      0  3425					      dw	EXPR
      1  3425		       f0 34		      .word.w	EXPR
      0  3427					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  3427					      db	101
      1  3427		       65		      .byte.b	101
      0  3428					      db	(UNKNOWNV-*)-1
      1  3428		       60		      .byte.b	(UNKNOWNV-*)-1
      0  3429					      db	oRightBracket
      1  3429		       e1		      .byte.b	oRightBracket
      0  342a					      RTN
      0  342a					      db	25
      1  342a		       19		      .byte.b	25
    400  342b							;
    401  342b							;================================================================
    402  342b							; Copy a block of memory
    403  342b							; CopyMem(Length, Destination, Source)
    404  342b				   ekCopyMem
      0  342b					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  342b					      db	101
      1  342b		       65		      .byte.b	101
      0  342c					      db	(UNKNOWNV-*)-1
      1  342c		       5c		      .byte.b	(UNKNOWNV-*)-1
      0  342d					      db	oLeftBracket
      1  342d		       e0		      .byte.b	oLeftBracket
      0  342e					      CALL	EXPR	; Length
      0  342e					      db	28
      1  342e		       1c		      .byte.b	28
      0  342f					      dw	EXPR
      1  342f		       f0 34		      .word.w	EXPR
      0  3431					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  3431					      db	101
      1  3431		       65		      .byte.b	101
      0  3432					      db	(UNKNOWNV-*)-1
      1  3432		       56		      .byte.b	(UNKNOWNV-*)-1
      0  3433					      db	oComma
      1  3433		       e2		      .byte.b	oComma
      0  3434					      CALL	EXPR	; Destination
      0  3434					      db	28
      1  3434		       1c		      .byte.b	28
      0  3435					      dw	EXPR
      1  3435		       f0 34		      .word.w	EXPR
      0  3437					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  3437					      db	101
      1  3437		       65		      .byte.b	101
      0  3438					      db	(UNKNOWNV-*)-1
      1  3438		       50		      .byte.b	(UNKNOWNV-*)-1
      0  3439					      db	oComma
      1  3439		       e2		      .byte.b	oComma
      0  343a					      CALL	EXPR	; Source
      0  343a					      db	28
      1  343a		       1c		      .byte.b	28
      0  343b					      dw	EXPR
      1  343b		       f0 34		      .word.w	EXPR
      0  343d					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  343d					      db	101
      1  343d		       65		      .byte.b	101
      0  343e					      db	(UNKNOWNV-*)-1
      1  343e		       4a		      .byte.b	(UNKNOWNV-*)-1
      0  343f					      db	oRightBracket
      1  343f		       e1		      .byte.b	oRightBracket
      0  3440					      COPYBLOCK		; Copy the memory
      0  3440					      db	111
      1  3440		       6f		      .byte.b	111
      0  3441					      DONE
      0  3441					      db	1
      1  3441		       01		      .byte.b	1
      0  3442					      NXT	CO
      0  3442					      db	6
      1  3442		       06		      .byte.b	6
      0  3443					      dw	CO
      1  3443		       cf 32		      .word.w	CO
      0  3445					      IJMP	STMT
      0  3445					      db	29
      1  3445		       1d		      .byte.b	29
      0  3446					      dw	STMT
      1  3446		       d7 32		      .word.w	STMT
    416  3448
    417  3448							;================================================================
    418  3448							; Write a single byte to the output device
    419  3448							;
    420  3448				   ekPutch
      0  3448					      CALL	EXPR
      0  3448					      db	28
      1  3448		       1c		      .byte.b	28
      0  3449					      dw	EXPR
      1  3449		       f0 34		      .word.w	EXPR
      0  344b					      PUTCHAR
      0  344b					      db	52
      1  344b		       34		      .byte.b	52
      0  344c					      DONE
      0  344c					      db	1
      1  344c		       01		      .byte.b	1
      0  344d					      NXT	CO	;AND SEQUENCE TO NEXT
      0  344d					      db	6
      1  344d		       06		      .byte.b	6
      0  344e					      dw	CO
      1  344e		       cf 32		      .word.w	CO
      0  3450					      IJMP	STMT
      0  3450					      db	29
      1  3450		       1d		      .byte.b	29
      0  3451					      dw	STMT
      1  3451		       d7 32		      .word.w	STMT
    426  3453							;================================================================
    427  3453							; Clear the screen lines
    428  3453							;  Uses the vt100 control seq, so must be connected to vt100 terminal
    429  3453							;
    430  3453				   ekCls
      0  3453					      CLEARSCREEN
      0  3453					      db	46
      1  3453		       2e		      .byte.b	46
      0  3454					      NXT	CO	;AND SEQUENCE TO NEXT
      0  3454					      db	6
      1  3454		       06		      .byte.b	6
      0  3455					      dw	CO
      1  3455		       cf 32		      .word.w	CO
      0  3457					      IJMP	STMT
      0  3457					      db	29
      1  3457		       1d		      .byte.b	29
      0  3458					      dw	STMT
      1  3458		       d7 32		      .word.w	STMT
    434  345a							;==================================================================
    435  345a							; Get input from the terminal
    436  345a							;   Reads from the currently active input device
    437  345a							;
    438  345a				   ekInput
    439  345a				   S10
      0  345a					      TSTB	S10A,tString	;If there is a string print the prompt
      0  345a					      db	101
      1  345a		       65		      .byte.b	101
      0  345b					      db	(S10A-*)-1
      1  345b		       05		      .byte.b	(S10A-*)-1
      0  345c					      db	tString
      1  345c		       a0		      .byte.b	tString
      0  345d					      PRS
      0  345d					      db	2
      1  345d		       02		      .byte.b	2
      0  345e					      TSTB	S10Z,oSemiColon	;Must follow the prompt
      0  345e					      db	101
      1  345e		       65		      .byte.b	101
      0  345f					      db	(S10Z-*)-1
      1  345f		       1e		      .byte.b	(S10Z-*)-1
      0  3460					      db	oSemiColon
      1  3460		       e3		      .byte.b	oSemiColon
    443  3461				   S10A
      0  3461					      TSTB	InNoString,oDollar	; Check if we are reading characters
      0  3461					      db	101
      1  3461		       65		      .byte.b	101
      0  3462					      db	(InNoString-*)-1
      1  3462		       0c		      .byte.b	(InNoString-*)-1
      0  3463					      db	oDollar
      1  3463		       e7		      .byte.b	oDollar
      0  3464					      TSTV	UNKNOWN
      0  3464					      db	33
      1  3464		       21		      .byte.b	33
      0  3465					      db	(UNKNOWN-*)-1
      1  3465		       86		      .byte.b	(UNKNOWN-*)-1
      0  3466					      CALL	FactVarPtrNoTst
      0  3466					      db	28
      1  3466		       1c		      .byte.b	28
      0  3467					      dw	FactVarPtrNoTst
      1  3467		       a0 36		      .word.w	FactVarPtrNoTst
      0  3469					      INSTR		;Move character From tty to AESTK
      0  3469					      db	59
      1  3469		       3b		      .byte.b	59
      0  346a					      SETR2	tByte
      0  346a					      db	94
      1  346a		       5e		      .byte.b	94
      0  346b					      db	tByte
      1  346b		       a2		      .byte.b	tByte
      0  346c					      IJMP	S10A2
      0  346c					      db	29
      1  346c		       1d		      .byte.b	29
      0  346d					      dw	S10A2
      1  346d		       77 34		      .word.w	S10A2
    450  346f
    451  346f				   InNoString
      0  346f					      TSTV	UNKNOWN	; GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  346f					      db	33
      1  346f		       21		      .byte.b	33
      0  3470					      db	(UNKNOWN-*)-1
      1  3470		       7b		      .byte.b	(UNKNOWN-*)-1
      0  3471					      CALL	FactVarPtrNoTst
      0  3471					      db	28
      1  3471		       1c		      .byte.b	28
      0  3472					      dw	FactVarPtrNoTst
      1  3472		       a0 36		      .word.w	FactVarPtrNoTst
      0  3474					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  3474					      db	11
      1  3474		       0b		      .byte.b	11
      0  3475					      SETR2	tInteger
      0  3475					      db	94
      1  3475		       5e		      .byte.b	94
      0  3476					      db	tInteger
      1  3476		       a4		      .byte.b	tInteger
    456  3477
    457  3477				   S10A2
      0  3477					      STORE		;STORE IT
      0  3477					      db	19
      1  3477		       13		      .byte.b	19
      0  3478					      TSTB	S11,oComma	;IS THERE MORE?
      0  3478					      db	101
      1  3478		       65		      .byte.b	101
      0  3479					      db	(S11-*)-1
      1  3479		       07		      .byte.b	(S11-*)-1
      0  347a					      db	oComma
      1  347a		       e2		      .byte.b	oComma
      0  347b					      IJMP	S10	;YES
      0  347b					      db	29
      1  347b		       1d		      .byte.b	29
      0  347c					      dw	S10
      1  347c		       5a 34		      .word.w	S10
    461  347e				   S10Z
      0  347e					      iJMP	UNKNOWN
      0  347e					      db	29
      1  347e		       1d		      .byte.b	29
      0  347f					      dw	UNKNOWN
      1  347f		       ec 34		      .word.w	UNKNOWN
    463  3481				   S11
      0  3481					      DONE		;MUST BE CR
      0  3481					      db	1
      1  3481		       01		      .byte.b	1
      0  3482					      NXT	CO	;SEQUENCE TO NEXT
      0  3482					      db	6
      1  3482		       06		      .byte.b	6
      0  3483					      dw	CO
      1  3483		       cf 32		      .word.w	CO
      0  3485					      IJMP	STMT
      0  3485					      db	29
      1  3485		       1d		      .byte.b	29
      0  3486					      dw	STMT
      1  3486		       d7 32		      .word.w	STMT
    467  3488							;=====================================================================
    468  3488							; End of program, return to command line process
    469  3488							; Main Task may also use taske or return to stopped
    470  3488							;
    471  3488				   ekEnd
      0  3488					      FIN
      0  3488					      db	12
      1  3488		       0c		      .byte.b	12
    473  3489				   UNKNOWNV
      0  3489					      IJMP	UNKNOWN
      0  3489					      db	29
      1  3489		       1d		      .byte.b	29
      0  348a					      dw	UNKNOWN
      1  348a		       ec 34		      .word.w	UNKNOWN
    475  348c							;====================================================================
    476  348c							; IRQ <IRQ-HANDLER-Line expression>
    477  348c							;   Specify a line number subroutine to call when an interupt is processed
    478  348c							;   These subroutines must use iret to return.
    479  348c							;
    480  348c				   ekIrq
      0  348c					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  348c					      db	28
      1  348c		       1c		      .byte.b	28
      0  348d					      dw	EXPR
      1  348d		       f0 34		      .word.w	EXPR
      0  348f					      DONE		;must be CR
      0  348f					      db	1
      1  348f		       01		      .byte.b	1
      0  3490					      SETIRQ		;Set the line number now
      0  3490					      db	56
      1  3490		       38		      .byte.b	56
      0  3491					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  3491					      db	6
      1  3491		       06		      .byte.b	6
      0  3492					      dw	CO
      1  3492		       cf 32		      .word.w	CO
      0  3494					      IJMP	STMT
      0  3494					      db	29
      1  3494		       1d		      .byte.b	29
      0  3495					      dw	STMT
      1  3495		       d7 32		      .word.w	STMT
    486  3497
    487  3497							;=========================================================================
    488  3497							; KILL PID-expression	 kill a running task
    489  3497							;  ignored of task has already stopped
    490  3497							;
    491  3497				   ekKill
      0  3497					      CALL	EXPR
      0  3497					      db	28
      1  3497		       1c		      .byte.b	28
      0  3498					      dw	EXPR
      1  3498		       f0 34		      .word.w	EXPR
      0  349a					      DONE
      0  349a					      db	1
      1  349a		       01		      .byte.b	1
      0  349b					      TASKKILL
      0  349b					      db	65
      1  349b		       41		      .byte.b	65
      0  349c					      NXT	CO
      0  349c					      db	6
      1  349c		       06		      .byte.b	6
      0  349d					      dw	CO
      1  349d		       cf 32		      .word.w	CO
      0  349f					      IJMP	STMT
      0  349f					      db	29
      1  349f		       1d		      .byte.b	29
      0  34a0					      dw	STMT
      1  34a0		       d7 32		      .word.w	STMT
    497  34a2
    498  34a2							;============================================================================
    499  34a2							; List all program lines
    500  34a2							;
    501  34a2				   ekList
      0  34a2					      DONE
      0  34a2					      db	1
      1  34a2		       01		      .byte.b	1
      0  34a3					      LST
      0  34a3					      db	21
      1  34a3		       15		      .byte.b	21
      0  34a4					      IJMP	CO
      0  34a4					      db	29
      1  34a4		       1d		      .byte.b	29
      0  34a5					      dw	CO
      1  34a5		       cf 32		      .word.w	CO
    505  34a7							;=======================================================================
    506  34a7							;RUN begin to executed the program in memory
    507  34a7							;
    508  34a7				   ekRun
      0  34a7					      DONE
      0  34a7					      db	1
      1  34a7		       01		      .byte.b	1
      0  34a8					      VINIT		;clear variables compile the line numbers
      0  34a8					      db	30
      1  34a8		       1e		      .byte.b	30
      0  34a9					      LIT	1	;GOTO line 1
      0  34a9					      db	27
      1  34a9		       1b		      .byte.b	27
      0  34aa					      dw	1
      1  34aa		       01 00		      .word.w	1
      0  34ac					      XFER		;Bob's addition
      0  34ac					      db	7
      1  34ac		       07		      .byte.b	7
    513  34ad							; EXIT
      0  34ad					      IJMP	STMT	;and run!
      0  34ad					      db	29
      1  34ad		       1d		      .byte.b	29
      0  34ae					      dw	STMT
      1  34ae		       d7 32		      .word.w	STMT
    515  34b0							;=========================================================================
    516  34b0							;Clear the program memory, delete all proram lines
    517  34b0							;
    518  34b0				   ekNew
      0  34b0					      DONE
      0  34b0					      db	1
      1  34b0		       01		      .byte.b	1
      0  34b1					      IJMP	START
      0  34b1					      db	29
      1  34b1		       1d		      .byte.b	29
      0  34b2					      dw	START
      1  34b2		       c9 32		      .word.w	START
    521  34b4
    522  34b4							;========================================================================
    523  34b4							; Slice(slice legth expression)
    524  34b4							;   set the length of time between task switches
    525  34b4							;
    526  34b4				   ekSlice
      0  34b4					      CALL	EXPR
      0  34b4					      db	28
      1  34b4		       1c		      .byte.b	28
      0  34b5					      dw	EXPR
      1  34b5		       f0 34		      .word.w	EXPR
      0  34b7					      SLICE
      0  34b7					      db	100
      1  34b7		       64		      .byte.b	100
      0  34b8					      DONE
      0  34b8					      db	1
      1  34b8		       01		      .byte.b	1
      0  34b9					      NXT	CO
      0  34b9					      db	6
      1  34b9		       06		      .byte.b	6
      0  34ba					      dw	CO
      1  34ba		       cf 32		      .word.w	CO
      0  34bc					      IJMP	STMT
      0  34bc					      db	29
      1  34bc		       1d		      .byte.b	29
      0  34bd					      dw	STMT
      1  34bd		       d7 32		      .word.w	STMT
    532  34bf							;==========================================================================
    533  34bf							; Turn off and on the trace functions
    534  34bf							; a debug terminal needs to be available
    535  34bf							; Trace( Trace flag expression)
    536  34bf							;	128 trace IL code, 64 trace basic code, 1 turn on interactive debug
    537  34bf							;	for individual lines of basic code. These can be combined
    538  34bf				   ekTrace
      0  34bf					      TSTB	UNKNOWN,oLeftBracket	;Are we going to trace
      0  34bf					      db	101
      1  34bf		       65		      .byte.b	101
      0  34c0					      db	(UNKNOWN-*)-1
      1  34c0		       2b		      .byte.b	(UNKNOWN-*)-1
      0  34c1					      db	oLeftBracket
      1  34c1		       e0		      .byte.b	oLeftBracket
      0  34c2					      CALL	EXPR
      0  34c2					      db	28
      1  34c2		       1c		      .byte.b	28
      0  34c3					      dw	EXPR
      1  34c3		       f0 34		      .word.w	EXPR
      0  34c5					      TSTB	UNKNOWN,oRightBracket
      0  34c5					      db	101
      1  34c5		       65		      .byte.b	101
      0  34c6					      db	(UNKNOWN-*)-1
      1  34c6		       25		      .byte.b	(UNKNOWN-*)-1
      0  34c7					      db	oRightBracket
      1  34c7		       e1		      .byte.b	oRightBracket
      0  34c8					      TRACEPROGRAM
      0  34c8					      db	78
      1  34c8		       4e		      .byte.b	78
      0  34c9					      DONE
      0  34c9					      db	1
      1  34c9		       01		      .byte.b	1
      0  34ca					      NXT	CO
      0  34ca					      db	6
      1  34ca		       06		      .byte.b	6
      0  34cb					      dw	CO
      1  34cb		       cf 32		      .word.w	CO
      0  34cd					      IJMP	STMT
      0  34cd					      db	29
      1  34cd		       1d		      .byte.b	29
      0  34ce					      dw	STMT
      1  34ce		       d7 32		      .word.w	STMT
    546  34d0							;=====================================================================
    547  34d0							; Exit basic to machine monitor
    548  34d0							;
    549  34d0				   ekExit
      0  34d0					      EXIT
      0  34d0					      db	26
      1  34d0		       1a		      .byte.b	26
    551  34d1
    552  34d1							;=======================================================================
    553  34d1							; Commands related to saving/restoring programs
    554  34d1							; to/from mass storage.
    555  34d1							;=======================================================================
    556  34d1							; Save a program file
    557  34d1							;
    558  34d1					      if	(XKIM || CTMON65) && DISK_ACCESS
    559  34d1
    560  34d1				   ekSave
      0  34d1					      OPENWRITE	OPEN_CREATE
      0  34d1					      db	40
      1  34d1		       28		      .byte.b	40
      0  34d2					      db	OPEN_CREATE
      1  34d2		       01		      .byte.b	OPEN_CREATE
      0  34d3					      DLIST
      0  34d3					      db	43
      1  34d3		       2b		      .byte.b	43
      0  34d4					      DCLOSE
      0  34d4					      db	41
      1  34d4		       29		      .byte.b	41
      0  34d5					      IJMP	CO
      0  34d5					      db	29
      1  34d5		       1d		      .byte.b	29
      0  34d6					      dw	CO
      1  34d6		       cf 32		      .word.w	CO
    565  34d8							;=========================================================================
    566  34d8							; Load a program file
    567  34d8							;
    568  34d8				   ekLoad
      0  34d8					      OPENREAD
      0  34d8					      db	39
      1  34d8		       27		      .byte.b	39
    570  34d9				   S17CLP
      0  34d9					      DGETLINE		;get line from file
      0  34d9					      db	42
      1  34d9		       2a		      .byte.b	42
      0  34da					      TSTL	S17EOL	;no line num means EOL
      0  34da					      db	34
      1  34da		       22		      .byte.b	34
      0  34db					      db	(S17EOL-*)-1
      1  34db		       04		      .byte.b	(S17EOL-*)-1
      0  34dc					      INSERT		;put it into the program
      0  34dc					      db	24
      1  34dc		       18		      .byte.b	24
      0  34dd					      IJMP	S17CLP	;keep going
      0  34dd					      db	29
      1  34dd		       1d		      .byte.b	29
      0  34de					      dw	S17CLP
      1  34de		       d9 34		      .word.w	S17CLP
    575  34e0				   S17EOL
      0  34e0					      DCLOSE		;close disk file
      0  34e0					      db	41
      1  34e0		       29		      .byte.b	41
      0  34e1					      IJMP	CO	;back to start
      0  34e1					      db	29
      1  34e1		       1d		      .byte.b	29
      0  34e2					      dw	CO
      1  34e2		       cf 32		      .word.w	CO
    578  34e4							;=========================================================================
    579  34e4							; Display the directory content
    580  34e4							;
    581  34e4				   ekDir
      0  34e4					      DDIR		;Display the directory content
      0  34e4					      db	44
      1  34e4		       2c		      .byte.b	44
      0  34e5					      IJMP	CO
      0  34e5					      db	29
      1  34e5		       1d		      .byte.b	29
      0  34e6					      dw	CO
      1  34e6		       cf 32		      .word.w	CO
    584  34e8							;=========================================================================
    585  34e8							; Erase a file from disk
    586  34e8							;
    587  34e8				   ekErase
      0  34e8					      RMFILE		;Erase the file from the disk
      0  34e8					      db	45
      1  34e8		       2d		      .byte.b	45
      0  34e9					      IJMP	CO
      0  34e9					      db	29
      1  34e9		       1d		      .byte.b	29
      0  34ea					      dw	CO
      1  34ea		       cf 32		      .word.w	CO
    590  34ec
    591  34ec					      endif
    592  34ec
    593  34ec							;===========================================================================
    594  34ec							; Else, unknown command.
    595  34ec							;
    596  34ec				   UNKNOWN
      0  34ec					      ENDIO
      0  34ec					      db	71
      1  34ec		       47		      .byte.b	71
    598  34ed
    599  34ed				   NotKnownStatement
    600  34ed
      0  34ed					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  34ed					      db	13
      1  34ed		       0d		      .byte.b	13
      0  34ee					      dw	ERR_SYNTAX
      1  34ee		       05 00		      .word.w	ERR_SYNTAX
    602  34f0
    603  34f0							;=======================================================
    604  34f0							; Process Expresions, precidence is represented by the
    605  34f0							; various call levels
    606  34f0							;
    607  34f0				   EXPR
      0  34f0					      TSTB	EXPRLOGS,kNot
      0  34f0					      db	101
      1  34f0		       65		      .byte.b	101
      0  34f1					      db	(EXPRLOGS-*)-1
      1  34f1		       06		      .byte.b	(EXPRLOGS-*)-1
      0  34f2					      db	kNot
      1  34f2		       29		      .byte.b	kNot
    609  34f3				   ekNot
      0  34f3					      Call	EXPR
      0  34f3					      db	28
      1  34f3		       1c		      .byte.b	28
      0  34f4					      dw	EXPR
      1  34f4		       f0 34		      .word.w	EXPR
      0  34f6					      LOGNOT
      0  34f6					      db	72
      1  34f6		       48		      .byte.b	72
      0  34f7					      RTN
      0  34f7					      db	25
      1  34f7		       19		      .byte.b	25
    613  34f8
    614  34f8							;=========================================================
    615  34f8							;Look for logical operators, but does get first part of expression
    616  34f8				   EXPRLOGS
      0  34f8					      Call	EXPR2	; get the left first expression
      0  34f8					      db	28
      1  34f8		       1c		      .byte.b	28
      0  34f9					      dw	EXPR2
      1  34f9		       27 35		      .word.w	EXPR2
      0  34fb					      TSTRELOP	EXPSHIFT	; Exit level if no rel ops found
      0  34fb					      db	104
      1  34fb		       68		      .byte.b	104
      0  34fc					      db	(EXPSHIFT-*)-1
      1  34fc		       05		      .byte.b	(EXPSHIFT-*)-1
    619  34fd							;	  TSTB	     iR0,oEqual
    620  34fd							;	  LIT	     2		     ;=
    621  34fd							;	  IJMP	     iRFound
    622  34fd							;iR0:
    623  34fd							;	  TSTB	      iR1,oLessEqual
    624  34fd							;	  LIT	      3 	      ;<=
    625  34fd							;	  IJMP	     iRFound
    626  34fd							;iR1:
    627  34fd							;	  TSTB	     iR3,oNotEqual
    628  34fd							;	  LIT	     5		      ;<>
    629  34fd							;	      IJMP	  iRFound
    630  34fd							;iR3:
    631  34fd							;	  TSTB	     iR4,oLess
    632  34fd							;	  LIT	     1		     ;<
    633  34fd							;	      IJMP	  iRFound
    634  34fd							;iR4:
    635  34fd							;	  TST	     iR5,oGreaterEqual
    636  34fd							;	  LIT	     6		     ;>=
    637  34fd							;	      IJMP	  iRFound
    638  34fd							;iR5:
    639  34fd							;	  TSTB	     iRDone,oGreater
    640  34fd							;	  LIT	     4		     ;>
    641  34fd				   iRFound
      0  34fd					      Call	EXPR2	; EXPR; get the right side of the expression
      0  34fd					      db	28
      1  34fd		       1c		      .byte.b	28
      0  34fe					      dw	EXPR2
      1  34fe		       27 35		      .word.w	EXPR2
      0  3500					      CMPR		; Push the value of the true false onto the stack
      0  3500					      db	10
      1  3500		       0a		      .byte.b	10
      0  3501					      RTN
      0  3501					      db	25
      1  3501		       19		      .byte.b	25
    645  3502
    646  3502							;=========================================================
    647  3502							;Look for shift left and shift right level
    648  3502				   EXPSHIFT
      0  3502					      OnGoto	BasicShift,EXPRLOGICAL
      0  3502					      db	103
      1  3502		       67		      .byte.b	103
      0  3503					      dw	BasicShift
      1  3503		       9d 32		      .word.w	BasicShift
      0  3505					      dw	EXPRLOGICAL
      1  3505		       13 35		      .word.w	EXPRLOGICAL
    650  3507
    651  3507				   ekShiftLeft
      0  3507					      Call	EXPR
      0  3507					      db	28
      1  3507		       1c		      .byte.b	28
      0  3508					      dw	EXPR
      1  3508		       f0 34		      .word.w	EXPR
      0  350a					      SHIFT	0
      0  350a					      db	113
      1  350a		       71		      .byte.b	113
      0  350b					      db	0
      1  350b		       00		      .byte.b	0
      0  350c					      RTN
      0  350c					      db	25
      1  350c		       19		      .byte.b	25
    655  350d
    656  350d				   ekShiftRight
      0  350d					      Call	EXPR
      0  350d					      db	28
      1  350d		       1c		      .byte.b	28
      0  350e					      dw	EXPR
      1  350e		       f0 34		      .word.w	EXPR
      0  3510					      SHIFT	1
      0  3510					      db	113
      1  3510		       71		      .byte.b	113
      0  3511					      db	1
      1  3511		       01		      .byte.b	1
      0  3512					      RTN
      0  3512					      db	25
      1  3512		       19		      .byte.b	25
    660  3513
    661  3513							;======================================================================
    662  3513				   EXPRLOGICAL
      0  3513					      OnGoto	BasicLogical,iLOGExit
      0  3513					      db	103
      1  3513		       67		      .byte.b	103
      0  3514					      dw	BasicLogical
      1  3514		       95 32		      .word.w	BasicLogical
      0  3516					      dw	iLOGExit
      1  3516		       26 35		      .word.w	iLOGExit
    664  3518				   ekAnd
      0  3518					      Call	EXPR
      0  3518					      db	28
      1  3518		       1c		      .byte.b	28
      0  3519					      dw	EXPR
      1  3519		       f0 34		      .word.w	EXPR
      0  351b					      LOGAND
      0  351b					      db	74
      1  351b		       4a		      .byte.b	74
      0  351c					      RTN
      0  351c					      db	25
      1  351c		       19		      .byte.b	25
    668  351d				   ekOr
      0  351d					      Call	EXPR
      0  351d					      db	28
      1  351d		       1c		      .byte.b	28
      0  351e					      dw	EXPR
      1  351e		       f0 34		      .word.w	EXPR
      0  3520					      LOGOR
      0  3520					      db	73
      1  3520		       49		      .byte.b	73
      0  3521					      RTN
      0  3521					      db	25
      1  3521		       19		      .byte.b	25
    672  3522				   ekXor
      0  3522					      Call	EXPR
      0  3522					      db	28
      1  3522		       1c		      .byte.b	28
      0  3523					      dw	EXPR
      1  3523		       f0 34		      .word.w	EXPR
      0  3525					      LOGXOR
      0  3525					      db	75
      1  3525		       4b		      .byte.b	75
    675  3526				   iLOGExit
      0  3526					      RTN
      0  3526					      db	25
      1  3526		       19		      .byte.b	25
    677  3527
    678  3527							; get the right part of an expression
    679  3527				   EXPR2
      0  3527					      TSTB	E0,oMinus	; Look for leading - to negate term
      0  3527					      db	101
      1  3527		       65		      .byte.b	101
      0  3528					      db	(E0-*)-1
      1  3528		       08		      .byte.b	(E0-*)-1
      0  3529					      db	oMinus
      1  3529		       eb		      .byte.b	oMinus
      0  352a					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  352a					      db	28
      1  352a		       1c		      .byte.b	28
      0  352b					      dw	TERM
      1  352b		       4d 35		      .word.w	TERM
      0  352d					      NEG		; Make value negated
      0  352d					      db	16
      1  352d		       10		      .byte.b	16
      0  352e					      IJMP	E1	; We have Left term process operators next
      0  352e					      db	29
      1  352e		       1d		      .byte.b	29
      0  352f					      dw	E1
      1  352f		       37 35		      .word.w	E1
    684  3531				   E0
      0  3531					      TSTB	E1A,oPlus	; Look for a leading + for value and disgard it if found
      0  3531					      db	101
      1  3531		       65		      .byte.b	101
      0  3532					      db	(E1A-*)-1
      1  3532		       01		      .byte.b	(E1A-*)-1
      0  3533					      db	oPlus
      1  3533		       ea		      .byte.b	oPlus
    686  3534				   E1A
      0  3534					      CALL	TERM	; Get the left term if it was not negated
      0  3534					      db	28
      1  3534		       1c		      .byte.b	28
      0  3535					      dw	TERM
      1  3535		       4d 35		      .word.w	TERM
    688  3537				   E1
      0  3537					      TST	E2,oPlus	; Check if we are adding left term to something
      0  3537					      db	32
      1  3537		       20		      .byte.b	32
      0  3538					      db	(E2-*)-1
      1  3538		       09		      .byte.b	(E2-*)-1
      0  3539					      db	oPlus,0
      1  3539		       ea 00		      .byte.b	oPlus,0
      0  353b					      CALL	TERM	; if adding then get the right side term
      0  353b					      db	28
      1  353b		       1c		      .byte.b	28
      0  353c					      dw	TERM
      1  353c		       4d 35		      .word.w	TERM
      0  353e					      ADD		; Add it to left term
      0  353e					      db	14
      1  353e		       0e		      .byte.b	14
      0  353f					      IJMP	E1	; look for next + or -
      0  353f					      db	29
      1  353f		       1d		      .byte.b	29
      0  3540					      dw	E1
      1  3540		       37 35		      .word.w	E1
    693  3542				   E2
      0  3542					      TSTB	E3,oMinus	; Check if we are subtractig something
      0  3542					      db	101
      1  3542		       65		      .byte.b	101
      0  3543					      db	(E3-*)-1
      1  3543		       08		      .byte.b	(E3-*)-1
      0  3544					      db	oMinus
      1  3544		       eb		      .byte.b	oMinus
      0  3545					      CALL	TERM	; get right side to subtract Diffrence
      0  3545					      db	28
      1  3545		       1c		      .byte.b	28
      0  3546					      dw	TERM
      1  3546		       4d 35		      .word.w	TERM
      0  3548					      SUB		; Subtract the value
      0  3548					      db	15
      1  3548		       0f		      .byte.b	15
      0  3549					      IJMP	E1	; Look for next + or -
      0  3549					      db	29
      1  3549		       1d		      .byte.b	29
      0  354a					      dw	E1
      1  354a		       37 35		      .word.w	E1
    698  354c				   E3			; Finish processing the expression
      0  354c					      RTN		; We are finished processing the Expression
      0  354c					      db	25
      1  354c		       19		      .byte.b	25
    700  354d							;
    701  354d							; Get one of the terms of an expression
    702  354d							;
    703  354d				   TERM
      0  354d					      CALL	FACT	; Get a value
      0  354d					      db	28
      1  354d		       1c		      .byte.b	28
      0  354e					      dw	FACT
      1  354e		       72 35		      .word.w	FACT
    705  3550				   T0			; Check for higher precidence operators
      0  3550					      TSTB	T1,oMultiply	; Check for *
      0  3550					      db	101
      1  3550		       65		      .byte.b	101
      0  3551					      db	(T1-*)-1
      1  3551		       08		      .byte.b	(T1-*)-1
      0  3552					      db	oMultiply
      1  3552		       ee		      .byte.b	oMultiply
      0  3553					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  3553					      db	28
      1  3553		       1c		      .byte.b	28
      0  3554					      dw	FACT
      1  3554		       72 35		      .word.w	FACT
      0  3556					      MUL		; Multiply factors
      0  3556					      db	17
      1  3556		       11		      .byte.b	17
      0  3557					      IJMP	T0	; Check for * or /
      0  3557					      db	29
      1  3557		       1d		      .byte.b	29
      0  3558					      dw	T0
      1  3558		       50 35		      .word.w	T0
    710  355a				   T1
      0  355a					      TSTB	T2,oDivide	; Check for a division
      0  355a					      db	101
      1  355a		       65		      .byte.b	101
      0  355b					      db	(T2-*)-1
      1  355b		       08		      .byte.b	(T2-*)-1
      0  355c					      db	oDivide
      1  355c		       ec		      .byte.b	oDivide
      0  355d					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  355d					      db	28
      1  355d		       1c		      .byte.b	28
      0  355e					      dw	FACT
      1  355e		       72 35		      .word.w	FACT
      0  3560					      DIV		; do division
      0  3560					      db	18
      1  3560		       12		      .byte.b	18
      0  3561					      IJMP	T0	; check for more * or /
      0  3561					      db	29
      1  3561		       1d		      .byte.b	29
      0  3562					      dw	T0
      1  3562		       50 35		      .word.w	T0
    715  3564				   T2
      0  3564					      TSTB	T3,oModulo	; Check for a division
      0  3564					      db	101
      1  3564		       65		      .byte.b	101
      0  3565					      db	(T3-*)-1
      1  3565		       08		      .byte.b	(T3-*)-1
      0  3566					      db	oModulo
      1  3566		       ed		      .byte.b	oModulo
      0  3567					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  3567					      db	28
      1  3567		       1c		      .byte.b	28
      0  3568					      dw	FACT
      1  3568		       72 35		      .word.w	FACT
      0  356a					      MODULO		; do division for remainder
      0  356a					      db	60
      1  356a		       3c		      .byte.b	60
      0  356b					      IJMP	T0	; check for more * or / or %
      0  356b					      db	29
      1  356b		       1d		      .byte.b	29
      0  356c					      dw	T0
      1  356c		       50 35		      .word.w	T0
    720  356e				   T3			; Finish processing the Term
      0  356e					      RTN
      0  356e					      db	25
      1  356e		       19		      .byte.b	25
    722  356f
    723  356f				   UNKNOWNVEC
      0  356f					      IJMP	UNKNOWN
      0  356f					      db	29
      1  356f		       1d		      .byte.b	29
      0  3570					      dw	UNKNOWN
      1  3570		       ec 34		      .word.w	UNKNOWN
    725  3572
    726  3572							;=============================================================================================
    727  3572							; Factor an expression.  Always test for functions
    728  3572							; first or else they'll be confused for variables.
    729  3572							;
    730  3572				   FACT
      0  3572					      OnGoto	BasicFuncs,FactNumber
      0  3572					      db	103
      1  3572		       67		      .byte.b	103
      0  3573					      dw	BasicFuncs
      1  3573		       a3 32		      .word.w	BasicFuncs
      0  3575					      dw	FactNumber
      1  3575		       72 36		      .word.w	FactNumber
    732  3577
    733  3577							;FACTCONTINUE:
    734  3577							;	  TSTB	     F1AA,kTrue
    735  3577				   ekTrue
      0  3577					      LIT	-1
      0  3577					      db	27
      1  3577		       1b		      .byte.b	27
      0  3578					      dw	-1
      1  3578		       ff ff		      .word.w	-1
      0  357a					      RTN
      0  357a					      db	25
      1  357a		       19		      .byte.b	25
    738  357b							;F1AA:
    739  357b							;	  TSTB	     F1AB,kFalse
    740  357b				   ekFalse
      0  357b					      LIT	0
      0  357b					      db	27
      1  357b		       1b		      .byte.b	27
      0  357c					      dw	0
      1  357c		       00 00		      .word.w	0
      0  357e					      RTN
      0  357e					      db	25
      1  357e		       19		      .byte.b	25
    743  357f							;==================================================================================
    744  357f							; Returns the amount of free SPACE
    745  357f				   ekFree
      0  357f					      TSTB	UNKNOWNVEC,oLeftBracket
      0  357f					      db	101
      1  357f		       65		      .byte.b	101
      0  3580					      db	(UNKNOWNVEC-*)-1
      1  3580		       ee		      .byte.b	(UNKNOWNVEC-*)-1
      0  3581					      db	oLeftBracket
      1  3581		       e0		      .byte.b	oLeftBracket
      0  3582					      TSTB	UNKNOWNVEC,oRightBracket
      0  3582					      db	101
      1  3582		       65		      .byte.b	101
      0  3583					      db	(UNKNOWNVEC-*)-1
      1  3583		       eb		      .byte.b	(UNKNOWNVEC-*)-1
      0  3584					      db	oRightBracket
      1  3584		       e1		      .byte.b	oRightBracket
      0  3585					      FREE
      0  3585					      db	36
      1  3585		       24		      .byte.b	36
      0  3586					      RTN
      0  3586					      db	25
      1  3586		       19		      .byte.b	25
    750  3587							;===================================================================================
    751  3587							; getch() read a character from the input device
    752  3587							;
    753  3587				   ekGetch
      0  3587					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3587					      db	101
      1  3587		       65		      .byte.b	101
      0  3588					      db	(UNKNOWNVEC-*)-1
      1  3588		       e6		      .byte.b	(UNKNOWNVEC-*)-1
      0  3589					      db	oLeftBracket
      1  3589		       e0		      .byte.b	oLeftBracket
      0  358a					      TSTB	UNKNOWNVEC,oRightBracket
      0  358a					      db	101
      1  358a		       65		      .byte.b	101
      0  358b					      db	(UNKNOWNVEC-*)-1
      1  358b		       e3		      .byte.b	(UNKNOWNVEC-*)-1
      0  358c					      db	oRightBracket
      1  358c		       e1		      .byte.b	oRightBracket
      0  358d					      GETCHAR
      0  358d					      db	51
      1  358d		       33		      .byte.b	51
      0  358e					      RTN
      0  358e					      db	25
      1  358e		       19		      .byte.b	25
    758  358f							;
    759  358f							;====================================================================================
    760  358f							; addr(variable definition)
    761  358f							; Returns the address of a variable on top of the stack
    762  358f				   ekAddr
      0  358f					      TSTB	UNKNOWNVEC,oLeftBracket
      0  358f					      db	101
      1  358f		       65		      .byte.b	101
      0  3590					      db	(UNKNOWNVEC-*)-1
      1  3590		       de		      .byte.b	(UNKNOWNVEC-*)-1
      0  3591					      db	oLeftBracket
      1  3591		       e0		      .byte.b	oLeftBracket
      0  3592					      TSTV	ExpectedVariable
      0  3592					      db	33
      1  3592		       21		      .byte.b	33
      0  3593					      db	(ExpectedVariable-*)-1
      1  3593		       07		      .byte.b	(ExpectedVariable-*)-1
      0  3594					      CALL	FactVarPtrNoTst
      0  3594					      db	28
      1  3594		       1c		      .byte.b	28
      0  3595					      dw	FactVarPtrNoTst
      1  3595		       a0 36		      .word.w	FactVarPtrNoTst
      0  3597					      TSTB	UNKNOWNVEC,oRightBracket
      0  3597					      db	101
      1  3597		       65		      .byte.b	101
      0  3598					      db	(UNKNOWNVEC-*)-1
      1  3598		       d6		      .byte.b	(UNKNOWNVEC-*)-1
      0  3599					      db	oRightBracket
      1  3599		       e1		      .byte.b	oRightBracket
      0  359a					      RTN
      0  359a					      db	25
      1  359a		       19		      .byte.b	25
    768  359b
    769  359b				   ExpectedVariable
      0  359b					      ERRMSG	ERR_SYNTAX	;Expected Variable
      0  359b					      db	13
      1  359b		       0d		      .byte.b	13
      0  359c					      dw	ERR_SYNTAX
      1  359c		       05 00		      .word.w	ERR_SYNTAX
    771  359e							;
    772  359e							;================================================================
    773  359e							; Compare a block of memory
    774  359e							; CmpMem(Length, Source 1, Source 2)
    775  359e							; returns on the stack 0 equal, 1 s1>s2, -1 s1<s2
    776  359e				   ekCmpMem
      0  359e					      TSTB	UNKNOWNVEC,oLeftBracket	; opening bracket
      0  359e					      db	101
      1  359e		       65		      .byte.b	101
      0  359f					      db	(UNKNOWNVEC-*)-1
      1  359f		       cf		      .byte.b	(UNKNOWNVEC-*)-1
      0  35a0					      db	oLeftBracket
      1  35a0		       e0		      .byte.b	oLeftBracket
      0  35a1					      CALL	EXPR	; Length
      0  35a1					      db	28
      1  35a1		       1c		      .byte.b	28
      0  35a2					      dw	EXPR
      1  35a2		       f0 34		      .word.w	EXPR
      0  35a4					      TSTB	UNKNOWNVEC,oComma	; Must have a comma
      0  35a4					      db	101
      1  35a4		       65		      .byte.b	101
      0  35a5					      db	(UNKNOWNVEC-*)-1
      1  35a5		       c9		      .byte.b	(UNKNOWNVEC-*)-1
      0  35a6					      db	oComma
      1  35a6		       e2		      .byte.b	oComma
      0  35a7					      CALL	EXPR	; Source 1
      0  35a7					      db	28
      1  35a7		       1c		      .byte.b	28
      0  35a8					      dw	EXPR
      1  35a8		       f0 34		      .word.w	EXPR
      0  35aa					      TSTB	UNKNOWNVEC,oComma	; Must have a comma
      0  35aa					      db	101
      1  35aa		       65		      .byte.b	101
      0  35ab					      db	(UNKNOWNVEC-*)-1
      1  35ab		       c3		      .byte.b	(UNKNOWNVEC-*)-1
      0  35ac					      db	oComma
      1  35ac		       e2		      .byte.b	oComma
      0  35ad					      CALL	EXPR	; Source 2
      0  35ad					      db	28
      1  35ad		       1c		      .byte.b	28
      0  35ae					      dw	EXPR
      1  35ae		       f0 34		      .word.w	EXPR
      0  35b0					      TSTB	UNKNOWNVEC,oRightBracket	; closing bracket
      0  35b0					      db	101
      1  35b0		       65		      .byte.b	101
      0  35b1					      db	(UNKNOWNVEC-*)-1
      1  35b1		       bd		      .byte.b	(UNKNOWNVEC-*)-1
      0  35b2					      db	oRightBracket
      1  35b2		       e1		      .byte.b	oRightBracket
      0  35b3					      CMPMEM		; Compare the memory
      0  35b3					      db	112
      1  35b3		       70		      .byte.b	112
      0  35b4					      RTN
      0  35b4					      db	25
      1  35b4		       19		      .byte.b	25
    786  35b5							;
    787  35b5							;===============================================================================
    788  35b5							; Set/stop/return timer values
    789  35b5							;value 9 = 1 second, 1-5 = value * 10ms 6 = 10ms, 7=250ms, 8=500ms
    790  35b5							;cmd	0 =
    791  35b5				   eKTimer
      0  35b5					      TSTB	UNKNOWNVEC,oLeftBracket	; opening bracket
      0  35b5					      db	101
      1  35b5		       65		      .byte.b	101
      0  35b6					      db	(UNKNOWNVEC-*)-1
      1  35b6		       b8		      .byte.b	(UNKNOWNVEC-*)-1
      0  35b7					      db	oLeftBracket
      1  35b7		       e0		      .byte.b	oLeftBracket
      0  35b8					      CALL	EXPR	; purpose 0-4
      0  35b8					      db	28
      1  35b8		       1c		      .byte.b	28
      0  35b9					      dw	EXPR
      1  35b9		       f0 34		      .word.w	EXPR
      0  35bb					      TSTB	eKTimerZero,oComma	; Must have a comma if more than one value
      0  35bb					      db	101
      1  35bb		       65		      .byte.b	101
      0  35bc					      db	(eKTimerZero-*)-1
      1  35bc		       07		      .byte.b	(eKTimerZero-*)-1
      0  35bd					      db	oComma
      1  35bd		       e2		      .byte.b	oComma
      0  35be					      CALL	EXPR	; only used by set parameters
      0  35be					      db	28
      1  35be		       1c		      .byte.b	28
      0  35bf					      dw	EXPR
      1  35bf		       f0 34		      .word.w	EXPR
      0  35c1					      iJMP	eKTimerOut	; get out
      0  35c1					      db	29
      1  35c1		       1d		      .byte.b	29
      0  35c2					      dw	eKTimerOut
      1  35c2		       c7 35		      .word.w	eKTimerOut
    797  35c4				   eKTimerZero
      0  35c4					      lit	0	; no second parameter
      0  35c4					      db	27
      1  35c4		       1b		      .byte.b	27
      0  35c5					      dw	0
      1  35c5		       00 00		      .word.w	0
    799  35c7				   eKTimerOut
      0  35c7					      TSTB	UNKNOWNVEC,oRightBracket	; closing bracket
      0  35c7					      db	101
      1  35c7		       65		      .byte.b	101
      0  35c8					      db	(UNKNOWNVEC-*)-1
      1  35c8		       a6		      .byte.b	(UNKNOWNVEC-*)-1
      0  35c9					      db	oRightBracket
      1  35c9		       e1		      .byte.b	oRightBracket
      0  35ca					      Timer
      0  35ca					      db	114
      1  35ca		       72		      .byte.b	114
      0  35cb					      RTN
      0  35cb					      db	25
      1  35cb		       19		      .byte.b	25
    803  35cc
    804  35cc							;====================================================================================
    805  35cc							; peek(mem address) return the value of a byte in memory
    806  35cc							; @[offset] return a word value from offset -- see tstv
    807  35cc							;
    808  35cc							;F1A2:
    809  35cc							;	  TSTB	      F2AZ,kPeek		      ;Return a value from memory
    810  35cc				   ekPeek
      0  35cc					      TSTB	UNKNOWNVEC,oLeftBracket
      0  35cc					      db	101
      1  35cc		       65		      .byte.b	101
      0  35cd					      db	(UNKNOWNVEC-*)-1
      1  35cd		       a1		      .byte.b	(UNKNOWNVEC-*)-1
      0  35ce					      db	oLeftBracket
      1  35ce		       e0		      .byte.b	oLeftBracket
      0  35cf					      CALL	EXPR	;Get the address to write to
      0  35cf					      db	28
      1  35cf		       1c		      .byte.b	28
      0  35d0					      dw	EXPR
      1  35d0		       f0 34		      .word.w	EXPR
      0  35d2					      TSTB	UNKNOWNVEC,oRightBracket
      0  35d2					      db	101
      1  35d2		       65		      .byte.b	101
      0  35d3					      db	(UNKNOWNVEC-*)-1
      1  35d3		       9b		      .byte.b	(UNKNOWNVEC-*)-1
      0  35d4					      db	oRightBracket
      1  35d4		       e1		      .byte.b	oRightBracket
      0  35d5					      PEEKMEM
      0  35d5					      db	48
      1  35d5		       30		      .byte.b	48
      0  35d6					      RTN
      0  35d6					      db	25
      1  35d6		       19		      .byte.b	25
    816  35d7							;=======================================================================================
    817  35d7							; TASK(line-num expr,[Parm1,....]) start a task with or without Parameters
    818  35d7							;
    819  35d7							;F2AZ:
    820  35d7							;	  TSTB	      F2AZ1,kTask		      ;Check if we are setting a task start
    821  35d7				   ekTask
      0  35d7					      TSTBRANCH	ekTaskCompiled
      0  35d7					      db	106
      1  35d7		       6a		      .byte.b	106
      0  35d8					      db	(ekTaskCompiled-*)-1
      1  35d8		       0c		      .byte.b	(ekTaskCompiled-*)-1
      0  35d9					      TSTB	UNKNOWNVEC,oLeftBracket
      0  35d9					      db	101
      1  35d9		       65		      .byte.b	101
      0  35da					      db	(UNKNOWNVEC-*)-1
      1  35da		       94		      .byte.b	(UNKNOWNVEC-*)-1
      0  35db					      db	oLeftBracket
      1  35db		       e0		      .byte.b	oLeftBracket
      0  35dc					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  35dc					      db	28
      1  35dc		       1c		      .byte.b	28
      0  35dd					      dw	EXPR
      1  35dd		       f0 34		      .word.w	EXPR
      0  35df					      lit	0
      0  35df					      db	27
      1  35df		       1b		      .byte.b	27
      0  35e0					      dw	0
      1  35e0		       00 00		      .word.w	0
      0  35e2					      iJMP	ekTaskLinenum
      0  35e2					      db	29
      1  35e2		       1d		      .byte.b	29
      0  35e3					      dw	ekTaskLinenum
      1  35e3		       e8 35		      .word.w	ekTaskLinenum
    827  35e5
    828  35e5				   ekTaskCompiled
      0  35e5					      lit	1
      0  35e5					      db	27
      1  35e5		       1b		      .byte.b	27
      0  35e6					      dw	1
      1  35e6		       01 00		      .word.w	1
    830  35e8
    831  35e8				   ekTaskLinenum
      0  35e8					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  35e8					      db	61
      1  35e8		       3d		      .byte.b	61
      0  35e9					      TSTB	F2AZNoParms,oComma	;Parameters to be passed to task
      0  35e9					      db	101
      1  35e9		       65		      .byte.b	101
      0  35ea					      db	(F2AZNoParms-*)-1
      1  35ea		       0e		      .byte.b	(F2AZNoParms-*)-1
      0  35eb					      db	oComma
      1  35eb		       e2		      .byte.b	oComma
      0  35ec					      SAVEMATHSTACK		;Push The mathstack
      0  35ec					      db	86
      1  35ec		       56		      .byte.b	86
      0  35ed					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  35ed					      db	89
      1  35ed		       59		      .byte.b	89
    836  35ee
    837  35ee				   F2AZLOOP
      0  35ee					      CALL	EXPR
      0  35ee					      db	28
      1  35ee		       1c		      .byte.b	28
      0  35ef					      dw	EXPR
      1  35ef		       f0 34		      .word.w	EXPR
      0  35f1					      TSTB	F2AZEndParm,oComma	;Parameters to be passed tp task
      0  35f1					      db	101
      1  35f1		       65		      .byte.b	101
      0  35f2					      db	(F2AZEndParm-*)-1
      1  35f2		       04		      .byte.b	(F2AZEndParm-*)-1
      0  35f3					      db	oComma
      1  35f3		       e2		      .byte.b	oComma
      0  35f4					      IJMP	F2AZLOOP	;check for more
      0  35f4					      db	29
      1  35f4		       1d		      .byte.b	29
      0  35f5					      dw	F2AZLOOP
      1  35f5		       ee 35		      .word.w	F2AZLOOP
    841  35f7
    842  35f7				   F2AZEndParm
      0  35f7					      RESTOREMATHSTACK		;Back to normal stack
      0  35f7					      db	87
      1  35f7		       57		      .byte.b	87
      0  35f8					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  35f8					      db	92
      1  35f8		       5c		      .byte.b	92
    845  35f9
    846  35f9				   F2AZNoParms
      0  35f9					      TSTB	UNKNOWNVEC,oRightBracket	;must be )
      0  35f9					      db	101
      1  35f9		       65		      .byte.b	101
      0  35fa					      db	(UNKNOWNVEC-*)-1
      1  35fa		       74		      .byte.b	(UNKNOWNVEC-*)-1
      0  35fb					      db	oRightBracket
      1  35fb		       e1		      .byte.b	oRightBracket
    848  35fc
      0  35fc					      TASKENABLE		;Enable the task to execute
      0  35fc					      db	90
      1  35fc		       5a		      .byte.b	90
    850  35fd
      0  35fd					      RTN		;Returns the Task number
      0  35fd					      db	25
      1  35fd		       19		      .byte.b	25
    852  35fe							;=========================================================================================
    853  35fe							; Check for IPC interproccess instructions
    854  35fe							;   IPCS  - Send a message
    855  35fe							;
    856  35fe							;F2AZ1:
    857  35fe							;	  TSTB	      F2AZa,kIpcs		      ;Test if one of the IPC functions
    858  35fe				   ekIpcs
      0  35fe					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  35fe					      db	101
      1  35fe		       65		      .byte.b	101
      0  35ff					      db	(UNKNOWNVEC-*)-1
      1  35ff		       6f		      .byte.b	(UNKNOWNVEC-*)-1
      0  3600					      db	oLeftBracket
      1  3600		       e0		      .byte.b	oLeftBracket
      0  3601					      CALL	EXPR	;Get the message value
      0  3601					      db	28
      1  3601		       1c		      .byte.b	28
      0  3602					      dw	EXPR
      1  3602		       f0 34		      .word.w	EXPR
      0  3604					      TSTB	UNKNOWNVEC,oComma
      0  3604					      db	101
      1  3604		       65		      .byte.b	101
      0  3605					      db	(UNKNOWNVEC-*)-1
      1  3605		       69		      .byte.b	(UNKNOWNVEC-*)-1
      0  3606					      db	oComma
      1  3606		       e2		      .byte.b	oComma
      0  3607					      CALL	EXPR	;Get pid of task to send to
      0  3607					      db	28
      1  3607		       1c		      .byte.b	28
      0  3608					      dw	EXPR
      1  3608		       f0 34		      .word.w	EXPR
      0  360a					      TSTB	UNKNOWNVEC,oRightBracket
      0  360a					      db	101
      1  360a		       65		      .byte.b	101
      0  360b					      db	(UNKNOWNVEC-*)-1
      1  360b		       63		      .byte.b	(UNKNOWNVEC-*)-1
      0  360c					      db	oRightBracket
      1  360c		       e1		      .byte.b	oRightBracket
      0  360d					      IPCSEND		;Send msg and clear pid msg pending
      0  360d					      db	80
      1  360d		       50		      .byte.b	80
      0  360e					      RTN
      0  360e					      db	25
      1  360e		       19		      .byte.b	25
    866  360f							;================================================================================
    867  360f							; IPCR() --- recieve a message, IPCR(VARIABLE) -- receive msg and return pid in var
    868  360f							;
    869  360f				   ekIpcr
      0  360f					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  360f					      db	101
      1  360f		       65		      .byte.b	101
      0  3610					      db	(UNKNOWNVEC-*)-1
      1  3610		       5e		      .byte.b	(UNKNOWNVEC-*)-1
      0  3611					      db	oLeftBracket
      1  3611		       e0		      .byte.b	oLeftBracket
      0  3612					      TSTB	F2AZa1,oRightBracket
      0  3612					      db	101
      1  3612		       65		      .byte.b	101
      0  3613					      db	(F2AZa1-*)-1
      1  3613		       07		      .byte.b	(F2AZa1-*)-1
      0  3614					      db	oRightBracket
      1  3614		       e1		      .byte.b	oRightBracket
      0  3615					      LIT	0	;We dont want the pid returned to us
      0  3615					      db	27
      1  3615		       1b		      .byte.b	27
      0  3616					      dw	0
      1  3616		       00 00		      .word.w	0
      0  3618					      IJMP	ekIpcrComplete
      0  3618					      db	29
      1  3618		       1d		      .byte.b	29
      0  3619					      dw	ekIpcrComplete
      1  3619		       20 36		      .word.w	ekIpcrComplete
    874  361b				   F2AZa1
      0  361b					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  361b					      db	33
      1  361b		       21		      .byte.b	33
      0  361c					      db	(UNKNOWNVEC-*)-1
      1  361c		       52		      .byte.b	(UNKNOWNVEC-*)-1
      0  361d					      TSTB	UNKNOWNVEC,oRightBracket
      0  361d					      db	101
      1  361d		       65		      .byte.b	101
      0  361e					      db	(UNKNOWNVEC-*)-1
      1  361e		       50		      .byte.b	(UNKNOWNVEC-*)-1
      0  361f					      db	oRightBracket
      1  361f		       e1		      .byte.b	oRightBracket
    877  3620
    878  3620				   ekIpcrComplete
      0  3620					      IPCIO		;Set the io bit and exit task till message
      0  3620					      db	83
      1  3620		       53		      .byte.b	83
      0  3621					      IPCRECEIVE		;Get the message
      0  3621					      db	81
      1  3621		       51		      .byte.b	81
      0  3622					      RTN
      0  3622					      db	25
      1  3622		       19		      .byte.b	25
    882  3623							;===============================================================================
    883  3623							; IPCC ---- check if a message is available
    884  3623				   ekIpcc
      0  3623					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3623					      db	101
      1  3623		       65		      .byte.b	101
      0  3624					      db	(UNKNOWNVEC-*)-1
      1  3624		       4a		      .byte.b	(UNKNOWNVEC-*)-1
      0  3625					      db	oLeftBracket
      1  3625		       e0		      .byte.b	oLeftBracket
      0  3626					      TSTB	UNKNOWNVEC,oRightBracket
      0  3626					      db	101
      1  3626		       65		      .byte.b	101
      0  3627					      db	(UNKNOWNVEC-*)-1
      1  3627		       47		      .byte.b	(UNKNOWNVEC-*)-1
      0  3628					      db	oRightBracket
      1  3628		       e1		      .byte.b	oRightBracket
      0  3629					      IPCCHECK
      0  3629					      db	82
      1  3629		       52		      .byte.b	82
      0  362a					      RTN
      0  362a					      db	25
      1  362a		       19		      .byte.b	25
    889  362b
    890  362b				   UNKNOWNID
      0  362b					      IJMP	UNKNOWN
      0  362b					      db	29
      1  362b		       1d		      .byte.b	29
      0  362c					      dw	UNKNOWN
      1  362c		       ec 34		      .word.w	UNKNOWN
    892  362e							;============================================================
    893  362e							; RND() is supposed to have an argument but if none
    894  362e							; was provided, just assume a large value.
    895  362e							;
    896  362e				   ekRnd
      0  362e					      TSTB	UNKNOWNVEC,oLeftBracket
      0  362e					      db	101
      1  362e		       65		      .byte.b	101
      0  362f					      db	(UNKNOWNVEC-*)-1
      1  362f		       3f		      .byte.b	(UNKNOWNVEC-*)-1
      0  3630					      db	oLeftBracket
      1  3630		       e0		      .byte.b	oLeftBracket
      0  3631					      TSTB	F2A1,oRightBracket
      0  3631					      db	101
      1  3631		       65		      .byte.b	101
      0  3632					      db	(F2A1-*)-1
      1  3632		       06		      .byte.b	(F2A1-*)-1
      0  3633					      db	oRightBracket
      1  3633		       e1		      .byte.b	oRightBracket
      0  3634					      LIT	32766
      0  3634					      db	27
      1  3634		       1b		      .byte.b	27
      0  3635					      dw	32766
      1  3635		       fe 7f		      .word.w	32766
      0  3637					      RANDOM
      0  3637					      db	37
      1  3637		       25		      .byte.b	37
      0  3638					      RTN
      0  3638					      db	25
      1  3638		       19		      .byte.b	25
    902  3639
    903  3639				   F2A1
      0  3639					      CALL	EXPR	;GET RANGE
      0  3639					      db	28
      1  3639		       1c		      .byte.b	28
      0  363a					      dw	EXPR
      1  363a		       f0 34		      .word.w	EXPR
      0  363c					      TSTB	UNKNOWNVEC,oRightBracket
      0  363c					      db	101
      1  363c		       65		      .byte.b	101
      0  363d					      db	(UNKNOWNVEC-*)-1
      1  363d		       31		      .byte.b	(UNKNOWNVEC-*)-1
      0  363e					      db	oRightBracket
      1  363e		       e1		      .byte.b	oRightBracket
      0  363f					      RANDOM
      0  363f					      db	37
      1  363f		       25		      .byte.b	37
      0  3640					      RTN
      0  3640					      db	25
      1  3640		       19		      .byte.b	25
    908  3641							;==========================================================
    909  3641							;	Return absolute value of expresion
    910  3641							;
    911  3641				   ekAbs
      0  3641					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3641					      db	101
      1  3641		       65		      .byte.b	101
      0  3642					      db	(UNKNOWNVEC-*)-1
      1  3642		       2c		      .byte.b	(UNKNOWNVEC-*)-1
      0  3643					      db	oLeftBracket
      1  3643		       e0		      .byte.b	oLeftBracket
      0  3644					      CALL	EXPR	;get value
      0  3644					      db	28
      1  3644		       1c		      .byte.b	28
      0  3645					      dw	EXPR
      1  3645		       f0 34		      .word.w	EXPR
      0  3647					      TSTB	UNKNOWNVEC,oRightBracket
      0  3647					      db	101
      1  3647		       65		      .byte.b	101
      0  3648					      db	(UNKNOWNVEC-*)-1
      1  3648		       26		      .byte.b	(UNKNOWNVEC-*)-1
      0  3649					      db	oRightBracket
      1  3649		       e1		      .byte.b	oRightBracket
      0  364a					      ABS
      0  364a					      db	38
      1  364a		       26		      .byte.b	38
      0  364b					      RTN
      0  364b					      db	25
      1  364b		       19		      .byte.b	25
    917  364c							;============================================================
    918  364c							;     Return the the status of a task, provide the PID
    919  364c							;
    920  364c				   ekStat
      0  364c					      TSTB	UNKNOWNVEC,oLeftBracket
      0  364c					      db	101
      1  364c		       65		      .byte.b	101
      0  364d					      db	(UNKNOWNVEC-*)-1
      1  364d		       21		      .byte.b	(UNKNOWNVEC-*)-1
      0  364e					      db	oLeftBracket
      1  364e		       e0		      .byte.b	oLeftBracket
      0  364f					      Call	EXPR
      0  364f					      db	28
      1  364f		       1c		      .byte.b	28
      0  3650					      dw	EXPR
      1  3650		       f0 34		      .word.w	EXPR
      0  3652					      TSTB	UNKNOWNVEC,oRightBracket
      0  3652					      db	101
      1  3652		       65		      .byte.b	101
      0  3653					      db	(UNKNOWNVEC-*)-1
      1  3653		       1b		      .byte.b	(UNKNOWNVEC-*)-1
      0  3654					      db	oRightBracket
      1  3654		       e1		      .byte.b	oRightBracket
      0  3655					      TASKSTAT
      0  3655					      db	66
      1  3655		       42		      .byte.b	66
      0  3656					      RTN
      0  3656					      db	25
      1  3656		       19		      .byte.b	25
    926  3657							;==============================================================
    927  3657							; Return the current tasks pid
    928  3657							;
    929  3657				   ekPid
      0  3657					      TASKPID
      0  3657					      db	77
      1  3657		       4d		      .byte.b	77
      0  3658					      RTN
      0  3658					      db	25
      1  3658		       19		      .byte.b	25
    932  3659							;===========================================================================
    933  3659							; Call a machine function, provide the address to call and optionally
    934  3659							; the value to be passed in reg A
    935  3659				   ekCall
      0  3659					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3659					      db	101
      1  3659		       65		      .byte.b	101
      0  365a					      db	(UNKNOWNVEC-*)-1
      1  365a		       14		      .byte.b	(UNKNOWNVEC-*)-1
      0  365b					      db	oLeftBracket
      1  365b		       e0		      .byte.b	oLeftBracket
      0  365c					      CALL	EXPR
      0  365c					      db	28
      1  365c		       1c		      .byte.b	28
      0  365d					      dw	EXPR
      1  365d		       f0 34		      .word.w	EXPR
      0  365f					      TSTB	F2B2A,oComma
      0  365f					      db	101
      1  365f		       65		      .byte.b	101
      0  3660					      db	(F2B2A-*)-1
      1  3660		       09		      .byte.b	(F2B2A-*)-1
      0  3661					      db	oComma
      1  3661		       e2		      .byte.b	oComma
      0  3662					      CALL	EXPR
      0  3662					      db	28
      1  3662		       1c		      .byte.b	28
      0  3663					      dw	EXPR
      1  3663		       f0 34		      .word.w	EXPR
      0  3665					      TSTB	UNKNOWNVEC,oRightBracket
      0  3665					      db	101
      1  3665		       65		      .byte.b	101
      0  3666					      db	(UNKNOWNVEC-*)-1
      1  3666		       08		      .byte.b	(UNKNOWNVEC-*)-1
      0  3667					      db	oRightBracket
      1  3667		       e1		      .byte.b	oRightBracket
      0  3668					      CALLFUNC
      0  3668					      db	53
      1  3668		       35		      .byte.b	53
      0  3669					      RTN
      0  3669					      db	25
      1  3669		       19		      .byte.b	25
    943  366a							; Run the gosub within this function
    944  366a				   F2B2A
      0  366a					      TSTB	UNKNOWNID,oRightBracket
      0  366a					      db	101
      1  366a		       65		      .byte.b	101
      0  366b					      db	(UNKNOWNID-*)-1
      1  366b		       bf		      .byte.b	(UNKNOWNID-*)-1
      0  366c					      db	oRightBracket
      1  366c		       e1		      .byte.b	oRightBracket
      0  366d					      LIT	0	; No parameter passed so just load zero to A
      0  366d					      db	27
      1  366d		       1b		      .byte.b	27
      0  366e					      dw	0
      1  366e		       00 00		      .word.w	0
      0  3670					      CALLFUNC
      0  3670					      db	53
      1  3670		       35		      .byte.b	53
      0  3671					      RTN
      0  3671					      db	25
      1  3671		       19		      .byte.b	25
    949  3672
    950  3672							;=================================================================================
    951  3672							;Check for a number !
    952  3672							;
    953  3672				   FactNumber
      0  3672					      TSTN	FactVariable	;NUMBER, GET ITS VALUE.
      0  3672					      db	35
      1  3672		       23		      .byte.b	35
      0  3673					      db	(FactVariable-*)-1
      1  3673		       0f		      .byte.b	(FactVariable-*)-1
      0  3674					      RTN
      0  3674					      db	25
      1  3674		       19		      .byte.b	25
    956  3675
    957  3675				   FactWithBracket
      0  3675					      TSTB	F2RTN,oLeftBracket	;PARENTHESIZED EXPR.
      0  3675					      db	101
      1  3675		       65		      .byte.b	101
      0  3676					      db	(F2RTN-*)-1
      1  3676		       08		      .byte.b	(F2RTN-*)-1
      0  3677					      db	oLeftBracket
      1  3677		       e0		      .byte.b	oLeftBracket
      0  3678					      CALL	EXPR
      0  3678					      db	28
      1  3678		       1c		      .byte.b	28
      0  3679					      dw	EXPR
      1  3679		       f0 34		      .word.w	EXPR
      0  367b					      TST	F2,oRightBracket
      0  367b					      db	32
      1  367b		       20		      .byte.b	32
      0  367c					      db	(F2-*)-1
      1  367c		       03		      .byte.b	(F2-*)-1
      0  367d					      db	oRightBracket,0
      1  367d		       e1 00		      .byte.b	oRightBracket,0
    961  367f				   F2RTN
      0  367f					      RTN
      0  367f					      db	25
      1  367f		       19		      .byte.b	25
    963  3680
    964  3680				   F2
      0  3680					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  3680					      db	13
      1  3680		       0d		      .byte.b	13
      0  3681					      dw	ERR_SYNTAX
      1  3681		       05 00		      .word.w	ERR_SYNTAX
    966  3683							;
    967  3683							;=============================================================================
    968  3683							; See if this is just a simple variable
    969  3683							;  Allow a subscript for any variable
    970  3683							;
    971  3683				   FactVariable
    972  3683
      0  3683					      SETR2	tInteger
      0  3683					      db	94
      1  3683		       5e		      .byte.b	94
      0  3684					      db	tInteger
      1  3684		       a4		      .byte.b	tInteger
      0  3685					      TSTV	FactWithBracket
      0  3685					      db	33
      1  3685		       21		      .byte.b	33
      0  3686					      db	(FactWithBracket-*)-1
      1  3686		       ee		      .byte.b	(FactWithBracket-*)-1
      0  3687					      TSTBYTE	FactFNParm,R2,GOSUB_RTN_VALUE
      0  3687					      db	97
      1  3687		       61		      .byte.b	97
      0  3688					      db	(FactFNParm-*)-1
      1  3688		       08		      .byte.b	(FactFNParm-*)-1
      0  3689					      dw	R2
      1  3689		       58 00		      .word.w	R2
      0  368b					      db	GOSUB_RTN_VALUE
      1  368b		       81		      .byte.b	GOSUB_RTN_VALUE
      0  368c					      CALL	FactVarPTR
      0  368c					      db	28
      1  368c		       1c		      .byte.b	28
      0  368d					      dw	FactVarPTR
      1  368d		       a0 36		      .word.w	FactVarPTR
    977  368f							;	  CALL	      FactVariableValue
      0  368f					      IND		; get the variable value
      0  368f					      db	20
      1  368f		       14		      .byte.b	20
      0  3690					      RTN
      0  3690					      db	25
      1  3690		       19		      .byte.b	25
    980  3691
    981  3691				   FactFNParm
      0  3691					      TSTB	FactExpectedOpeningBracket,oLeftSQBracket
      0  3691					      db	101
      1  3691		       65		      .byte.b	101
      0  3692					      db	(FactExpectedOpeningBracket-*)-1
      1  3692		       44		      .byte.b	(FactExpectedOpeningBracket-*)-1
      0  3693					      db	oLeftSQBracket
      1  3693		       e4		      .byte.b	oLeftSQBracket
      0  3694					      CALL	EXPR
      0  3694					      db	28
      1  3694		       1c		      .byte.b	28
      0  3695					      dw	EXPR
      1  3695		       f0 34		      .word.w	EXPR
      0  3697					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  3697					      db	101
      1  3697		       65		      .byte.b	101
      0  3698					      db	(FactMissingRightBracket-*)-1
      1  3698		       3b		      .byte.b	(FactMissingRightBracket-*)-1
      0  3699					      db	oRightSQBracket
      1  3699		       e5		      .byte.b	oRightSQBracket
      0  369a					      SUBSCRIPT	GOSUB_RTN_VALUE
      0  369a					      db	64
      1  369a		       40		      .byte.b	64
      0  369b					      db	GOSUB_RTN_VALUE
      1  369b		       81		      .byte.b	GOSUB_RTN_VALUE
      0  369c					      SETR2	tInteger
      0  369c					      db	94
      1  369c		       5e		      .byte.b	94
      0  369d					      db	tInteger
      1  369d		       a4		      .byte.b	tInteger
      0  369e					      IND
      0  369e					      db	20
      1  369e		       14		      .byte.b	20
      0  369f					      RTN
      0  369f					      db	25
      1  369f		       19		      .byte.b	25
    989  36a0
    990  36a0				   FactVarPTR
    991  36a0				   FactVarPtrNoTst
      0  36a0					      TSTB	F2CLocalTask,oBang
      0  36a0					      db	101
      1  36a0		       65		      .byte.b	101
      0  36a1					      db	(F2CLocalTask-*)-1
      1  36a1		       04		      .byte.b	(F2CLocalTask-*)-1
      0  36a2					      db	oBang
      1  36a2		       e8		      .byte.b	oBang
      0  36a3					      IND		; we just got a pid
      0  36a3					      db	20
      1  36a3		       14		      .byte.b	20
      0  36a4					      TSTVT	UNKNOWNID	; if it is not another variable then error, Call test var. task
      0  36a4					      db	93
      1  36a4		       5d		      .byte.b	93
      0  36a5					      db	(UNKNOWNID-*)-1
      1  36a5		       85		      .byte.b	(UNKNOWNID-*)-1
    995  36a6
    996  36a6				   F2CLocalTask
      0  36a6					      SETR2	tInteger	; Sets the default type to integer
      0  36a6					      db	94
      1  36a6		       5e		      .byte.b	94
      0  36a7					      db	tInteger
      1  36a7		       a4		      .byte.b	tInteger
      0  36a8					      TSTB	F2INTEGER,oDollar	; Check if this will be a byte array @$[index] or a..z$[index] use a byte array
      0  36a8					      db	101
      1  36a8		       65		      .byte.b	101
      0  36a9					      db	(F2INTEGER-*)-1
      1  36a9		       11		      .byte.b	(F2INTEGER-*)-1
      0  36aa					      db	oDollar
      1  36aa		       e7		      .byte.b	oDollar
      0  36ab					      SETR2	tByte
      0  36ab					      db	94
      1  36ab		       5e		      .byte.b	94
      0  36ac					      db	tByte
      1  36ac		       a2		      .byte.b	tByte
      0  36ad					      TSTB	F2PTRLOADED,oLeftSQBracket
      0  36ad					      db	101
      1  36ad		       65		      .byte.b	101
      0  36ae					      db	(F2PTRLOADED-*)-1
      1  36ae		       22		      .byte.b	(F2PTRLOADED-*)-1
      0  36af					      db	oLeftSQBracket
      1  36af		       e4		      .byte.b	oLeftSQBracket
      0  36b0					      CALL	EXPR
      0  36b0					      db	28
      1  36b0		       1c		      .byte.b	28
      0  36b1					      dw	EXPR
      1  36b1		       f0 34		      .word.w	EXPR
      0  36b3					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  36b3					      db	101
      1  36b3		       65		      .byte.b	101
      0  36b4					      db	(FactMissingRightBracket-*)-1
      1  36b4		       1f		      .byte.b	(FactMissingRightBracket-*)-1
      0  36b5					      db	oRightSQBracket
      1  36b5		       e5		      .byte.b	oRightSQBracket
      0  36b6					      SUBSCRIPT	tByte	; Byte type array
      0  36b6					      db	64
      1  36b6		       40		      .byte.b	64
      0  36b7					      db	tByte
      1  36b7		       a2		      .byte.b	tByte
      0  36b8					      SETR2	tByte	; Set byte data type
      0  36b8					      db	94
      1  36b8		       5e		      .byte.b	94
      0  36b9					      db	tByte
      1  36b9		       a2		      .byte.b	tByte
      0  36ba					      RTN
      0  36ba					      db	25
      1  36ba		       19		      .byte.b	25
   1006  36bb
   1007  36bb				   F2INTEGER
      0  36bb					      TSTB	F2PTRLOADED,oLeftSQBracket
      0  36bb					      db	101
      1  36bb		       65		      .byte.b	101
      0  36bc					      db	(F2PTRLOADED-*)-1
      1  36bc		       14		      .byte.b	(F2PTRLOADED-*)-1
      0  36bd					      db	oLeftSQBracket
      1  36bd		       e4		      .byte.b	oLeftSQBracket
      0  36be					      CALL	EXPR
      0  36be					      db	28
      1  36be		       1c		      .byte.b	28
      0  36bf					      dw	EXPR
      1  36bf		       f0 34		      .word.w	EXPR
      0  36c1					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  36c1					      db	101
      1  36c1		       65		      .byte.b	101
      0  36c2					      db	(FactMissingRightBracket-*)-1
      1  36c2		       11		      .byte.b	(FactMissingRightBracket-*)-1
      0  36c3					      db	oRightSQBracket
      1  36c3		       e5		      .byte.b	oRightSQBracket
      0  36c4					      SUBSCRIPT	tInteger	; Integer type array
      0  36c4					      db	64
      1  36c4		       40		      .byte.b	64
      0  36c5					      db	tInteger
      1  36c5		       a4		      .byte.b	tInteger
      0  36c6					      SETR2	tInteger	; Set word datatype
      0  36c6					      db	94
      1  36c6		       5e		      .byte.b	94
      0  36c7					      db	tInteger
      1  36c7		       a4		      .byte.b	tInteger
      0  36c8					      TSTB	F2PTRLOADED,oBang	; for a word it can be fillowed by a! as ref to other task variables
      0  36c8					      db	101
      1  36c8		       65		      .byte.b	101
      0  36c9					      db	(F2PTRLOADED-*)-1
      1  36c9		       07		      .byte.b	(F2PTRLOADED-*)-1
      0  36ca					      db	oBang
      1  36ca		       e8		      .byte.b	oBang
      0  36cb					      IND		; Get the value of the task context to access
      0  36cb					      db	20
      1  36cb		       14		      .byte.b	20
      0  36cc					      TSTVT	UNKNOWNID	; if it is not another variable name then it is a halt error
      0  36cc					      db	93
      1  36cc		       5d		      .byte.b	93
      0  36cd					      db	(UNKNOWNID-*)-1
      1  36cd		       5d		      .byte.b	(UNKNOWNID-*)-1
      0  36ce					      IJMP	FactVarPTR	; Process the value on the other side
      0  36ce					      db	29
      1  36ce		       1d		      .byte.b	29
      0  36cf					      dw	FactVarPTR
      1  36cf		       a0 36		      .word.w	FactVarPTR
   1017  36d1				   F2PTRLOADED
      0  36d1					      RTN
      0  36d1					      db	25
      1  36d1		       19		      .byte.b	25
   1019  36d2
   1020  36d2				   FactVariableValue
      0  36d2					      IND		; YES, GET THE VALUE as word
      0  36d2					      db	20
      1  36d2		       14		      .byte.b	20
      0  36d3					      RTN
      0  36d3					      db	25
      1  36d3		       19		      .byte.b	25
   1023  36d4
   1024  36d4				   FactMissingRightBracket
      0  36d4					      IJMP	ReturnExpectBracket
      0  36d4					      db	29
      1  36d4		       1d		      .byte.b	29
      0  36d5					      dw	ReturnExpectBracket
      1  36d5		       25 37		      .word.w	ReturnExpectBracket
   1026  36d7				   FactExpectedOpeningBracket
      0  36d7					      ERRMSG	ERR_EXPECTED_OPENING_BRACKET
      0  36d7					      db	13
      1  36d7		       0d		      .byte.b	13
      0  36d8					      dw	ERR_EXPECTED_OPENING_BRACKET
      1  36d8		       1a 00		      .word.w	ERR_EXPECTED_OPENING_BRACKET
   1028  36da							;===============================================================================================================================
   1029  36da							;
   1030  36da							;===============================================================================================================================
   1031  36da							;while .. wend statement
   1032  36da							;
   1033  36da				   ekWhile
      0  36da					      BeginBlock	kWhile,kWend	; push the info to stack as a while loop
      0  36da					      db	117
      1  36da		       75		      .byte.b	117
      0  36db					      db	kWhile,kWend
      1  36db		       24 25		      .byte.b	kWhile,kWend
   1035  36dd				   xWhileTest
      0  36dd					      CALL	EXPR	; test if condition is true
      0  36dd					      db	28
      1  36dd		       1c		      .byte.b	28
      0  36de					      dw	EXPR
      1  36de		       f0 34		      .word.w	EXPR
      0  36e0					      DONE		; should be nothing else on the line
      0  36e0					      db	1
      1  36e0		       01		      .byte.b	1
      0  36e1					      IFFALSE	xWhileCleanup	; if false goto end of block
      0  36e1					      db	119
      1  36e1		       77		      .byte.b	119
      0  36e2					      db	(xWhileCleanup-*)-1
      1  36e2		       0c		      .byte.b	(xWhileCleanup-*)-1
      0  36e3					      NXT	CO	; next line or exit
      0  36e3					      db	6
      1  36e3		       06		      .byte.b	6
      0  36e4					      dw	CO
      1  36e4		       cf 32		      .word.w	CO
      0  36e6					      IJMP	STMT	; do the next statement
      0  36e6					      db	29
      1  36e6		       1d		      .byte.b	29
      0  36e7					      dw	STMT
      1  36e7		       d7 32		      .word.w	STMT
   1041  36e9
      0  36e9				   ekWend     DONE		; should be only thing on the line
      0  36e9					      db	1
      1  36e9		       01		      .byte.b	1
      0  36ea					      JmpStart	kWhile	; always set user program PC to beginning of the block
      0  36ea					      db	116
      1  36ea		       74		      .byte.b	116
      0  36eb					      db	kWhile
      1  36eb		       24		      .byte.b	kWhile
      0  36ec					      IJMP	xWhileTest
      0  36ec					      db	29
      1  36ec		       1d		      .byte.b	29
      0  36ed					      dw	xWhileTest
      1  36ed		       dd 36		      .word.w	xWhileTest
   1045  36ef				   xWhileCleanup
      0  36ef					      JmpEnd	kWhile
      0  36ef					      db	115
      1  36ef		       73		      .byte.b	115
      0  36f0					      db	kWhile
      1  36f0		       24		      .byte.b	kWhile
      0  36f1					      NXT	CO
      0  36f1					      db	6
      1  36f1		       06		      .byte.b	6
      0  36f2					      dw	CO
      1  36f2		       cf 32		      .word.w	CO
      0  36f4					      IJMP	STMT	; next statement after the while block
      0  36f4					      db	29
      1  36f4		       1d		      .byte.b	29
      0  36f5					      dw	STMT
      1  36f5		       d7 32		      .word.w	STMT
   1049  36f7							;
   1050  36f7							;==========================for next step interface =============================================================================
   1051  36f7							;
   1052  36f7				   ekFor
   1053  36f7				   ekNext
   1054  36f7				   ekStep
   1055  36f7							;
   1056  36f7							;========================= Gosub and function interface ========================================================================
   1057  36f7							; Process gosub 1000(Parm1, ...) no return value
   1058  36f7							;
   1059  36f7				   ekGosub
      0  36f7					      CALL	GOSUBSTATEMENT	; Do the gosub
      0  36f7					      db	28
      1  36f7		       1c		      .byte.b	28
      0  36f8					      dw	GOSUBSTATEMENT
      1  36f8		       29 37		      .word.w	GOSUBSTATEMENT
      0  36fa					      DONE		; ERROR IF CR NOT NEXT
      0  36fa					      db	1
      1  36fa		       01		      .byte.b	1
      0  36fb					      SAV	GOSUB_RTN	; SAVE RETURN LINE
      0  36fb					      db	8
      1  36fb		       08		      .byte.b	8
      0  36fc					      db	GOSUB_RTN
      1  36fc		       01		      .byte.b	GOSUB_RTN
      0  36fd					      FASTXFER		; AND JUMP to sub rtn
      0  36fd					      db	107
      1  36fd		       6b		      .byte.b	107
   1064  36fe							;
   1065  36fe							; End of gosub processing
   1066  36fe							;===========================================================================
   1067  36fe							; Same as gosub but expects a return value
   1068  36fe							;   FN 1000(parm1, ....)  Expects an integer to be returned
   1069  36fe							;
   1070  36fe				   ekGofn
      0  36fe					      Call	GOSUBSTATEMENT
      0  36fe					      db	28
      1  36fe		       1c		      .byte.b	28
      0  36ff					      dw	GOSUBSTATEMENT
      1  36ff		       29 37		      .word.w	GOSUBSTATEMENT
      0  3701					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  3701					      db	8
      1  3701		       08		      .byte.b	8
      0  3702					      db	GOSUB_RTN_VALUE
      1  3702		       81		      .byte.b	GOSUB_RTN_VALUE
      0  3703					      FASTXFER
      0  3703					      db	107
      1  3703		       6b		      .byte.b	107
   1074  3704
   1075  3704				   GOFNRet
      0  3704					      RTN
      0  3704					      db	25
      1  3704		       19		      .byte.b	25
   1077  3705							;===============================================================================================================================
   1078  3705							; Return from a gosub
   1079  3705							;
   1080  3705				   ekReturn
      0  3705					      TSTB	S2NoReturnValue,oLeftBracket	; Check if we will return some value
      0  3705					      db	101
      1  3705		       65		      .byte.b	101
      0  3706					      db	(S2NoReturnValue-*)-1
      1  3706		       11		      .byte.b	(S2NoReturnValue-*)-1
      0  3707					      db	oLeftBracket
      1  3707		       e0		      .byte.b	oLeftBracket
      0  3708					      CALL	EXPR
      0  3708					      db	28
      1  3708		       1c		      .byte.b	28
      0  3709					      dw	EXPR
      1  3709		       f0 34		      .word.w	EXPR
      0  370b					      TSTB	ReturnExpectBracket,oRightBracket	; Now a value is on the stack
      0  370b					      db	101
      1  370b		       65		      .byte.b	101
      0  370c					      db	(ReturnExpectBracket-*)-1
      1  370c		       18		      .byte.b	(ReturnExpectBracket-*)-1
      0  370d					      db	oRightBracket
      1  370d		       e1		      .byte.b	oRightBracket
      0  370e					      DONE
      0  370e					      db	1
      1  370e		       01		      .byte.b	1
      0  370f					      RSTR	S2RetFunc,1	; decides if call was a func or statement, branch on func, return value
      0  370f					      db	9
      1  370f		       09		      .byte.b	9
      0  3710					      db	(S2RetFunc-*)-1
      1  3710		       11		      .byte.b	(S2RetFunc-*)-1
      0  3711					      db	1
      1  3711		       01		      .byte.b	1
      0  3712					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  3712					      db	6
      1  3712		       06		      .byte.b	6
      0  3713					      dw	CO
      1  3713		       cf 32		      .word.w	CO
      0  3715					      IJMP	STMT	; Process the new statement
      0  3715					      db	29
      1  3715		       1d		      .byte.b	29
      0  3716					      dw	STMT
      1  3716		       d7 32		      .word.w	STMT
   1088  3718
   1089  3718				   S2NoReturnValue
      0  3718					      DONE
      0  3718					      db	1
      1  3718		       01		      .byte.b	1
      0  3719					      RSTR	S2RetFunc,0	; decides if call was a func or statement, branch on func, no return value
      0  3719					      db	9
      1  3719		       09		      .byte.b	9
      0  371a					      db	(S2RetFunc-*)-1
      1  371a		       07		      .byte.b	(S2RetFunc-*)-1
      0  371b					      db	0
      1  371b		       00		      .byte.b	0
      0  371c					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  371c					      db	6
      1  371c		       06		      .byte.b	6
      0  371d					      dw	CO
      1  371d		       cf 32		      .word.w	CO
      0  371f					      IJMP	STMT	; Process the new statement
      0  371f					      db	29
      1  371f		       1d		      .byte.b	29
      0  3720					      dw	STMT
      1  3720		       d7 32		      .word.w	STMT
   1094  3722
   1095  3722				   S2RetFunc
      0  3722					      IJMP	GOFNRet	; Back into the Function
      0  3722					      db	29
      1  3722		       1d		      .byte.b	29
      0  3723					      dw	GOFNRet
      1  3723		       04 37		      .word.w	GOFNRet
   1097  3725
   1098  3725				   ReturnExpectBracket
      0  3725					      ENDIO
      0  3725					      db	71
      1  3725		       47		      .byte.b	71
      0  3726					      ERRMSG	ERR_CLOSINGBRACKET
      0  3726					      db	13
      1  3726		       0d		      .byte.b	13
      0  3727					      dw	ERR_CLOSINGBRACKET
      1  3727		       17 00		      .word.w	ERR_CLOSINGBRACKET
   1101  3729							;
   1102  3729							; End of return from gosub
   1103  3729							;=============================================================
   1104  3729							; Gosub can be both a Function and a Subroutine
   1105  3729				   GOSUBSTATEMENT
      0  3729					      TSTBRANCH	GOSUBCOMPILED	; if the two bytes after gosub are not zero then direct transfer
      0  3729					      db	106
      1  3729		       6a		      .byte.b	106
      0  372a					      db	(GOSUBCOMPILED-*)-1
      1  372a		       0a		      .byte.b	(GOSUBCOMPILED-*)-1
      0  372b					      CALL	EXPR	; GET DESTINATION
      0  372b					      db	28
      1  372b		       1c		      .byte.b	28
      0  372c					      dw	EXPR
      1  372c		       f0 34		      .word.w	EXPR
      0  372e					      CALL	GOSUBCONT
      0  372e					      db	28
      1  372e		       1c		      .byte.b	28
      0  372f					      dw	GOSUBCONT
      1  372f		       3c 37		      .word.w	GOSUBCONT
      0  3731					      lit	0	; mark as lookup on stack
      0  3731					      db	27
      1  3731		       1b		      .byte.b	27
      0  3732					      dw	0
      1  3732		       00 00		      .word.w	0
      0  3734					      RTN
      0  3734					      db	25
      1  3734		       19		      .byte.b	25
   1111  3735
   1112  3735				   GOSUBCOMPILED
      0  3735					      CALL	GOSUBCONT
      0  3735					      db	28
      1  3735		       1c		      .byte.b	28
      0  3736					      dw	GOSUBCONT
      1  3736		       3c 37		      .word.w	GOSUBCONT
      0  3738					      lit	1	;mark as compiled on stack
      0  3738					      db	27
      1  3738		       1b		      .byte.b	27
      0  3739					      dw	1
      1  3739		       01 00		      .word.w	1
      0  373b					      RTN
      0  373b					      db	25
      1  373b		       19		      .byte.b	25
   1116  373c
   1117  373c				   GOSUBCONT
      0  373c					      TSTB	GOSUBDONE,oLeftBracket	;Check if any Parameters If not bracket get out
      0  373c					      db	101
      1  373c		       65		      .byte.b	101
      0  373d					      db	(GOSUBDONE-*)-1
      1  373d		       11		      .byte.b	(GOSUBDONE-*)-1
      0  373e					      db	oLeftBracket
      1  373e		       e0		      .byte.b	oLeftBracket
      0  373f					      STK2TMP		;Transfer stack top to temp, temp gets line to goto
      0  373f					      db	95
      1  373f		       5f		      .byte.b	95
      0  3740					      PUSHMATHSTACK		;Record stack frame for return
      0  3740					      db	84
      1  3740		       54		      .byte.b	84
   1121  3741				   GOSUBLOOP
      0  3741					      CALL	EXPR	; Allows what ever fits onto stack
      0  3741					      db	28
      1  3741		       1c		      .byte.b	28
      0  3742					      dw	EXPR
      1  3742		       f0 34		      .word.w	EXPR
      0  3744					      INCPARMCOUNT
      0  3744					      db	88
      1  3744		       58		      .byte.b	88
      0  3745					      TSTB	GOSUBParmDONE,oComma
      0  3745					      db	101
      1  3745		       65		      .byte.b	101
      0  3746					      db	(GOSUBParmDONE-*)-1
      1  3746		       04		      .byte.b	(GOSUBParmDONE-*)-1
      0  3747					      db	oComma
      1  3747		       e2		      .byte.b	oComma
      0  3748					      IJMP	GOSUBLOOP
      0  3748					      db	29
      1  3748		       1d		      .byte.b	29
      0  3749					      dw	GOSUBLOOP
      1  3749		       41 37		      .word.w	GOSUBLOOP
   1126  374b				   GOSUBParmDONE
      0  374b					      TSTB	ReturnExpectBracket,oRightBracket
      0  374b					      db	101
      1  374b		       65		      .byte.b	101
      0  374c					      db	(ReturnExpectBracket-*)-1
      1  374c		       d8		      .byte.b	(ReturnExpectBracket-*)-1
      0  374d					      db	oRightBracket
      1  374d		       e1		      .byte.b	oRightBracket
      0  374e					      TMP2STK		; Restore line to goto
      0  374e					      db	96
      1  374e		       60		      .byte.b	96
   1129  374f				   GOSUBDONE
      0  374f					      RTN
      0  374f					      db	25
      1  374f		       19		      .byte.b	25
   1131  3750
   1132  3750		       37 50	   ILEND      equ	*
------- FILE mytb.asm
   2487  3750		       37 50	   PROGEND    equ	*
   2488  3750
   2489  3750							;=====================================================
   2490  3750							; Define start of non page zero data
   2491 U37a3					      seg.u	TBData
   2492 U37a3
   2493 U37a3							;=====================================================
   2494 U37a3							; These are storage items not in page zero.
   2495 U37a3							;==================================================================================================
   2496 U37a3							; Task Management information
   2497 U37a3							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2498 U37a3							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2499 U37a3							; Task switchs happen at the beginning of the next Basic command line
   2500 U37a3							; It will not happen during an input or output operations
   2501 U37a3							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2502 U37a3							; Task Zero is always the root task, main line program
   2503 U37a3							;
   2504 U37a3							; Layout is repeated for each configured task
   2505 U37a3							; Task Table Byte   use masks follow
   2506 U37a3		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2507 U37a3		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2508 U37a3		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2509 U37a3		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2510 U37a3		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2511 U37a3
   2512 U37a3		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2513 U37a4		       00 00 00 00*taskTable  ds	[TASKCOUNT * CONTEXTLEN]	; Task Table Offset and pointer to Basic code, active flag
   2514 U37a4		       38 9e	   TASKTABLEEND equ	*	; End of task table
   2515 U37a4		       00 fa	   TASKTABLELEN equ	[TASKTABLEEND-taskTable]	; actual length of the task table
   2516 U389e
   2517 U389e							;Task Cycle Counter and reset count
   2518 U389e		       00 00	   taskCurrentCycles ds	2
   2519 U38a0		       00 00	   taskResetValue ds	2
   2520 U38a2		       00	   taskCounter ds	1	; Count of active tasks
   2521 U38a3
   2522 U38a3							;
   2523 U38a3							; Math stack and IL call and Gosub/For-next return stack definitions
   2524 U38a3							;
   2525 U38a3		       38 a3	   STACKSTART equ	*
   2526 U38a3		       00 00 00 00*mathStack  ds	[MATHSTACKSIZE * 2 * TASKCOUNT]	; Stack used for math expressions
   2527 U3a33		       00 00 00 00*ilStack    ds	[ILSTACKSIZE * 2 * TASKCOUNT]	; stack used by the IL for calls and returns
   2528 U3e1b		       00 00 00 00*gosubStack ds	[GOSUBSTACKSIZE * 4 * TASKCOUNT]	; stack size for gosub stacks
   2529 U409b		       00 00 00 00*variableStack ds	[VARIABLESSIZE * 2 * TASKCOUNT]	; Stack of variables, 26 A-Z-task exit code,taskio block
   2530 U437f							;									  stdin,stdout,stdstat,iostatus
   2531 U437f		       00 48	   TASKEXITCODE equ	[[VARIABLESSIZE * 2] - 2]	; Offset to exit code location
   2532 U437f		       43 7f	   STACKEND   equ	*
   2533 U437f		       0a dc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2534 U437f							;
   2535 U437f							;
   2536 U437f		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2537 U4403		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2538 U4404		       00	   printtx    ds	1	;temp X for print funcs
   2539 U4405		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2540 U4406		       00	   promptChar ds	1	;the character to use for a prompt
   2541 U4407		       00	   diddigit   ds	1	;for leading zero suppression
   2542 U4408		       00	   putsy      ds	1
   2543 U4409		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2544 U440b		       00	   sign       ds	1	;0 = positive, else negative
   2545 U440c		       00 00	   rtemp1     ds	2	;Temp for x and y
   2546 U440e		       00 00	   random     ds	2
   2547 U4410		       00	   tempy      ds	1	;temp y storage
   2548 U4411
   2549 U4411							; Moved from page zero as one clock cycle diff gives more space on page zero
   2550 U4411		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
   2551 U4413		       00	   tempIlY    ds	1	;Temp IL Y register storage
   2552 U4414		       00	   offset     ds	1	;IL Offset to next inst when test fails
   2553 U4415		       00	   lineLength ds	1	;Length of current line
   2554 U4416
   2555 U4416		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
   2556 U4417		       00	   taskRDPending ds	1	; 1 = background read is pending
   2557 U4418		       00 00 00 00 timercounter ds	4	; if timer is running then this is continuously incremented
   2558 U441c
   2559 U441c				  -	      if	XKIM
   2560 U441c				  -buffer     ds	BUFFER_SIZE
   2561 U441c					      endif
   2562 U441c							;
   2563 U441c							; PROGRAMEND is the end of the user's BASIC program.
   2564 U441c							; More precisely, it is one byte past the end.  Or,
   2565 U441c							; it's where the next line added to the end will be
   2566 U441c							; placed.
   2567 U441c							;
   2568 U441c		       00 00	   ProgramStart ds	2	; Start Of usable memory
   2569 U441e		       00 00	   ProgramEnd ds	2	; End of users basic program, Next free byte after end
   2570 U4420		       00 00	   HighMem    ds	2	; highest location
   2571 U4422		       00 00	   UsedMem    ds	2	; size of user program
   2572 U4424		       00 00	   FreeMem    ds	2	; amount of free memory
   2573 U4426							;
   2574 U4426							;=====================================================
   2575 U4426							; This is the start of the user's BASIC program space.
   2576 U4426							;
   2577 U4426							; PERSONAL GOAL: This should be no larger than $0DFF. *JustLostInTim abandoned, just for fun
   2578 U4426							;		  0200-05FF = 1K
   2579 U4426							;		  0200-09FF = 2K
   2580 U4426							;		  0200-0DFF = 3K
   2581 U4426							;		  0200-11FF = 4K
   2582 U4426							;		  0200-13FF = 4.5K
   2583 U4426							;
   2584 U4426				  -	      if	FIXED
   2585 U4426				  -	      org	$2000
   2586 U4426					      endif
   2587 U4426
   2588 U4426		       44 26	   FreeMemStart equ	*
   2589 U4426							;/*
   2590 U4426							;  if	  CTMON65 || XKIM
   2591 U4426							;	  SEG Code
   2592 U4426							;	  org	  AutoRun
   2593 U4426							;	  dw	  TBasicCold
   2594 U4426							;  endif
   2595 U4426							;*/
   2596 U4426					      end
