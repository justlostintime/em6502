------- FILE mytb.asm LEVEL 1 PASS 6
      1 U435a				   input      processor	6502
      2 U435a ????						;=====================================================
      3 U435a ????						; Concurrent Tiny Basic, no longer Tiny
      4 U435a ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U435a ????						; Free Time. Now abiut 6K Full OS features.
      6 U435a ????						;
      7 U435a ????						; While working on the Corsham Technologies KIM Clone
      8 U435a ????						; project, I wanted to include a TINY BASIC since that
      9 U435a ????						; was a highly desirable feature of early computers.
     10 U435a ????						;
     11 U435a ????						; Rather than negotiating copyright issues for
     12 U435a ????						; existing BASICs, I decided to just write one from
     13 U435a ????						; scratch.
     14 U435a ????						;
     15 U435a ????						; 10/07/2017
     16 U435a ????						;
     17 U435a ????						; This implements a stripped down Tiny BASIC
     18 U435a ????						; interpreter using the Interpretive Language (IL)
     19 U435a ????						; method as described in the first few issues of
     20 U435a ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U435a ????						; to write various languages simply by changing the
     22 U435a ????						; IL code rather than the interpreter itself.
     23 U435a ????						;
     24 U435a ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U435a ????						;		* Fixed major bug in findLine that
     26 U435a ????						;		  caused corrupted lines, crashes, etc.
     27 U435a ????						;		* If no parameter given to RND, assume
     28 U435a ????						;		  32766.
     29 U435a ????						;		* No more error 5 when a program
     30 U435a ????						;		  reaches the end without an END.
     31 U435a ????						;
     32 U435a ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U435a ????						;		 * Unexpanded version to play with everything
     34 U435a ????						;		 * Add some usefull system level functions
     35 U435a ????						;		 * allow a larger number of tiny basic formats
     36 U435a ????						;		 * Add byte at start of line holding length
     37 U435a ????						;		   for faster execution of goto and gosub
     38 U435a ????						;		 * Re-added gosub
     39 U435a ????						;		 * allow ; or , at end if print stmt
     40 U435a ????						;		   without CRLF being added.
     41 U435a ????						;		 * Added extended function erase to
     42 U435a ????						;		   use the extended ctmon65 rm file
     43 U435a ????						;		 * Fix quoted text to not have to backtrack
     44 U435a ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U435a ????						;		 * Add concurrency features
     46 U435a ????						;		 * Add Compile at runtime for gosub and goto addresses
     47 U435a ????						;
     48 U435a ????						; 10/31/2023 v0.5 Justlostintime@gmail.com
     49 U435a ????						;		 * Inline in il some var load value instead of calling
     50 U435a ????						;
     51 U435a ????						; 11/20/2023 v1.1.3 Justlostintime@gmail.com
     52 U435a ????						;		 * Many improvment, bug fixes
     53 U435a ????						;
     54 U435a ????						; www.corshamtech.com Now defunct
     55 U435a ????						; bob@corshamtech.com Bob sadly passed away
     56 U435a ????						; JustLostInTime@gmail.com Active development
     57 U435a ????						;
     58 U435a ????						;=====================================================
     59 U435a ????						;
     60 U435a ????						; Create TRUE and FALSE values for conditionals.
     61 U435a ????						;
     62 U435a ????
     63 U435a ????	       00 00	   FALSE      equ	0
     64 U435a ????	       ff ff ff ff TRUE       equ	~FALSE
     65 U435a ????						;
     66 U435a ????						;---------------------------------------------------------
     67 U435a ????						; One of these must be set to indicate which environment
     68 U435a ????						; Tiny BASIC will be running in.  Here are the current
     69 U435a ????						; environments:
     70 U435a ????						;
     71 U435a ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     72 U435a ????						; more K of RAM.
     73 U435a ????						;
     74 U435a ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     75 U435a ????						; which enhances, without replacing, the standard KIM
     76 U435a ????						; monitor.  It gives access to routines to save/load files
     77 U435a ????						; to a micro SD card.
     78 U435a ????						;
     79 U435a ????						; CTMON65 is a from-scratch monitor written for the
     80 U435a ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     81 U435a ????						; easily be ported to other systems.  It has support for
     82 U435a ????						; using a micro SD card for file storage/retrieval.
     83 U435a ????						;
     84 U435a ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     85 U435a ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     86 U435a ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     87 U435a ????	       ff ff ff ff IL_DEBUG_TEXT equ	TRUE	;Print out as text IL instructions
     88 U435a ????						;
     89 U435a ????						;   Need to define some macros for the dasm assembler
     90 U435a ????						;
     91 U435a ????				      MACRO	dw
     92 U435a ????				      .word	{0}
     93 U435a ????				      ENDM
     94 U435a ????
     95 U435a ????				      MACRO	db
     96 U435a ????				      .byte	{0}
     97 U435a ????				      ENDM
     98 U435a ????
     99 U435a ????						;
    100 U435a ????						; If set, include disk functions.
    101 U435a ????						;
    102 U435a ????	       ff ff ff ff DISK_ACCESS equ	TRUE
    103 U435a ????						;
    104 U435a ????						; If ILTRACE is set then dump out the address of every
    105 U435a ????						; IL opcode before executing it.
    106 U435a ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    107 U435a ????						;
    108 U435a ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    109 U435a ????						;
    110 U435a ????						; If FIXED is set, put the IL code and the user
    111 U435a ????						; program space at fixed locations in memory.	This is
    112 U435a ????						; meant only for debugging.
    113 U435a ????						;
    114 U435a ????	       00 00	   FIXED      equ	FALSE
    115 U435a ????
    116 U435a ????	       00 0f	   terminalIOblockLen equ	[TerminalIOblockEnd - TerminalIOblock]
    117 U435a ????
    118 U435a ????						;
    119 U435a ????						; Sets the arithmetic stack depth.  This is *TINY*
    120 U435a ????						; BASIC, so keep this small!
    121 U435a ????						;
    122 U435a ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    123 U435a ????	       00 32	   ILSTACKSIZE equ	50	;number of entries in ilstack
    124 U435a ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    125 U435a ????	       00 25	   VARIABLESSIZE equ	37	;26 variables + 1 for exit code + 10 entries (20bytes) for ioblock
    126 U435a ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 10 tasks
    127 U435a ????	       00 ff	   TASKCYCLESDEFAULT equ	255	;Default Task Switch 0-255 uses a single byte
    128 U435a ????	       00 02	   TASKCYCLESHIGH equ	2	;hi order count
    129 U435a ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    130 U435a ????
    131 U435a ????	       00 36	   taskSTDIN  equ	[[VARIABLESSIZE - 10]*2]	;io vector
    132 U435a ????	       00 38	   taskSTDOUT equ	[[[VARIABLESSIZE - 10]*2]+2]	;io vector
    133 U435a ????
    134 U435a ????	       00 3f	   taskIOinPort equ	[[[VARIABLESSIZE - 10]*2]+4+5]	;Offset into the ioblock
    135 U435a ????	       00 3b	   taskIOoutPort equ	[[[VARIABLESSIZE - 10]*2]+4+1]	;Offset into the ioblock
    136 U435a ????	       00 46	   taskIOstatusPort equ	[[[VARIABLESSIZE - 10]*2]+4+12]	;Offset into the ioblock
    137 U435a ????						;
    138 U435a ????						; Common ASCII constants
    139 U435a ????						;
    140 U435a ????	       00 07	   BEL	      equ	$07
    141 U435a ????	       00 08	   BS	      equ	$08
    142 U435a ????	       00 09	   TAB	      equ	$09
    143 U435a ????	       00 0a	   LF	      equ	$0A
    144 U435a ????	       00 0d	   CR	      equ	$0D
    145 U435a ????	       00 22	   quote      equ	$22
    146 U435a ????	       00 20	   SPACE      equ	$20
    147 U435a ????	       00 2c	   COMMA      equ	',
    148 U435a ????	       00 3b	   SEMICOLON  equ	';
    149 U435a ????	       00 3a	   COLON      equ	':
    150 U435a ????	       00 24	   DOLLAR     equ	'$
    151 U435a ????						;
    152 U435a ????						; These are error codes
    153 U435a ????						;
    154 U435a ????	       00 00	   ERR_NONE   equ	0	;No Errror
    155 U435a ????	       00 01	   ERR_EXPR   equ	1	;expression error
    156 U435a ????	       00 02	   ERR_UNDER  equ	2	;The Math stack underflow
    157 U435a ????	       00 03	   ERR_OVER   equ	3	;The Math stack overflow
    158 U435a ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    159 U435a ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    160 U435a ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    161 U435a ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    162 U435a ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    163 U435a ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    164 U435a ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    165 U435a ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    166 U435a ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;the gosub Stack overflow
    167 U435a ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    168 U435a ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    169 U435a ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    170 U435a ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    171 U435a ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    172 U435a ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    173 U435a ????	       00 13	   ERR_NO_RETURN_VALUE_PROVIDED equ	19	;No value returned by a gofn call
    174 U435a ????	       00 14	   ERR_LINE_NOT_FOUND equ	20	;Gosub/goto/gofn line number not found
    175 U435a ????	       00 15	   ERR_IL_STACK_OVER_FLOW equ	21	;The IL return stack has overflowed
    176 U435a ????	       00 16	   ERR_EXPECTVAR equ	22	;Expected a variable name or definition
    177 U435a ????	       00 17	   ERR_CLOSINGBRACKET equ	23	;Expected a closing bracket
    178 U435a ????	       00 18	   ERR_MISSINGEQUALSIGN equ	24	;Expected an equal sign for assignment
    179 U435a ????	       00 19	   ERR_FUNCTION_EXPECTED_PARAMETERS equ	25	;Function expected parameters
    180 U435a ????	       00 1a	   ERR_EXPECTED_OPENING_BRACKET equ	26	;Expected opening bracket [ or (
    181 U435a ????						;
    182 U435a ????						;=====================================================
    183 U435a ????						; Zero page storage.
    184 U435a ????						;
    185 U00f6 ????				      SEG.U	ZEROPAGE
    186 U0040					      org	$0040
    187 U0040
    188 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    189 U0041
    190 U0041							; The context is used to locate a task switch
    191 U0041							; it copies from here till all task fields are saved/swapped
    192 U0041							; The max number of tasks is 256 / context length
    193 U0041							; All positions POS values are plus one task table incldues
    194 U0041							; a leading status byte .
    195 U0041							;
    196 U0041		       00 41	   CONTEXT    equ	*
    197 U0041							;StatusCode		 db	 1  this is here to remind why everything is plus 1 this and is only in the Task table
    198 U0041
    199 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    200 U0041		       00 01	   VARIABLEPOS equ	VARIABLES - CONTEXT + 1
    201 U0043
    202 U0043		       00 00	   ILPC       ds	2	; IL program counter
    203 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    204 U0047		       00	   ILSTACKPTR ds	1
    205 U0048
    206 U0048
    207 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    208 U0048		       00 08	   MATHSTACKPOS equ	MATHSTACK - CONTEXT + 1
    209 U004a
    210 U004a
    211 U004a		       00	   MATHSTACKPTR ds	1
    212 U004a		       00 0a	   MATHSTACKPTRPOS equ	MATHSTACKPTR - CONTEXT + 1
    213 U004b
    214 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    215 U004b		       00 0b	   GOSUBSTKPOS equ	GOSUBSTACK - CONTEXT + 1	; Get the offset to the gosub/msg stack
    216 U004d
    217 U004d
    218 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    219 U004d		       00 0d	   GOSUBPTRPOS equ	GOSUBSTACKPTR - CONTEXT+1	; Pointer to gosub stack pointer
    220 U004e
    221 U004e
    222 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of gosub stack
    223 U004e		       00 0e	   MSGPTRPOS  equ	MESSAGEPTR - CONTEXT+1	; Pointer to the message counter
    224 U004f							;
    225 U004f							; CURPTR is a pointer to curent BASIC line being
    226 U004f							; executed.  Always points to start of line, CUROFF
    227 U004f							; is the offset to the current character.
    228 U004f							; The order of these fields is important
    229 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    230 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    231 U0052							;
    232 U0052							;The order of these fields in important
    233 U0052
    234 U0052							;
    235 U0052							; R0, R1 and MQ are used for arithmetic operations and
    236 U0052							; general use.
    237 U0052							;
    238 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    239 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    240 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    241 U0056		       00 00	   MQ	      ds	2	;used for some math
    242 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    243 U0058		       00 59	   REGISTERSEND equ	*
    244 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    245 U0059
    246 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    247 U0059		       00 19	   CONTEXTLEN equ	CONTEXTEND - CONTEXT + 1	; length of the context plus the status byte
    248 U0059
    249 U0059		       00 00	   dpl	      ds	2	; Used as a pointer to call il instructions
    250 U005b							;
    251 U005b							; This is zero if in immediate mode, or non-zero
    252 U005b							; if currently running a program.  Any input from
    253 U005b							; the main loop clears this, and the XFER IL
    254 U005b							; statement will set it.
    255 U005b							;
    256 U005b		       00	   RunMode    ds	1	;Basic program is running or stop
    257 U005c							;
    258 U005c							; Used for line insertion/removal.
    259 U005c							;
    260 U005c		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    261 U005e
    262 U005e							; THE ADDRESS USED BY THE PRINTER FUNCTION
    263 U005e							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    264 U005e							;
    265 U005e		       00 00	   PrtFrom    ds	2	; FROM
    266 U0060
    267 U0060							;
    268 U0060							;=====================================================
    269 U0060							;
    270  3684 ????				      SEG	Code
    271  0200					      org	$0200
    272  0200							;
    273  0200							; Cold start is at $0200.  Warm start is at $0203.
    274  0200							;
    275  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    276  0203		       4c 82 02    warm       jmp	warm2	;Entry point for worm restart
    277  0206							;
    278  0206							; These are the user-supplied vectors to I/O routines.
    279  0206							; If you want, you can just patch these in the binary
    280  0206							; file, but it would be better to change the source
    281  0206							; code.
    282  0206							;
    283  0206				  -	      if	KIM
    284  0206				  -OUTCH      jmp	$1ea0	;output char in A
    285  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    286  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    287  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    288  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    289  0206					      endif
    290  0206				  -	      if	XKIM
    291  0206				  -	      include	"xkim.inc"
    292  0206				  -	      SEG	Code
    293  0206				  -OUTCH      jmp	$1ea0
    294  0206				  -GETCH      jmp	xkGETCH
    295  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    296  0206				  -OUTHEX     jmp	xkPRTBYT
    297  0206				  -MONITOR    jmp	extKIM
    298  0206				  -puts       equ	putsil
    299  0206				  -BUFFER_SIZE equ	132
    300  0206					      endif
    301  0206
    302  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0060					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    304 Udf8e
    305  0206					      SEG	Code
    306  0206							;
    307  0206		       f0 0c	   OUTCH      equ	cout
    308  0206		       f0 09	   GETCH      equ	cin
    309  0206		       2d 96	   CRLF       equ	tbcrlf
    310  0206		       21 99	   OUTHEX     equ	HexToOut
    311  0206		       f0 03	   MONITOR    equ	WARM
    312  0206		       f0 0f	   ISCHAR     equ	cstatus
    313  0206		       21 b6	   puts       equ	tbputs
    314  0206					      endif
    315  0206							;
    316  0206		       20 dd 2e    cold2      jsr	SetOutConsole
    317  0209		       20 ea 2e 	      jsr	SetInConsole
    318  020c		       20 b6 21 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.1.30  IRQs/Tasks/Tokens"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.1.30  IRQs/Tasks/Tokens"
      0  0241					      db	CR,LF,0
      1  0241		       0d 0a 00 	      .byte.b	CR,LF,0
    322  0244							;
    323  0244		       20 aa 23 	      jsr	MemInit	;setup the free space available
    324  0247
    325  0247		       a9 01	   calcstack  lda	#1
    326  0249		       8d d6 37 	      sta	taskCounter	; Initialize number of tasks to 1
    327  024c		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    328  024e		       8d d8 36 	      sta	taskTable	; mark the main task as active
    329  0251		       20 15 26 	      jsr	taskSetStacks	; setup all the task stacks/Variables, Init task io block
    330  0254		       a9 1a		      lda	#IL&$ff
    331  0256		       85 43		      sta	ILPC
    332  0258		       a9 32		      lda	#IL>>8
    333  025a		       85 44		      sta	ILPC+1
    334  025c							;
    335  025c							;		  lda	  ProgramStart		     ; user prog
    336  025c							;		  sta	  ProgramEnd
    337  025c							;		  lda	  ProgramStart+1
    338  025c							;		  sta	  ProgramEnd+1
    339  025c							;
    340  025c
    341  025c							;  Init time slices defaults
    342  025c		       a9 02		      lda	#TASKCYCLESHIGH
    343  025e		       8d d5 37 	      sta	taskResetValue+1
    344  0261		       a9 ff		      lda	#TASKCYCLESDEFAULT
    345  0263		       8d d4 37 	      sta	taskResetValue
    346  0266							;
    347  0266							; Initialize the pseudo-random number sequence...
    348  0266							;
    349  0266		       a9 5a		      lda	#$5a
    350  0268		       8d 40 43 	      sta	rtemp1
    351  026b		       a9 9d		      lda	#%10011101
    352  026d		       8d 42 43 	      sta	random
    353  0270		       a9 5b		      lda	#%01011011
    354  0272		       8d 43 43 	      sta	random+1
    355  0275							;
    356  0275							;   Insert a Basic irq handler for the basic Language
    357  0275		       a9 3c		      lda	#ServiceIrq&$ff
    358  0277		       8d 00 df 	      sta	IRQvec
    359  027a		       a9 1a		      lda	#ServiceIrq>>8
    360  027c		       8d 01 df 	      sta	IRQvec+1
    361  027f		       4c 95 02 	      jmp	coldtwo
    362  0282
    363  0282							;
    364  0282							;
    365  0282							; This is the warm start entry point
    366  0282							;
    367  0282		       20 dd 2e    warm2      jsr	SetOutConsole
    368  0285		       20 ea 2e 	      jsr	SetInConsole
    369  0288		       20 96 2d 	      jsr	CRLF
    370  028b		       ad 3d 43 	      lda	errGoto
    371  028e		       85 43		      sta	ILPC
    372  0290		       ad 3e 43 	      lda	errGoto+1
    373  0293		       85 44		      sta	ILPC+1
    374  0295							;
    375  0295							; And continue with both starts here
    376  0295							;
    377  0295				   coldtwo
    378  0295							;
    379  0295							; The ILTrace flag is now run-time settable.
    380  0295							;
    381  0295		       a9 00		      lda	#ILTRACE&$ff
    382  0297		       85 40		      sta	ILTrace
    383  0299							;
    384  0299
    385  0299		       a9 00		      lda	#0
    386  029b		       85 5b		      sta	RunMode
    387  029d		       8d b3 42 	      sta	LINBUF
    388  02a0
    389  02a0							; Clear everything from the stacks
    390  02a0
    391  02a0		       8d 4a 43 	      sta	taskIOPending	; No one waiting for io
    392  02a3		       8d 4b 43 	      sta	taskRDPending	; No one waiting for bg io
    393  02a6
    394  02a6		       20 91 26 	      jsr	taskReset
    395  02a9							;
    396  02a9		       a9 b3		      lda	#LINBUF&$ff
    397  02ab		       85 4f		      sta	CURPTR
    398  02ad		       a9 42		      lda	#LINBUF>>8
    399  02af		       85 50		      sta	CURPTR+1	;fall through...
    400  02b1
    401  02b1							;=====================================================
    402  02b1							; This is the top of the IL interpreter.  This fetches
    403  02b1							; and executes the instruction currently pointed to
    404  02b1							; by ILPC and adjusts ILPC to point to the next
    405  02b1							; instruction to execute.
    406  02b1							;
    407  02b1				   NextIL
    408  02b1		       ba		      tsx		; Get the stack pointer value
    409  02b2		       e0 ff		      cpx	#$FF	; Should be empty
    410  02b4		       d0 29		      bne	ILbad	; Halt and catch fire now!
    411  02b6
    412  02b6		       ce d2 37 	      dec	taskCurrentCycles
    413  02b9		       d0 03		      bne	NextIlNow
    414  02bb		       20 ba 26 	      jsr	iTaskSwitch	;check for a task switch
    415  02be		       a5 40	   NextIlNow  lda	ILTrace	;Do we need to trace this
    416  02c0		       f0 03		      beq	NextIL2	;Skip if no bits set
    417  02c2
    418  02c2		       20 27 2e 	      jsr	dbgLine	;Print the IL trace information
    419  02c5
    420  02c5		       a4 51	   NextIL2    ldy	CUROFF
    421  02c7							;		  jsr	  SkipSpaces	       ; no longer needed as tokenizer takes care of this
    422  02c7							;		  sty	  CUROFF
    423  02c7							;Task IO Management
    424  02c7		       ad 4b 43 	      lda	taskRDPending	; if it is zero then Nothing pending
    425  02ca		       f0 08		      beq	NextILStr
    426  02cc		       20 cf 2b 	      jsr	ReadLine	; else Pending and poll keyboard
    427  02cf		       90 03		      bcc	NextILStr	; if carry is clear then no end of line yet
    428  02d1		       ce 4b 43 	      dec	taskRDPending	; Carry is set if CR has been recieved
    429  02d4							;
    430  02d4		       20 52 2a    NextILStr  jsr	getILByte
    431  02d7							;
    432  02d7							; When the handler is called, these are the conditions
    433  02d7							; of several important items:
    434  02d7							;
    435  02d7							;    (ILPC) will point to the byte AFTER the IL
    436  02d7							;    opcode being executed.
    437  02d7							;
    438  02d7							;    (CURPTR),CUROFF will point to the start of the
    439  02d7							;    next word in the input buffer.  Ie, the next word
    440  02d7							;    in the user program.
    441  02d7							;
    442  02d7		       18		      clc		; Clear carry before shift
    443  02d8		       0a		      asl		; valid for 0-127
    444  02d9		       b0 04		      bcs	ILbad	; Out of range
    445  02db		       aa		      tax		; Move value to x
      0  02dc					      db	$7c	; jmp (ILTBL,X) ; dasm does not support 65c02 inst
      1  02dc		       7c		      .byte.b	$7c
      0  02dd					      dw	ILTBL	; Actual IL table address
      1  02dd		       20 03		      .word.w	ILTBL
    448  02df
    449  02df							;		asl
    450  02df							;		cmp	#ILTBLend-ILTBL+2
    451  02df							;		bcc	ILgood
    452  02df							;
    453  02df							; This handles an illegal IL opcode.  This is serious
    454  02df							; and there's no way to recover.
    455  02df							;
    456  02df				   iBadOP
    457  02df		       20 b6 21    ILbad      jsr	puts
      0  02e2					      db	CR,LF
      1  02e2		       0d 0a		      .byte.b	CR,LF
      0  02e4					      db	"Illegal IL "
      1  02e4		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02ef					      db	0
      1  02ef		       00		      .byte.b	0
    461  02f0							;
    462  02f0							; Well this is awkward, we need to back up the IL
    463  02f0							; by one since it no longer points to the current
    464  02f0							; opcode.
    465  02f0							;
    466  02f0		       20 5f 2a 	      jsr	decIL
    467  02f3							;
    468  02f3		       a0 00		      ldy	#0
    469  02f5		       b1 43		      lda	(ILPC),y
    470  02f7		       20 99 21 	      jsr	OUTHEX
    471  02fa		       20 b6 21 	      jsr	puts
      0  02fd					      db	" at ",0
      1  02fd		       20 61 74 20*	      .byte.b	" at ",0
    473  0302		       a5 44		      lda	ILPC+1
    474  0304		       20 99 21 	      jsr	OUTHEX
    475  0307		       a5 43		      lda	ILPC
    476  0309		       20 99 21 	      jsr	OUTHEX
    477  030c		       20 96 2d 	      jsr	CRLF
    478  030f		       4c 03 f0 	      jmp	MONITOR
    479  0312							;
    480  0312							; Just jump to the address (ILPC),y.  Have to do
    481  0312							; some goofy stuff.
    482  0312							;
    483  0312		       a8	   ILgood     tay		;move index into Y
    484  0313		       b9 20 03 	      lda	ILTBL,y
    485  0316		       85 59		      sta	dpl
    486  0318		       b9 21 03 	      lda	ILTBL+1,y
    487  031b		       85 5a		      sta	dpl+1
    488  031d		       6c 59 00 	      jmp	(dpl)	;go to handler
    489  0320							;
    490  0320							;=====================================================
    491  0320							; This is the IL jump table.  The IL opcode is
    492  0320							; mulitplied by two, then looked-up in this table.
    493  0320							; There is absolutely nothing special about the order
    494  0320							; of entries here... they all decode at exactly the
    495  0320							; same speed.	However the entry number must match the
    496  0320							; values in IL.inc.
    497  0320							;
    498  0320				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  0320					      include	"ilvectortable.asm"
      1  0320					      seg	Code
      2  0320				   ILTBL1
      0  0320					      dw	iXINIT	;0
      1  0320		       58 04		      .word.w	iXINIT
      0  0322					      dw	iDONE	;1
      1  0322		       75 04		      .word.w	iDONE
      0  0324					      dw	iPRS	;2
      1  0324		       8c 04		      .word.w	iPRS
      0  0326					      dw	iPRN	;3
      1  0326		       94 04		      .word.w	iPRN
      0  0328					      dw	iSPC	;4
      1  0328		       9d 04		      .word.w	iSPC
      0  032a					      dw	iNLINE	;5
      1  032a		       44 09		      .word.w	iNLINE
      0  032c					      dw	iNXT	;6
      1  032c		       a5 04		      .word.w	iNXT
      0  032e					      dw	iXFER	;7
      1  032e		       e7 04		      .word.w	iXFER
      0  0330					      dw	iSAV	;8
      1  0330		       05 05		      .word.w	iSAV
      0  0332					      dw	iRSTR	;9
      1  0332		       72 25		      .word.w	iRSTR
      0  0334					      dw	iCMPR	;10
      1  0334		       4b 05		      .word.w	iCMPR
      0  0336					      dw	iINNUM	;11
      1  0336		       ca 05		      .word.w	iINNUM
      0  0338					      dw	iFIN	;12
      1  0338		       02 06		      .word.w	iFIN
      0  033a					      dw	iERR	;13
      1  033a		       16 06		      .word.w	iERR
      0  033c					      dw	iADD	;14
      1  033c		       9f 06		      .word.w	iADD
      0  033e					      dw	iSUB	;15
      1  033e		       b5 06		      .word.w	iSUB
      0  0340					      dw	iNEG	;16
      1  0340		       cb 06		      .word.w	iNEG
      0  0342					      dw	iMUL	;17
      1  0342		       e3 06		      .word.w	iMUL
      0  0344					      dw	iDIV	;18
      1  0344		       23 07		      .word.w	iDIV
      0  0346					      dw	iSTORE	;19
      1  0346		       7b 07		      .word.w	iSTORE
      0  0348					      dw	iIND	;20
      1  0348		       99 07		      .word.w	iIND
      0  034a					      dw	iLST	;21
      1  034a		       3a 08		      .word.w	iLST
      0  034c					      dw	iINIT	;22
      1  034c		       20 04		      .word.w	iINIT
      0  034e					      dw	iGETLINE	;23
      1  034e		       70 08		      .word.w	iGETLINE
      0  0350					      dw	iINSRT	;24
      1  0350		       8d 08		      .word.w	iINSRT
      0  0352					      dw	iRTN	;25
      1  0352		       3e 09		      .word.w	iRTN
      0  0354					      dw	MONITOR	;26
      1  0354		       03 f0		      .word.w	MONITOR
      0  0356					      dw	iLIT	;27
      1  0356		       68 09		      .word.w	iLIT
      0  0358					      dw	iCALL	;28
      1  0358		       4a 09		      .word.w	iCALL
      0  035a					      dw	iJMP	;29
      1  035a		       56 09		      .word.w	iJMP
      0  035c					      dw	iVINIT	;30
      1  035c		       8d 09		      .word.w	iVINIT
      0  035e					      dw	iERRGOTO	;31
      1  035e		       96 09		      .word.w	iERRGOTO
      0  0360					      dw	iTST	;32
      1  0360		       a2 09		      .word.w	iTST
      0  0362					      dw	iTSTV	;33
      1  0362		       c7 0a		      .word.w	iTSTV
      0  0364					      dw	iTSTL	;34
      1  0364		       6d 0b		      .word.w	iTSTL
      0  0366					      dw	iTSTN	;35
      1  0366		       88 0b		      .word.w	iTSTN
      0  0368					      dw	iFREE	;36
      1  0368		       41 0c		      .word.w	iFREE
      0  036a					      dw	iRANDOM	;37
      1  036a		       47 0c		      .word.w	iRANDOM
      0  036c					      dw	iABS	;38
      1  036c		       18 0d		      .word.w	iABS
     42  036e							;
     43  036e							; Disk functions.  There must be pointers
     44  036e							; to functions even if no disk is supported.
     45  036e							; Makes things easier in IL.inc.
     46  036e							;
     47  036e					      if	DISK_ACCESS
      0  036e					      dw	iOPENREAD	;39
      1  036e		       36 30		      .word.w	iOPENREAD
      0  0370					      dw	iOPENWRITE	;40
      1  0370		       97 30		      .word.w	iOPENWRITE
      0  0372					      dw	iDCLOSE	;41
      1  0372		       2b 31		      .word.w	iDCLOSE
      0  0374					      dw	iDGETLINE	;42 Life, universe, everything(hitch hiker)
      1  0374		       b9 30		      .word.w	iDGETLINE
      0  0376					      dw	iDLIST	;43 Did you remember your towel?
      1  0376		       25 31		      .word.w	iDLIST
      0  0378					      dw	iDDIR	;44
      1  0378		       00 31		      .word.w	iDDIR
      0  037a					      dw	iRMFILE	;45
      1  037a		       85 30		      .word.w	iRMFILE
     55  037c				  -	      else
     56  037c				  -	      dw	NextIL	;39
     57  037c				  -	      dw	NextIL	;40
     58  037c				  -	      dw	NextIL	;41
     59  037c				  -	      dw	NextIL	;42
     60  037c				  -	      dw	NextIL	;43
     61  037c				  -	      dw	NextIL	;44
     62  037c				  -	      dw	NextIL	;45
     63  037c					      endif
     64  037c							;
      0  037c					      dw	iCLEARSCREEN	;46
      1  037c		       f7 2e		      .word.w	iCLEARSCREEN
      0  037e					      dw	iPOKEMEMORY	;47
      1  037e		       a5 0c		      .word.w	iPOKEMEMORY
      0  0380					      dw	iPEEKMEMORY	;48
      1  0380		       ba 0c		      .word.w	iPEEKMEMORY
      0  0382					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  0382		       e9 09		      .word.w	iTSTLET
      0  0384					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  0384		       6e 0a		      .word.w	iTSTDONE
      0  0386					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  0386		       e7 0c		      .word.w	iGETCHAR
      0  0388					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  0388		       fb 0c		      .word.w	iPUTCHAR
      0  038a					      dw	iCallFunc	;53	   call a machine rtn accumulator
      1  038a		       d0 0c		      .word.w	iCallFunc
      0  038c					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  038c		       98 05		      .word.w	iBranch
      0  038e					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  038e		       cc 09		      .word.w	iTSTStr
      0  0390					      dw	iSetIrq	;56	   sets the irq handler
      1  0390		       bf 0d		      .word.w	iSetIrq
      0  0392					      dw	iTstIrq	;57	   test if irq is pending
      1  0392		       ff 0b		      .word.w	iTstIrq
      0  0394					      dw	iRET	;58	   return from interupt
      1  0394		       39 05		      .word.w	iRET
      0  0396					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  0396		       e3 05		      .word.w	iINSTR
      0  0398					      dw	iMOD	;60	   returns remainder of division
      1  0398		       2c 07		      .word.w	iMOD
      0  039a					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  039a		       0e 27		      .word.w	iTaskSet
      0  039c					      dw	iETask	;62	   Terminates a task
      1  039c		       4b 28		      .word.w	iETask
      0  039e					      dw	iNTask	;63	   goto next task
      1  039e		       fe 27		      .word.w	iNTask
     83  03a0				   ILTBL2
      0  03a0					      dw	iArray	;64	   Allow Variable to have a subscript
      1  03a0		       b8 07		      .word.w	iArray
      0  03a2					      dw	iTaskKill	;65	   kill a running task
      1  03a2		       f6 27		      .word.w	iTaskKill
      0  03a4					      dw	iTaskStat	;66	   return the state of a task PID
      1  03a4		       ca 27		      .word.w	iTaskStat
      0  03a6					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  03a6		       06 0d		      .word.w	iHexOut
      0  03a8					      dw	iReadComplete	;68	   Called after a background read completes
      1  03a8		       b4 05		      .word.w	iReadComplete
      0  03aa					      dw	iReadStart	;69	   Called to start a background read request
      1  03aa		       aa 05		      .word.w	iReadStart
      0  03ac					      dw	iStartIO	;70	   Lock task until io complete
      1  03ac		       2e 28		      .word.w	iStartIO
      0  03ae					      dw	iEndIO	;71	   release task lock for io
      1  03ae		       34 28		      .word.w	iEndIO
      0  03b0					      dw	iLogNot	;72	   Logical not
      1  03b0		       71 0d		      .word.w	iLogNot
      0  03b2					      dw	iLogOr	;73	   Logical Or
      1  03b2		       47 0d		      .word.w	iLogOr
      0  03b4					      dw	iLogAnd	;74	   Logical And
      1  03b4		       32 0d		      .word.w	iLogAnd
      0  03b6					      dw	iLogXor	;75	   Logical Xor
      1  03b6		       5c 0d		      .word.w	iLogXor
      0  03b8					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  03b8		       09 28		      .word.w	iWTASK
      0  03ba					      dw	iTASKPID	;77	   Returns the TASK PID
      1  03ba		       3f 28		      .word.w	iTASKPID
      0  03bc					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  03bc		       fd 0d		      .word.w	iTRACEPROG
      0  03be					      dw	idbgBasic	;79	   Interactive basic debugging
      1  03be		       a3 2d		      .word.w	idbgBasic
      0  03c0					      dw	iIPCS	;80	   Sending a msg to a task
      1  03c0		       2b 29		      .word.w	iIPCS
      0  03c2					      dw	iIPCR	;81	   Recieve a message from a task
      1  03c2		       42 29		      .word.w	iIPCR
      0  03c4					      dw	iIPCC	;82	   Check if any message available for task
      1  03c4		       56 29		      .word.w	iIPCC
      0  03c6					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03c6		       63 29		      .word.w	iIPCIO
      0  03c8					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03c8		       d8 24		      .word.w	iPushMathStack
      0  03ca					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03ca		       08 25		      .word.w	iPopMathStack
      0  03cc					      dw	iSaveMathStack	;86	   Save all math info
      1  03cc		       25 25		      .word.w	iSaveMathStack
      0  03ce					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03ce		       44 25		      .word.w	iRestoreMathStack
      0  03d0					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03d0		       f5 24		      .word.w	iIncParmCount
      0  03d2					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03d2		       6b 28		      .word.w	iTaskGetMathStack
      0  03d4					      dw	iTaskEnable	;90	   enable a suspended task
      1  03d4		       98 27		      .word.w	iTaskEnable
      0  03d6					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03d6		       b2 27		      .word.w	iTaskSuspend
      0  03d8					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03d8		       85 28		      .word.w	iTaskPutMathPtr
      0  03da					      dw	iTSTVT	;93	   test for another tasks variable
      1  03da		       be 0a		      .word.w	iTSTVT
      0  03dc					      dw	iSetR2	;94	   Set the Working register R2 to a value
      1  03dc		       60 09		      .word.w	iSetR2
      0  03de					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03de		       17 05		      .word.w	iStk2Tmp
      0  03e0					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03e0		       28 05		      .word.w	iTmp2Stk
      0  03e2					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03e2		       0a 0a		      .word.w	iTSTBYTE
      0  03e4					      dw	iINCVAR	;98	   Increment variable
      1  03e4		       90 0a		      .word.w	iINCVAR
      0  03e6					      dw	iDECVAR	;99	   Decrement variable
      1  03e6		       a8 0a		      .word.w	iDECVAR
      0  03e8					      dw	iSLICE	;100	   set the time slice for tasks
      1  03e8		       be 28		      .word.w	iSLICE
      0  03ea					      dw	iTSTB	;101	   Test if byte equals
      1  03ea		       29 0a		      .word.w	iTSTB
      0  03ec					      dw	iTSTW	;102	   Test If word equals
      1  03ec		       44 0a		      .word.w	iTSTW
      0  03ee					      dw	iOnGoto	;103	   Branch to table entry based upon buffer value
      1  03ee		       4f 1f		      .word.w	iOnGoto
      0  03f0					      dw	iTSTRELOP	;104	   Test relop, push mask onto stack if true, branch otherwise
      1  03f0		       80 1f		      .word.w	iTSTRELOP
      0  03f2					      dw	iRepeatLine	;105	   Repeat the same line again, start execution from beginning of the same line
      1  03f2		       cb 04		      .word.w	iRepeatLine
      0  03f4					      dw	iTSTBRANCH	;106	   Test for compiled branch, take branch if is, skip two bytes and following integer value(line number) goto, gosub, gofn
      1  03f4		       a7 1f		      .word.w	iTSTBRANCH
      0  03f6					      dw	iFastXfer	;107	   move top of stack to curptr
      1  03f6		       d2 04		      .word.w	iFastXfer
      0  03f8					      dw	iSetTerminal	;108	   Set the Io Terminal to be used by print and input statements
      1  03f8		       79 2f		      .word.w	iSetTerminal
      0  03fa					      dw	iINDB	;109	   fetch a single byte from memory indirect
      1  03fa		       a6 07		      .word.w	iINDB
      0  03fc					      dw	iSetBlock	;110	   Set a block or words or byte to a value 16 bit length
      1  03fc		       ff 23		      .word.w	iSetBlock
      0  03fe					      dw	iCopyBlock	;111	   Copy a block or memory from one location to another 16 bit length
      1  03fe		       55 24		      .word.w	iCopyBlock
      0  0400					      dw	iCmpBlock	;112	   Compare to parts of memory
      1  0400		       89 24		      .word.w	iCmpBlock
      0  0402					      dw	iShift	;113	   Shift left 0 or right 1 as parameters
      1  0402		       95 0d		      .word.w	iShift
      0  0404					      dw	iTimer	;114	   Start/Stop/Set timer and enable disable system irq
      1  0404		       74 19		      .word.w	iTimer
    135  0406
      0  0406					      dw	iJmpEndFalse	;115	   Jump end Block if top of math stack is false(0)
      1  0406		       f7 25		      .word.w	iJmpEndFalse
      0  0408					      dw	iJmpStart	;116	   Jump to beginning of block in stack
      1  0408		       06 26		      .word.w	iJmpStart
      0  040a					      dw	iBadOP	;117	   Invalid IL op code
      1  040a		       df 02		      .word.w	iBadOP
      0  040c					      dw	iBadOP	;118	   Invalid IL op code
      1  040c		       df 02		      .word.w	iBadOP
      0  040e					      dw	iBadOP	;119	   Invalid IL op code
      1  040e		       df 02		      .word.w	iBadOP
      0  0410					      dw	iBadOP	;120	   Invalid IL op code
      1  0410		       df 02		      .word.w	iBadOP
      0  0412					      dw	iBadOP	;121	   Invalid IL op code
      1  0412		       df 02		      .word.w	iBadOP
      0  0414					      dw	iBadOP	;122	   Invalid IL op code
      1  0414		       df 02		      .word.w	iBadOP
      0  0416					      dw	iBadOP	;123	   Invalid IL op code
      1  0416		       df 02		      .word.w	iBadOP
      0  0418					      dw	iBadOP	;124	   Invalid IL op code
      1  0418		       df 02		      .word.w	iBadOP
      0  041a					      dw	iBadOP	;125	   Invalid IL op code
      1  041a		       df 02		      .word.w	iBadOP
      0  041c					      dw	iBadOP	;126	   Invalid IL op code
      1  041c		       df 02		      .word.w	iBadOP
      0  041e					      dw	iBadOP	;127	   Invalid IL op code
      1  041e		       df 02		      .word.w	iBadOP
    149  0420
    150  0420
    151  0420
    152  0420
------- FILE mytb.asm
    500  0420		       04 20	   ILTBLend   equ	*
    501  0420
    502  0420							;
    503  0420							;=====================================================
    504  0420							;=====================================================
    505  0420							;=====================================================
    506  0420							; This marks the start of the handlers for IL opcodes.
    507  0420							;=====================================================
    508  0420							;=====================================================
    509  0420							;=====================================================
    510  0420							;
    511  0420							;
    512  0420		       a9 00	   iINIT      lda	#0	; clear IL stack pointer,gosub stack
    513  0422		       85 47		      sta	ILSTACKPTR
    514  0424		       85 4a		      sta	MATHSTACKPTR
    515  0426		       85 4d		      sta	GOSUBSTACKPTR
    516  0428		       a9 38		      lda	#[[GOSUBSTACKSIZE - 2] * 4]	; Reserve two entries for gosubs
    517  042a		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    518  042c							;
    519  042c		       ad 50 43 	      lda	ProgramStart	; user prog
    520  042f		       85 4f		      sta	CURPTR
    521  0431		       8d d9 36 	      sta	taskTable+1
    522  0434		       8d 52 43 	      sta	ProgramEnd
    523  0437		       ad 51 43 	      lda	ProgramStart+1
    524  043a		       85 50		      sta	CURPTR+1
    525  043c		       8d da 36 	      sta	taskTable+2
    526  043f		       8d 53 43 	      sta	ProgramEnd+1
    527  0442		       a9 80		      lda	#TASKACTIVE
    528  0444		       8d d8 36 	      sta	taskTable	;Mark the first slot as active
    529  0447		       a9 01		      lda	#1
    530  0449		       8d d6 37 	      sta	taskCounter	;there is always one task / Main task
    531  044c		       ad d4 37 	      lda	taskResetValue
    532  044f		       8d d2 37 	      sta	taskCurrentCycles	; set up the task switch counts
    533  0452		       ad d5 37 	      lda	taskResetValue+1
    534  0455		       8d d3 37 	      sta	taskCurrentCycles+1
    535  0458							;
    536  0458							; fall into XINIT...
    537  0458							;
    538  0458							;=====================================================
    539  0458							; This initializes for the start of the next line of
    540  0458							; BASIC text.
    541  0458							;
    542  0458		       78	   iXINIT     sei		; ensure interupts are off
    543  0459		       20 91 26 	      jsr	taskReset	; Clear the task table
    544  045c		       a9 00		      lda	#0	; Clear the irq flags
    545  045e		       8d c1 19 	      sta	IRQPending	; reset the irq pending
    546  0461		       8d c0 19 	      sta	IRQStatus	; Make sure irqs are off
    547  0464
    548  0464		       4c b1 02    goodExit   jmp	NextIL
    549  0467							;
    550  0467							;=====================================================
    551  0467							; This check if the escape key has been entered
    552  0467							; then changes out of run mode. z Set if esc found
    553  0467				   BreakSet
    554  0467		       20 0f f0 	      jsr	ISCHAR
    555  046a		       f0 06		      beq	BreakNo
    556  046c		       20 61 1a 	      jsr	VGETCH
    557  046f		       c9 1b		      cmp	#$1B
    558  0471		       60		      rts
    559  0472				   BreakNo
    560  0472		       a9 01		      lda	#1
    561  0474		       60		      rts
    562  0475
    563  0475							;
    564  0475
    565  0475							;=====================================================
    566  0475							; Verify there is nothing else on this input line.
    567  0475							; If there is, generate an error.
    568  0475							;
    569  0475		       a4 51	   iDONE      ldy	CUROFF
    570  0477		       b1 4f		      lda	(CURPTR),y
    571  0479		       f0 0e		      beq	doneadv
    572  047b		       c9 e6		      cmp	#oColon	; is it a  ':' or eol
    573  047d		       d0 03		      bne	idoneErr
    574  047f							;		  sty	  CUROFF
    575  047f		       4c b1 02 	      jmp	NextIL	; continue on this line
    576  0482
    577  0482				   idoneErr
    578  0482		       a2 04		      ldx	#ERR_EXTRA_STUFF
    579  0484		       a9 00		      lda	#0
    580  0486		       4c 7d 06 	      jmp	iErr2
    581  0489							;
    582  0489							; Advance to the next line
    583  0489							;
    584  0489				   doneadv
    585  0489		       4c b1 02 	      jmp	NextIL
    586  048c							;
    587  048c							;=====================================================
    588  048c							; Print the string until a closing quote
    589  048c							;
    590  048c				   iPRS
    591  048c		       20 d9 21 	      jsr	PrtQuoted
    592  048f		       84 51		      sty	CUROFF
    593  0491		       4c b1 02 	      jmp	NextIL
    594  0494							;
    595  0494							;=====================================================
    596  0494							; Pop the top off the stack and print it as a signed
    597  0494							; decimal number.
    598  0494							;
    599  0494				   iPRN
    600  0494		       20 dd 2c 	      jsr	popR0
    601  0497		       20 e5 20 	      jsr	PrintDecimal
    602  049a		       4c b1 02 	      jmp	NextIL
    603  049d							;
    604  049d							;=====================================================
    605  049d							; Space to next zone.	Currently the code does not
    606  049d							; keep track of which column the output is on, so
    607  049d							; just print a tab.
    608  049d							;
    609  049d				   iSPC
    610  049d		       a9 09		      lda	#TAB
    611  049f		       20 5e 1a 	      jsr	VOUTCH
    612  04a2		       4c b1 02 	      jmp	NextIL
    613  04a5							;
    614  04a5							;=====================================================
    615  04a5							; If in immediate mode, jump to the address following
    616  04a5							; the NXT instruction.  Else move to the next line of
    617  04a5							; user code and continue.
    618  04a5							;
    619  04a5		       a5 5b	   iNXT       lda	RunMode
    620  04a7		       d0 03		      bne	iNxtRun	;in run mode
    621  04a9							;
    622  04a9							; Get address and jump to it.
    623  04a9							;
    624  04a9		       4c 56 09 	      jmp	iJMP
    625  04ac							;
    626  04ac				   iNxtRun
    627  04ac		       a4 51		      ldy	CUROFF
    628  04ae		       b1 4f		      lda	(CURPTR),y
    629  04b0		       c9 e6		      cmp	#oColon
    630  04b2		       d0 06		      bne	iNxtRunGo
    631  04b4		       c8		      iny
    632  04b5		       84 51		      sty	CUROFF
    633  04b7		       4c c5 04 	      jmp	iNxtRun2
    634  04ba
    635  04ba				   iNxtRunGo
    636  04ba		       20 dc 2a 	      jsr	FindNextLine
    637  04bd		       20 f0 2a 	      jsr	AtEnd
    638  04c0		       d0 03		      bne	iNxtRun2	;not at end
    639  04c2							;
    640  04c2							; At the end of the program.  Pretend an END statement
    641  04c2							; was found.
    642  04c2							;
    643  04c2		       4c 02 06    iFINv      jmp	iFIN
    644  04c5							;
    645  04c5		       20 4e 2a    iNxtRun2   jsr	getILWord	;ignore next word
    646  04c8		       4c b1 02 	      jmp	NextIL
    647  04cb							;=====================================================
    648  04cb							;Repeat the same line against
    649  04cb		       a0 03	   iRepeatLine ldy	#3
    650  04cd		       84 51		      sty	CUROFF
    651  04cf		       4c b1 02 	      jmp	NextIL
    652  04d2							;
    653  04d2							;=====================================================
    654  04d2							; XFER takes the number on top of the stack and looks
    655  04d2							; for that line in the program, or the next line
    656  04d2							; higher.  Ie, if it's 1 but there is no line 1, then
    657  04d2							; find the next one after that.
    658  04d2							;
    659  04d2				   iFastXfer
    660  04d2		       20 f5 2c 	      jsr	popR1	; get type of transfer
    661  04d5		       a5 54		      lda	R1
    662  04d7		       f0 0e		      beq	iXFER
    663  04d9
    664  04d9		       20 dd 2c 	      jsr	popR0	; get where to transfer
    665  04dc				   FastFastXfer
    666  04dc		       a5 52		      lda	R0
    667  04de		       85 4f		      sta	CURPTR
    668  04e0		       a5 53		      lda	R0+1
    669  04e2		       85 50		      sta	CURPTR+1
    670  04e4		       4c ed 04 	      jmp	iXFER2
    671  04e7
    672  04e7				   iXFER
    673  04e7		       20 dd 2c 	      jsr	popR0
    674  04ea		       20 97 2a 	      jsr	findLine
    675  04ed
    676  04ed				   iXFER2
    677  04ed		       20 f0 2a 	      jsr	AtEnd	;at end of user program?
    678  04f0		       f0 d0		      beq	iFINv
    679  04f2
    680  04f2		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    681  04f4		       84 51		      sty	CUROFF
    682  04f6
    683  04f6							;		  lda	  #$ff
    684  04f6							;		  sta	  RunMode
    685  04f6							;
    686  04f6							; Transfer IL to STMT.  I don't like having this
    687  04f6							; hard-coded; fix it.
    688  04f6							;
    689  04f6							;		  lda	  #STMT&$ff
    690  04f6							;		  sta	  ILPC
    691  04f6							;		  lda	  #STMT>>8
    692  04f6							;		  sta	  ILPC+1
    693  04f6							;		  jmp	  NextIL
    694  04f6							;
    695  04f6							; Run
    696  04f6							;
    697  04f6				   iXferok
    698  04f6		       a9 ff		      lda	#$ff
    699  04f8		       85 5b		      sta	RunMode	;we're running
    700  04fa							;
    701  04fa							; Need a more elegant way to do this
    702  04fa							;
    703  04fa		       a9 28		      lda	#STMT&$ff
    704  04fc		       85 43		      sta	ILPC
    705  04fe		       a9 32		      lda	#STMT>>8
    706  0500		       85 44		      sta	ILPC+1
    707  0502		       4c b1 02 	      jmp	NextIL
    708  0505							;
    709  0505							;=====================================================
    710  0505							; Save the pointer to the next line to the call stack.
    711  0505							;
    712  0505		       20 52 2a    iSAV       jsr	getILByte	; load type of gosub
    713  0508		       20 65 2c 	      jsr	pushLN	; Type passed in A
    714  050b		       b0 03		      bcs	iSAVErr
    715  050d		       4c b1 02 	      jmp	NextIL
    716  0510
    717  0510		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    718  0512		       a9 00	   iSAVErr2   lda	#0
    719  0514		       4c 7d 06 	      jmp	iErr2
    720  0517							;====================================================
    721  0517							; Move stack top to and from temp area
    722  0517				   iStk2Tmp
    723  0517		       20 dd 2c 	      jsr	popR0
    724  051a		       a5 52		      lda	R0
    725  051c		       a0 48		      ldy	#TASKEXITCODE	; can also be used as temp
    726  051e		       91 41		      sta	(VARIABLES),y
    727  0520		       c8		      iny
    728  0521		       a5 53		      lda	R0+1
    729  0523		       91 41		      sta	(VARIABLES),y
    730  0525		       4c b1 02 	      jmp	NextIL
    731  0528
    732  0528		       a0 48	   iTmp2Stk   ldy	#TASKEXITCODE
    733  052a		       b1 41		      lda	(VARIABLES),y
    734  052c		       85 52		      sta	R0
    735  052e		       c8		      iny
    736  052f		       b1 41		      lda	(VARIABLES),y
    737  0531		       85 53		      sta	R0+1
    738  0533		       20 4b 2c 	      jsr	pushR0
    739  0536		       4c b1 02 	      jmp	NextIL
    740  0539							;
    741  0539							;=====================================================
    742  0539							; Pop the next line from the call stack. IRQ return
    743  0539							;
    744  0539		       20 8e 2c    iRET       jsr	popLN
    745  053c		       b0 d2		      bcs	iSAVErr
    746  053e		       a0 03		      ldy	#3
    747  0540		       84 51		      sty	CUROFF
    748  0542		       a9 00		      lda	#0
    749  0544		       8d c1 19 	      sta	IRQPending
    750  0547		       58		      cli
    751  0548		       4c b1 02 	      jmp	NextIL
    752  054b							;
    753  054b							;=====================================================
    754  054b							; Compare items on stack.  Okay, so on input there are
    755  054b							; three things on the stack
    756  054b							;
    757  054b							;    EXPR2 <- Top of stack
    758  054b							;    OP    <- relational operator, next on stack
    759  054b							;    EXPR1 <- last item on stack
    760  054b							;
    761  054b							; Comparison is: EXPR1 <operator> EXPR2
    762  054b							;
    763  054b							; Operator is one of...
    764  054b							;
    765  054b							;    2 is =
    766  054b							;    1 is <
    767  054b							;    3 is <=
    768  054b							;    5 is <>
    769  054b							;    4 is >
    770  054b							;    6 is >=
    771  054b							;
    772  054b							; Those are bit-mapped:
    773  054b							;
    774  054b							;    xxxxxGEL
    775  054b							;
    776  054b							;    G = Greater than
    777  054b							;    E = Equal
    778  054b							;    L = Less than
    779  054b							;
    780  054b							; If the comparison is false, do a NXT, ie, move to the
    781  054b							; next line and continue.  If true, continue executing
    782  054b							; on this line.
    783  054b							;
    784  054b		       00 01	   REL_LT     equ	%001
    785  054b		       00 02	   REL_EQUAL  equ	%010
    786  054b		       00 04	   REL_GT     equ	%100
    787  054b							;
    788  054b		       20 f5 2c    iCMPR      jsr	popR1
    789  054e		       20 0c 2d 	      jsr	popMQ	;operator in MQ
    790  0551		       20 dd 2c 	      jsr	popR0
    791  0554		       20 5d 05 	      jsr	iCMPRsub
    792  0557		       20 4b 2c 	      jsr	pushR0
    793  055a		       4c b1 02 	      jmp	NextIL
    794  055d							;
    795  055d							; See if they are equal or not
    796  055d							;
    797  055d				   iCMPRsub		; Called by internal functions
    798  055d
    799  055d		       a5 52		      lda	R0
    800  055f		       c5 54		      cmp	R1
    801  0561		       d0 0a		      bne	iCMPRnoteq	;try not equal
    802  0563		       a5 53		      lda	R0+1
    803  0565		       c5 55		      cmp	R1+1
    804  0567		       d0 04		      bne	iCMPRnoteq
    805  0569							;
    806  0569							; Equal, set the flag in MQ+1
    807  0569							;
    808  0569		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    809  056b		       d0 14		      bne	iCMPcom	;Exit it is equal
    810  056d							;
    811  056d							; See if EXPR1 (R0) < EXPR2 (R1)
    812  056d							; See www.6502.org/tutorials/compare_beyond.html
    813  056d							;
    814  056d				   iCMPRnoteq
    815  056d		       a5 52		      lda	R0
    816  056f		       c5 54		      cmp	R1	; Sets the carry flag
    817  0571		       a5 53		      lda	R0+1
    818  0573		       e5 55		      sbc	R1+1
    819  0575
    820  0575		       50 02		      bvc	iCMPR_2	; branch if N eor V
    821  0577		       49 80		      eor	#$80
    822  0579
    823  0579		       30 04	   iCMPR_2    bmi	iCMPlt
    824  057b		       a9 04		      lda	#REL_GT
    825  057d		       d0 02		      bne	iCMPcom
    826  057f
    827  057f		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    828  0581
    829  0581				   iCMPcom		;ora	    MQ+1	     ; or with original mask MQ+1 is always zero
    830  0581							;
    831  0581							; Now compare the end result with what the caller
    832  0581							; was looking for.
    833  0581							;
    834  0581		       25 56		      and	MQ
    835  0583		       f0 0c		      beq	iCMPno	; no match
    836  0585		       a9 ff		      lda	#$FF	; true is $ffff
    837  0587		       85 52		      sta	R0
    838  0589		       85 53		      sta	R0+1
    839  058b		       d0 0a		      bne	iCMPDone
    840  058d							;
    841  058d							; R0 > R1
    842  058d							;
    843  058d		       a9 04	   iCMPgt     lda	#REL_GT
    844  058f		       d0 f0		      bne	iCMPcom
    845  0591				   iCMPno
    846  0591		       a9 00		      lda	#0
    847  0593		       85 52		      sta	R0
    848  0595		       85 53		      sta	R0+1
    849  0597
    850  0597				   iCMPDone
    851  0597		       60		      rts
    852  0598
    853  0598							;
    854  0598							; if Not a match, so jump to the next line of code.
    855  0598							; Branches based upon value on top of the stack
    856  0598				   iBranch
    857  0598		       20 dd 2c 	      jsr	popR0
    858  059b		       a5 52		      lda	R0
    859  059d		       05 53		      ora	R0+1
    860  059f		       f0 03		      beq	iBranchFalse	; not true
    861  05a1		       4c b1 02 	      jmp	NextIL	; It is true if any value not zero
    862  05a4							;
    863  05a4				   iBranchFalse
    864  05a4		       20 dc 2a 	      jsr	FindNextLine
    865  05a7		       4c ed 04 	      jmp	iXFER2
    866  05aa							;
    867  05aa							;=====================================================
    868  05aa							; Start a read of data in background
    869  05aa				   iReadStart
    870  05aa		       a9 3f		      lda	#'?	; Prompt with question mark
    871  05ac		       a6 01		      ldx	1	; Indicate to start read in background
    872  05ae		       20 68 2b 	      jsr	GetLine	; Call the getline to start read
    873  05b1		       4c b1 02 	      jmp	NextIL	; next instruction
    874  05b4							;
    875  05b4							;=====================================================
    876  05b4							; Complete the read and return the curptr, curoff pointing to data
    877  05b4				   iReadComplete
    878  05b4		       a9 01		      lda	#GOSUB_RTN
    879  05b6		       20 65 2c 	      jsr	pushLN
    880  05b9		       90 03		      bcc	iReadOk
    881  05bb		       4c 3a 0c    iReadErr   jmp	ErrStkOver	; Check if there was an error
    882  05be				   iReadOk
    883  05be		       20 88 2b 	      jsr	ReadComplete
    884  05c1		       4c b1 02 	      jmp	NextIL
    885  05c4		       20 8e 2c 	      jsr	popLN
    886  05c7		       4c b1 02 	      jmp	NextIL
    887  05ca							;=====================================================
    888  05ca							; Get a line of text from the user, convert to a
    889  05ca							; number, leave on top of stack.
    890  05ca							;
    891  05ca				   iINNUM
    892  05ca		       a9 01		      lda	#GOSUB_RTN
    893  05cc		       20 65 2c 	      jsr	pushLN
    894  05cf		       b0 ea		      bcs	iReadErr	; Stack over flow error
    895  05d1							;
    896  05d1		       a9 3f		      lda	#'?
    897  05d3		       a2 00		      ldx	#0	;Wait for complete
    898  05d5		       20 68 2b 	      jsr	GetLine
    899  05d8		       20 fd 2a 	      jsr	getDecimal
    900  05db		       20 4b 2c 	      jsr	pushR0	;put onto stack
    901  05de		       b0 db		      bcs	iReadErr	;StackOverflow error
    902  05e0							;
    903  05e0		       4c fc 05 	      jmp	ExitIn
    904  05e3							;
    905  05e3							;=====================================================
    906  05e3							; Get a line of text from the user, convert to a
    907  05e3							; character value , leave on top of stack. up to 2 characters
    908  05e3							;
    909  05e3				   iINSTR
    910  05e3		       a9 01		      lda	#GOSUB_RTN
    911  05e5		       20 65 2c 	      jsr	pushLN
    912  05e8		       b0 d1		      bcs	iReadErr	; Stack overflow error
    913  05ea		       a9 3f		      lda	#'?
    914  05ec		       a2 00		      ldx	#0	;wait for read complete
    915  05ee		       20 68 2b 	      jsr	GetLine
    916  05f1		       b1 4f		      lda	(CURPTR),y
    917  05f3		       85 52		      sta	R0
    918  05f5		       a9 00		      lda	#0
    919  05f7		       85 53		      sta	R0+1
    920  05f9		       20 4b 2c 	      jsr	pushR0	;put onto stack
    921  05fc				   ExitIn
    922  05fc		       20 8e 2c 	      jsr	popLN
    923  05ff		       4c b1 02 	      jmp	NextIL
    924  0602							;
    925  0602							;
    926  0602							;=====================================================
    927  0602							; Stop the currently running program.	Actually very
    928  0602							; simple to do... clear the RunMode flag, then set the
    929  0602							; ILPC to the standard handler and continue running.
    930  0602							;
    931  0602		       a9 00	   iFIN       lda	#0
    932  0604		       85 5b		      sta	RunMode
    933  0606		       20 91 26 	      jsr	taskReset
    934  0609							;
    935  0609		       ad 3d 43 	      lda	errGoto
    936  060c		       85 43		      sta	ILPC
    937  060e		       ad 3e 43 	      lda	errGoto+1
    938  0611		       85 44		      sta	ILPC+1
    939  0613		       4c b1 02 	      jmp	NextIL
    940  0616							;
    941  0616							;=====================================================
    942  0616							; Handle the ERR opcode.  Following the instruction is
    943  0616							; a 16 bit error number.  Print an error message, and
    944  0616							; if we're in run mode, print the line number.  Stop
    945  0616							; program execution and return to the initial state.
    946  0616							;
    947  0616		       ad 4a 43    iERR       lda	taskIOPending
    948  0619		       f0 03		      beq	iErrNext
    949  061b		       ce 4a 43 	      dec	taskIOPending
    950  061e
    951  061e		       20 4e 2a    iErrNext   jsr	getILWord	;get err code
    952  0621		       20 27 06 	      jsr	DisplayError
    953  0624		       4c 80 06 	      jmp	iErrComplete
    954  0627							;
    955  0627							; Enter here with the error code in X (LSB) and A (MSB).
    956  0627							;
    957  0627				   DisplayError
    958  0627		       86 52		      stx	R0
    959  0629		       85 53		      sta	R0+1
    960  062b							;
    961  062b		       20 b6 21 	      jsr	puts
      0  062e					      db	CR,LF,"Error ",0
      1  062e		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
    963  0637		       20 e5 20 	      jsr	PrintDecimal
    964  063a							;
    965  063a		       a5 5b		      lda	RunMode	;running?
    966  063c		       f0 3b		      beq	iERR3	;nope
    967  063e		       20 b6 21 	      jsr	puts
      0  0641					      db	" at line ",0
      1  0641		       20 61 74 20*	      .byte.b	" at line ",0
    969  064b		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    970  064d				   iErr2a
    971  064d		       b1 4f		      lda	(CURPTR),y
    972  064f		       85 52		      sta	R0
    973  0651		       c8		      iny
    974  0652		       b1 4f		      lda	(CURPTR),y
    975  0654		       85 53		      sta	R0+1
    976  0656		       20 e5 20 	      jsr	PrintDecimal
    977  0659		       20 b6 21 	      jsr	puts
      0  065c					      db	":",0
      1  065c		       3a 00		      .byte.b	":",0
    979  065e		       a9 00		      lda	#0
    980  0660		       85 53		      sta	R0+1
    981  0662		       a5 51		      lda	CUROFF
    982  0664		       18		      clc
    983  0665		       e9 03		      sbc	#3
    984  0667		       85 52		      sta	R0
    985  0669		       20 e5 20 	      jsr	PrintDecimal
    986  066c		       20 b6 21 	      jsr	puts
      0  066f					      db	":",0
      1  066f		       3a 00		      .byte.b	":",0
    988  0671		       ad d7 36 	      lda	taskPtr
    989  0674		       85 52		      sta	R0
    990  0676		       20 99 21 	      jsr	HexToOut
    991  0679							;
    992  0679				   iERR3
    993  0679		       20 96 2d 	      jsr	CRLF
    994  067c		       60		      rts
    995  067d
    996  067d				   iErr2
    997  067d		       20 27 06 	      jsr	DisplayError
    998  0680
    999  0680				   iErrComplete
   1000  0680		       20 89 26 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
   1001  0683		       a9 00		      lda	#0
   1002  0685		       85 5b		      sta	RunMode	; fall through...
   1003  0687							;
   1004  0687							;=====================================================
   1005  0687							; Reset the IL to be back at the idle loop.  Does not
   1006  0687							; clear variables so the user can see what state
   1007  0687							; the program is in.
   1008  0687							;
   1009  0687		       a9 00	   ResetIL    lda	#0
   1010  0689		       85 4f		      sta	CURPTR
   1011  068b		       85 51		      sta	CUROFF
   1012  068d		       85 47		      sta	ILSTACKPTR
   1013  068f		       ad 3d 43 	      lda	errGoto
   1014  0692		       85 43		      sta	ILPC
   1015  0694		       ad 3e 43 	      lda	errGoto+1
   1016  0697		       85 44		      sta	ILPC+1
   1017  0699		       a2 ff		      ldx	#$FF	; make sure the stack pointer is reset
   1018  069b		       9a		      txs
   1019  069c		       4c b1 02 	      jmp	NextIL
   1020  069f
   1021  069f							;
   1022  069f							;=====================================================
   1023  069f							; Pop two items off stack, add them, then place the
   1024  069f							; result back onto the stack.
   1025  069f							;
   1026  069f		       20 dd 2c    iADD       jsr	popR0
   1027  06a2		       20 f5 2c 	      jsr	popR1
   1028  06a5				   iADDfast
   1029  06a5		       18		      clc
   1030  06a6		       a5 52		      lda	R0
   1031  06a8		       65 54		      adc	R1
   1032  06aa		       85 52		      sta	R0
   1033  06ac		       a5 53		      lda	R0+1
   1034  06ae		       65 55		      adc	R1+1
   1035  06b0		       85 53		      sta	R0+1
   1036  06b2		       4c 1d 07 	      jmp	pushR0nextIl
   1037  06b5							;
   1038  06b5							;=====================================================
   1039  06b5							; Pop two items off the stack.  Subtract the top of
   1040  06b5							; stack from the lower entry.
   1041  06b5							;
   1042  06b5		       20 f5 2c    iSUB       jsr	popR1
   1043  06b8		       20 dd 2c 	      jsr	popR0
   1044  06bb		       38		      sec
   1045  06bc		       a5 52		      lda	R0
   1046  06be		       e5 54		      sbc	R1
   1047  06c0		       85 52		      sta	R0
   1048  06c2		       a5 53		      lda	R0+1
   1049  06c4		       e5 55		      sbc	R1+1
   1050  06c6		       85 53		      sta	R0+1
   1051  06c8		       4c 1d 07 	      jmp	pushR0nextIl
   1052  06cb							;
   1053  06cb							;=====================================================
   1054  06cb							; Negate the top of stack.
   1055  06cb							;
   1056  06cb		       20 dd 2c    iNEG       jsr	popR0
   1057  06ce		       a5 52		      lda	R0
   1058  06d0		       49 ff		      eor	#$ff
   1059  06d2		       85 52		      sta	R0
   1060  06d4		       a5 53		      lda	R0+1
   1061  06d6		       49 ff		      eor	#$ff
   1062  06d8		       85 53		      sta	R0+1
   1063  06da		       e6 52		      inc	R0
   1064  06dc		       d0 02		      bne	iNEG2
   1065  06de		       e6 53		      inc	R0+1
   1066  06e0		       4c 1d 07    iNEG2      jmp	pushR0nextIl
   1067  06e3							;
   1068  06e3							;=====================================================
   1069  06e3							; Multiply top two items on the stack, put the results
   1070  06e3							; on top.  This uses the algorithm documented on page
   1071  06e3							; 115 of "Microprocessor Programming for Computer
   1072  06e3							; Hobbyists" by Neill Graham.
   1073  06e3							;
   1074  06e3		       20 e9 06    iMUL       jsr	iMultiply
   1075  06e6		       4c b1 02 	      jmp	NextIL
   1076  06e9
   1077  06e9				   iMultiply
   1078  06e9		       20 dd 2c 	      jsr	popR0	;AC
   1079  06ec		       20 f5 2c 	      jsr	popR1	;OP
   1080  06ef							;
   1081  06ef		       a5 52		      lda	R0
   1082  06f1		       85 56		      sta	MQ
   1083  06f3		       a5 53		      lda	R0+1
   1084  06f5		       85 57		      sta	MQ+1
   1085  06f7		       a9 00		      lda	#0	;clear result
   1086  06f9		       85 52		      sta	R0
   1087  06fb		       85 53		      sta	R0+1
   1088  06fd							;
   1089  06fd		       a2 10		      ldx	#16	;number of bits in value
   1090  06ff		       06 52	   multloop   asl	R0
   1091  0701		       26 53		      rol	R0+1
   1092  0703		       06 56		      asl	MQ
   1093  0705		       26 57		      rol	MQ+1
   1094  0707		       90 0d		      bcc	multno	;skip add if no carry
   1095  0709							;
   1096  0709							; Add R1 back into R0
   1097  0709							;
   1098  0709		       18		      clc
   1099  070a		       a5 52		      lda	R0
   1100  070c		       65 54		      adc	R1
   1101  070e		       85 52		      sta	R0
   1102  0710		       a5 53		      lda	R0+1
   1103  0712		       65 55		      adc	R1+1
   1104  0714		       85 53		      sta	R0+1
   1105  0716							;
   1106  0716		       ca	   multno     dex		;did all bits yet?
   1107  0717		       d0 e6		      bne	multloop
   1108  0719		       20 4b 2c 	      jsr	pushR0	;OP
   1109  071c		       60		      rts
   1110  071d							;
   1111  071d				   pushR0nextIl
   1112  071d		       20 4b 2c 	      jsr	pushR0	;OP
   1113  0720		       4c b1 02 	      jmp	NextIL
   1114  0723							;
   1115  0723							;=====================================================
   1116  0723							; Divide the top of stack into the next to top item.
   1117  0723							; Leave results on stack.  Taken from:
   1118  0723							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1119  0723							;
   1120  0723							; R0 = R0 / R1
   1121  0723							; Remainder is in MQ
   1122  0723							;
   1123  0723		       20 3d 07    iDIV       jsr	iDoDiv
   1124  0726		       20 5e 2d 	      jsr	RestoreSigns
   1125  0729		       4c 1d 07 	      jmp	pushR0nextIl
   1126  072c
   1127  072c		       20 3d 07    iMOD       jsr	iDoDiv
   1128  072f		       20 5e 2d 	      jsr	RestoreSigns
   1129  0732		       a5 56		      lda	MQ
   1130  0734		       85 52		      sta	R0
   1131  0736		       a5 57		      lda	MQ+1
   1132  0738		       85 53		      sta	R0+1
   1133  073a		       4c 1d 07 	      jmp	pushR0nextIl
   1134  073d
   1135  073d				   iDoDiv
   1136  073d		       20 f5 2c 	      jsr	popR1
   1137  0740		       20 dd 2c 	      jsr	popR0
   1138  0743							;
   1139  0743							; Check for divide by zero
   1140  0743							;
   1141  0743
   1142  0743				   iDivNoPop
   1143  0743		       a5 54		      lda	R1
   1144  0745		       05 55		      ora	R1+1
   1145  0747		       f0 29		      beq	divby0
   1146  0749							;
   1147  0749		       20 23 2d 	      jsr	SaveSigns
   1148  074c		       a9 00		      lda	#0	;preset remainder to 0
   1149  074e		       85 56		      sta	MQ
   1150  0750		       85 57		      sta	MQ+1
   1151  0752		       a2 10		      ldx	#16	;repeat for each bit: ...
   1152  0754				   divloop
   1153  0754		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1154  0756		       26 53		      rol	R0+1
   1155  0758		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1156  075a		       26 57		      rol	MQ+1
   1157  075c		       a5 56		      lda	MQ
   1158  075e		       38		      sec
   1159  075f		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1160  0761		       a8		      tay		;lb result -> Y, for we may need it later
   1161  0762		       a5 57		      lda	MQ+1
   1162  0764		       e5 55		      sbc	R1+1
   1163  0766		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1164  0768
   1165  0768		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1166  076a		       84 56		      sty	MQ
   1167  076c		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1168  076e
   1169  076e		       ca	   skip       dex
   1170  076f		       d0 e3		      bne	divloop
   1171  0771		       60		      rts
   1172  0772							;
   1173  0772							; Indicate divide-by-zero error
   1174  0772							;
   1175  0772		       68	   divby0     pla		; remove the reyurn from the stack
   1176  0773		       68		      pla
   1177  0774		       a2 06		      ldx	#ERR_DIVIDE_ZERO	; do the error
   1178  0776		       a9 00		      lda	#0
   1179  0778		       4c 7d 06 	      jmp	iErr2
   1180  077b							;
   1181  077b							;=====================================================
   1182  077b							; This pops the top two items off the stack.  The top
   1183  077b							; item is a data value and the other is an ABSOLUTE address.
   1184  077b							; Save the value into that address.
   1185  077b							;
   1186  077b		       98	   iSTORE     tya
   1187  077c		       48		      pha
   1188  077d		       20 dd 2c 	      jsr	popR0	;data
   1189  0780		       20 f5 2c 	      jsr	popR1	;Storage location
   1190  0783		       a0 01		      ldy	#1
   1191  0785		       a5 58		      lda	R2
   1192  0787		       c9 a2		      cmp	#tByte
   1193  0789		       f0 04		      beq	iStoreB
   1194  078b				   iStoreW
   1195  078b		       a5 53		      lda	R0+1
   1196  078d		       91 54		      sta	(R1),y
   1197  078f				   iStoreB
   1198  078f		       a5 52		      lda	R0
   1199  0791		       88		      dey
   1200  0792		       91 54		      sta	(R1),y
   1201  0794		       68		      pla
   1202  0795		       a8		      tay
   1203  0796		       4c b1 02 	      jmp	NextIL
   1204  0799							;
   1205  0799							;=====================================================
   1206  0799							; Replaces the top of stack with the Value
   1207  0799							; of the variable  whose absolute address it represents.
   1208  0799							;
   1209  0799
   1210  0799		       98	   iIND       tya
   1211  079a		       48		      pha
   1212  079b		       20 f5 2c 	      jsr	popR1
   1213  079e		       a0 01		      ldy	#1
   1214  07a0		       a5 58		      lda	R2
   1215  07a2		       c9 a4		      cmp	#tInteger
   1216  07a4		       f0 04		      beq	iINDW
   1217  07a6				   iINDB
   1218  07a6		       a9 00		      lda	#0
   1219  07a8		       f0 02		      BEQ	iINDC
   1220  07aa				   iINDW
   1221  07aa		       b1 54		      lda	(R1),y
   1222  07ac				   iINDC
   1223  07ac		       85 53		      sta	R0+1
   1224  07ae		       88		      dey
   1225  07af		       b1 54		      lda	(R1),y
   1226  07b1		       85 52		      sta	R0
   1227  07b3		       68		      pla
   1228  07b4		       a8		      tay
   1229  07b5		       4c 1d 07 	      jmp	pushR0nextIl
   1230  07b8
   1231  07b8							;
   1232  07b8							;=====================================================
   1233  07b8							; Check which type of index to use byte or word and jmp to correct
   1234  07b8							; function
   1235  07b8		       98	   iArray     tya
   1236  07b9		       48		      pha
   1237  07ba
   1238  07ba		       20 dd 2c 	      jsr	popR0	; Get the array index
   1239  07bd		       20 f5 2c 	      jsr	popR1	; Get the Variable address
   1240  07c0
   1241  07c0		       20 52 2a 	      jsr	getILByte	; Get type of number to process
   1242  07c3		       c9 81		      cmp	#GOSUB_RTN_VALUE	; Are we testing a valid parameter
   1243  07c5		       f0 52		      beq	iArrayFNparm	; process a fn pramater index
   1244  07c7
   1245  07c7		       29 fe		      and	#$FE	; Turn off the unsigned bit
   1246  07c9		       c9 a2		      cmp	#tByte	; Test for a byte index
   1247  07cb		       f0 10		      beq	iArrayB	; yes so branch to process a byte
   1248  07cd							;=====================================================
   1249  07cd							; Process 32 bit index into memory
   1250  07cd		       c9 a6	   iArrayL    cmp	#tLong	; Are we working with 32 bit integers
   1251  07cf		       d0 06		      bne	iArrayW	; Process with sigle shift
   1252  07d1		       06 52		      asl	R0	; Do the multiply by 2
   1253  07d3		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1254  07d5		       b0 39		      bcs	iArrayError	; if the carry is set we have an error
   1255  07d7							;=====================================================
   1256  07d7							; Get the array index from top of stack get Current variable
   1257  07d7							; address from next on stack, add the offset
   1258  07d7							; push the result back onto the stack
   1259  07d7				   iArrayW		; pointers, arrays etc all use 16 bit unsigned integers
   1260  07d7		       06 52		      asl	R0	; Do the multiply by 2
   1261  07d9		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1262  07db		       b0 33		      bcs	iArrayError	; if the carry is set we have an error
   1263  07dd
   1264  07dd							;=====================================================
   1265  07dd							; Get from Byte array not Integer array
   1266  07dd				   iArrayB
   1267  07dd		       18		      clc
   1268  07de		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1269  07e0		       65 52		      adc	R0
   1270  07e2		       85 52		      sta	R0
   1271  07e4		       a5 55		      lda	R1+1
   1272  07e6		       65 53		      adc	R0+1
   1273  07e8		       85 53		      sta	R0+1	; The new Variable Address is stored in R0
   1274  07ea		       a5 55		      lda	R1+1
   1275  07ec		       cd 53 43 	      cmp	ProgramEnd+1	; lets check if we are processing an @ buffer pointer to free memory
   1276  07ef		       d0 08		      bne	iArrayCheckVar
   1277  07f1				   iArrayExit
   1278  07f1		       20 4b 2c 	      jsr	pushR0	; Push R0 assume it is correct
   1279  07f4
   1280  07f4		       68		      pla
   1281  07f5		       a8		      tay
   1282  07f6		       4c b1 02 	      jmp	NextIL
   1283  07f9							; Check for valis variable and valid index to use
   1284  07f9		       a5 41	   iArrayCheckVar lda	VARIABLES
   1285  07fb		       18		      clc
   1286  07fc		       69 33		      adc	#[25*2]+1	; the number of actual variable valid bytes
   1287  07fe		       85 56		      sta	MQ	; mq contains the last valid byte we can use
   1288  0800		       a9 00		      lda	#0
   1289  0802		       65 42		      adc	VARIABLES+1	; Memory past last word R0+1 > A then invalid
   1290  0804		       c5 53		      cmp	R0+1
   1291  0806		       90 08		      bcc	iArrayError
   1292  0808		       a5 52		      lda	R0	; a > m invalid past last byte of variable area
   1293  080a		       c5 56		      cmp	MQ
   1294  080c		       f0 e3		      beq	iArrayExit	; If it is equal then it is valid
   1295  080e		       90 e1		      bcc	iArrayExit	; if it is less it is valid
   1296  0810
   1297  0810							; Get here if array index is out of range
   1298  0810		       68	   iArrayError pla
   1299  0811		       98		      tya
   1300  0812		       a9 00		      lda	#0
   1301  0814		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1302  0816		       4c 7d 06 	      jmp	iErr2
   1303  0819							;=====================================================
   1304  0819							; Verify function paramater index is valid
   1305  0819		       20 c1 25    iArrayFNparm jsr	GosubFindParms	; Get a pointer to the current functions parameter list info
   1306  081c		       90 f2		      bcc	iArrayError	; There are no paramters for this call, should never be true
   1307  081e		       88		      dey
   1308  081f		       88		      dey		; Points to parameter count
   1309  0820		       a5 52		      lda	R0	; get parm to be accessed
   1310  0822		       d1 4b		      cmp	(GOSUBSTACK),y	; compare to max number allowed
   1311  0824		       b0 ea		      bcs	iArrayError	; the parameter index should be less than the count
   1312  0826		       06 52		      asl	R0	; Do the multiply by 2
   1313  0828		       26 53		      rol	R0+1
   1314  082a
   1315  082a		       18		      clc
   1316  082b		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1317  082d		       65 52		      adc	R0
   1318  082f		       85 52		      sta	R0
   1319  0831		       a5 55		      lda	R1+1
   1320  0833		       65 53		      adc	R0+1
   1321  0835		       85 53		      sta	R0+1	; The new Variable Address is stored in R0
   1322  0837		       4c f1 07 	      jmp	iArrayExit	; Get ot we are done
   1323  083a							;
   1324  083a							;=====================================================
   1325  083a							; List the current BASIC program in memory.  Uses R0,
   1326  083a							; tempIly, and dpl.
   1327  083a							;
   1328  083a		       20 dd 2e    iLST       jsr	SetOutConsole
   1329  083d		       ad 50 43    iLST2      lda	ProgramStart
   1330  0840		       85 59		      sta	dpl
   1331  0842		       ad 51 43 	      lda	ProgramStart+1
   1332  0845		       85 5a		      sta	dpl+1
   1333  0847							;
   1334  0847							; dpl/dph point to the current line.  See if we're at
   1335  0847							; the end of the program.
   1336  0847							;
   1337  0847		       a5 59	   iLSTloop   lda	dpl
   1338  0849		       cd 52 43 	      cmp	ProgramEnd
   1339  084c		       d0 07		      bne	iLstNotEnd
   1340  084e		       a5 5a		      lda	dpl+1
   1341  0850		       cd 53 43 	      cmp	ProgramEnd+1
   1342  0853		       f0 15		      beq	iLstdone
   1343  0855							;
   1344  0855		       20 4e 22    iLstNotEnd jsr	PrintProgramLine
   1345  0858							;		  ldy	  #1		  ;Change:  Skip first byte length
   1346  0858							;		  lda	  (dpl),y	  ;line number LSB
   1347  0858							;		  sta	  R0
   1348  0858							;		  iny
   1349  0858							;		  lda	  (dpl),y		 ;line number MSB
   1350  0858							;		  sta	  R0+1
   1351  0858							;		  iny
   1352  0858							;		  sty	  tempIlY
   1353  0858							;		  jsr	  PrintDecimal
   1354  0858							;		  lda	  #SPACE
   1355  0858							;		  jsr	  VOUTCH
   1356  0858							;		  ldy	  tempIlY
   1357  0858							;iLSTl2	  lda	  (dpl),y
   1358  0858							;		  beq	  iLST3 	  ;end of this line 0 value
   1359  0858							;		  sty	  tempIlY
   1360  0858							;		  jsr	  VOUTCH
   1361  0858							;		  ldy	  tempIlY
   1362  0858							;		  iny
   1363  0858							;		  bne	  iLSTl2	  ;do next char
   1364  0858							;
   1365  0858							; End of this line.  Print CR/LF, then move to the
   1366  0858							; next line.
   1367  0858							;
   1368  0858		       a0 00	   iLST3      ldy	#0	;Move to next line
   1369  085a		       b1 59		      lda	(dpl),y	;Current line length
   1370  085c		       18		      clc		;Clear the carry flag
   1371  085d							;		  tya
   1372  085d		       65 59		      adc	dpl	;Add the offset to the pointer
   1373  085f		       85 59		      sta	dpl	;Save the new value
   1374  0861		       a5 5a		      lda	dpl+1	;Next byte
   1375  0863		       69 00		      adc	#0	;ad in the carry if any
   1376  0865		       85 5a		      sta	dpl+1	;Save it
   1377  0867							;
   1378  0867							; Have to manually do CR/LF so it uses the vectored
   1379  0867							; output function.
   1380  0867							;
   1381  0867							;		  lda	  #CR
   1382  0867							;		  jsr	  VOUTCH
   1383  0867							;		  lda	  #LF
   1384  0867							;		  jsr	  VOUTCH
   1385  0867		       4c 47 08 	      jmp	iLSTloop	;do next line
   1386  086a							;
   1387  086a		       20 dd 2e    iLstdone   jsr	SetOutConsole
   1388  086d		       4c b1 02 	      jmp	NextIL
   1389  0870							;
   1390  0870							;=====================================================
   1391  0870							; Get a line of text into LINBUF.  Terminate with a
   1392  0870							; null byte.
   1393  0870							;
   1394  0870				   iGETLINE
   1395  0870		       a9 3e		      lda	#'>	;prompt character
   1396  0872		       a6 00		      ldx	0	;Wait for read to complete
   1397  0874		       20 68 2b 	      jsr	GetLine
   1398  0877							;
   1399  0877		       a9 00		      lda	#0
   1400  0879		       85 5b		      sta	RunMode
   1401  087b				   iGetParseLine
   1402  087b							; lda	   CUROFF
   1403  087b							; pha
   1404  087b		       20 59 1d 	      jsr	ParseInputLine
   1405  087e							; pla
   1406  087e							;  sta     CUROFF
   1407  087e		       a9 56		      lda	#TOKENBUFFER&$FF
   1408  0880		       85 4f		      sta	CURPTR
   1409  0882		       a9 1c		      lda	#TOKENBUFFER>>8
   1410  0884		       85 50		      sta	CURPTR+1
   1411  0886		       a9 01		      lda	#1
   1412  0888		       85 51		      sta	CUROFF
   1413  088a		       4c b1 02 	      jmp	NextIL
   1414  088d							;
   1415  088d							;=====================================================
   1416  088d							; This is called when the input buffer contains a line
   1417  088d							; typed in by the user that starts with a line number.
   1418  088d							; Insert the line into the program or delete the line
   1419  088d							; if there is nothing after the line number,
   1420  088d							;
   1421  088d				   iINSRT		; On entry here the TOKEBUFFER contains the Parsed input line completely
   1422  088d		       ad 57 1c 	      lda	TOKENBUFFER+1	; Get the first byte of the line number
   1423  0890		       85 52		      sta	R0	; place the number into R0
   1424  0892		       ad 58 1c 	      lda	TOKENBUFFER+2	; Get hi byte of line number
   1425  0895		       85 53		      STA	R0+1	; Place it into
   1426  0897							;
   1427  0897							; Now find the line OR the next higher line OR the
   1428  0897							; end of the program.
   1429  0897							;
   1430  0897		       20 97 2a 	      jsr	findLine	; Look for the line number in the current program
   1431  089a							; Returns Z and curptr point to the line if found
   1432  089a							; Returns C and curptr at next higher line if not found and there is a higher line
   1433  089a							; Returns ZC clear and curptr to end of program if higher than all other lines
   1434  089a							;
   1435  089a							; If the line exists, it needs to be removed.
   1436  089a							;
   1437  089a		       d0 44		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1438  089c							;
   1439  089c							; Get length of line to be removed, we fall thru to here if we find a matching line
   1440  089c							;
   1441  089c							;		 jsr	 getCURPTRLength ;results in Y , curptr is pointing to point we need to insert the line
   1442  089c		       a0 00		      ldy	#0
   1443  089e		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1444  08a0		       a8		      tay
   1445  08a1							;If it is equal we delete the line and replace it, get length
   1446  08a1							;then adjust all program line after up or down depending on len of line
   1447  08a1							;If next higher then just move everythimg down by length bytes
   1448  08a1							;This call will return how many bytes in the line we found
   1449  08a1		       8c 49 43 	      sty	lineLength	;Save the length of the line we found
   1450  08a4							;
   1451  08a4							; Compute the new end of the program first.
   1452  08a4							;
   1453  08a4		       38		      sec		;Set the carry bit
   1454  08a5		       ad 52 43 	      lda	ProgramEnd	;Get low byte of program end
   1455  08a8		       ed 49 43 	      sbc	lineLength	;Subtract the length of the current line
   1456  08ab		       8d 52 43 	      sta	ProgramEnd	;save it
   1457  08ae		       ad 53 43 	      lda	ProgramEnd+1
   1458  08b1		       e9 00		      sbc	#0	;Process the carry
   1459  08b3		       8d 53 43 	      sta	ProgramEnd+1	;We now have the new end of program with the line removed
   1460  08b6							;
   1461  08b6							; Copy CURPTR into R1 for working
   1462  08b6							;
   1463  08b6		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1464  08b8		       85 54		      sta	R1
   1465  08ba		       a5 50		      lda	CURPTR+1
   1466  08bc		       85 55		      sta	R1+1
   1467  08be							;
   1468  08be							; See if we're at the end.
   1469  08be							;
   1470  08be		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1471  08c0		       cd 52 43 	      cmp	ProgramEnd
   1472  08c3		       d0 07		      bne	InsDelLoop
   1473  08c5		       a5 55		      lda	R1+1
   1474  08c7		       cd 53 43 	      cmp	ProgramEnd+1
   1475  08ca		       f0 14		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1476  08cc							;
   1477  08cc							; Move one byte, move to next location.
   1478  08cc							;
   1479  08cc		       ac 49 43    InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1480  08cf		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1481  08d1		       b1 54		      lda	(R1),y
   1482  08d3		       a0 00		      ldy	#0
   1483  08d5		       91 54		      sta	(R1),y
   1484  08d7		       e6 54		      inc	R1
   1485  08d9		       d0 e3		      bne	InsDelChk
   1486  08db		       e6 55		      inc	R1+1
   1487  08dd		       4c be 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1488  08e0							;
   1489  08e0							; Deletion is done.
   1490  08e0							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1491  08e0							;
   1492  08e0				   insert2		; ldy	   offset		; get back ptr	Get the current offset
   1493  08e0		       ad 56 1c 	      lda	TOKENBUFFER	; Get the length
   1494  08e3		       c9 04		      cmp	#4	; empty lines only have 4 bytes { len(1), linenum(2) ,null(1) }
   1495  08e5							;		 lda	 LINBUF,y	      ;next byte     Get the next byte to be stored
   1496  08e5		       f0 54		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1497  08e7							;
   1498  08e7							; CURPTR points to where the line will be inserted.
   1499  08e7							;
   1500  08e7							;		 jsr	 getLineLength	 ;get bytes needed Reload the number of bytes required for the new line
   1501  08e7		       ae 56 1c 	      ldx	TOKENBUFFER
   1502  08ea		       8e 49 43 	      stx	lineLength	; So update, the TOKENBUFFER already has the line length
   1503  08ed							;
   1504  08ed		       ad 52 43 	      lda	ProgramEnd	;Load the start address for the copy
   1505  08f0							;At this point curptr still contains the location we will insert data
   1506  08f0		       85 5c		      sta	FROM
   1507  08f2		       ad 53 43 	      lda	ProgramEnd+1
   1508  08f5		       85 5d		      sta	FROM+1
   1509  08f7							;
   1510  08f7		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1511  08f9		       b1 5c		      lda	(FROM),y
   1512  08fb		       ac 49 43 	      ldy	lineLength	;Now load y with new offset downward to store the byte
   1513  08fe		       91 5c		      sta	(FROM),y	;Save the new byte
   1514  0900							;
   1515  0900		       a5 5c		      lda	FROM	;Check if we have copied the last byte
   1516  0902		       c5 4f		      cmp	CURPTR
   1517  0904		       d0 06		      bne	mvUpMore
   1518  0906		       a5 5d		      lda	FROM+1
   1519  0908		       c5 50		      cmp	CURPTR+1
   1520  090a		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1521  090c							;
   1522  090c							; Not done yet
   1523  090c							;
   1524  090c		       a5 5c	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1525  090e		       d0 02		      bne	mvUpMore2
   1526  0910		       c6 5d		      dec	FROM+1
   1527  0912		       c6 5c	   mvUpMore2  dec	FROM
   1528  0914		       4c f7 08 	      jmp	mvup1	;Loop until everything is moved
   1529  0917							;
   1530  0917							; All done with copy.
   1531  0917							;
   1532  0917				   mvUpDone
   1533  0917		       18		      clc		;Ok, We are now ready to copy the new line to the program
   1534  0918		       ad 49 43 	      lda	lineLength	;Number of bytes to copy from line buff
   1535  091b		       6d 52 43 	      adc	ProgramEnd	;Now pdate the end of program address for space we just opened
   1536  091e		       8d 52 43 	      sta	ProgramEnd
   1537  0921		       ad 53 43 	      lda	ProgramEnd+1
   1538  0924		       69 00		      adc	#0
   1539  0926		       8d 53 43 	      sta	ProgramEnd+1	;Program end now points to the correct enpty space
   1540  0929							;
   1541  0929							;===================jlit use length before line newline
   1542  0929
   1543  0929		       a0 00		      ldy	#0	;Set offset of copy
   1544  092b							;		  lda	  lineLength	  ;We will insert the actual length of the line first
   1545  092b							;		  sta	  (CURPTR),y	  ;Store the length
   1546  092b							;		  iny
   1547  092b							;		  lda	  R0		  ;Store the line number next
   1548  092b							;		  sta	  (CURPTR),y
   1549  092b							;		  iny
   1550  092b							;		  lda	  R0+1
   1551  092b							;		  sta	  (CURPTR),y
   1552  092b							;		  iny
   1553  092b							;
   1554  092b							;		  ldx	  offset	 ; Load the offset into line buffer in page zero
   1555  092b		       a2 00		      ldx	#0	; the token buffer is ready to copy
   1556  092d				   mvUpLoop2
   1557  092d							;		  lda	  LINBUF,x	 ;get a byte
   1558  092d		       bd 56 1c 	      lda	TOKENBUFFER,x	;get a byte
   1559  0930		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1560  0932
   1561  0932		       e8		      inx
   1562  0933		       ec 56 1c 	      cpx	TOKENBUFFER	; Check if we have copied all that we need to
   1563  0936		       b0 03		      bcs	mvUpFini	;hit the null at end of line then we are done
   1564  0938		       c8		      iny
   1565  0939		       d0 f2		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1566  093b							;
   1567  093b		       4c b1 02    mvUpFini   jmp	NextIL
   1568  093e							;
   1569  093e							;=====================================================
   1570  093e							; Pops the top value of the ILPC stack and stores it
   1571  093e							; in ILPC.  Ie, return from an IL subroutine.
   1572  093e							;
   1573  093e		       20 85 2a    iRTN       jsr	popILPC
   1574  0941		       4c b1 02 	      jmp	NextIL
   1575  0944							;
   1576  0944							;=====================================================
   1577  0944							; NLINE print a newline
   1578  0944							;
   1579  0944		       20 96 2d    iNLINE     jsr	CRLF	;user supplied sub
   1580  0947		       4c b1 02 	      jmp	NextIL
   1581  094a							;
   1582  094a							;=====================================================
   1583  094a							; This saves the current ILPC value on the stack, then
   1584  094a							; jumps to the address specified by the next two bytes.
   1585  094a							;
   1586  094a		       20 68 2a    iCALL      jsr	pushILPC	;save ILPC
   1587  094d		       90 07		      bcc	iJMP
   1588  094f
   1589  094f							;If the push failed not enough stack space
   1590  094f		       a2 15	   ErrILStkOver ldx	#ERR_IL_STACK_OVER_FLOW	; Flag any error in line number
   1591  0951		       a9 00		      lda	#0	; stop the execution
   1592  0953		       4c 7d 06 	      jmp	iErr2
   1593  0956							;
   1594  0956							; Jmp to a specific location in the IL code.  The new
   1595  0956							; address immediately follows the opcode.
   1596  0956							;
   1597  0956		       20 4e 2a    iJMP       jsr	getILWord
   1598  0959		       86 43		      stx	ILPC
   1599  095b		       85 44		      sta	ILPC+1
   1600  095d		       4c b1 02 	      jmp	NextIL
   1601  0960
   1602  0960
   1603  0960							;
   1604  0960							;=====================================================
   1605  0960							; Push the next two bytes onto the arithmetic stack.
   1606  0960							;
   1607  0960		       20 52 2a    iSetR2     jsr	getILByte
   1608  0963		       85 58		      sta	R2
   1609  0965		       4c b1 02 	      jmp	NextIL
   1610  0968							;
   1611  0968							;=====================================================
   1612  0968							; Push the next two bytes onto the arithmetic stack.
   1613  0968							;
   1614  0968		       20 4e 2a    iLIT       jsr	getILWord
   1615  096b		       86 52		      stx	R0
   1616  096d		       85 53		      sta	R0+1
   1617  096f		       20 4b 2c 	      jsr	pushR0
   1618  0972		       4c b1 02 	      jmp	NextIL
   1619  0975							;
   1620  0975							;=====================================================
   1621  0975							; Initialize all variables for a single task.	Ie, set to zero.
   1622  0975							; And internal stack pointers
   1623  0975							;
   1624  0975		       98	   subVINIT   tya
   1625  0976		       48		      pha
   1626  0977
   1627  0977		       a9 00		      lda	#0
   1628  0979		       a0 00		      ldy	#0
   1629  097b		       91 41	   Vinit2     sta	(VARIABLES),y
   1630  097d		       c8		      iny
   1631  097e		       c0 48		      cpy	#[[VARIABLESSIZE * 2] - 2]	; skip the old exit code
   1632  0980		       90 f9		      bcc	Vinit2
   1633  0982		       85 4a		      sta	MATHSTACKPTR	; Clear the math stack
   1634  0984		       85 4d		      sta	GOSUBSTACKPTR	; Clear the gosub stack
   1635  0986		       a9 38		      lda	#[[GOSUBSTACKSIZE - 2] * 4]	; Reset the message queue
   1636  0988		       85 4e		      STA	MESSAGEPTR
   1637  098a
   1638  098a		       68		      pla
   1639  098b		       a8		      tay
   1640  098c		       60		      rts
   1641  098d
   1642  098d				   iVINIT
   1643  098d		       20 75 09 	      jsr	subVINIT
   1644  0990		       20 f0 1f 	      jsr	Compile	; compile line numbers to memory pointers
   1645  0993		       4c b1 02 	      jmp	NextIL
   1646  0996							;
   1647  0996							;=====================================================
   1648  0996							; Set the address of the error handler.  After any
   1649  0996							; error, set to the ILPC to the specified location.
   1650  0996							;
   1651  0996		       20 4e 2a    iERRGOTO   jsr	getILWord
   1652  0999		       8e 3d 43 	      stx	errGoto
   1653  099c		       8d 3e 43 	      sta	errGoto+1
   1654  099f		       4c b1 02 	      jmp	NextIL
   1655  09a2							;
   1656  09a2							;=====================================================
   1657  09a2							; TST is followed by an 8 bit signed offset, then a
   1658  09a2							; null terminated string.  Compare the string against
   1659  09a2							; the string starting at (CURPTR),CUROFF.  If the
   1660  09a2							; strings match, continue executing the next IL
   1661  09a2							; opcode.  Else, add the offset to ILPC.
   1662  09a2							;
   1663  09a2		       20 52 2a    iTST       jsr	getILByte	;Get the relative jump address
   1664  09a5		       8d 48 43 	      sta	offset	;save it to use if test faile
   1665  09a8		       20 35 2c 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1666  09ab
   1667  09ab		       a4 51		      ldy	CUROFF
   1668  09ad		       84 59		      sty	dpl	;save for later
   1669  09af							;
   1670  09af		       20 52 2a    iTSTloop   jsr	getILByte	;get next char
   1671  09b2		       f0 11		      beq	iTSTm	;match!
   1672  09b4		       a4 59		      ldy	dpl
   1673  09b6		       d1 4f		      cmp	(CURPTR),y
   1674  09b8		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1675  09ba		       09 20		      ora	#$20	; lets allow lowercase as well
   1676  09bc		       d1 4f		      cmp	(CURPTR),y
   1677  09be		       d0 23		      bne	iTSTfail	;mismatch
   1678  09c0		       c8	   iTSTUpper  iny
   1679  09c1		       84 59		      sty	dpl
   1680  09c3		       d0 ea		      bne	iTSTloop
   1681  09c5							;
   1682  09c5							; It's a match!  Clean up a bit.
   1683  09c5							;
   1684  09c5		       a4 59	   iTSTm      ldy	dpl
   1685  09c7		       84 51		      sty	CUROFF
   1686  09c9		       4c b1 02 	      jmp	NextIL
   1687  09cc
   1688  09cc							; Test for a single quote string
   1689  09cc		       20 52 2a    iTSTStr    jsr	getILByte
   1690  09cf		       8d 48 43 	      sta	offset
   1691  09d2		       20 35 2c 	      jsr	saveIL
   1692  09d5		       a4 51		      ldy	CUROFF
   1693  09d7		       a9 22		      lda	#'"
   1694  09d9		       d1 4f		      cmp	(CURPTR),y
   1695  09db		       d0 06		      bne	iTSTfail
   1696  09dd		       c8		      iny
   1697  09de		       84 51		      sty	CUROFF
   1698  09e0		       4c d4 02 	      jmp	NextILStr
   1699  09e3							;
   1700  09e3							; Not a match, reset ILPC and then move to the
   1701  09e3							; offset.
   1702  09e3							;
   1703  09e3		       20 40 2c    iTSTfail   jsr	restoreIL
   1704  09e6		       4c e0 0b 	      jmp	tstBranch
   1705  09e9							;
   1706  09e9							;=================================================JLIT=
   1707  09e9							; Test if we have a let statement without the let keyword
   1708  09e9		       20 52 2a    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1709  09ec		       8d 48 43 	      sta	offset	; Save the jump offset for fails
   1710  09ef		       20 35 2c 	      jsr	saveIL	; save to restore when done if fail
   1711  09f2
   1712  09f2		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1713  09f4		       b1 4f		      lda	(CURPTR),y	; Get the byte
   1714  09f6		       c9 01		      cmp	#kLet	; Is it a let keyword
   1715  09f8		       f0 0a		      beq	iTSTLETGOOD	; We have a good let statement
   1716  09fa		       c9 80		      cmp	#tVa	; lets check for a variable
   1717  09fc		       90 e5		      bcc	iTSTfail	; Less than variable range
   1718  09fe		       c9 9e		      cmp	#tVat+1	; Test if it is greater that the last variable
   1719  0a00		       90 05		      bcc	iTSTGOODVAR	; No it failed get out Fast
   1720  0a02		       b0 df		      bcs	iTSTfail	; return it failed
   1721  0a04
   1722  0a04				   iTSTLETGOOD
   1723  0a04		       c8		      iny
   1724  0a05		       84 51		      sty	CUROFF	; If it was a let then inc past the let word
   1725  0a07				   iTSTGOODVAR
   1726  0a07		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1727  0a0a
   1728  0a0a							;=================================================JLIT=
   1729  0a0a							; Test a byte at an indirect address
   1730  0a0a							; fails if byte is not equal to the value at the address
   1731  0a0a							; The tests an indirect byte and branches if true
   1732  0a0a		       20 52 2a    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1733  0a0d		       8d 48 43 	      sta	offset	; Save the jump offset for fails
   1734  0a10		       20 35 2c 	      jsr	saveIL	; save to restore when done if fail
   1735  0a13		       20 4e 2a 	      jsr	getILWord	; Get a word into RO
   1736  0a16		       86 52		      stx	R0
   1737  0a18		       85 53		      sta	R0+1
   1738  0a1a		       20 52 2a 	      jsr	getILByte	; Get byte into A
   1739  0a1d		       a0 00		      ldy	#0
   1740  0a1f		       d1 52		      cmp	(R0),y
   1741  0a21		       d0 03		      bne	iTSTByteNotEqual
   1742  0a23		       4c e3 09 	      jmp	iTSTfail
   1743  0a26
   1744  0a26				   iTSTByteNotEqual
   1745  0a26		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1746  0a29
   1747  0a29							;=================================================JLIT=
   1748  0a29							; Test a byte	branch if it fails
   1749  0a29		       20 52 2a    iTSTB      jsr	getILByte	; Get the relative offset byte
   1750  0a2c		       8d 48 43 	      sta	offset	; Save the jump offset for fails
   1751  0a2f		       20 35 2c 	      jsr	saveIL	; save to restore when done if fail
   1752  0a32		       20 52 2a 	      jsr	getILByte	; Get a byte into Acc
   1753  0a35		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1754  0a37		       d1 4f		      cmp	(CURPTR),y
   1755  0a39		       f0 03		      beq	iTSTBMatch	; Yes it matched move on
   1756  0a3b		       4c e3 09 	      jmp	iTSTfail	; REcover and move on to next test
   1757  0a3e
   1758  0a3e				   iTSTBMatch
   1759  0a3e		       c8		      iny
   1760  0a3f		       84 51		      sty	CUROFF	; Point to the next byte
   1761  0a41		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1762  0a44
   1763  0a44							;=================================================JLIT=
   1764  0a44							; Test a byte	branch if it fails
   1765  0a44		       20 52 2a    iTSTW      jsr	getILByte	; Get the relative offset byte
   1766  0a47		       8d 48 43 	      sta	offset	; Save the jump offset for fails
   1767  0a4a		       20 35 2c 	      jsr	saveIL	; save to restore when done if fail
   1768  0a4d		       20 4e 2a 	      jsr	getILWord	; Get a word into RO
   1769  0a50		       86 52		      stx	R0
   1770  0a52		       85 53		      sta	R0+1
   1771  0a54		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1772  0a56		       8a		      txa
   1773  0a57		       d1 4f		      cmp	(CURPTR),y	; Test if low order byte matches
   1774  0a59		       f0 e3		      beq	iTSTBMatch	; Yes it matched move on
   1775  0a5b		       4c e3 09 	      jmp	iTSTfail	; REcover and move on to next test
   1776  0a5e		       c8	   iTSTWM1    iny
   1777  0a5f		       a5 53		      lda	R0+1
   1778  0a61		       d1 4f		      cmp	(CURPTR),y	; Check high order byte
   1779  0a63		       f0 03		      beq	iTSTWMatch
   1780  0a65		       4c e3 09 	      jmp	iTSTfail
   1781  0a68
   1782  0a68				   iTSTWMatch
   1783  0a68		       c8		      iny
   1784  0a69		       84 51		      sty	CUROFF
   1785  0a6b		       4c b1 02 	      jmp	NextIL	; Then next instruction
   1786  0a6e
   1787  0a6e							;================================================jLIT=
   1788  0a6e							;Test for end of line
   1789  0a6e							;
   1790  0a6e				   iTSTDONE
   1791  0a6e		       20 52 2a 	      jsr	getILByte
   1792  0a71		       8d 48 43 	      sta	offset
   1793  0a74		       20 35 2c 	      jsr	saveIL
   1794  0a77		       a4 51		      ldy	CUROFF
   1795  0a79		       84 59		      sty	dpl
   1796  0a7b		       b1 4f		      lda	(CURPTR),y
   1797  0a7d		       f0 0b		      beq	iTSTDONEtrue
   1798  0a7f		       c9 e6		      cmp	#oColon
   1799  0a81		       f0 07		      beq	iTSTDONEtrue
   1800  0a83		       a4 59		      ldy	dpl
   1801  0a85		       84 51		      sty	CUROFF
   1802  0a87		       4c e3 09 	      jmp	iTSTfail
   1803  0a8a							;
   1804  0a8a							; Advance to the next line
   1805  0a8a							;
   1806  0a8a				   iTSTDONEtrue
   1807  0a8a		       4c b1 02 	      jmp	NextIL
   1808  0a8d
   1809  0a8d		       4c e0 0b    tstBranchLink jmp	tstBranch
   1810  0a90							;
   1811  0a90							;=====================================================
   1812  0a90							; Inc and dec a variable , faster than a = a + 1
   1813  0a90				   iINCVAR
   1814  0a90		       20 dd 2c 	      jsr	popR0
   1815  0a93		       a0 00		      ldy	#0
   1816  0a95		       18		      clc
   1817  0a96		       a9 01		      lda	#1
   1818  0a98		       71 52		      adc	(R0),y
   1819  0a9a		       91 52		      sta	(R0),y
   1820  0a9c		       90 07		      bcc	iINCDONE
   1821  0a9e		       c8		      iny
   1822  0a9f		       a9 00		      lda	#0
   1823  0aa1		       71 52		      adc	(R0),y
   1824  0aa3		       91 52		      sta	(R0),y
   1825  0aa5				   iINCDONE
   1826  0aa5		       4c b1 02 	      jmp	NextIL
   1827  0aa8
   1828  0aa8				   iDECVAR
   1829  0aa8		       20 dd 2c 	      jsr	popR0
   1830  0aab		       a0 00		      ldy	#0
   1831  0aad		       38		      sec
   1832  0aae		       b1 52		      lda	(R0),y
   1833  0ab0		       e9 01		      sbc	#1
   1834  0ab2		       91 52		      sta	(R0),y
   1835  0ab4		       c8		      iny
   1836  0ab5		       b1 52		      lda	(R0),y
   1837  0ab7		       e9 00		      sbc	#0
   1838  0ab9		       91 52		      sta	(R0),y
   1839  0abb		       4c b1 02 	      jmp	NextIL
   1840  0abe
   1841  0abe
   1842  0abe							;
   1843  0abe							;=====================================================
   1844  0abe							; TSTV is followed by an 8 bit signed offset.	If the
   1845  0abe							; value at (CURPTR),CUROFF appears to be a variable
   1846  0abe							; name, move to the next IL statement.  Else, add the
   1847  0abe							; offset to ILPC. Converted to use actual absolute memory addresses
   1848  0abe							; TSTVT Looks for the task context
   1849  0abe							;
   1850  0abe		       20 f5 2c    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1851  0ac1		       a9 00		      lda	#0
   1852  0ac3		       85 58		      sta	R2
   1853  0ac5		       f0 04		      beq	iTSTVV
   1854  0ac7
   1855  0ac7							; Test for simple variable
   1856  0ac7		       a9 01	   iTSTV      lda	#1	; set a process Flag
   1857  0ac9		       85 58		      sta	R2
   1858  0acb
   1859  0acb		       20 52 2a    iTSTVV     jsr	getILByte	;offset
   1860  0ace		       8d 48 43 	      sta	offset
   1861  0ad1							;
   1862  0ad1		       a4 51		      ldy	CUROFF	; Get the pointer into the program
   1863  0ad3		       b1 4f		      lda	(CURPTR),y	; Get the next byte to process
   1864  0ad5		       d0 03		      bne	iTSTVnext	; if is not null then process it
   1865  0ad7		       4c 8d 0a 	      jmp	tstBranchLink	; if we are at the end of line just get out with error
   1866  0ada							;
   1867  0ada				   iTSTVnext
   1868  0ada		       c9 9d		      cmp	#tVat	; allow access to all unused memory as an array or integers
   1869  0adc		       f0 4f		      beq	iTSTVat	; Setup to do a pointer to unused memory
   1870  0ade
   1871  0ade		       c9 9c		      cmp	#tVhash	; parameters passed to this task
   1872  0ae0		       f0 5b		      beq	iTSTVParm
   1873  0ae2
   1874  0ae2		       c9 9b		      cmp	#tVhat	; task exit code
   1875  0ae4		       d0 04		      bne	iTSTV_A2Z
   1876  0ae6		       a9 48		      lda	#TASKEXITCODE
   1877  0ae8		       d0 0b		      bne	iTSTVContinue
   1878  0aea
   1879  0aea				   iTSTV_A2Z
   1880  0aea
   1881  0aea		       c9 80		      cmp	#tVa
   1882  0aec		       90 9f		      bcc	tstBranchLink
   1883  0aee		       c9 9a		      cmp	#tVz+1
   1884  0af0		       b0 9b		      bcs	tstBranchLink
   1885  0af2
   1886  0af2
   1887  0af2							;
   1888  0af2							; The condition is true, so convert to an index, push
   1889  0af2							; it onto the stack and continue running.
   1890  0af2							;
   1891  0af2		       29 7f		      and	#%01111111	; Mask off the high bit
   1892  0af4		       0a		      asl		; multiply by two
   1893  0af5
   1894  0af5				   iTSTVContinue
   1895  0af5		       c8		      iny
   1896  0af6		       84 51		      sty	CUROFF	; it is a valid variable
   1897  0af8		       48		      pha		; save the last variable pointer value
   1898  0af9		       a5 58		      lda	R2
   1899  0afb		       d0 1e		      bne	iTSTVLocalValue	; Value local to this task
   1900  0afd
   1901  0afd		       20 27 2a 	      jsr	ipc_ValidateContext	; Lets make sure R1 has a valid context value
   1902  0b00		       90 08		      bcc	iTSTVGOODPID	; Invalid PID provided
   1903  0b02
   1904  0b02		       68		      pla		; We have an invalid pid for getting variable value
   1905  0b03		       a2 10		      ldx	#ERR_INVALID_PID
   1906  0b05		       a9 00		      lda	#0
   1907  0b07		       4c 7d 06 	      jmp	iErr2
   1908  0b0a
   1909  0b0a				   iTSTVGOODPID
   1910  0b0a		       20 0f 2a 	      jsr	ipc_getcontext	; Get the other tasks variables
   1911  0b0d		       a0 01		      ldy	#VARIABLEPOS
   1912  0b0f		       b1 56		      lda	(MQ),y
   1913  0b11		       85 52		      sta	R0
   1914  0b13		       c8		      iny
   1915  0b14		       b1 56		      lda	(MQ),y
   1916  0b16		       85 53		      sta	R0+1
   1917  0b18		       4c 23 0b 	      jmp	iTSTVAddOffset
   1918  0b1b
   1919  0b1b				   iTSTVLocalValue
   1920  0b1b		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1921  0b1d		       85 52		      sta	R0
   1922  0b1f		       a5 42		      lda	VARIABLES+1
   1923  0b21		       85 53		      sta	R0+1
   1924  0b23
   1925  0b23				   iTSTVAddOffset
   1926  0b23		       68		      pla
   1927  0b24		       85 54		      sta	R1
   1928  0b26		       a9 00		      lda	#0
   1929  0b28		       85 55		      sta	R1+1
   1930  0b2a
   1931  0b2a				   iTSTVcontinue
   1932  0b2a
   1933  0b2a		       4c a5 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1934  0b2d
   1935  0b2d							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1936  0b2d							; an array of integer values or byte.
   1937  0b2d				   iTSTVat
   1938  0b2d		       c8		      iny
   1939  0b2e		       84 51		      sty	CUROFF	;it is a valid variable
   1940  0b30		       ad 52 43 	      lda	ProgramEnd	;set flag to let evaluator to use PROGRAMEND as the root
   1941  0b33		       85 52		      sta	R0
   1942  0b35		       ad 53 43 	      lda	ProgramEnd+1
   1943  0b38		       85 53		      sta	R0+1
   1944  0b3a		       4c 1d 07 	      jmp	pushR0nextIl	;place this onto the stack
   1945  0b3d
   1946  0b3d							; When we get parameters passed we can access them using the # variable with[]
   1947  0b3d							; example #[0] #[1] etc, we dont check yet if there is too many
   1948  0b3d		       c8	   iTSTVParm  iny
   1949  0b3e		       84 51		      sty	CUROFF	;it is a valid variable
   1950  0b40
   1951  0b40							; upon return the y register  point to the gosub Parms entry value entry
   1952  0b40		       20 c1 25 	      jsr	GosubFindParms
   1953  0b43		       90 21		      bcc	iTSTMissingParms
   1954  0b45
   1955  0b45		       88		      dey
   1956  0b46		       88		      dey
   1957  0b47		       88		      dey		;Point to the actual index of first parameter in math stack
   1958  0b48
   1959  0b48		       a5 48		      lda	MATHSTACK
   1960  0b4a		       85 52		      sta	R0
   1961  0b4c		       a5 49		      lda	MATHSTACK+1
   1962  0b4e		       85 53		      sta	R0+1
   1963  0b50		       b1 4b		      lda	(GOSUBSTACK),y	; Get the correct Offset to start of parameters
   1964  0b52		       f0 0b		      beq	iTSTVindex0	; no math if no offset
   1965  0b54		       18		      clc
   1966  0b55		       65 52		      adc	R0	; Point to the actual address that the variables start, not just top of stack
   1967  0b57		       85 52		      sta	R0
   1968  0b59		       a9 00		      lda	#0
   1969  0b5b		       65 53		      adc	R0+1
   1970  0b5d		       85 53		      sta	R0+1
   1971  0b5f				   iTSTVindex0
   1972  0b5f		       a9 81		      lda	#GOSUB_RTN_VALUE
   1973  0b61		       85 58		      sta	R2	; Set the data type as a parameter to a function
   1974  0b63		       4c 1d 07 	      jmp	pushR0nextIl
   1975  0b66
   1976  0b66
   1977  0b66				   iTSTMissingParms
   1978  0b66		       a9 00		      lda	#0
   1979  0b68		       a2 19		      ldx	#ERR_FUNCTION_EXPECTED_PARAMETERS
   1980  0b6a		       4c 7d 06 	      jmp	iErr2
   1981  0b6d
   1982  0b6d							;
   1983  0b6d							;=====================================================
   1984  0b6d							; TSTL seems basically the same as TSTN, but leave the
   1985  0b6d							; value in R0 instead of pushing onto stack.
   1986  0b6d							; This tests for a valid line number
   1987  0b6d							;
   1988  0b6d		       20 52 2a    iTSTL      jsr	getILByte
   1989  0b70		       8d 48 43 	      sta	offset
   1990  0b73							;
   1991  0b73		       a4 51		      ldy	CUROFF
   1992  0b75		       b1 4f		      lda	(CURPTR),y
   1993  0b77		       c8		      iny
   1994  0b78		       11 4f		      ora	(CURPTR),y
   1995  0b7a		       f0 06		      beq	iTSTLNotLineNo
   1996  0b7c
   1997  0b7c
   1998  0b7c							; In Both cases we need to point to the first usefull byte to process.
   1999  0b7c		       c8		      iny
   2000  0b7d		       84 51		      sty	CUROFF
   2001  0b7f		       4c b1 02 	      jmp	NextIL
   2002  0b82				   iTSTLNotLineNo
   2003  0b82		       c8		      iny
   2004  0b83		       84 51		      sty	CUROFF
   2005  0b85		       4c e0 0b 	      jmp	tstBranch
   2006  0b88
   2007  0b88							;
   2008  0b88							;=====================================================
   2009  0b88							; TSTN checks for a number.  This is very simplistic;
   2010  0b88							; if the character is a digit, assume it's a number.
   2011  0b88							; Convert to a number and push it onto the stack.
   2012  0b88							;
   2013  0b88		       20 52 2a    iTSTN      jsr	getILByte
   2014  0b8b		       8d 48 43 	      sta	offset
   2015  0b8e							;
   2016  0b8e		       a9 00		      lda	#0
   2017  0b90		       85 59		      sta	dpl
   2018  0b92		       a4 51		      ldy	CUROFF
   2019  0b94				   chkType
   2020  0b94		       b1 4f		      lda	(CURPTR),y
   2021  0b96		       c9 a2		      cmp	#tByte
   2022  0b98		       f0 0e		      beq	chkByte
   2023  0b9a		       c9 a4		      cmp	#tInteger
   2024  0b9c		       f0 16		      beq	chkInteger
   2025  0b9e		       c9 eb		      cmp	#oMinus
   2026  0ba0		       d0 3e		      bne	tstBranch
   2027  0ba2		       e6 59		      inc	dpl
   2028  0ba4		       c8		      iny
   2029  0ba5		       4c 94 0b 	      jmp	chkType
   2030  0ba8
   2031  0ba8				   chkByte
   2032  0ba8		       a9 00		      lda	#0
   2033  0baa		       85 53		      sta	R0+1
   2034  0bac		       c8		      iny
   2035  0bad		       b1 4f		      lda	(CURPTR),y
   2036  0baf		       85 52		      sta	R0
   2037  0bb1		       c8		      iny
   2038  0bb2		       d0 0b		      bne	iTSTN_1
   2039  0bb4
   2040  0bb4				   chkInteger
   2041  0bb4		       c8		      iny
   2042  0bb5		       b1 4f		      lda	(CURPTR),y
   2043  0bb7		       85 52		      sta	R0
   2044  0bb9		       c8		      iny
   2045  0bba		       b1 4f		      lda	(CURPTR),y
   2046  0bbc		       85 53		      sta	R0+1
   2047  0bbe		       c8		      iny
   2048  0bbf							;
   2049  0bbf							; Check if it is negative and make it so
   2050  0bbf							;
   2051  0bbf				   iTSTN_1
   2052  0bbf		       84 51		      sty	CUROFF
   2053  0bc1
   2054  0bc1		       a5 59		      lda	dpl
   2055  0bc3		       f0 18		      beq	iTSTN_2	;positive
   2056  0bc5							;
   2057  0bc5		       a5 52		      lda	R0
   2058  0bc7		       05 53		      ora	R0+1
   2059  0bc9		       f0 12		      beq	iTSTN_2	;zero
   2060  0bcb
   2061  0bcb							; Invert all the bits, then add one.
   2062  0bcb							;
   2063  0bcb		       a5 52		      lda	R0
   2064  0bcd		       49 ff		      eor	#$ff
   2065  0bcf		       85 52		      sta	R0
   2066  0bd1		       a5 53		      lda	R0+1
   2067  0bd3		       49 ff		      eor	#$ff
   2068  0bd5		       85 53		      sta	R0+1
   2069  0bd7							;
   2070  0bd7		       e6 52		      inc	R0
   2071  0bd9		       d0 02		      bne	iTSTN_2
   2072  0bdb		       e6 53		      inc	R0+1
   2073  0bdd				   iTSTN_2
   2074  0bdd		       4c 1d 07 	      jmp	pushR0nextIl	;save onto stack
   2075  0be0
   2076  0be0							;
   2077  0be0							; Common jump point for all TSTx instructions that
   2078  0be0							; fail to meet the requirements.  This takes the
   2079  0be0							; offset and adds/subtracts to/from ILPC.
   2080  0be0							;
   2081  0be0		       ad 48 43    tstBranch  lda	offset	;get signed offset
   2082  0be3		       10 0e		      bpl	tstPositive
   2083  0be5							;
   2084  0be5							; Do negative branch.	Do sign extension.
   2085  0be5							;
   2086  0be5		       18	   tstNegative clc
   2087  0be6		       65 43		      adc	ILPC
   2088  0be8		       85 43		      sta	ILPC
   2089  0bea							;		  bcc	  tstBothDone
   2090  0bea							;		  dec	  ILPC+1
   2091  0bea							;		  jmp	  NextIL
   2092  0bea
   2093  0bea		       a5 44		      lda	ILPC+1
   2094  0bec		       69 ff		      adc	#$ff
   2095  0bee		       85 44		      sta	ILPC+1
   2096  0bf0		       4c b1 02 	      jmp	NextIL	;keep going
   2097  0bf3							;
   2098  0bf3		       18	   tstPositive clc
   2099  0bf4		       65 43		      adc	ILPC
   2100  0bf6		       85 43		      sta	ILPC
   2101  0bf8		       90 02		      bcc	tstBothDone
   2102  0bfa		       e6 44		      inc	ILPC+1
   2103  0bfc				   tstBothDone
   2104  0bfc		       4c b1 02 	      jmp	NextIL
   2105  0bff
   2106  0bff							;
   2107  0bff							;====================================================
   2108  0bff							; Test for IRQ pending, and test if a break key pressed
   2109  0bff							; Yes I know but this handles all sorts of irq/break issues
   2110  0bff							;
   2111  0bff		       20 52 2a    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   2112  0c02		       8d 48 43 	      sta	offset	; Store the not true jump address offset
   2113  0c05		       ad c1 19    irqNo      lda	IRQPending	; Check if the pending value is set
   2114  0c08		       f0 20		      beq	tstBreak	; if no irq then check for an escape key pressed
   2115  0c0a		       c9 01		      cmp	#1	; only do this if set to first time
   2116  0c0c		       d0 1c		      bne	tstBreak	; We are in a irq service already
   2117  0c0e				   iTSTProcessIRQ
   2118  0c0e		       78		      sei		; disable the interupt until ireturn resets it
   2119  0c0f		       ee c1 19 	      inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   2120  0c12		       a9 01		      lda	#GOSUB_RTN	; Save as gosub
   2121  0c14		       20 65 2c 	      jsr	pushLN	; Push the next line to be executed
   2122  0c17		       b0 21		      bcs	ErrStkOver	; Check if there was an error
   2123  0c19		       ad c2 19 	      lda	IRQEntry	; Get the line number to branch to
   2124  0c1c		       85 4f		      sta	CURPTR	; put line number into r0
   2125  0c1e		       ad c3 19 	      lda	IRQEntry+1
   2126  0c21		       85 50		      sta	CURPTR+1
   2127  0c23		       a9 03		      lda	#3	; Point to first byte of program text
   2128  0c25		       85 51		      sta	CUROFF
   2129  0c27		       4c b1 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   2130  0c2a
   2131  0c2a				   tstBreak
   2132  0c2a		       20 67 04 	      jsr	BreakSet	; Check if the escape key was pressed
   2133  0c2d		       d0 b1		      bne	tstBranch	; z not set of no break found
   2134  0c2f		       ad 4a 43 	      lda	taskIOPending
   2135  0c32		       f0 03		      beq	tstBrkComplete
   2136  0c34		       ce 4a 43 	      dec	taskIOPending
   2137  0c37		       4c 02 06    tstBrkComplete jmp	iFIN	; Exit out of run mode
   2138  0c3a
   2139  0c3a		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   2140  0c3c		       a9 00		      lda	#0	; stop the execution
   2141  0c3e		       4c 7d 06 	      jmp	iErr2
   2142  0c41							;
   2143  0c41
   2144  0c41							;=====================================================
   2145  0c41							; This places the number of free bytes on top of the
   2146  0c41							; stack.
   2147  0c41							;
   2148  0c41		       20 cf 23    iFREE      jsr	MemFree
   2149  0c44		       4c 1d 07 	      jmp	pushR0nextIl
   2150  0c47							;
   2151  0c47							;=====================================================
   2152  0c47							; Generate a random number from 0-FFFF and then MOD
   2153  0c47							; it with the value on top of stack.  Leaves number on
   2154  0c47							; stack
   2155  0c47							;
   2156  0c47		       20 f5 2c    iRANDOM    jsr	popR1	;mod value
   2157  0c4a							;
   2158  0c4a							; If the value is zero, just return a one.
   2159  0c4a							;
   2160  0c4a		       a5 54		      lda	R1
   2161  0c4c		       05 55		      ora	R1+1
   2162  0c4e		       f0 4a		      beq	irandom1
   2163  0c50							;
   2164  0c50		       ad 43 43 	      lda	random+1
   2165  0c53		       8d 40 43 	      sta	rtemp1
   2166  0c56		       ad 42 43 	      lda	random
   2167  0c59		       0a		      asl
   2168  0c5a		       2e 40 43 	      rol	rtemp1
   2169  0c5d		       0a		      asl
   2170  0c5e		       2e 40 43 	      rol	rtemp1
   2171  0c61		       18		      clc
   2172  0c62		       6d 42 43 	      adc	random
   2173  0c65
   2174  0c65		       48		      pha
   2175  0c66
   2176  0c66		       ad 40 43 	      lda	rtemp1
   2177  0c69		       6d 43 43 	      adc	random+1
   2178  0c6c		       8d 43 43 	      sta	random+1
   2179  0c6f
   2180  0c6f		       68		      pla
   2181  0c70
   2182  0c70		       69 11		      adc	#$11
   2183  0c72		       8d 42 43 	      sta	random
   2184  0c75		       ad 43 43 	      lda	random+1
   2185  0c78		       69 36		      adc	#$36
   2186  0c7a		       8d 43 43 	      sta	random+1
   2187  0c7d
   2188  0c7d		       ad 42 43 	      lda	random
   2189  0c80		       85 52		      sta	R0
   2190  0c82		       ad 43 43 	      lda	random+1
   2191  0c85		       29 7f		      and	#$7f	;make positive
   2192  0c87		       85 53		      sta	R0+1
   2193  0c89							;
   2194  0c89							; R0 contains the number and R1 contains the max value.
   2195  0c89							;
   2196  0c89		       20 43 07 	      jsr	iDivNoPop
   2197  0c8c		       20 5e 2d 	      jsr	RestoreSigns
   2198  0c8f		       a5 56		      lda	MQ
   2199  0c91		       85 52		      sta	R0
   2200  0c93		       a5 57		      lda	MQ+1
   2201  0c95		       85 53		      sta	R0+1
   2202  0c97		       4c 1d 07 	      jmp	pushR0nextIl
   2203  0c9a				   irandom1
   2204  0c9a		       a9 00		      lda	#0
   2205  0c9c		       85 53		      sta	R0+1
   2206  0c9e		       a9 01		      lda	#1
   2207  0ca0		       85 52		      sta	R0
   2208  0ca2		       4c 1d 07 	      jmp	pushR0nextIl
   2209  0ca5
   2210  0ca5							; The following replaced by call to division/modulo
   2211  0ca5							;iRANDOM_2	lda	R0
   2212  0ca5							;		cmp	R1
   2213  0ca5							;		bne	iRANDOM_1
   2214  0ca5							;		lda	R0+1
   2215  0ca5							;		cmp	R1+1
   2216  0ca5							;		bne	iRANDOM_1	;need to subtract
   2217  0ca5							;
   2218  0ca5							; Subtract R1 from R0
   2219  0ca5							;
   2220  0ca5							;iRANDOM_sub	sec
   2221  0ca5							;		lda	R0
   2222  0ca5							;		sbc	R1
   2223  0ca5							;		sta	R0
   2224  0ca5							;		lda	R0+1
   2225  0ca5							;		sbc	R1+1
   2226  0ca5							;		sta	R0+1
   2227  0ca5							;		jmp	iRANDOM_2
   2228  0ca5							;
   2229  0ca5							; See if R1 > R0.  If so, branch to subtract.
   2230  0ca5							;
   2231  0ca5							;iRANDOM_1	lda	R0
   2232  0ca5							;		cmp	R1
   2233  0ca5							;		lda	R0+1
   2234  0ca5							;		sbc	R1+1
   2235  0ca5							;		bvc	iRANDOM_4
   2236  0ca5							;		eor	#$80
   2237  0ca5							;iRANDOM_4	bpl	iRANDOM_sub
   2238  0ca5							;
   2239  0ca5							; All done.  Almost.  Add one, then push the result.
   2240  0ca5							;
   2241  0ca5							;irandom1	inc	R0
   2242  0ca5							;		bne	iRANDOM_3
   2243  0ca5							;		inc	R0+1
   2244  0ca5							;iRANDOM_3
   2245  0ca5							;		  jsr	pushR0	;return value
   2246  0ca5							;		jmp	NextIL
   2247  0ca5							;
   2248  0ca5							; Poke a value into a memory location
   2249  0ca5		       8c 44 43    iPOKEMEMORY sty	tempy
   2250  0ca8		       20 dd 2c 	      jsr	popR0
   2251  0cab		       20 f5 2c 	      jsr	popR1
   2252  0cae		       a0 00		      ldy	#0
   2253  0cb0		       a5 52		      lda	R0
   2254  0cb2		       91 54		      sta	(R1),y
   2255  0cb4		       ac 44 43 	      ldy	tempy
   2256  0cb7		       4c b1 02 	      jmp	NextIL
   2257  0cba							;
   2258  0cba							; Get a value from a memory location
   2259  0cba							;
   2260  0cba		       8c 44 43    iPEEKMEMORY sty	tempy
   2261  0cbd		       20 dd 2c 	      jsr	popR0
   2262  0cc0		       a0 00		      ldy	#0
   2263  0cc2		       b1 52		      lda	(R0),y
   2264  0cc4		       ac 44 43 	      ldy	tempy
   2265  0cc7		       85 52		      sta	R0
   2266  0cc9		       a9 00		      lda	#0
   2267  0ccb		       85 53		      sta	R0+1
   2268  0ccd		       4c 1d 07 	      jmp	pushR0nextIl
   2269  0cd0							;
   2270  0cd0							; Call to address return what ever is in a to the stack
   2271  0cd0							; func2 will load a value into a before the call
   2272  0cd0		       20 f5 2c    iCallFunc  jsr	popR1
   2273  0cd3		       a5 54		      lda	R1
   2274  0cd5		       20 e1 0c 	      jsr	iCallRtn
   2275  0cd8		       85 52		      sta	R0
   2276  0cda		       a9 00		      lda	#0
   2277  0cdc		       85 53		      sta	R0+1
   2278  0cde		       20 1d 07 	      jsr	pushR0nextIl
   2279  0ce1				   iCallRtn
   2280  0ce1		       20 dd 2c 	      jsr	popR0
   2281  0ce4		       6c 52 00 	      jmp	(R0)
   2282  0ce7
   2283  0ce7
   2284  0ce7							;===========================================jlit======
   2285  0ce7							;Get a character from the terminal convert to value
   2286  0ce7							;leave the number on top of the stack
   2287  0ce7							;
   2288  0ce7				   iGETCHAR
   2289  0ce7		       20 61 1a 	      jsr	VGETCH
   2290  0cea					      if	CTMON65
   2291  0cea		       48		      pha
   2292  0ceb		       20 5e 1a 	      jsr	VOUTCH	;echo echo echo
   2293  0cee		       68		      pla
   2294  0cef					      endif
   2295  0cef		       85 52		      sta	R0
   2296  0cf1		       a9 00		      lda	#0
   2297  0cf3		       85 53		      sta	R0+1
   2298  0cf5		       20 4b 2c 	      jsr	pushR0
   2299  0cf8							;
   2300  0cf8		       4c b1 02 	      jmp	NextIL
   2301  0cfb							;===========================================jusilostintim======
   2302  0cfb							;Put a character to the terminal convert to
   2303  0cfb							;
   2304  0cfb		       20 dd 2c    iPUTCHAR   jsr	popR0
   2305  0cfe		       a5 52		      lda	R0
   2306  0d00		       20 5e 1a 	      jsr	VOUTCH
   2307  0d03		       4c b1 02 	      jmp	NextIL
   2308  0d06							;=====================================================
   2309  0d06							; Put the number on the stack out as hex, suppress leading 0
   2310  0d06				   iHexOut
   2311  0d06		       20 dd 2c 	      jsr	popR0
   2312  0d09		       a5 53		      lda	R0+1
   2313  0d0b		       f0 03		      beq	iHexSecondByte
   2314  0d0d		       20 99 21 	      jsr	OUTHEX
   2315  0d10				   iHexSecondByte
   2316  0d10		       a5 52		      lda	R0
   2317  0d12		       20 99 21 	      jsr	OUTHEX
   2318  0d15		       4c b1 02 	      jmp	NextIL
   2319  0d18							;
   2320  0d18							;=====================================================
   2321  0d18							; Replace TOS with its absolute value.
   2322  0d18							;
   2323  0d18		       20 dd 2c    iABS       jsr	popR0
   2324  0d1b		       a5 53		      lda	R0+1
   2325  0d1d		       10 10		      bpl	iABS_1	;already positive
   2326  0d1f		       49 ff		      eor	#$ff
   2327  0d21		       85 53		      sta	R0+1
   2328  0d23		       a5 52		      lda	R0
   2329  0d25		       49 ff		      eor	#$ff
   2330  0d27		       85 52		      sta	R0
   2331  0d29		       e6 52		      inc	R0
   2332  0d2b		       d0 02		      bne	iABS_1
   2333  0d2d		       e6 53		      inc	R0+1
   2334  0d2f		       4c 1d 07    iABS_1     jmp	pushR0nextIl
   2335  0d32
   2336  0d32							;
   2337  0d32							;================================================================
   2338  0d32							; The set of logical operators
   2339  0d32				   iLogAnd
   2340  0d32		       20 dd 2c 	      jsr	popR0
   2341  0d35		       20 f5 2c 	      jsr	popR1
   2342  0d38		       a5 52		      lda	R0
   2343  0d3a		       25 54		      and	R1
   2344  0d3c		       85 52		      sta	R0
   2345  0d3e		       a5 53		      lda	R0+1
   2346  0d40		       25 55		      and	R1+1
   2347  0d42		       85 53		      sta	R0+1
   2348  0d44		       4c 1d 07 	      jmp	pushR0nextIl
   2349  0d47
   2350  0d47				   iLogOr
   2351  0d47		       20 dd 2c 	      jsr	popR0
   2352  0d4a		       20 f5 2c 	      jsr	popR1
   2353  0d4d		       a5 52		      lda	R0
   2354  0d4f		       05 54		      ora	R1
   2355  0d51		       85 52		      sta	R0
   2356  0d53		       a5 53		      lda	R0+1
   2357  0d55		       05 55		      ora	R1+1
   2358  0d57		       85 53		      sta	R0+1
   2359  0d59		       4c 1d 07 	      jmp	pushR0nextIl
   2360  0d5c				   iLogXor
   2361  0d5c		       20 dd 2c 	      jsr	popR0
   2362  0d5f		       20 f5 2c 	      jsr	popR1
   2363  0d62		       a5 52		      lda	R0
   2364  0d64		       45 54		      eor	R1
   2365  0d66		       85 52		      sta	R0
   2366  0d68		       a5 53		      lda	R0+1
   2367  0d6a		       45 55		      eor	R1+1
   2368  0d6c		       85 53		      sta	R0+1
   2369  0d6e		       4c 1d 07 	      jmp	pushR0nextIl
   2370  0d71				   iLogNot
   2371  0d71		       20 dd 2c 	      jsr	popR0
   2372  0d74		       a5 52		      lda	R0
   2373  0d76		       49 ff		      eor	#$FF
   2374  0d78		       85 52		      sta	R0
   2375  0d7a		       a5 53		      lda	R0+1
   2376  0d7c		       49 ff		      eor	#$FF
   2377  0d7e		       85 53		      sta	R0+1
   2378  0d80		       4c 1d 07 	      jmp	pushR0nextIl
   2379  0d83
   2380  0d83				   iTruth
   2381  0d83		       a9 ff		      lda	#$FF
   2382  0d85		       85 52		      sta	R0
   2383  0d87		       85 53		      sta	R0+1
   2384  0d89		       4c 1d 07 	      jmp	pushR0nextIl
   2385  0d8c				   iFalse
   2386  0d8c		       a9 00		      lda	#$00
   2387  0d8e		       85 52		      sta	R0
   2388  0d90		       85 53		      sta	R0+1
   2389  0d92		       4c 1d 07 	      jmp	pushR0nextIl
   2390  0d95							;===============================================================
   2391  0d95							;Shift instruction a is set to right = 1, left = 0
   2392  0d95							;
   2393  0d95		       8a	   iShift     txa
   2394  0d96		       48		      pha
   2395  0d97		       20 dd 2c 	      jsr	popR0	; number of places to shift 0 to 16 really
   2396  0d9a		       20 f5 2c 	      jsr	popR1	; value to shift
   2397  0d9d		       a6 52		      ldx	R0	; get number of times to shift
   2398  0d9f		       20 52 2a 	      jsr	getILByte	; get direction to shift
   2399  0da2		       c9 01		      cmp	#1	; Should we be doing left
   2400  0da4		       f0 0a		      beq	iShiftRight
   2401  0da6							;
   2402  0da6							; Shift r1 left n bits
   2403  0da6				   iShiftLeft
   2404  0da6		       18	   iShiftLloop clc
   2405  0da7		       26 54		      rol	R1
   2406  0da9		       26 55		      rol	R1+1
   2407  0dab		       ca		      dex
   2408  0dac		       d0 f8		      bne	iShiftLloop
   2409  0dae		       f0 07		      beq	iShiftExit
   2410  0db0							;
   2411  0db0							; Shift R1 right n bits
   2412  0db0							;
   2413  0db0				   iShiftRight
   2414  0db0		       46 55	   iShiftRloop lsr	R1+1
   2415  0db2		       46 54		      lsr	R1
   2416  0db4		       ca		      dex
   2417  0db5		       d0 f9		      bne	iShiftRloop
   2418  0db7				   iShiftExit
   2419  0db7		       68		      pla
   2420  0db8		       aa		      tax
   2421  0db9		       20 c3 2c 	      jsr	pushR1
   2422  0dbc		       4c b1 02 	      jmp	NextIL
   2423  0dbf
   2424  0dbf							;================================================================
   2425  0dbf							;Set the IRQ service rtn line number
   2426  0dbf							;
   2427  0dbf		       78	   iSetIrq    sei		; disable the interupts
   2428  0dc0		       a9 00		      lda	#0	; Zero the Status flag
   2429  0dc2		       8d c0 19 	      sta	IRQStatus
   2430  0dc5		       20 dd 2c 	      jsr	popR0	; get the line number
   2431  0dc8		       a5 52		      lda	R0
   2432  0dca		       05 53		      ora	R0+1
   2433  0dcc		       f0 22		      beq	iSetExt	; if it is zero disable all
   2434  0dce		       a9 01		      lda	#GOSUB_RTN	; default push type
   2435  0dd0		       20 65 2c 	      jsr	pushLN	; Save the current line pointer
   2436  0dd3		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2437  0dd5		       4c 3a 0c 	      jmp	ErrStkOver	; Check if there was an error
   2438  0dd8				   iSetIrqOk
   2439  0dd8		       20 97 2a 	      jsr	findLine	; Find the IRQ func Line Pointer
   2440  0ddb		       d0 16		      bne	iSetIrqErr	; Error if exact line not found
   2441  0ddd		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2442  0ddf		       8d c3 19 	      sta	IRQEntry+1
   2443  0de2		       a5 4f		      lda	CURPTR
   2444  0de4		       8d c2 19 	      sta	IRQEntry
   2445  0de7		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2446  0de9		       8d c0 19 	      sta	IRQStatus
   2447  0dec		       20 8e 2c 	      jsr	popLN	; Restore the old line number
   2448  0def		       58		      cli		; Enable the interupts
   2449  0df0		       4c b1 02    iSetExt    jmp	NextIL
   2450  0df3
   2451  0df3		       20 8e 2c    iSetIrqErr jsr	popLN
   2452  0df6		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2453  0df8		       a9 00		      lda	#0
   2454  0dfa		       4c 7d 06 	      jmp	iErr2
   2455  0dfd							;
   2456  0dfd		       20 dd 2c    iTRACEPROG jsr	popR0
   2457  0e00		       a5 52		      lda	R0
   2458  0e02		       85 40		      sta	ILTrace
   2459  0e04		       4c b1 02 	      jmp	NextIL
   2460  0e07
   2461  0e07							;=====================================================
   2462  0e07							; Define start of non page zero data
   2463 U435a ????				      seg.u	TBData
   2464 U3684					      org	PROGEND
   2465 U3684							;=================================================================
   2466 U3684							;
   2467 U3684					      if	IL_DEBUG_TEXT
------- FILE ILKeyText.inc LEVEL 2 PASS 6
      0 U3684					      include	"ILKeyText.inc"
      1  0e07					      seg	Code
      2  0e07					      if	IL_DEBUG_TEXT
      3  0e07				   ILTEXTTABLE
      0  0e07					      db	0,23,"iXINIT		   ",0
      1  0e07		       00 17 69 58*	      .byte.b	0,23,"iXINIT		   ",0
      0  0e1e					      db	1,23,"iDONE		   ",0
      1  0e1e		       01 17 69 44*	      .byte.b	1,23,"iDONE		   ",0
      0  0e35					      db	2,23,"iPRS		   ",0
      1  0e35		       02 17 69 50*	      .byte.b	2,23,"iPRS		   ",0
      0  0e4c					      db	3,23,"iPRN		   ",0
      1  0e4c		       03 17 69 50*	      .byte.b	3,23,"iPRN		   ",0
      0  0e63					      db	4,23,"iSPC		   ",0
      1  0e63		       04 17 69 53*	      .byte.b	4,23,"iSPC		   ",0
      0  0e7a					      db	5,23,"iNLINE		   ",0
      1  0e7a		       05 17 69 4e*	      .byte.b	5,23,"iNLINE		   ",0
      0  0e91					      db	6,23,"iNXT		   ",0
      1  0e91		       06 17 69 4e*	      .byte.b	6,23,"iNXT		   ",0
      0  0ea8					      db	7,23,"iXFER		   ",0
      1  0ea8		       07 17 69 58*	      .byte.b	7,23,"iXFER		   ",0
      0  0ebf					      db	8,23,"iSAV		   ",0
      1  0ebf		       08 17 69 53*	      .byte.b	8,23,"iSAV		   ",0
      0  0ed6					      db	9,23,"iRSTR		   ",0
      1  0ed6		       09 17 69 52*	      .byte.b	9,23,"iRSTR		   ",0
      0  0eed					      db	10,23,"iCMPR		    ",0
      1  0eed		       0a 17 69 43*	      .byte.b	10,23,"iCMPR		    ",0
      0  0f04					      db	11,23,"iINNUM		    ",0
      1  0f04		       0b 17 69 49*	      .byte.b	11,23,"iINNUM		    ",0
      0  0f1b					      db	12,23,"iFIN		    ",0
      1  0f1b		       0c 17 69 46*	      .byte.b	12,23,"iFIN		    ",0
      0  0f32					      db	13,23,"iERR		    ",0
      1  0f32		       0d 17 69 45*	      .byte.b	13,23,"iERR		    ",0
      0  0f49					      db	14,23,"iADD		    ",0
      1  0f49		       0e 17 69 41*	      .byte.b	14,23,"iADD		    ",0
      0  0f60					      db	15,23,"iSUB		    ",0
      1  0f60		       0f 17 69 53*	      .byte.b	15,23,"iSUB		    ",0
      0  0f77					      db	16,23,"iNEG		    ",0
      1  0f77		       10 17 69 4e*	      .byte.b	16,23,"iNEG		    ",0
      0  0f8e					      db	17,23,"iMUL		    ",0
      1  0f8e		       11 17 69 4d*	      .byte.b	17,23,"iMUL		    ",0
      0  0fa5					      db	18,23,"iDIV		    ",0
      1  0fa5		       12 17 69 44*	      .byte.b	18,23,"iDIV		    ",0
      0  0fbc					      db	19,23,"iSTORE		    ",0
      1  0fbc		       13 17 69 53*	      .byte.b	19,23,"iSTORE		    ",0
      0  0fd3					      db	20,23,"iIND		    ",0
      1  0fd3		       14 17 69 49*	      .byte.b	20,23,"iIND		    ",0
      0  0fea					      db	21,23,"iLST		    ",0
      1  0fea		       15 17 69 4c*	      .byte.b	21,23,"iLST		    ",0
      0  1001					      db	22,23,"iINIT		    ",0
      1  1001		       16 17 69 49*	      .byte.b	22,23,"iINIT		    ",0
      0  1018					      db	23,23,"iGETLINE	    ",0
      1  1018		       17 17 69 47*	      .byte.b	23,23,"iGETLINE	    ",0
      0  102f					      db	24,23,"iINSRT		    ",0
      1  102f		       18 17 69 49*	      .byte.b	24,23,"iINSRT		    ",0
      0  1046					      db	25,23,"iRTN		    ",0
      1  1046		       19 17 69 52*	      .byte.b	25,23,"iRTN		    ",0
      0  105d					      db	26,23,"MONITOR 	    ",0
      1  105d		       1a 17 4d 4f*	      .byte.b	26,23,"MONITOR 	    ",0
      0  1074					      db	27,23,"iLIT		    ",0
      1  1074		       1b 17 69 4c*	      .byte.b	27,23,"iLIT		    ",0
      0  108b					      db	28,23,"iCALL		    ",0
      1  108b		       1c 17 69 43*	      .byte.b	28,23,"iCALL		    ",0
      0  10a2					      db	29,23,"iJMP		    ",0
      1  10a2		       1d 17 69 4a*	      .byte.b	29,23,"iJMP		    ",0
      0  10b9					      db	30,23,"iVINIT		    ",0
      1  10b9		       1e 17 69 56*	      .byte.b	30,23,"iVINIT		    ",0
      0  10d0					      db	31,23,"iERRGOTO	    ",0
      1  10d0		       1f 17 69 45*	      .byte.b	31,23,"iERRGOTO	    ",0
      0  10e7					      db	32,23,"iTST		    ",0
      1  10e7		       20 17 69 54*	      .byte.b	32,23,"iTST		    ",0
      0  10fe					      db	33,23,"iTSTV		    ",0
      1  10fe		       21 17 69 54*	      .byte.b	33,23,"iTSTV		    ",0
      0  1115					      db	34,23,"iTSTL		    ",0
      1  1115		       22 17 69 54*	      .byte.b	34,23,"iTSTL		    ",0
      0  112c					      db	35,23,"iTSTN		    ",0
      1  112c		       23 17 69 54*	      .byte.b	35,23,"iTSTN		    ",0
      0  1143					      db	36,23,"iFREE		    ",0
      1  1143		       24 17 69 46*	      .byte.b	36,23,"iFREE		    ",0
      0  115a					      db	37,23,"iRANDOM 	    ",0
      1  115a		       25 17 69 52*	      .byte.b	37,23,"iRANDOM 	    ",0
      0  1171					      db	38,23,"iABS		    ",0
      1  1171		       26 17 69 41*	      .byte.b	38,23,"iABS		    ",0
      0  1188					      db	39,23,"iOPENREAD	    ",0
      1  1188		       27 17 69 4f*	      .byte.b	39,23,"iOPENREAD	    ",0
      0  119f					      db	40,23,"iOPENWRITE	    ",0
      1  119f		       28 17 69 4f*	      .byte.b	40,23,"iOPENWRITE	    ",0
      0  11b6					      db	41,23,"iDCLOSE 	    ",0
      1  11b6		       29 17 69 44*	      .byte.b	41,23,"iDCLOSE 	    ",0
      0  11cd					      db	42,23,"iDGETLINE	    ",0
      1  11cd		       2a 17 69 44*	      .byte.b	42,23,"iDGETLINE	    ",0
      0  11e4					      db	43,23,"iDLIST		    ",0
      1  11e4		       2b 17 69 44*	      .byte.b	43,23,"iDLIST		    ",0
      0  11fb					      db	44,23,"iDDIR		    ",0
      1  11fb		       2c 17 69 44*	      .byte.b	44,23,"iDDIR		    ",0
      0  1212					      db	45,23,"iRMFILE 	    ",0
      1  1212		       2d 17 69 52*	      .byte.b	45,23,"iRMFILE 	    ",0
      0  1229					      db	39,23,"NextIL		    ",0
      1  1229		       27 17 4e 65*	      .byte.b	39,23,"NextIL		    ",0
      0  1240					      db	40,23,"NextIL		    ",0
      1  1240		       28 17 4e 65*	      .byte.b	40,23,"NextIL		    ",0
      0  1257					      db	41,23,"NextIL		    ",0
      1  1257		       29 17 4e 65*	      .byte.b	41,23,"NextIL		    ",0
      0  126e					      db	42,23,"NextIL		    ",0
      1  126e		       2a 17 4e 65*	      .byte.b	42,23,"NextIL		    ",0
      0  1285					      db	43,23,"NextIL		    ",0
      1  1285		       2b 17 4e 65*	      .byte.b	43,23,"NextIL		    ",0
      0  129c					      db	44,23,"NextIL		    ",0
      1  129c		       2c 17 4e 65*	      .byte.b	44,23,"NextIL		    ",0
      0  12b3					      db	45,23,"NextIL		    ",0
      1  12b3		       2d 17 4e 65*	      .byte.b	45,23,"NextIL		    ",0
      0  12ca					      db	46,23,"iCLEARSCREEN	    ",0
      1  12ca		       2e 17 69 43*	      .byte.b	46,23,"iCLEARSCREEN	    ",0
      0  12e1					      db	47,23,"iPOKEMEMORY	    ",0
      1  12e1		       2f 17 69 50*	      .byte.b	47,23,"iPOKEMEMORY	    ",0
      0  12f8					      db	48,23,"iPEEKMEMORY	    ",0
      1  12f8		       30 17 69 50*	      .byte.b	48,23,"iPEEKMEMORY	    ",0
      0  130f					      db	49,23,"iTSTLET 	    ",0
      1  130f		       31 17 69 54*	      .byte.b	49,23,"iTSTLET 	    ",0
      0  1326					      db	50,23,"iTSTDONE	    ",0
      1  1326		       32 17 69 54*	      .byte.b	50,23,"iTSTDONE	    ",0
      0  133d					      db	51,23,"iGETCHAR	    ",0
      1  133d		       33 17 69 47*	      .byte.b	51,23,"iGETCHAR	    ",0
      0  1354					      db	52,23,"iPUTCHAR	    ",0
      1  1354		       34 17 69 50*	      .byte.b	52,23,"iPUTCHAR	    ",0
      0  136b					      db	53,23,"iCallFunc	    ",0
      1  136b		       35 17 69 43*	      .byte.b	53,23,"iCallFunc	    ",0
      0  1382					      db	54,23,"iBranch 	    ",0
      1  1382		       36 17 69 42*	      .byte.b	54,23,"iBranch 	    ",0
      0  1399					      db	55,23,"iTSTStr 	    ",0
      1  1399		       37 17 69 54*	      .byte.b	55,23,"iTSTStr 	    ",0
      0  13b0					      db	56,23,"iSetIrq 	    ",0
      1  13b0		       38 17 69 53*	      .byte.b	56,23,"iSetIrq 	    ",0
      0  13c7					      db	57,23,"iTstIrq 	    ",0
      1  13c7		       39 17 69 54*	      .byte.b	57,23,"iTstIrq 	    ",0
      0  13de					      db	58,23,"iRET		    ",0
      1  13de		       3a 17 69 52*	      .byte.b	58,23,"iRET		    ",0
      0  13f5					      db	59,23,"iINSTR		    ",0
      1  13f5		       3b 17 69 49*	      .byte.b	59,23,"iINSTR		    ",0
      0  140c					      db	60,23,"iMOD		    ",0
      1  140c		       3c 17 69 4d*	      .byte.b	60,23,"iMOD		    ",0
      0  1423					      db	61,23,"iTaskSet	    ",0
      1  1423		       3d 17 69 54*	      .byte.b	61,23,"iTaskSet	    ",0
      0  143a					      db	62,23,"iETask		    ",0
      1  143a		       3e 17 69 45*	      .byte.b	62,23,"iETask		    ",0
      0  1451					      db	63,23,"iNTask		    ",0
      1  1451		       3f 17 69 4e*	      .byte.b	63,23,"iNTask		    ",0
      0  1468					      db	64,23,"iArray		    ",0
      1  1468		       40 17 69 41*	      .byte.b	64,23,"iArray		    ",0
      0  147f					      db	65,23,"iTaskKill	    ",0
      1  147f		       41 17 69 54*	      .byte.b	65,23,"iTaskKill	    ",0
      0  1496					      db	66,23,"iTaskStat	    ",0
      1  1496		       42 17 69 54*	      .byte.b	66,23,"iTaskStat	    ",0
      0  14ad					      db	67,23,"iHexOut 	    ",0
      1  14ad		       43 17 69 48*	      .byte.b	67,23,"iHexOut 	    ",0
      0  14c4					      db	68,23,"iReadComplete	    ",0
      1  14c4		       44 17 69 52*	      .byte.b	68,23,"iReadComplete	    ",0
      0  14db					      db	69,23,"iReadStart	    ",0
      1  14db		       45 17 69 52*	      .byte.b	69,23,"iReadStart	    ",0
      0  14f2					      db	70,23,"iStartIO	    ",0
      1  14f2		       46 17 69 53*	      .byte.b	70,23,"iStartIO	    ",0
      0  1509					      db	71,23,"iEndIO		    ",0
      1  1509		       47 17 69 45*	      .byte.b	71,23,"iEndIO		    ",0
      0  1520					      db	72,23,"iLogNot 	    ",0
      1  1520		       48 17 69 4c*	      .byte.b	72,23,"iLogNot 	    ",0
      0  1537					      db	73,23,"iLogOr		    ",0
      1  1537		       49 17 69 4c*	      .byte.b	73,23,"iLogOr		    ",0
      0  154e					      db	74,23,"iLogAnd 	    ",0
      1  154e		       4a 17 69 4c*	      .byte.b	74,23,"iLogAnd 	    ",0
      0  1565					      db	75,23,"iLogXor 	    ",0
      1  1565		       4b 17 69 4c*	      .byte.b	75,23,"iLogXor 	    ",0
      0  157c					      db	76,23,"iWTASK		    ",0
      1  157c		       4c 17 69 57*	      .byte.b	76,23,"iWTASK		    ",0
      0  1593					      db	77,23,"iTASKPID	    ",0
      1  1593		       4d 17 69 54*	      .byte.b	77,23,"iTASKPID	    ",0
      0  15aa					      db	78,23,"iTRACEPROG	    ",0
      1  15aa		       4e 17 69 54*	      .byte.b	78,23,"iTRACEPROG	    ",0
      0  15c1					      db	79,23,"idbgBasic	    ",0
      1  15c1		       4f 17 69 64*	      .byte.b	79,23,"idbgBasic	    ",0
      0  15d8					      db	80,23,"iIPCS		    ",0
      1  15d8		       50 17 69 49*	      .byte.b	80,23,"iIPCS		    ",0
      0  15ef					      db	81,23,"iIPCR		    ",0
      1  15ef		       51 17 69 49*	      .byte.b	81,23,"iIPCR		    ",0
      0  1606					      db	82,23,"iIPCC		    ",0
      1  1606		       52 17 69 49*	      .byte.b	82,23,"iIPCC		    ",0
      0  161d					      db	83,23,"iIPCIO		    ",0
      1  161d		       53 17 69 49*	      .byte.b	83,23,"iIPCIO		    ",0
      0  1634					      db	84,23,"iPushMathStack	    ",0
      1  1634		       54 17 69 50*	      .byte.b	84,23,"iPushMathStack	    ",0
      0  164b					      db	85,23,"iPopMathStack	    ",0
      1  164b		       55 17 69 50*	      .byte.b	85,23,"iPopMathStack	    ",0
      0  1662					      db	86,23,"iSaveMathStack	    ",0
      1  1662		       56 17 69 53*	      .byte.b	86,23,"iSaveMathStack	    ",0
      0  1679					      db	87,23,"iRestoreMathStack   ",0
      1  1679		       57 17 69 52*	      .byte.b	87,23,"iRestoreMathStack   ",0
      0  1690					      db	88,23,"iIncParmCount	    ",0
      1  1690		       58 17 69 49*	      .byte.b	88,23,"iIncParmCount	    ",0
      0  16a7					      db	89,23,"iTaskGetMathStack   ",0
      1  16a7		       59 17 69 54*	      .byte.b	89,23,"iTaskGetMathStack   ",0
      0  16be					      db	90,23,"iTaskEnable	    ",0
      1  16be		       5a 17 69 54*	      .byte.b	90,23,"iTaskEnable	    ",0
      0  16d5					      db	91,23,"iTaskSuspend	    ",0
      1  16d5		       5b 17 69 54*	      .byte.b	91,23,"iTaskSuspend	    ",0
      0  16ec					      db	92,23,"iTaskPutMathPtr     ",0
      1  16ec		       5c 17 69 54*	      .byte.b	92,23,"iTaskPutMathPtr     ",0
      0  1703					      db	93,23,"iTSTVT		    ",0
      1  1703		       5d 17 69 54*	      .byte.b	93,23,"iTSTVT		    ",0
      0  171a					      db	94,23,"iSetR2		    ",0
      1  171a		       5e 17 69 53*	      .byte.b	94,23,"iSetR2		    ",0
      0  1731					      db	95,23,"iStk2Tmp	    ",0
      1  1731		       5f 17 69 53*	      .byte.b	95,23,"iStk2Tmp	    ",0
      0  1748					      db	96,23,"iTmp2Stk	    ",0
      1  1748		       60 17 69 54*	      .byte.b	96,23,"iTmp2Stk	    ",0
      0  175f					      db	97,23,"iTSTBYTE	    ",0
      1  175f		       61 17 69 54*	      .byte.b	97,23,"iTSTBYTE	    ",0
      0  1776					      db	98,23,"iINCVAR 	    ",0
      1  1776		       62 17 69 49*	      .byte.b	98,23,"iINCVAR 	    ",0
      0  178d					      db	99,23,"iDECVAR 	    ",0
      1  178d		       63 17 69 44*	      .byte.b	99,23,"iDECVAR 	    ",0
      0  17a4					      db	100,23,"iSLICE 	     ",0
      1  17a4		       64 17 69 53*	      .byte.b	100,23,"iSLICE 	     ",0
      0  17bb					      db	101,23,"iTSTB		     ",0
      1  17bb		       65 17 69 54*	      .byte.b	101,23,"iTSTB		     ",0
      0  17d2					      db	102,23,"iTSTW		     ",0
      1  17d2		       66 17 69 54*	      .byte.b	102,23,"iTSTW		     ",0
      0  17e9					      db	103,23,"iOnGoto	     ",0
      1  17e9		       67 17 69 4f*	      .byte.b	103,23,"iOnGoto	     ",0
      0  1800					      db	104,23,"iTSTRELOP	     ",0
      1  1800		       68 17 69 54*	      .byte.b	104,23,"iTSTRELOP	     ",0
      0  1817					      db	105,23,"iRepeatLine	     ",0
      1  1817		       69 17 69 52*	      .byte.b	105,23,"iRepeatLine	     ",0
      0  182e					      db	106,23,"iTSTBRANCH	     ",0
      1  182e		       6a 17 69 54*	      .byte.b	106,23,"iTSTBRANCH	     ",0
      0  1845					      db	107,23,"iFastXfer	     ",0
      1  1845		       6b 17 69 46*	      .byte.b	107,23,"iFastXfer	     ",0
      0  185c					      db	108,23,"iSetTerminal	     ",0
      1  185c		       6c 17 69 53*	      .byte.b	108,23,"iSetTerminal	     ",0
      0  1873					      db	109,23,"iINDB		     ",0
      1  1873		       6d 17 69 49*	      .byte.b	109,23,"iINDB		     ",0
      0  188a					      db	110,23,"iSetBlock	     ",0
      1  188a		       6e 17 69 53*	      .byte.b	110,23,"iSetBlock	     ",0
      0  18a1					      db	111,23,"iCopyBlock	     ",0
      1  18a1		       6f 17 69 43*	      .byte.b	111,23,"iCopyBlock	     ",0
      0  18b8					      db	112,23,"iCmpBlock	     ",0
      1  18b8		       70 17 69 43*	      .byte.b	112,23,"iCmpBlock	     ",0
      0  18cf					      db	113,23,"iShift 	     ",0
      1  18cf		       71 17 69 53*	      .byte.b	113,23,"iShift 	     ",0
      0  18e6					      db	114,23,"iTimer 	     ",0
      1  18e6		       72 17 69 54*	      .byte.b	114,23,"iTimer 	     ",0
      0  18fd					      db	$FF,23,"0		     ",0
      1  18fd		       ff 17 30 20*	      .byte.b	$FF,23,"0		     ",0
    127  1914
    128  1914							; Search for the il instruction and print the correct text for it
    129  1914							; on entry a contains the ip instruction to print
    130  1914
    131 U3684					      seg.u	TBData
    132 U3684		       00 00	   R0TempIL   ds	2
    133 U3686		       00	   ILSTA      ds	1
    134 U3687
    135  1914					      Seg	Code
    136  1914
    137  1914		       8d 86 36    PrintILText sta	ILSTA
    138  1917		       98		      tya
    139  1918		       48		      pha
    140  1919		       8a		      txa
    141  191a		       48		      pha
    142  191b		       a5 52		      lda	R0
    143  191d		       8d 84 36 	      sta	R0TempIL
    144  1920		       a5 53		      lda	R0+1
    145  1922		       8d 84 36 	      sta	R0TempIL
    146  1925		       a9 07		      lda	#ILTEXTTABLE&$FF
    147  1927		       85 52		      sta	R0
    148  1929		       a9 0e		      LDA	#ILTEXTTABLE>>8
    149  192b		       85 53		      sta	R0+1
    150  192d							;Loop Here for each entry
    151  192d		       a0 00	   PrintILLoop ldy	#0
    152  192f		       b1 52		      lda	(R0),y
    153  1931		       c9 ff		      cmp	#$FF
    154  1933		       f0 2a		      beq	PrintILNotFound
    155  1935		       cd 86 36 	      cmp	ILSTA
    156  1938		       f0 11		      beq	PrintILFound
    157  193a		       c8		      iny
    158  193b		       b1 52		      lda	(R0),y
    159  193d		       18		      clc
    160  193e		       65 52		      adc	R0
    161  1940		       85 52		      sta	R0
    162  1942		       a9 00		      lda	#0
    163  1944		       65 53		      adc	R0+1
    164  1946		       85 53		      sta	R0+1
    165  1948		       4c 2d 19 	      jmp	PrintILLoop
    166  194b							; The text was discovered
    167  194b		       c8	   PrintILFound iny		; point to length of instruction
    168  194c		       c8		      iny		; Point to start of text
    169  194d		       98		      tya
    170  194e		       18		      clc
    171  194f		       65 52		      adc	R0
    172  1951		       a8		      tay		; Low order byte of address
    173  1952		       a9 00		      lda	#0
    174  1954		       65 53		      adc	R0+1
    175  1956		       aa		      tax		; High order byte of address
    176  1957		       a9 00		      lda	#0	; Termination byte of string
    177  1959		       20 f4 21 	      jsr	PrtStr	; print the string
    178  195c		       4c 65 19 	      jmp	PrintILDone
    179  195f
    180  195f		       ad 86 36    PrintILNotFound lda	ILSTA
    181  1962		       20 99 21 	      jsr	HexToOut
    182  1965
    183  1965		       ad 84 36    PrintILDone lda	R0TempIL
    184  1968		       85 52		      sta	R0
    185  196a		       ad 85 36 	      lda	R0TempIL+1
    186  196d		       85 52		      sta	R0
    187  196f		       68		      pla
    188  1970		       aa		      tax
    189  1971		       68		      pla
    190  1972		       a8		      tay
    191  1973		       60		      rts
    192  1974					      endif
------- FILE mytb.asm
   2469  1974					      endif
------- FILE time.asm LEVEL 2 PASS 6
      0  1974					      include	"time.asm"
      1  1974							;This is the timer management functions
      2  1974							; a = 0 turn off irq, stop timer
      3  1974							; a = 1 turn on irq, set parm contained in x
      4  1974							; a = 4 get low value
      5  1974							; a = 2 get high value
      6  1974
      7  1974		       e0 10	   timerinterface equ	$E010
      8  1974		       00 1e	   cTimerControl equ	$1E
      9  1974		       00 00	   cTimerStop equ	0
     10  1974		       00 01	   cTimerStart equ	1
     11  1974		       00 02	   cTimerLow  equ	2
     12  1974		       00 04	   cTimerHigh equ	4
     13  1974
     14  1974							; returns	$82 ack    dec(130)
     15  1974							;		$83 Failed dec(131)
     16  1974
     17  1974							; il interface to the timer
     18  1974
     19  1974				   iTimer
     20  1974		       20 dd 2c 	      jsr	popR0
     21  1977		       a6 52		      ldx	R0	; Set time parameter
     22  1979		       20 dd 2c 	      jsr	popR0
     23  197c		       a5 52		      lda	R0	; control parameter 0-4
     24  197e		       20 88 19 	      jsr	iTimerif
     25  1981		       85 52		      sta	R0
     26  1983		       86 53		      stx	R0+1
     27  1985		       4c 1d 07 	      jmp	pushR0nextIl
     28  1988
     29  1988							; Actual system interface to the timer
     30  1988							; x is value 9 = 1 second, 1-5 = value * 10ms 6 = 100ms, 7=250ms, 8=500ms, 0 = stop timer
     31  1988							; a is 0,1,2,4
     32  1988				   iTimerif
     33  1988
     34  1988		       c9 02		      cmp	#cTimerLow	; Do they want the low byte
     35  198a		       b0 25		      bcs	iTimerValue	; Just get the value we need
     36  198c		       78		      sei		; Disable the interupts
     37  198d		       48		      pha		; save the command
     38  198e		       a9 1e		      lda	#cTimerControl	; Load the timer control command
     39  1990		       8d 10 e0 	      sta	timerinterface	; Write it to the timer port
     40  1993		       8a		      txa		; get value to write, if cmd = 0 stop then x is init to zero
     41  1994		       8d 10 e0 	      sta	timerinterface	; write it to the port the timeout value
     42  1997		       68		      pla		; Get the actual command back
     43  1998		       c9 00		      cmp	#cTimerStop	; if the command was stop timer just get out
     44  199a		       f0 0f		      beq	iTimerAck	; if not then get ack/nak and continue
     45  199c
     46  199c		       a9 00		      lda	#0	; Clear the counter
     47  199e		       8d 4c 43 	      sta	timercounter
     48  19a1		       8d 4d 43 	      sta	timercounter+1
     49  19a4		       8d 4e 43 	      sta	timercounter+2
     50  19a7		       8d 4f 43 	      sta	timercounter+3
     51  19aa		       58		      cli		; enable the interupts, this is start/restart timer
     52  19ab
     53  19ab				   iTimerAck
     54  19ab		       ad 10 e0 	      lda	timerinterface	; get the ack nak
     55  19ae		       a2 00		      ldx	#0	; the ack value is single byte so pad with x
     56  19b0		       60		      rts		; Get out of here
     57  19b1
     58  19b1				   iTimerValue		; get the value from the offsets provided
     59  19b1		       08		      php		; Save the flags so we can restore irq setting later
     60  19b2		       78		      sei		; turn off the interupts
     61  19b3		       aa		      tax		; the control is also the value
     62  19b4		       bd 4a 43 	      lda	[timercounter-2],x	; get the high byte of value
     63  19b7		       48		      pha		; Save the value for x set
     64  19b8		       bd 4b 43 	      lda	[timercounter-1],x	; get the low part of value
     65  19bb		       aa		      tax
     66  19bc		       68		      pla
     67  19bd		       28		      plp		; restore the interupt flag if it was enabled
     68  19be		       60		      rts
     69  19bf
     70  19bf
     71  19bf
------- FILE mytb.asm
------- FILE io.asm LEVEL 2 PASS 6
      0  19bf					      include	"io.asm"
      1  19bf							; This is the io blocks and function for reading and writing
      2  19bf							; to devices attached to this computer.
      3  19bf							; This supports devices mapped at e000 thru efff in slot sizes of 16 byte
      4  19bf							;
      5  19bf							;=====================================================================
      6  19bf							; Device configuration equates
      7  19bf		       00 00	   ConsoleID  equ	0
      8  19bf		       00 08	   SerialID   equ	[1<<3]
      9  19bf		       00 10	   ClockID    equ	[2<<3]
     10  19bf		       00 18	   TimerID    equ	[3<<3]
     11  19bf		       00 20	   DiskID     equ	[4<<3]
     12  19bf
     13  19bf		       00 0a	   IO_MAX_DEVICES equ	10
     14  19bf		       00 06	   IO_VECT_LEN equ	6
     15  19bf
     16  19bf		       00 01	   IO_DEVICE_CLOSED equ	1	; The device is not open
     17  19bf		       00 02	   IO_DEVICE_INVALID equ	2	; The Device number provided is invalid
     18  19bf
     19  19bf							;========================================================================================
     20  19bf							; Uninitialized data segment
     21 U3687					      seg.u	TBData
     22 U3687
     23 U3687		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
     24 U3689		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
     25 U368b		       00 00	   BStatVec   ds	2	; This is used by inteface to read write status/config information
      0 U368d				   BActiveDevice db	1	; the index of the current device block
      1 U368d		       01		      .byte.b	1
      0 U368e				   BActiveDriver db	1	; Index of the device driver block
      1 U368e		       01		      .byte.b	1
     28 U368f
     29 U368f							;============================================================================================
     30  19bf					      Seg	Code
     31  19bf							; IRQ BASIC Code Service RTN Support
      0  19bf				   SaveIrqReg db	0	; Store current setting
      1  19bf		       00		      .byte.b	0
      0  19c0				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1  19c0		       00		      .byte.b	0
      0  19c1				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1  19c1		       00		      .byte.b	0
      0  19c2				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1  19c2		       00 00		      .byte.b	0,0
     36  19c4
     37  19c4							;============================================================================================
     38  19c4							; Define the device interface blocks
     39  19c4				   DeviceDriverBlocks
     40  19c4				   ConsoleDevice		; Block 0
      0  19c4					      dw	ConsoleID	; device idenifier Console
      1  19c4		       00 00		      .word.w	ConsoleID
      0  19c6					      dw	cin	; read function vector
      1  19c6		       09 f0		      .word.w	cin
      0  19c8					      dw	cout	; write function vector
      1  19c8		       0c f0		      .word.w	cout
      0  19ca					      dw	cstatus	; Get current Status info/Write config
      1  19ca		       0f f0		      .word.w	cstatus
     45  19cc
     46  19cc				   SerialDevice 		; Block 1
      0  19cc					      dw	SerialID	; device idenifier Serial
      1  19cc		       08 00		      .word.w	SerialID
      0  19ce					      dw	SerialIn	; read function vector
      1  19ce		       ba 1a		      .word.w	SerialIn
      0  19d0					      dw	SerialOut	; write function vector
      1  19d0		       ba 1a		      .word.w	SerialOut
      0  19d2					      dw	SerialStatus	; Get current Status info/Write config
      1  19d2		       ba 1a		      .word.w	SerialStatus
     51  19d4
     52  19d4				   ClockDevice		; Block 2
      0  19d4					      dw	ClockID	; Day/date Clock
      1  19d4		       10 00		      .word.w	ClockID
      0  19d6					      dw	ClockRead	; Read the date from clock
      1  19d6		       bb 1a		      .word.w	ClockRead
      0  19d8					      dw	ClockWrite	; Set the date/time of clock
      1  19d8		       bb 1a		      .word.w	ClockWrite
      0  19da					      dw	#0	; No Status/Config Function
      1  19da		       00 00		      .word.w	#0
     57  19dc
     58  19dc				   TimerDevice		; Block 3
      0  19dc					      dw	TimerID	; Timer/interrupt interface
      1  19dc		       18 00		      .word.w	TimerID
      0  19de					      dw	TimerStart	; Start the timer
      1  19de		       bc 1a		      .word.w	TimerStart
      0  19e0					      dw	TimerStop	; Stop the timer
      1  19e0		       bc 1a		      .word.w	TimerStop
      0  19e2					      dw	TimerStatus	; Config/read status
      1  19e2		       bc 1a		      .word.w	TimerStatus
     63  19e4
      0  19e4				   DiskDevice dw	DiskID	; Block 4
      1  19e4		       20 00		      .word.w	DiskID
      0  19e6					      dw	DIN	; Disk Input / read function
      1  19e6		       84 31		      .word.w	DIN
      0  19e8					      dw	DOUT	; Disk Output / write function
      1  19e8		       6b 31		      .word.w	DOUT
      0  19ea					      dw	DSTAT	; Disk Status/open/close etc information
      1  19ea		       9d 31		      .word.w	DSTAT
     68  19ec							;
     69  19ec							;======================================================================
     70  19ec							; Define the Device/Slot,driver control blocks
     71  19ec							; entry format: ControlWord,DeviceDriver,PortAddress,StatusWord
     72  19ec							; Fixed at 10 devices memory usage is getting pretty big!!!!!!
     73  19ec							; Control word : bit 0 = active 1, Free 0
     74  19ec
     75  19ec				   DeviceIoBlocks
      0  19ec					      dw	1, ConsoleID, $E000, 0	; Console device is 0 file
      1  19ec		       01 00 00 00*	      .word.w	1, ConsoleID, $E000, 0
      0  19f4					      dw	1, ClockID, $E010, 0	; Port for the day/time clock
      1  19f4		       01 00 10 00*	      .word.w	1, ClockID, $E010, 0
      0  19fc					      dw	1, TimerID, $E010, 0	; Timer interface
      1  19fc		       01 00 18 00*	      .word.w	1, TimerID, $E010, 0
      0  1a04					      dw	1, DiskID, $E010, 0	; Disk Driver interface
      1  1a04		       01 00 20 00*	      .word.w	1, DiskID, $E010, 0
      0  1a0c					      dw	1, SerialID, $E020, 0	; Second terminal(default Basic debug)
      1  1a0c		       01 00 08 00*	      .word.w	1, SerialID, $E020, 0
      0  1a14					      dw	0, SerialID, $E030, 0	; Unused slot
      1  1a14		       00 00 08 00*	      .word.w	0, SerialID, $E030, 0
      0  1a1c					      dw	0, SerialID, $E040, 0	; Unused slot
      1  1a1c		       00 00 08 00*	      .word.w	0, SerialID, $E040, 0
      0  1a24					      dw	0, SerialID, $E050, 0	; Unused slot
      1  1a24		       00 00 08 00*	      .word.w	0, SerialID, $E050, 0
      0  1a2c					      dw	0, SerialID, $E060, 0	; Unused slot
      1  1a2c		       00 00 08 00*	      .word.w	0, SerialID, $E060, 0
      0  1a34					      dw	0, SerialID, $E070, 0	; Unused slot
      1  1a34		       00 00 08 00*	      .word.w	0, SerialID, $E070, 0
     86  1a3c							;
     87  1a3c							;======================================================================
     88  1a3c							;
     89  1a3c					      Seg	Code
     90  1a3c							;======================================================================
     91  1a3c							; This is the Basic IRQ handler, works with task manager, assumes timer interupt
     92  1a3c							;
     93  1a3c		       48	   ServiceIrq pha
     94  1a3d		       8a		      txa
     95  1a3e		       48		      pha
     96  1a3f		       a2 00		      ldx	#0
     97  1a41				   ServiceLoop
     98  1a41		       fe 4c 43 	      inc	timercounter,x
     99  1a44		       d0 05		      bne	ServiceCont
    100  1a46		       e8		      inx
    101  1a47		       e0 04		      cpx	#4
    102  1a49		       d0 f6		      bne	ServiceLoop
    103  1a4b				   ServiceCont
    104  1a4b		       ad c0 19 	      lda	IRQStatus
    105  1a4e		       f0 0a		      beq	RetIrq
    106  1a50		       ad c1 19 	      lda	IRQPending
    107  1a53		       d0 05		      bne	RetIrq
    108  1a55		       a9 01		      lda	#1
    109  1a57		       8d c1 19 	      sta	IRQPending
    110  1a5a				   RetIrq
    111  1a5a		       68		      pla
    112  1a5b		       aa		      tax
    113  1a5c		       68		      pla
    114  1a5d		       40		      rti
    115  1a5e							;======================================================================
    116  1a5e							; Jump to the output/input function in BOutVec/BInVec
    117  1a5e							;
    118  1a5e		       6c 89 36    VOUTCH     jmp	(BOutVec)	; Primary block io vectors
    119  1a61		       6c 87 36    VGETCH     jmp	(BInVec)
    120  1a64		       6c 8b 36    VSTAT      jmp	(BStatVec)
    121  1a67							;
    122  1a67							;======================================================================
    123  1a67							; IO Service functions
    124  1a67							; Validate the device index and set x to offest in table
    125  1a67							; does not return to ioInterface if invalid, returns to original caller
    126  1a67							; should be called immediatly after entering the ioInterface call
    127  1a67				   ioValidateDevice
    128  1a67		       e0 0a		      cpx	#IO_MAX_DEVICES
    129  1a69		       90 04		      bcc	ioValidIndex
    130  1a6b		       a2 02		      ldx	#IO_DEVICE_INVALID
    131  1a6d		       b0 13		      bcs	ioInvalidDevice
    132  1a6f				   ioValidIndex
    133  1a6f		       8a		      txa
    134  1a70		       0a		      asl		; Multiply by 8
    135  1a71		       0a		      asl
    136  1a72		       0a		      asl
    137  1a73		       aa		      tax		; Point to actual offset in the table
    138  1a74		       ec 8d 36 	      cpx	BActiveDevice	; is it already active ?
    139  1a77		       f0 0d		      beq	ioValidDevice	; Shortcut if this is the active device already
    140  1a79		       a9 01		      lda	#1	; Active flag
    141  1a7b		       3d ec 19 	      and	DeviceIoBlocks,x	; Check if the device is active
    142  1a7e		       d0 06		      bne	ioValidDevice	; The device is active and valid index
    143  1a80		       a2 01		      ldx	#IO_DEVICE_CLOSED
    144  1a82
    145  1a82				   ioInvalidDevice
    146  1a82		       68		      pla		; Remove return address of IO interface
    147  1a83		       68		      pla
    148  1a84		       38		      sec		; ensure that carry is set
    149  1a85		       60		      rts
    150  1a86
    151  1a86				   ioValidDevice
    152  1a86		       18		      clc
    153  1a87		       60		      rts
    154  1a88							;
    155  1a88							;===================================================================================
    156  1a88							; Set the io device jmp vectors
    157  1a88							; input x contains the vector to the active Device IO Block
    158  1a88							; output a, x undefined y unchanged
    159  1a88				   ioSetDeviceVectors
    160  1a88		       ec 8d 36 	      cpx	BActiveDevice	; Check if already set
    161  1a8b		       f0 1b		      beq	ioSetDevExit	; if already set then do nothing
    162  1a8d
    163  1a8d		       8e 8d 36 	      stx	BActiveDevice	; set the active device vector
    164  1a90		       98		      tya
    165  1a91		       48		      pha
    166  1a92
    167  1a92		       bc ee 19 	      ldy	DeviceIoBlocks+2,x	; Get the device driver index
    168  1a95		       8c 8e 36 	      sty	BActiveDriver	; Pointer to active Device driver
    169  1a98		       a2 00		      ldx	#0	; Transfer the 6 pointers to the Vectors
    170  1a9a				   ioSetDevLoop
    171  1a9a		       b9 c6 19 	      lda	DeviceDriverBlocks+2,y
    172  1a9d		       9d 87 36 	      sta	BInVec,x
    173  1aa0		       e8		      inx
    174  1aa1		       c8		      iny
    175  1aa2		       e0 06		      cpx	#IO_VECT_LEN	; Transfer the vector length to copy
    176  1aa4		       d0 f4		      bne	ioSetDevLoop
    177  1aa6
    178  1aa6		       68		      pla
    179  1aa7		       a8		      tay
    180  1aa8				   ioSetDevExit
    181  1aa8		       60		      rts
    182  1aa9							;
    183  1aa9							;======================================================================
    184  1aa9							; Generic call interface for devices
    185  1aa9							; input x = DeviceIoBlockIndex
    186  1aa9							; Carry set if error, x contains the error code
    187  1aa9							; all other parameters are dependant upon the actual device interface
    188  1aa9							;
    189  1aa9							; ioPutCH  a contains the character to send
    190  1aa9		       20 67 1a    ioPutCH    jsr	ioValidateDevice
    191  1aac		       48		      pha
    192  1aad		       20 88 1a 	      jsr	ioSetDeviceVectors
    193  1ab0		       68		      pla
    194  1ab1		       20 5e 1a 	      jsr	VOUTCH
    195  1ab4		       18		      clc
    196  1ab5		       60		      rts
    197  1ab6
    198  1ab6							; io Getch returns the character read from device
    199  1ab6		       20 67 1a    ioGetCH    jsr	ioValidateDevice
    200  1ab9
    201  1ab9		       60		      rts
    202  1aba							;
    203  1aba							;======================================================================
    204  1aba							;TTY interface functions,
    205  1aba							;	a contains the character to send
    206  1aba							;	x contains the Device ID (equals index into io blocks)	of the io block to used
    207  1aba							;
    208  1aba				   SerialIn
    209  1aba
    210  1aba				   SerialOut
    211  1aba
    212  1aba				   SerialStatus
    213  1aba		       60		      rts
    214  1abb							;
    215  1abb							;======================================================================
    216  1abb							; Date/Time clock interface
    217  1abb				   ClockRead
    218  1abb
    219  1abb				   ClockWrite
    220  1abb		       60		      rts
    221  1abc							;
    222  1abc							;======================================================================
    223  1abc							;
    224  1abc				   TimerStart
    225  1abc
    226  1abc				   TimerStop
    227  1abc
    228  1abc				   TimerStatus
    229  1abc		       60		      rts
    230  1abd
------- FILE mytb.asm
------- FILE tokenizer.asm LEVEL 2 PASS 6
      0  1abd					      include	"tokenizer.asm"
      1  1abd					      seg	Code
      2  1abd		       00 00	   DEBUGPARSER equ	FALSE	; Print debugging information
      3  1abd
      4  1abd							; Define the types of tokens found, and identifiers
      5  1abd		       00 7f	   KeywordsMax equ	$7F	; Allow to be range  1 to 127	key words, high order bit must be 0 for it to be a key word
      6  1abd		       00 80	   tVa	      equ	$80	; Variable A = 1, .... Z = 26	 ^ = 27
      7  1abd		       00 81	   tVb	      equ	$81	; Variables 128 - 157	$80-$9D
      8  1abd		       00 99	   tVz	      equ	tVa+25	; Value of the last variable
      9  1abd
     10  1abd		       00 9b	   tVhat      equ	$9B	; Variable ^
     11  1abd		       00 9c	   tVhash     equ	$9C	; Variable #
     12  1abd		       00 9d	   tVat       equ	$9D	; Variable @ = 0
     13  1abd
     14  1abd							; Base variable type supported by This basic
     15  1abd							; Unsigned types always have the 0 bit set to 1
     16  1abd		       00 a0	   tString    equ	$A0	; Strings all start with this byte and end with  byte value 0 strings can be accessed with array slicing
     17  1abd		       00 a2	   tByte      equ	$A2	; Signed Byte value
     18  1abd		       00 a4	   tInteger   equ	$A4	; all tokenized integers start with 251 as first byte 16 bit signed number
     19  1abd		       00 a6	   tLong      equ	$A6	; Signed 32 bit integer
     20  1abd
     21  1abd		       00 a1	   tArray     equ	$A1	; Identifies Array Type, the byte following defines the length of each element
     22  1abd							; Arrays of string are arrays of pointers 2 bytes each
     23  1abd		       00 a3	   tPointer   equ	$A3	; Pointer  unsigned 16 bit
     24  1abd		       00 a5	   tIndirect  equ	$A5	; Points to an address that points to the data 16 bits
     25  1abd		       00 a7	   tuByte     equ	$A7	; Unsigned byte value 8 bit unsigned value
     26  1abd		       00 a9	   tUint      equ	$A9	; unsigned integer type 16 bit
     27  1abd		       00 ab	   tUlong     equ	$AB	; Unsigned 32 bit integer
     28  1abd
     29  1abd		       3c 3e	   Operators  BYTE.b	"<>"
     30  1abf		       3c 3d		      BYTE.b	"<="
     31  1ac1		       3e 3d		      BYTE.b	">="
     32  1ac3		       3c 3c		      Byte.b	"<<"
     33  1ac5		       3e 3e		      Byte.b	">>"
     34  1ac7		       3c 00		      BYTE.b	"<",0
     35  1ac9		       3d 00		      BYTE.b	"=",0
     36  1acb		       3e 00		      BYTE.b	">",0
     37  1acd		       2b 2b		      Byte.b	"++"
     38  1acf		       2b 00		      BYTE.b	"+",0
     39  1ad1		       2d 2d		      Byte.b	"--"
     40  1ad3		       2d 00		      BYTE.b	"-",0
     41  1ad5		       2f 00		      BYTE.b	"/",0
     42  1ad7		       25 00		      BYTE.b	"%",0
     43  1ad9		       2a 00		      BYTE.b	"*",0
     44  1adb		       28 00		      BYTE.b	"(",0
     45  1add		       29 00		      BYTE.b	")",0
     46  1adf		       2c 00		      BYTE.b	",",0
     47  1ae1		       3b 00		      BYTE.b	";",0
     48  1ae3		       5b 00		      BYTE.b	"[",0
     49  1ae5		       5d 00		      BYTE.b	"]",0
     50  1ae7		       3a 00		      BYTE.b	":",0
     51  1ae9		       24 00		      BYTE.b	"$",0
     52  1aeb		       21 00		      BYTE.b	"!",0
     53  1aed		       3f 00		      BYTE.b	"?",0
     54  1aef		       2e 00		      BYTE.b	".",0
     55  1af1		       26 00		      BYTE.b	"&",0
     56  1af3		       27 00		      Byte.b	"'",0
     57  1af5		       7c 00		      Byte.b	"|",0
     58  1af7		       7e 00		      Byte.b	"~",0
     59  1af9		       00 00		      BYTE.b	0,0
     60  1afb
     61  1afb		       f5 f3 f6 29*OperValues BYTE.b	oNotEqual,oLessEqual,oGreaterEqual,oSHL,oSHR,oLess,oEqual,oGreater
     62  1b03		       02 ea 03 eb*	      BYTE.b	oINC, oPlus, oDEC, oMinus, oDivide, oModulo, oMultiply
     63  1b0a		       e0 e1 e2 e3*	      BYTE.b	oLeftBracket, oRightBracket, oComma, oSemiColon, oLeftSQBracket, oRightSQBracket
     64  1b10		       e6 e7 e8 0b*	      BYTE.b	oColon, oDollar, oBang, oQuestion, oPeriod, oAmphistan, oQuote, oBar,oTilde
     65  1b19
     66  1b19		       00 0b	   oQuestion  equ	kPrint
     67  1b19							;    2 is =
     68  1b19							;    1 is <
     69  1b19							;    3 is <=
     70  1b19							;    5 is <>
     71  1b19							;    4 is >
     72  1b19							;    6 is >=
     73  1b19		       00 f1	   oLess      equ	$F1
     74  1b19		       00 f2	   oEqual     equ	$F2
     75  1b19		       00 f3	   oLessEqual equ	$F3
     76  1b19		       00 f4	   oGreater   equ	$F4
     77  1b19		       00 f5	   oNotEqual  equ	$F5
     78  1b19		       00 f6	   oGreaterEqual equ	$F6
     79  1b19
     80  1b19		       00 e0	   oLeftBracket equ	$E0
     81  1b19		       00 e1	   oRightBracket equ	$E1
     82  1b19		       00 e2	   oComma     equ	$E2
     83  1b19		       00 e3	   oSemiColon equ	$E3
     84  1b19		       00 e4	   oLeftSQBracket equ	$E4
     85  1b19		       00 e5	   oRightSQBracket equ	$E5
     86  1b19		       00 e6	   oColon     equ	$E6
     87  1b19		       00 e7	   oDollar    equ	$E7
     88  1b19		       00 e8	   oBang      equ	$E8
     89  1b19		       00 e9	   oPeriod    equ	$E9
     90  1b19
     91  1b19
     92  1b19		       00 ea	   oPlus      equ	$EA
     93  1b19		       00 eb	   oMinus     equ	$EB
     94  1b19		       00 ec	   oDivide    equ	$EC
     95  1b19		       00 ed	   oModulo    equ	$ED
     96  1b19		       00 ee	   oMultiply  equ	$EE
     97  1b19
     98  1b19		       00 ed	   oPercent   equ	oModulo
     99  1b19		       00 27	   oAmphistan equ	kAnd
    100  1b19		       00 25	   oBar       equ	kOr
    101  1b19		       00 0a	   oQuote     equ	kRem
    102  1b19		       00 26	   oTilde     equ	kXor
    103  1b19		       00 28	   oSHR       equ	kShr
    104  1b19		       00 29	   oSHL       equ	kShl
    105  1b19		       00 02	   oINC       equ	kInc
    106  1b19		       00 03	   oDEC       equ	kDec
    107  1b19
    108  1b19		       00 f0	   tOperatorX equ	$F0	;+ operator Value  ; stores the value used to do the relational operator compare
    109  1b19
    110  1b19		       00 ff	   tError     equ	$FF	; Error should never happen
    111  1b19							;============================================================================================
    112  1b19							; Keyword and seperator values
    113  1b19				   '
    114  1b19		       00 01	   kBeginKey  equ	kLet
    115  1b19							;
    116  1b19		       00 01	   kLet       equ	1
    117  1b19		       00 02	   kInc       equ	kLet+1
    118  1b19		       00 03	   kDec       equ	kInc+1
    119  1b19		       00 04	   kIreturn   equ	kDec+1
    120  1b19		       00 05	   kIf	      equ	kIreturn+1
    121  1b19		       00 06	   kThen      equ	kIf+1
    122  1b19		       00 07	   kGoto      equ	kThen+1
    123  1b19		       00 08	   kGosub     equ	kGoto+1
    124  1b19		       00 09	   kReturn    equ	kGosub+1
    125  1b19		       00 0a	   kRem       equ	kReturn+1
    126  1b19		       00 0b	   kPrint     equ	kRem+1
    127  1b19		       00 0c	   kTaske     equ	kPrint+1
    128  1b19		       00 0d	   kTaskn     equ	kTaske+1
    129  1b19		       00 0e	   kTaskw     equ	kTaskn+1
    130  1b19		       00 0f	   kPoke      equ	kTaskw+1
    131  1b19		       00 10	   kPutch     equ	kPoke+1
    132  1b19		       00 11	   kCls       equ	kPutch+1
    133  1b19		       00 12	   kInput     equ	kCls+1
    134  1b19		       00 13	   kEnd       equ	kInput+1
    135  1b19		       00 14	   kIrq       equ	kEnd+1
    136  1b19		       00 15	   kKill      equ	kIrq+1
    137  1b19		       00 16	   kList      equ	kKill+1
    138  1b19		       00 17	   kRun       equ	kList+1
    139  1b19		       00 18	   kNew       equ	kRun+1
    140  1b19		       00 19	   kSlice     equ	kNew+1
    141  1b19		       00 1a	   kTrace     equ	kSlice+1
    142  1b19		       00 1b	   kExit      equ	kTrace+1
    143  1b19		       00 1c	   kSave      equ	kExit+1
    144  1b19		       00 1d	   kLoad      equ	kSave+1
    145  1b19		       00 1e	   kErase     equ	kLoad+1
    146  1b19		       00 1f	   kDir       equ	kErase+1
    147  1b19		       00 20	   kSetTerm   equ	kDir+1
    148  1b19		       00 21	   kSetMemB   equ	kSetTerm+1
    149  1b19		       00 22	   kSetMemW   equ	kSetMemB+1
    150  1b19		       00 23	   kCopyMem   equ	kSetMemW+1
    151  1b19							;
    152  1b19							; End of actual key words
    153  1b19							;
    154  1b19		       00 22	   kKeyCount  equ	kCopyMem-kBeginKey
    155  1b19							;
    156  1b19							; Logical operators
    157  1b19							;
    158  1b19		       00 24	   kNot       equ	kCopyMem+1
    159  1b19		       00 25	   kOr	      equ	kNot+1
    160  1b19		       00 26	   kXor       equ	kOr+1
    161  1b19		       00 27	   kAnd       equ	kXor+1
    162  1b19							;
    163  1b19							; Shift operators
    164  1b19							;
    165  1b19		       00 28	   kShr       equ	kAnd+1
    166  1b19		       00 29	   kShl       equ	kShr+1
    167  1b19
    168  1b19							; numeric functions
    169  1b19							;
    170  1b19		       00 2a	   kBeginFunc equ	kTrue
    171  1b19							;
    172  1b19							; Truth operators
    173  1b19							;
    174  1b19		       00 2a	   kTrue      equ	kShl+1
    175  1b19		       00 2b	   kFalse     equ	kTrue+1
    176  1b19							; Functions
    177  1b19		       00 2c	   kFree      equ	kFalse+1
    178  1b19		       00 2d	   kGetch     equ	kFree+1
    179  1b19		       00 2e	   kPeek      equ	kGetch+1
    180  1b19		       00 2f	   kTask      equ	kPeek+1
    181  1b19		       00 30	   kIpcc      equ	kTask+1
    182  1b19		       00 31	   kIpcs      equ	kIpcc+1
    183  1b19		       00 32	   kIpcr      equ	kIpcs+1
    184  1b19		       00 33	   kRnd       equ	kIpcr+1
    185  1b19		       00 34	   kStat      equ	kRnd+1
    186  1b19		       00 35	   kAbs       equ	kStat+1
    187  1b19		       00 36	   kCall      equ	kAbs+1
    188  1b19		       00 37	   kGofn      equ	kCall+1
    189  1b19		       00 38	   kPid       equ	kGofn+1
    190  1b19		       00 39	   kAddr      equ	kPid+1
    191  1b19		       00 3a	   kCmpMem    equ	kAddr+1
    192  1b19		       00 3b	   kTimer     equ	kCmpMem+1
    193  1b19							;
    194  1b19		       00 12	   kFuncCount equ	((kTimer - kBeginFunc) + 1)
    195  1b19
    196  1b19							;
    197  1b19							; Keyword table contains 54 keywords
    198  1b19				   KeyWordTable
      0  1b19					      db	kLet,"leT"	; 1, we only have 0 at end of program or line
      1  1b19		       01 6c 65 54	      .byte.b	kLet,"leT"
      0  1b1d					      db	kInc,"inC"
      1  1b1d		       02 69 6e 43	      .byte.b	kInc,"inC"
      0  1b21					      db	kDec,"deC"
      1  1b21		       03 64 65 43	      .byte.b	kDec,"deC"
      0  1b25					      db	kIreturn,"ireturN"
      1  1b25		       04 69 72 65*	      .byte.b	kIreturn,"ireturN"
      0  1b2d					      db	kIf,"iF"
      1  1b2d		       05 69 46 	      .byte.b	kIf,"iF"
      0  1b30					      db	kThen,"theN"
      1  1b30		       06 74 68 65*	      .byte.b	kThen,"theN"
      0  1b35					      db	kGoto,"gotO"
      1  1b35		       07 67 6f 74*	      .byte.b	kGoto,"gotO"
      0  1b3a					      db	kGosub,"gosuB"
      1  1b3a		       08 67 6f 73*	      .byte.b	kGosub,"gosuB"
      0  1b40					      db	kReturn,"returN"
      1  1b40		       09 72 65 74*	      .byte.b	kReturn,"returN"
      0  1b47					      db	kRem,"reM"
      1  1b47		       0a 72 65 4d	      .byte.b	kRem,"reM"
      0  1b4b					      db	kPrint,"prinT"
      1  1b4b		       0b 70 72 69*	      .byte.b	kPrint,"prinT"
      0  1b51					      db	kTaske,"taskE"
      1  1b51		       0c 74 61 73*	      .byte.b	kTaske,"taskE"
      0  1b57					      db	kTaskn,"taskN"
      1  1b57		       0d 74 61 73*	      .byte.b	kTaskn,"taskN"
      0  1b5d					      db	kTaskw,"taskW"
      1  1b5d		       0e 74 61 73*	      .byte.b	kTaskw,"taskW"
      0  1b63					      db	kPoke,"pokE"
      1  1b63		       0f 70 6f 6b*	      .byte.b	kPoke,"pokE"
      0  1b68					      db	kPutch,"putcH"
      1  1b68		       10 70 75 74*	      .byte.b	kPutch,"putcH"
      0  1b6e					      db	kCls,"clS"
      1  1b6e		       11 63 6c 53	      .byte.b	kCls,"clS"
      0  1b72					      db	kInput,"inpuT"
      1  1b72		       12 69 6e 70*	      .byte.b	kInput,"inpuT"
      0  1b78					      db	kEnd,"enD"
      1  1b78		       13 65 6e 44	      .byte.b	kEnd,"enD"
      0  1b7c					      db	kIrq,"irQ"
      1  1b7c		       14 69 72 51	      .byte.b	kIrq,"irQ"
      0  1b80					      db	kKill,"kilL"
      1  1b80		       15 6b 69 6c*	      .byte.b	kKill,"kilL"
      0  1b85					      db	kList,"lisT"
      1  1b85		       16 6c 69 73*	      .byte.b	kList,"lisT"
      0  1b8a					      db	kRun,"ruN"
      1  1b8a		       17 72 75 4e	      .byte.b	kRun,"ruN"
      0  1b8e					      db	kNew,"neW"
      1  1b8e		       18 6e 65 57	      .byte.b	kNew,"neW"
      0  1b92					      db	kSlice,"slicE"
      1  1b92		       19 73 6c 69*	      .byte.b	kSlice,"slicE"
      0  1b98					      db	kTrace,"tracE"
      1  1b98		       1a 74 72 61*	      .byte.b	kTrace,"tracE"
      0  1b9e					      db	kExit,"exiT"
      1  1b9e		       1b 65 78 69*	      .byte.b	kExit,"exiT"
      0  1ba3					      db	kSave,"savE"
      1  1ba3		       1c 73 61 76*	      .byte.b	kSave,"savE"
      0  1ba8					      db	kLoad,"loaD"
      1  1ba8		       1d 6c 6f 61*	      .byte.b	kLoad,"loaD"
      0  1bad					      db	kErase,"erasE"
      1  1bad		       1e 65 72 61*	      .byte.b	kErase,"erasE"
      0  1bb3					      db	kDir,"diR"
      1  1bb3		       1f 64 69 52	      .byte.b	kDir,"diR"
    230  1bb7							;Short form for statements:
      0  1bb7					      db	kIreturn,"ireT"
      1  1bb7		       04 69 72 65*	      .byte.b	kIreturn,"ireT"
      0  1bbc					      db	kReturn,"reT"
      1  1bbc		       09 72 65 54	      .byte.b	kReturn,"reT"
      0  1bc0					      db	kPrint,"pR"	; some dialects of tiny basic use this for print
      1  1bc0		       0b 70 52 	      .byte.b	kPrint,"pR"
      0  1bc3					      db	kSetTerm, "setterM"
      1  1bc3		       20 73 65 74*	      .byte.b	kSetTerm, "setterM"
      0  1bcb					      db	kSetMemB, "setmemB"
      1  1bcb		       21 73 65 74*	      .byte.b	kSetMemB, "setmemB"
      0  1bd3					      db	kSetMemW, "setmemW"
      1  1bd3		       22 73 65 74*	      .byte.b	kSetMemW, "setmemW"
      0  1bdb					      db	kCopyMem, "copymeM"
      1  1bdb		       23 63 6f 70*	      .byte.b	kCopyMem, "copymeM"
    238  1be3
    239  1be3							; Shift operators
      0  1be3					      db	kShr,"shR"
      1  1be3		       28 73 68 52	      .byte.b	kShr,"shR"
      0  1be7					      db	kShl,"shL"
      1  1be7		       29 73 68 4c	      .byte.b	kShl,"shL"
    242  1beb
    243  1beb							;Logical and truth operators
      0  1beb					      db	kNot,"noT"
      1  1beb		       24 6e 6f 54	      .byte.b	kNot,"noT"
      0  1bef					      db	kOr,"oR"
      1  1bef		       25 6f 52 	      .byte.b	kOr,"oR"
      0  1bf2					      db	kXor,"xoR"
      1  1bf2		       26 78 6f 52	      .byte.b	kXor,"xoR"
      0  1bf6					      db	kAnd,"anD"
      1  1bf6		       27 61 6e 44	      .byte.b	kAnd,"anD"
    248  1bfa
    249  1bfa							; Truth values
      0  1bfa					      db	kTrue,"truE"
      1  1bfa		       2a 74 72 75*	      .byte.b	kTrue,"truE"
      0  1bff					      db	kFalse,"falsE"
      1  1bff		       2b 66 61 6c*	      .byte.b	kFalse,"falsE"
    252  1c05
    253  1c05
    254  1c05
    255  1c05							;functions returning values
    256  1c05
      0  1c05					      db	kFree,"freE"
      1  1c05		       2c 66 72 65*	      .byte.b	kFree,"freE"
      0  1c0a					      db	kGetch,"getcH"
      1  1c0a		       2d 67 65 74*	      .byte.b	kGetch,"getcH"
      0  1c10					      db	kPeek,"peeK"
      1  1c10		       2e 70 65 65*	      .byte.b	kPeek,"peeK"
      0  1c15					      db	kTask,"tasK"
      1  1c15		       2f 74 61 73*	      .byte.b	kTask,"tasK"
      0  1c1a					      db	kIpcc,"ipcC"
      1  1c1a		       30 69 70 63*	      .byte.b	kIpcc,"ipcC"
      0  1c1f					      db	kIpcs,"ipcS"
      1  1c1f		       31 69 70 63*	      .byte.b	kIpcs,"ipcS"
      0  1c24					      db	kIpcr,"ipcR"
      1  1c24		       32 69 70 63*	      .byte.b	kIpcr,"ipcR"
      0  1c29					      db	kRnd,"rnD"
      1  1c29		       33 72 6e 44	      .byte.b	kRnd,"rnD"
      0  1c2d					      db	kStat,"staT"
      1  1c2d		       34 73 74 61*	      .byte.b	kStat,"staT"
      0  1c32					      db	kAbs,"abS"
      1  1c32		       35 61 62 53	      .byte.b	kAbs,"abS"
      0  1c36					      db	kCall,"calL"
      1  1c36		       36 63 61 6c*	      .byte.b	kCall,"calL"
      0  1c3b					      db	kGofn,"fN"
      1  1c3b		       37 66 4e 	      .byte.b	kGofn,"fN"
      0  1c3e					      db	kPid,"piD"
      1  1c3e		       38 70 69 44	      .byte.b	kPid,"piD"
      0  1c42					      db	kAddr,"addR"
      1  1c42		       39 61 64 64*	      .byte.b	kAddr,"addR"
      0  1c47					      db	kCmpMem, "cmpmeM"
      1  1c47		       3a 63 6d 70*	      .byte.b	kCmpMem, "cmpmeM"
      0  1c4e					      db	kTimer,"timeR"
      1  1c4e		       3b 74 69 6d*	      .byte.b	kTimer,"timeR"
      0  1c54					      db	0,0
      1  1c54		       00 00		      .byte.b	0,0
    274  1c56
    275  1c56		       1c 56	   KeyWordTableEnd equ	*
    276  1c56		       01 3d	   KeyWordTableLength equ	* - KeyWordTable
    277  1c56		       00 00 00 00*TOKENBUFFER ds	256	; placed here as temp for testing the Code
    278  1d56		       00 00 00    printStorage ds	3
    279  1d59							;==================================================================================================================
    280  1d59							; Read accross the inputline and output to TOKENBUFFER
    281  1d59							; Format   byte      Description
    282  1d59							;	     0	      length of line 1-255
    283  1d59							;	    0-1       Line Number
    284  1d59							;	    Tokens and litteral values encoded into the line
    285  1d59							;
    286  1d59							;  First test for numbers    for numbers insert type byte plus value 1 or 2 byte, byte, integer, string(pointers)
    287  1d59							;  if fails then test for keywords
    288  1d59							;  if fails then test for variables and arrays
    289  1d59							;  if fails check for operators/seperators  + - < > = % / * () [] , ; : >> <<
    290  1d59
    291  1d59				   ParseInputLine
    292  1d59				  -	      if	DEBUGPARSER
    293  1d59				  -	      jsr	SetOutDebug
    294  1d59				  -	      jsr	DebugClearBuffer
    295  1d59					      endif
    296  1d59		       a5 51		      lda	CUROFF
    297  1d5b		       48		      pha
    298  1d5c		       8a		      txa
    299  1d5d		       48		      pha
    300  1d5e		       98		      tya
    301  1d5f		       48		      pha
    302  1d60		       a2 01		      ldx	#1	; point to beginning of Token buffer + 1 reserve space for length byte
    303  1d62		       20 fd 2a 	      jsr	getDecimal	; Check for a line number, none is ok too
    304  1d65		       84 51		      sty	CUROFF
    305  1d67		       20 25 1f 	      jsr	R02TOKEN	; Move R0 to token buffer
    306  1d6a
    307  1d6a				   ParseInputLoop
    308  1d6a		       a4 51		      ldy	CUROFF
    309  1d6c		       20 8d 2d 	      jsr	SkipSpaces	; Skip any spaces
    310  1d6f		       84 51		      sty	CUROFF	; Even if it fails at least remove the spaces
    311  1d71		       b9 b3 42 	      lda	LINBUF,y	; Check for end of line
    312  1d74		       f0 25		      beq	ParseComplete	; Finish token buffer and return
    313  1d76
    314  1d76				   ParseForNumber
    315  1d76		       20 79 1e 	      jsr	ParseNumeric	; Check for a numeric value
    316  1d79		       90 ef		      bcc	ParseInputLoop	; Go Back for next element
    317  1d7b
    318  1d7b				   ParseForString
    319  1d7b		       20 4f 1e 	      jsr	ParseString	; Check for a string
    320  1d7e		       90 ea		      bcc	ParseInputLoop	; It was a string
    321  1d80
    322  1d80				   ParseForOp
    323  1d80		       20 b7 1e 	      jsr	ParseForOperator	; Check for operator or punctuation
    324  1d83		       90 e5		      bcc	ParseInputLoop	; it was an operator/punctuation
    325  1d85
    326  1d85				   ParseForKey
    327  1d85		       20 ac 1d 	      jsr	ParseLookupKey	; Check for a keyword value
    328  1d88		       90 e0		      bcc	ParseInputLoop	; Go back for next token, we are not syntax checking
    329  1d8a
    330  1d8a				   ParseForVar
    331  1d8a		       20 ee 1e 	      jsr	ParseForVariable	; Check for variable and convert to Index, as task centric
    332  1d8d		       90 db		      bcc	ParseInputLoop
    333  1d8f
    334  1d8f				   ParseKeepChar		; if it does not parse just keep it safe
    335  1d8f		       b9 b3 42 	      lda	LINBUF,y
    336  1d92		       9d 56 1c 	      sta	TOKENBUFFER,x
    337  1d95		       e8		      inx
    338  1d96		       c8		      iny
    339  1d97		       84 51		      sty	CUROFF
    340  1d99		       d0 cf		      bne	ParseInputLoop
    341  1d9b
    342  1d9b				   ParseComplete
    343  1d9b		       a9 00		      lda	#0
    344  1d9d		       9d 56 1c 	      sta	TOKENBUFFER,x	; null terminate the line of tokens
    345  1da0		       e8		      inx
    346  1da1		       8e 56 1c 	      stx	TOKENBUFFER	; Place size including null into buffer start
    347  1da4
    348  1da4		       68		      pla
    349  1da5		       a8		      tay
    350  1da6		       68		      pla
    351  1da7		       aa		      tax
    352  1da8		       68		      pla
    353  1da9		       85 51		      sta	CUROFF
    354  1dab
    355  1dab				  -	      if	DEBUGPARSER
    356  1dab				  -
    357  1dab				  -	      jsr	printTokenBuffer
    358  1dab				  -			;jsr	  DebugPrintProgramLine
    359  1dab				  -	      jsr	SetOutDebugEnd
    360  1dab				  -
    361  1dab					      endif
    362  1dab		       60		      rts
    363  1dac
    364  1dac							;==================================================================================================================
    365  1dac							; Look at curptr, curpos and check for a valid KeyWord
    366  1dac							; A contains the index value. c is clear
    367  1dac							;		     not found c set  A undefined
    368  1dac							; X is prerserved
    369  1dac							;
    370  1dac				   ParseLookupKey
    371  1dac		       86 58		      stx	R2
    372  1dae		       a0 00		      ldy	#0
    373  1db0		       a9 19		      lda	#KeyWordTable&$FF	; Key Table longer than 256 bytes
    374  1db2		       85 54		      sta	R1
    375  1db4		       a9 1b		      lda	#KeyWordTable>>8
    376  1db6		       85 55		      sta	R1+1	; R1 points to first entry in keyword table
    377  1db8		       b1 54		      lda	(R1),y	; Get the Key Token value for first keyword
    378  1dba		       85 52		      sta	R0	; Save until next keyword
    379  1dbc		       c8		      iny		; Point to first character of keyword
    380  1dbd		       a6 51		      ldx	CUROFF	; X points to the character in the input buffer
    381  1dbf
    382  1dbf				  -	      if	DEBUGPARSER
    383  1dbf				  -			;    jsr DebugKeyword
    384  1dbf					      endif
    385  1dbf
    386  1dbf				   ParseLookupLoop
    387  1dbf		       b1 54		      lda	(R1),y	; Get the first character of the keyword
    388  1dc1		       29 df		      and	#%11011111	; Force Keyword to upper case
    389  1dc3		       dd b3 42 	      cmp	LINBUF,x	; Check the input buffer
    390  1dc6		       f0 07		      beq	ParseNextLetter	; If it equals then do next letter
    391  1dc8		       09 20		      ora	#%00100000	; Force Keyword to lowercase
    392  1dca		       dd b3 42 	      cmp	LINBUF,x	; Compare value to upercase
    393  1dcd		       d0 34		      bne	ParseNextEntry	; Not equal then move to next entry in the keyword table
    394  1dcf
    395  1dcf				   ParseNextLetter
    396  1dcf		       b1 54		      lda	(R1),y	; Check if we just processed the last letter is upper
    397  1dd1		       29 20		      and	#%00100000	; if this bit not set then end of keyword, Last char is always uppercase
    398  1dd3		       f0 0b		      beq	ParseKeyFound	; If we are at end of keyword and all match then we found the key
    399  1dd5		       e8		      inx		; Point to next char in the input buffer
    400  1dd6		       c8		      iny		; Point to the next character in the Keyword table
    401  1dd7		       a9 00		      lda	#0	; Check if we are at the end of the input buffer
    402  1dd9		       dd b3 42 	      cmp	LINBUF,x	; Check if we are at the end of the input buffer
    403  1ddc		       f0 25		      beq	ParseNextEntry	; End of buffer but no keyword, ext keyword entry
    404  1dde		       d0 df		      bne	ParseLookupLoop	; Go back and check the next characters
    405  1de0
    406  1de0				   ParseKeyFound
    407  1de0		       a5 52		      lda	R0	; get the keyword index
    408  1de2
    409  1de2				   ParseKeyDone
    410  1de2		       e8		      inx		; point past the last character
    411  1de3		       86 51		      stx	CUROFF	; update to point to next character in the input buffer
    412  1de5		       a6 58		      ldx	R2	; Restore the original x pointer
    413  1de7		       9d 56 1c 	      sta	TOKENBUFFER,x	; store the Token into the compiled buffer
    414  1dea		       e8		      inx		; Point to next position in the output buffer
    415  1deb		       86 58		      stx	R2	; Save next position in buffer
    416  1ded		       c9 0a		      cmp	#kRem	; remark statement
    417  1def		       f0 3a		      beq	ParseMoveLine	; Move everything until the end of line to the token buffer
    418  1df1		       c9 07		      cmp	#kGoto
    419  1df3		       f0 4a		      beq	ParseHandleBranches	; Jump allow space for memory address in token buffer
    420  1df5		       c9 08		      cmp	#kGosub
    421  1df7		       f0 46		      beq	ParseHandleBranches	; Handle the gosub branch address
    422  1df9		       c9 37		      cmp	#kGofn
    423  1dfb		       f0 42		      beq	ParseHandleBranches	; Handle the gosub branch address
    424  1dfd		       c9 2f		      cmp	#kTask
    425  1dff		       f0 3e		      beq	ParseHandleBranches	; We may have the ability to also compile task vectors Bracket between the space and the value
    426  1e01
    427  1e01		       18		      clc		; C flag clear, we found it
    428  1e02		       60		      rts
    429  1e03
    430  1e03							; Move forward to the next entry in table
    431  1e03				   ParseNextEntry
    432  1e03		       b1 54		      lda	(R1),y	; Get the next character in the token
    433  1e05		       29 20		      and	#%00100000	; Is it the last character
    434  1e07		       f0 03		      beq	ParseEndOfEntry	; Yes then end of this entry found
    435  1e09		       c8		      iny		; Point to next char in the entry
    436  1e0a		       d0 f7		      bne	ParseNextEntry	; loop until we find the end character
    437  1e0c
    438  1e0c				   ParseEndOfEntry
    439  1e0c		       c8		      iny		; Point to the byte after the last character
    440  1e0d		       98		      tya		; Move into a as we must add this to the pointer in R1, more that 256 keyword characters in table
    441  1e0e		       18		      clc		; table May be longer than 256 so increment r1 to next entry
    442  1e0f		       65 54		      adc	R1
    443  1e11		       85 54		      sta	R1
    444  1e13		       a5 55		      lda	R1+1
    445  1e15		       69 00		      adc	#0
    446  1e17		       85 55		      sta	R1+1	; Now pointing to start of next entry in the table
    447  1e19		       a0 00		      ldy	#0	; Reset the index back to zero
    448  1e1b		       b1 54		      lda	(R1),y	; get keyword value
    449  1e1d		       f0 08		      beq	ParseNoneFound	; Check for end of the table -> 0
    450  1e1f		       85 52		      sta	R0	; save the next token value
    451  1e21		       c8		      iny		; Inc past token value
    452  1e22
    453  1e22				  -	      if	DEBUGPARSER
    454  1e22				  -			;    jsr DebugKeyword
    455  1e22					      endif
    456  1e22		       a6 51		      ldx	CUROFF	; Restore x to last position in the input buffer
    457  1e24		       4c bf 1d 	      jmp	ParseLookupLoop	; branch back for next key word
    458  1e27
    459  1e27				   ParseNoneFound
    460  1e27		       a6 58		      ldx	R2	; it did not find one, restore x to position in output buffer
    461  1e29		       38		      sec		; c clear, not found
    462  1e2a		       60		      rts
    463  1e2b
    464  1e2b							;===============================================================================
    465  1e2b							; Move everything from current position until the end of line into the token buffer
    466  1e2b							;
    467  1e2b		       a4 51	   ParseMoveLine ldy	CUROFF	; next byte to parse
    468  1e2d		       a6 58		      ldx	R2	; where to place in the buffer
    469  1e2f				   ParseMoveLoop
    470  1e2f		       b9 b3 42 	      lda	LINBUF,y	; get the next byte
    471  1e32		       f0 07		      beq	ParseMoveDone	; if we load a zero then done
    472  1e34		       9d 56 1c 	      sta	TOKENBUFFER,x	; save the byte
    473  1e37		       c8		      iny
    474  1e38		       e8		      inx
    475  1e39		       d0 f4		      bne	ParseMoveLoop
    476  1e3b				   ParseMoveDone
    477  1e3b		       84 51		      sty	CUROFF
    478  1e3d		       18		      clc
    479  1e3e		       60		      rts
    480  1e3f							;================================================================================================
    481  1e3f							; Add two bytes after the gosub and goto to allow the "compiler" to place mem address, to directly
    482  1e3f							; transfer to a memory address
    483  1e3f				   ParseHandleBranches
    484  1e3f		       a6 58		      ldx	R2
    485  1e41		       a9 00		      lda	#0
    486  1e43		       9d 56 1c 	      sta	TOKENBUFFER,x
    487  1e46		       e8		      inx
    488  1e47		       9d 56 1c 	      sta	TOKENBUFFER,x
    489  1e4a		       e8		      inx
    490  1e4b		       86 58		      stx	R2
    491  1e4d		       18		      clc
    492  1e4e		       60		      rts
    493  1e4f
    494  1e4f							;=========================================================================================================
    495  1e4f							;ParseString Parse a quotes string
    496  1e4f							; on input X = outbuf position
    497  1e4f							; y = inbuf position
    498  1e4f							; Copies string to output buffer, updates x and y
    499  1e4f				   ParseString
    500  1e4f		       a4 51		      ldy	CUROFF
    501  1e51		       a9 a0		      lda	#tString
    502  1e53		       9d 56 1c 	      sta	TOKENBUFFER,X
    503  1e56		       b9 b3 42 	      lda	LINBUF,y
    504  1e59		       c9 22		      cmp	#'"
    505  1e5b		       d0 1a		      bne	ParseStringInvalid
    506  1e5d		       e8		      inx
    507  1e5e		       9d 56 1c 	      sta	TOKENBUFFER,x
    508  1e61		       e8		      inx
    509  1e62		       c8		      iny
    510  1e63
    511  1e63				   ParseStringLoop
    512  1e63		       b9 b3 42 	      lda	LINBUF,y
    513  1e66		       9d 56 1c 	      sta	TOKENBUFFER,x
    514  1e69		       c9 22		      cmp	#'"
    515  1e6b		       f0 04		      beq	ParseStringDone
    516  1e6d		       c8		      iny
    517  1e6e		       e8		      inx
    518  1e6f		       d0 f2		      bne	ParseStringLoop
    519  1e71
    520  1e71				   ParseStringDone
    521  1e71		       e8		      inx
    522  1e72		       c8		      iny
    523  1e73		       84 51		      sty	CUROFF
    524  1e75		       18		      clc
    525  1e76		       60		      rts
    526  1e77
    527  1e77				   ParseStringInvalid
    528  1e77		       38		      sec
    529  1e78		       60		      rts
    530  1e79
    531  1e79							;=========================================================================================================
    532  1e79							; Get numeric values and return value in RO and type in a
    533  1e79							;
    534  1e79				   ParseNumeric
    535  1e79		       a4 51		      ldy	CUROFF
    536  1e7b		       b9 b3 42 	      lda	LINBUF,y
    537  1e7e		       c9 30		      cmp	#'0
    538  1e80		       90 33		      bcc	ParseNumInvalid
    539  1e82		       c9 3a		      cmp	#'9+1
    540  1e84		       b0 2f		      bcs	ParseNumInvalid
    541  1e86		       86 58		      stx	R2
    542  1e88		       20 fd 2a 	      jsr	getDecimal
    543  1e8b		       a6 58		      ldx	R2
    544  1e8d		       84 51		      sty	CUROFF
    545  1e8f		       a5 53		      lda	R0+1
    546  1e91		       f0 14		      beq	ParseByteValue
    547  1e93
    548  1e93				   ParseIntegerValue
    549  1e93		       a9 a4		      lda	#tInteger
    550  1e95		       9d 56 1c 	      sta	TOKENBUFFER,x
    551  1e98		       e8		      inx
    552  1e99		       a5 52		      lda	R0
    553  1e9b		       9d 56 1c 	      sta	TOKENBUFFER,x
    554  1e9e		       e8		      inx
    555  1e9f		       a5 53		      lda	R0+1
    556  1ea1		       9d 56 1c 	      sta	TOKENBUFFER,X
    557  1ea4		       e8		      inx
    558  1ea5		       18		      clc
    559  1ea6		       60		      rts
    560  1ea7
    561  1ea7				   ParseByteValue
    562  1ea7		       a9 a2		      lda	#tByte
    563  1ea9		       9d 56 1c 	      sta	TOKENBUFFER,x
    564  1eac		       e8		      inx
    565  1ead		       a5 52		      lda	R0
    566  1eaf		       9d 56 1c 	      sta	TOKENBUFFER,x
    567  1eb2		       e8		      inx
    568  1eb3		       18		      clc
    569  1eb4		       60		      rts
    570  1eb5
    571  1eb5				   ParseNumInvalid		;Not a valid Numeric
    572  1eb5		       38		      sec
    573  1eb6		       60		      rts
    574  1eb7
    575  1eb7							;=========================================================================================================
    576  1eb7							;Parse for operators and seperators
    577  1eb7							; on exit the A has the oper code, c is clear
    578  1eb7							;		 not found then c is set
    579  1eb7							;	x is preserved
    580  1eb7							;
    581  1eb7				   ParseForOperator
    582  1eb7		       86 58		      stx	R2
    583  1eb9		       a4 51		      ldy	CUROFF
    584  1ebb		       a2 00		      ldx	#0
    585  1ebd				  -	      if	DEBUGPARSER
    586  1ebd				  -			;	jsr    DebugPrintOP
    587  1ebd					      endif
    588  1ebd
    589  1ebd				   ParseOpLoop
    590  1ebd		       bd bd 1a 	      lda	Operators,x	; First byte of operator
    591  1ec0		       f0 28		      beq	ParseOpNotFound	; Last entry os 0,0
    592  1ec2
    593  1ec2		       d9 b3 42 	      cmp	LINBUF,y	; Check the first byte
    594  1ec5		       d0 1c		      bne	ParseOpNext
    595  1ec7
    596  1ec7		       c8		      iny
    597  1ec8
    598  1ec8		       bd be 1a 	      lda	Operators+1,x
    599  1ecb		       f0 06		      beq	ParseOpFoundSingle	; Single Character op
    600  1ecd
    601  1ecd		       d9 b3 42 	      cmp	LINBUF,y
    602  1ed0		       d0 11		      bne	ParseOpNext
    603  1ed2
    604  1ed2				   ParseOpFound
    605  1ed2		       c8		      iny
    606  1ed3
    607  1ed3				   ParseOpFoundSingle
    608  1ed3		       84 51		      sty	CUROFF
    609  1ed5
    610  1ed5		       8a		      txa
    611  1ed6		       4a		      lsr
    612  1ed7		       aa		      tax
    613  1ed8		       bd fb 1a 	      lda	OperValues,x
    614  1edb		       a6 58		      ldx	R2
    615  1edd		       9d 56 1c 	      sta	TOKENBUFFER,x
    616  1ee0		       e8		      inx
    617  1ee1		       18		      clc
    618  1ee2		       60		      rts
    619  1ee3
    620  1ee3				   ParseOpNext
    621  1ee3		       e8		      inx
    622  1ee4		       e8		      inx
    623  1ee5
    624  1ee5				  -	      if	DEBUGPARSER
    625  1ee5				  -			;	 jsr	DebugPrintOP
    626  1ee5					      endif
    627  1ee5		       a4 51		      ldy	CUROFF	; reset the y pointer to beginning
    628  1ee7		       4c bd 1e 	      jmp	ParseOpLoop
    629  1eea
    630  1eea				   ParseOpNotFound
    631  1eea		       a6 58		      ldx	R2
    632  1eec		       38		      sec
    633  1eed		       60		      rts
    634  1eee							;=========================================================================================================
    635  1eee				  -	      if	DEBUGPARSER
    636  1eee				  -			;Print the text of a keyword
    637  1eee				  -			;Input R1    = offset into table
    638  1eee				  -DebugKeyword
    639  1eee				  -	      tya
    640  1eee				  -	      pha
    641  1eee				  -	      ldy	#1
    642  1eee				  -DebugKeyLoop
    643  1eee				  -	      lda	(R1),y
    644  1eee				  -	      jsr	VOUTCH
    645  1eee				  -	      and	#%00100000
    646  1eee				  -	      beq	DebugKeyDone
    647  1eee				  -	      iny
    648  1eee				  -	      bne	DebugKeyLoop
    649  1eee				  -
    650  1eee				  -DebugKeyDone
    651  1eee				  -	      jsr	CRLF
    652  1eee				  -	      pla
    653  1eee				  -	      tay
    654  1eee				  -	      rts
    655  1eee				  -			;========================================
    656  1eee				  -DebugPrintOP
    657  1eee				  -	      pha
    658  1eee				  -	      lda	Operators,x
    659  1eee				  -	      jsr	VOUTCH
    660  1eee				  -	      lda	Operators+1,x
    661  1eee				  -	      beq	DbgPrtOpDone
    662  1eee				  -	      jsr	VOUTCH
    663  1eee				  -
    664  1eee				  -DbgPrtOpDone
    665  1eee				  -	      jsr	CRLF
    666  1eee				  -	      pla
    667  1eee				  -	      rts
    668  1eee				  -			;=======================================
    669  1eee				  -DebugClearBuffer
    670  1eee				  -	      txa
    671  1eee				  -	      pha
    672  1eee				  -	      ldx	#$FF
    673  1eee				  -	      lda	#0
    674  1eee				  -DebugClrLoop
    675  1eee				  -	      sta	TOKENBUFFER,x
    676  1eee				  -	      dex
    677  1eee				  -	      bne	DebugClrLoop
    678  1eee				  -	      sta	TOKENBUFFER,x
    679  1eee				  -	      pla
    680  1eee				  -	      tax
    681  1eee				  -	      rts
    682  1eee				  -
    683  1eee				  -			;=====================================================
    684  1eee				  -			; Print the parser buffer as hex values
    685  1eee				  -printTokenBuffer
    686  1eee				  -	      stx	printStorage
    687  1eee				  -	      sty	printStorage+1
    688  1eee				  -	      sta	printStorage+2
    689  1eee				  -
    690  1eee				  -	      ldx	TOKENBUFFER	; get the length of the buffer
    691  1eee				  -	      inx		; we want to show the last zero byte
    692  1eee				  -	      ldy	#0
    693  1eee				  -
    694  1eee				  -printHexLoop
    695  1eee				  -	      lda	TOKENBUFFER,y	; get the character
    696  1eee				  -	      jsr	HexToOut	; print it
    697  1eee				  -	      lda	#$20
    698  1eee				  -	      jsr	VOUTCH
    699  1eee				  -	      iny
    700  1eee				  -	      dex
    701  1eee				  -	      cpx	#0
    702  1eee				  -	      bne	printHexLoop
    703  1eee				  -	      jsr	CRLF
    704  1eee				  -
    705  1eee				  -	      ldy	printStorage+1
    706  1eee				  -	      ldx	printStorage
    707  1eee				  -	      lda	printStorage+2
    708  1eee				  -printHexDone
    709  1eee				  -	      clc
    710  1eee				  -	      rts
    711  1eee					      endif
    712  1eee
    713  1eee
    714  1eee							;=========================================================================================================
    715  1eee							; Parse for variables A-Z @, ^  x!x x[op]
    716  1eee				   ParseForVariable
    717  1eee		       a4 51		      ldy	CUROFF
    718  1ef0		       b9 b3 42 	      lda	LINBUF,y
    719  1ef3		       c9 5e		      cmp	#'^	; is it an exit code
    720  1ef5		       d0 04		      bne	ParseVarMem
    721  1ef7		       a9 9b		      lda	#tVhat	; Mark the index as 27th slot
    722  1ef9		       d0 1f		      bne	ParseVarSpecial
    723  1efb
    724  1efb				   ParseVarMem
    725  1efb		       c9 40		      cmp	#'@	; are we indirect through program end eg. @[0] ..
    726  1efd		       d0 04		      bne	ParseVarStack
    727  1eff		       a9 9d		      lda	#tVat
    728  1f01		       d0 17		      bne	ParseVarSpecial
    729  1f03
    730  1f03				   ParseVarStack
    731  1f03		       c9 23		      cmp	#'#	; Indirect var through top of stack eg. #[0]
    732  1f05		       d0 04		      bne	ParseVarLetters
    733  1f07		       a9 9c		      lda	#tVhash
    734  1f09		       d0 0f		      bne	ParseVarSpecial
    735  1f0b
    736  1f0b				   ParseVarLetters
    737  1f0b		       29 df		      and	#%11011111	; Force upper case
    738  1f0d		       c9 41		      cmp	#'A
    739  1f0f		       90 12		      bcc	ParseVarInvalid
    740  1f11		       c9 5b		      cmp	#'Z+1
    741  1f13		       b0 0e		      bcs	ParseVarInvalid
    742  1f15							;
    743  1f15							; The condition is true, so convert to an index, push
    744  1f15							; it onto the stack and continue running.
    745  1f15							;
    746  1f15		       38		      sec
    747  1f16		       e9 41		      sbc	#'A	;index is zero based
    748  1f18		       09 80		      ora	#$80
    749  1f1a
    750  1f1a				   ParseVarSpecial
    751  1f1a		       9d 56 1c 	      sta	TOKENBUFFER,x
    752  1f1d		       e8		      inx
    753  1f1e		       c8		      iny
    754  1f1f		       84 51		      sty	CUROFF
    755  1f21		       18		      clc
    756  1f22		       60		      rts
    757  1f23
    758  1f23				   ParseVarInvalid
    759  1f23		       38		      sec
    760  1f24		       60		      rts
    761  1f25
    762  1f25
    763  1f25							;=========================================================================================================
    764  1f25							; Transfer R0 to the TOKENBUFFER
    765  1f25							;
    766  1f25				   R02TOKEN
    767  1f25		       a5 52		      lda	R0
    768  1f27		       9d 56 1c 	      sta	TOKENBUFFER,x
    769  1f2a		       e8		      inx
    770  1f2b		       a5 53		      lda	R0+1
    771  1f2d		       9d 56 1c 	      sta	TOKENBUFFER,x
    772  1f30		       e8		      inx
    773  1f31		       18		      clc
    774  1f32		       60		      rts
    775  1f33							;=========================================================================
    776  1f33							; Transfer word in Token Buffer to R0
    777  1f33				   TOKEN2R0
    778  1f33		       b9 56 1c 	      lda	TOKENBUFFER,y
    779  1f36		       85 52		      sta	R0
    780  1f38		       c8		      iny
    781  1f39		       ca		      dex
    782  1f3a		       b9 56 1c 	      lda	TOKENBUFFER,y
    783  1f3d		       c8		      iny
    784  1f3e		       ca		      dex
    785  1f3f		       85 53		      sta	R0+1
    786  1f41		       60		      rts
    787  1f42							;==========================================================================
    788  1f42							; Transfer	Display Buffer position to R0
    789  1f42							;
    790  1f42				   DPL2R0
    791  1f42		       b1 59		      lda	(dpl),y
    792  1f44		       85 52		      sta	R0
    793  1f46		       c8		      iny
    794  1f47		       ca		      dex
    795  1f48		       b1 59		      lda	(dpl),y
    796  1f4a		       c8		      iny
    797  1f4b		       ca		      dex
    798  1f4c		       85 53		      sta	R0+1
    799  1f4e		       60		      rts
    800  1f4f
    801  1f4f
    802  1f4f							;=========================================================================
    803  1f4f							; Read an IL byte lookit up in the table, of words
    804  1f4f							; set the next ilpc to point to that address
    805  1f4f							; if not found then do ussual filter stuff
    806  1f4f							; ongoto ilvectortable, not found address
    807  1f4f		       20 4e 2a    iOnGoto    jsr	getILWord	; places the word into r0, pointer to table
    808  1f52		       86 52		      stx	R0
    809  1f54		       85 53		      sta	R0+1
    810  1f56
    811  1f56		       a4 51		      ldy	CUROFF
    812  1f58		       b1 4f		      lda	(CURPTR),y	; get the operation byte
    813  1f5a		       a0 00		      ldy	#0
    814  1f5c		       38		      sec
    815  1f5d		       f1 52		      sbc	(R0),y	; Subract the base value
    816  1f5f		       c8		      iny
    817  1f60		       d1 52		      cmp	(R0),y	; Check if we are in range
    818  1f62		       b0 12		      bcs	iOnGotoInvalid
    819  1f64		       e6 51		      inc	CUROFF	; Save the offset
    820  1f66
    821  1f66		       0a		      asl
    822  1f67		       a8		      tay		; Turn into vector
    823  1f68		       c8		      iny		; Inc must include the table base and entry count
    824  1f69		       c8		      iny
    825  1f6a
    826  1f6a		       b1 52		      lda	(R0),y
    827  1f6c		       85 43		      sta	ILPC
    828  1f6e		       c8		      iny
    829  1f6f		       b1 52		      lda	(R0),y
    830  1f71		       85 44		      sta	ILPC+1
    831  1f73		       4c b1 02 	      jmp	NextIL
    832  1f76
    833  1f76				   iOnGotoInvalid
    834  1f76		       20 4e 2a 	      jsr	getILWord
    835  1f79		       86 43		      stx	ILPC
    836  1f7b		       85 44		      sta	ILPC+1
    837  1f7d		       4c b1 02 	      jmp	NextIL
    838  1f80							;
    839  1f80							;==========================================================================================
    840  1f80							; Test the token for relop and push the value onto the stack if true
    841  1f80							;
    842  1f80				   iTSTRELOP
    843  1f80		       20 52 2a 	      jsr	getILByte
    844  1f83		       8d 48 43 	      sta	offset
    845  1f86
    846  1f86		       a4 51		      ldy	CUROFF
    847  1f88		       b1 4f		      lda	(CURPTR),y
    848  1f8a		       48		      pha
    849  1f8b		       29 f0		      and	#$F0
    850  1f8d		       c9 f0		      cmp	#$F0
    851  1f8f		       d0 12		      bne	iTSTRELOPNOT
    852  1f91		       68		      pla
    853  1f92		       29 0f		      and	#$0F	; get the actual value
    854  1f94		       85 52		      sta	R0	; save it for later
    855  1f96		       a9 00		      lda	#0
    856  1f98		       85 53		      sta	R0+1
    857  1f9a		       20 4b 2c 	      jsr	pushR0
    858  1f9d		       c8		      iny
    859  1f9e		       84 51		      sty	CUROFF	; save the y pointer
    860  1fa0		       4c b1 02 	      jmp	NextIL
    861  1fa3
    862  1fa3				   iTSTRELOPNOT
    863  1fa3		       68		      pla
    864  1fa4		       4c e0 0b 	      jmp	tstBranch
    865  1fa7
    866  1fa7							;
    867  1fa7							;===================================================================================================
    868  1fa7							; Test the token and following info for precompiled address information
    869  1fa7							; skip it if zero, transfer and skip next integer value if not zero
    870  1fa7							; used by both gosub, goto and gofN
    871  1fa7							;
    872  1fa7				   iTSTBRANCH		; il format TSTBRANCH whereToGoIfFailed
    873  1fa7		       20 52 2a 	      jsr	getILByte	; Get jump address if vector is valid
    874  1faa		       8d 48 43 	      sta	offset	; Mark offset for later if vector found
    875  1fad		       a4 51		      ldy	CUROFF	; get offset of first byte of compiled value
    876  1faf		       88		      dey		; point back to the type of branch
    877  1fb0		       b1 4f		      lda	(CURPTR),y	; get the actual instructions
    878  1fb2		       48		      pha		; Save till needed
    879  1fb3		       c8		      iny		; back to memory vectors
    880  1fb4				   ITSTBRANCHCont
    881  1fb4		       b1 4f		      lda	(CURPTR),y	; Get first byte of compiled value
    882  1fb6		       85 52		      sta	R0	; R0 will contain mem pointer of present
    883  1fb8		       c8		      iny		; Point to next byte of mem vector
    884  1fb9		       b1 4f		      lda	(CURPTR),y	; It was compiled so get the hi byte value
    885  1fbb		       85 53		      sta	R0+1	; Move it into R0, R0 now contains vector address
    886  1fbd		       c8		      iny		; Point to the byte past memory vector
    887  1fbe		       84 51		      sty	CUROFF	; At least point past the memory vector built in
    888  1fc0
    889  1fc0		       05 52		      ora	R0	; Get the second byte of the mem
    890  1fc2		       f0 28		      BEQ	iTSTBRANCHNoCompile	; If both are zero then not compiled
    891  1fc4		       68		      pla
    892  1fc5		       c9 07		      cmp	#kGoto	; Short cut lots if a goto stuff
    893  1fc7		       d0 03		      bne	NotGoto
    894  1fc9		       4c dc 04 	      jmp	FastFastXfer
    895  1fcc				   NotGoto
    896  1fcc		       c9 2f		      cmp	#kTask	; Task defined with Task() so bypass the first bracket
    897  1fce		       d0 07		      bne	iTSTBRANCHCont
    898  1fd0		       b1 4f		      lda	(CURPTR),y
    899  1fd2		       c9 e0		      cmp	#oLeftBracket
    900  1fd4		       d0 17		      bne	iTSTBRANCHErr	; Well in that case something is very wrong
    901  1fd6		       c8		      iny		; Increment past the bracket
    902  1fd7				   iTSTBRANCHCont
    903  1fd7		       b1 4f		      lda	(CURPTR),y	; We should get a datatype, if not memvector is invalid
    904  1fd9		       c9 a2		      cmp	#tByte	; A byte value is valid
    905  1fdb		       f0 05		      beq	ITSTBRANCHBYTE	; Skip the byte
    906  1fdd		       c9 a4		      cmp	#tInteger	; An integer value is valid
    907  1fdf		       d0 0c		      bne	iTSTBRANCHErr	; If not then we can not use the memory vector
    908  1fe1		       c8		      iny		; skip type indicator for
    909  1fe2				   ITSTBRANCHBYTE
    910  1fe2		       c8		      iny		; skip first byte of value line number
    911  1fe3		       c8		      iny		; Skip second byte of line number
    912  1fe4
    913  1fe4				   iTSTBRANCHVALID
    914  1fe4		       84 51		      sty	CUROFF
    915  1fe6		       20 4b 2c 	      jsr	pushR0	; place transfer address on top of stack
    916  1fe9		       4c e0 0b 	      jmp	tstBranch
    917  1fec
    918  1fec				   iTSTBRANCHNoCompile
    919  1fec		       68		      pla
    920  1fed				   iTSTBRANCHErr
    921  1fed		       4c b1 02 	      jmp	NextIL
    922  1ff0
    923  1ff0
    924  1ff0
    925  1ff0
    926  1ff0
    927  1ff0
    928  1ff0
    929  1ff0
    930  1ff0
    931  1ff0
------- FILE mytb.asm
------- FILE compile.asm LEVEL 2 PASS 6
      0  1ff0					      include	"compile.asm"
      1  1ff0					      Seg	Code
      2  1ff0							;
      3  1ff0							;=====================================================================
      4  1ff0							; Scan the loaded program just before running and insert memory locations of each
      5  1ff0							; line number branched to. goto 100, gosub 100, fn10(), task(100)
      6  1ff0							; These have the format  in memory  example 81{key word token} 0000{pointer to memory location} A1{number type} 92 00{byte or integer value line number value}
      7  1ff0							; goto 100   : 07 0000 A2 64			 the tokenizer optimizes the literal values to byte or int depending on value
      8  1ff0							; gosub 1000 : 08 0000 A4 E803
      9  1ff0							; fn 100()   ; 37 0000 A2 64 40 41
     10  1ff0							; task(1000) : 2F 0000 40 A4 E803 41
     11  1ff0				   Compile
     12  1ff0		       a9 00		      lda	#0
     13  1ff2		       85 52		      sta	R0	; keep track of how many errors we find
     14  1ff4		       a5 5b		      lda	RunMode
     15  1ff6		       48		      pha
     16  1ff7		       e6 5b		      inc	RunMode	; force run mode for error reporting
     17  1ff9		       a5 4f		      lda	CURPTR
     18  1ffb		       48		      pha
     19  1ffc		       a5 50		      lda	CURPTR+1
     20  1ffe		       48		      pha
     21  1fff		       a5 51		      lda	CUROFF
     22  2001		       48		      pha
     23  2002		       ad 50 43 	      lda	ProgramStart
     24  2005		       85 59		      sta	dpl
     25  2007		       ad 51 43 	      lda	ProgramStart+1
     26  200a		       85 5a		      sta	dpl+1
     27  200c
     28  200c				   CompileLineStart
     29  200c		       a5 59		      lda	dpl
     30  200e		       cd 52 43 	      cmp	ProgramEnd
     31  2011		       d0 07		      bne	CompileContinue
     32  2013		       a5 5a		      lda	dpl+1
     33  2015		       cd 53 43 	      cmp	ProgramEnd+1
     34  2018		       f0 3f		      beq	CompileComplete
     35  201a
     36  201a				   CompileContinue
     37  201a		       a0 03		      ldy	#3	; first real character in the line
     38  201c
     39  201c				   CompileLoop
     40  201c		       b1 59		      lda	(dpl),y	; get the byte
     41  201e		       f0 27		      beq	CompileEndOfLine	; End of line, so goto next line for scan
     42  2020		       c8		      iny		; Pass this byte
     43  2021		       c9 07		      cmp	#kGoto
     44  2023		       f0 58		      beq	CompileField	; Will update the memory address and move pointer to next value
     45  2025		       c9 08		      cmp	#kGosub
     46  2027		       f0 54		      beq	CompileField	; Will update the memory address and move pointer to next value
     47  2029		       c9 37		      cmp	#kGofn
     48  202b		       f0 50		      beq	CompileField	; Will update the memory address and move pointer to next value
     49  202d		       c9 2f		      cmp	#kTask
     50  202f		       f0 4c		      beq	CompileField
     51  2031		       c9 0a		      cmp	#kRem
     52  2033		       f0 12		      beq	CompileRem	; Skip until end of line
     53  2035		       c9 a0		      cmp	#tString
     54  2037		       f0 2f		      beq	CompileString
     55  2039		       c9 a4		      cmp	#tInteger
     56  203b		       f0 06		      beq	CompileInteger
     57  203d		       c9 a2		      cmp	#tByte
     58  203f		       f0 03		      beq	CompileByte
     59  2041		       d0 d9		      bne	CompileLoop	; Next character
     60  2043
     61  2043				   CompileInteger
     62  2043		       c8		      iny
     63  2044				   CompileByte
     64  2044		       c8		      iny
     65  2045		       d0 d5		      bne	CompileLoop
     66  2047				   CompileRem
     67  2047				   CompileEndOfLine
     68  2047		       a0 00		      ldy	#0
     69  2049		       b1 59		      lda	(dpl),y
     70  204b		       18		      clc
     71  204c		       65 59		      adc	dpl
     72  204e		       85 59		      sta	dpl
     73  2050		       a9 00		      lda	#0
     74  2052		       65 5a		      adc	dpl+1
     75  2054		       85 5a		      sta	dpl+1
     76  2056
     77  2056		       4c 0c 20 	      jmp	CompileLineStart
     78  2059
     79  2059				   CompileComplete
     80  2059		       68		      pla
     81  205a		       85 51		      sta	CUROFF
     82  205c		       68		      pla
     83  205d		       85 50		      sta	CURPTR+1
     84  205f		       68		      pla
     85  2060		       85 4f		      sta	CURPTR
     86  2062		       68		      pla
     87  2063		       85 5b		      sta	RunMode
     88  2065		       a5 52		      lda	R0	; returning the number of errors
     89  2067		       60		      rts
     90  2068
     91  2068
     92  2068				   CompileString
     93  2068		       c8		      iny		; point past first "
     94  2069				   CompileStringLoop
     95  2069		       b1 59		      lda	(dpl),y
     96  206b		       f0 0d		      beq	CompileStrDone2	; end of line
     97  206d		       c9 22		      cmp	#'"	; end of string
     98  206f		       f0 08		      beq	CompileStrDone
     99  2071		       c9 5c		      cmp	#'\	; escape character
    100  2073		       d0 01		      bne	CompileStrNext
    101  2075		       c8		      iny		; skip the escape character
    102  2076				   CompileStrNext
    103  2076		       c8		      iny		; Next character
    104  2077		       d0 f0		      bne	CompileStringLoop	; test for end
    105  2079				   CompileStrDone
    106  2079		       c8		      iny
    107  207a				   CompileStrDone2
    108  207a		       4c 1c 20 	      Jmp	CompileLoop
    109  207d							;
    110  207d							;===============================================================
    111  207d							; on entry y points to storage location y+2 points to line number
    112  207d							; on exit y points to line number type
    113  207d
    114  207d		       85 52	   CompileField sta	R0
    115  207f		       98		      tya		; save the y pointer to store the memory value
    116  2080		       48		      pha
    117  2081		       c8		      iny		; Skip over the memory vector
    118  2082		       c8		      iny
    119  2083		       a5 52		      lda	R0
    120  2085		       c9 2f		      cmp	#kTask	; for a task it is the next byte after a bracket
    121  2087		       d0 07		      bne	CompNoBracket
    122  2089
    123  2089		       b1 59		      lda	(dpl),y	; Lets make sure it is a (
    124  208b		       c9 e0		      cmp	#oLeftBracket
    125  208d		       d0 01		      bne	CompNoBracket	; in case of error
    126  208f		       c8		      iny		; skip the bracket
    127  2090
    128  2090				   CompNoBracket
    129  2090		       a9 00		      lda	#0	; In case the value is a byte
    130  2092		       85 53		      sta	R0+1
    131  2094
    132  2094		       b1 59		      lda	(dpl),Y	; get the type of the next byte txxx something or other
    133  2096		       c9 a2		      cmp	#tByte
    134  2098		       f0 15		      beq	CompByteLoad
    135  209a		       c9 a4		      cmp	#tInteger
    136  209c		       f0 04		      beq	CompIntLoad	; If it is not a number then get out of here
    137  209e		       68		      pla
    138  209f		       4c 1c 20 	      jmp	CompileLoop	; Ignore the saved stack
    139  20a2				   CompIntLoad
    140  20a2		       c8		      iny
    141  20a3		       b1 59		      lda	(dpl),y
    142  20a5		       85 52		      sta	R0
    143  20a7		       c8		      iny
    144  20a8		       b1 59		      lda	(dpl),y
    145  20aa		       85 53		      sta	R0+1
    146  20ac		       4c b4 20 	      jmp	CompFindLine
    147  20af				   CompByteLoad
    148  20af		       c8		      iny
    149  20b0		       b1 59		      lda	(dpl),y
    150  20b2		       85 52		      sta	R0
    151  20b4				   CompFindLine
    152  20b4		       20 97 2a 	      jsr	findLine
    153  20b7		       f0 1d		      beq	CompFoundLine
    154  20b9		       e6 52		      inc	R0	; number of errors
    155  20bb
    156  20bb		       a5 59		      lda	dpl
    157  20bd		       85 4f		      sta	CURPTR
    158  20bf		       a5 5a		      lda	dpl+1
    159  20c1		       85 50		      sta	CURPTR+1
    160  20c3		       84 51		      sty	CUROFF
    161  20c5
    162  20c5		       a2 14		      ldx	#ERR_LINE_NOT_FOUND
    163  20c7		       a9 00		      lda	#0
    164  20c9
    165  20c9		       20 27 06 	      jsr	DisplayError
    166  20cc		       20 4e 22 	      jsr	PrintProgramLine
    167  20cf
    168  20cf		       68		      pla
    169  20d0		       a8		      tay
    170  20d1		       c8		      iny
    171  20d2		       c8		      iny
    172  20d3		       4c 1c 20 	      jmp	CompileLoop
    173  20d6
    174  20d6				   CompFoundLine
    175  20d6		       68		      pla
    176  20d7		       a8		      tay
    177  20d8		       a5 4f		      lda	CURPTR
    178  20da		       91 59		      sta	(dpl),y
    179  20dc		       c8		      iny
    180  20dd		       a5 50		      lda	CURPTR+1
    181  20df		       91 59		      sta	(dpl),y
    182  20e1		       c8		      iny
    183  20e2		       4c 1c 20 	      jmp	CompileLoop
    184  20e5
    185  20e5
    186  20e5
    187  20e5
    188  20e5
    189  20e5
    190  20e5
    191  20e5
    192  20e5
    193  20e5
    194  20e5
    195  20e5
    196  20e5
    197  20e5
    198  20e5
    199  20e5
    200  20e5
    201  20e5
    202  20e5
    203  20e5
    204  20e5
    205  20e5
    206  20e5
    207  20e5
    208  20e5
    209  20e5
    210  20e5
    211  20e5
    212  20e5
    213  20e5
    214  20e5
    215  20e5
    216  20e5
    217  20e5
    218  20e5
    219  20e5
    220  20e5
    221  20e5
    222  20e5
    223  20e5
    224  20e5
------- FILE mytb.asm
------- FILE print.asm LEVEL 2 PASS 6
      0  20e5					      include	"print.asm"
      1  20e5					      Seg	Code
      2  20e5							;---------------------------
      3  20e5							; Print 24-bit decimal number or  16bit unsigned
      4  20e5							; ---------------------------
      5  20e5							; On entry, R0=number to print
      6  20e5							;	     Defaults to pad=0 , y=21 default
      7  20e5							;	     R2 = 1 unsigned 16 bit
      8  20e5							;	     R2 = 0 Signed   16 bit
      9  20e5
     10  20e5							; On entry at PrintDecPadded:
     11  20e5							;	     X = padding, Y=(number of digits)*3-3, eg 21 for 8 digits
     12  20e5
     13  20e5							; On exit,  A,X,Y,num,pad corrupted
     14  20e5							; Size      129 bytes, Table 24 bytes	--- total 153
     15  20e5							; -----------------------------------------------------------------
     16  20e5
     17  20e5				   PrintDecimal
     18  20e5		       8a		      TXA
     19  20e6		       48		      pha
     20  20e7		       98		      tya
     21  20e8		       48		      pha
     22  20e9		       a9 00		      lda	#0
     23  20eb		       8d 80 21 	      sta	pad
     24  20ee		       a0 15		      LDY	#21	; Offset to powers of ten
     25  20f0		       4c f6 20 	      JMP	PrintDo
     26  20f3
     27  20f3				   PrintDecPadded
     28  20f3		       8e 80 21 	      stx	pad
     29  20f6
     30  20f6				   PrintDo
     31  20f6		       a9 00		      lda	#0
     32  20f8		       85 54		      sta	R1
     33  20fa
     34  20fa		       a5 58		      lda	R2
     35  20fc		       c9 a9		      cmp	#tUint
     36  20fe		       f0 29		      beq	PrintPos
     37  2100
     38  2100		       a5 53		      lda	R0+1	;MSB has sign
     39  2102		       10 25		      bpl	PrintPos	;it's a positive number;
     40  2104
     41  2104
     42  2104							; Negative numbers need more work.  Invert all the bits,
     43  2104							; then add one.
     44  2104
     45  2104		       a9 2d		      lda	#'-
     46  2106		       20 5e 1a 	      jsr	VOUTCH	;print the negative sign
     47  2109
     48  2109		       a9 ff		      lda	#$FF
     49  210b		       85 54		      sta	R1
     50  210d		       a5 52		      lda	R0	;invert bits
     51  210f		       49 ff		      eor	#$ff
     52  2111		       85 52		      sta	R0
     53  2113		       a5 53		      lda	R0+1
     54  2115		       49 ff		      eor	#$ff
     55  2117		       85 53		      sta	R0+1
     56  2119		       a5 54		      lda	R1
     57  211b		       49 ff		      eor	#$ff
     58  211d		       85 54		      sta	R1
     59  211f		       e6 52		      inc	R0	;add one
     60  2121		       d0 06		      bne	PrintPos
     61  2123		       e6 53		      inc	R0+1
     62  2125		       d0 02		      bne	PrintPos
     63  2127		       e6 54		      inc	R1
     64  2129				   PrintPos
     65  2129
     66  2129				   PrDec24Lp1
     67  2129		       a2 ff		      LDX	#$FF
     68  212b		       38		      SEC		; Start with digit=-1
     69  212c				   PrDec24Lp2
     70  212c		       a5 52		      LDA	R0+0
     71  212e		       f9 81 21 	      SBC	PrDec24Tens+0,Y
     72  2131		       85 52		      STA	R0+0	; Subtract current tens
     73  2133		       a5 53		      LDA	R0+1
     74  2135		       f9 82 21 	      SBC	PrDec24Tens+1,Y
     75  2138		       85 53		      STA	R0+1
     76  213a		       a5 54		      LDA	R0+2
     77  213c		       f9 83 21 	      SBC	PrDec24Tens+2,Y
     78  213f		       85 54		      STA	R0+2
     79  2141		       e8		      INX
     80  2142		       b0 e8		      BCS	PrDec24Lp2	; Loop until <0
     81  2144		       a5 52		      LDA	R0+0
     82  2146		       79 81 21 	      ADC	PrDec24Tens+0,Y
     83  2149		       85 52		      STA	R0+0	; Add current tens back in
     84  214b		       a5 53		      LDA	R0+1
     85  214d		       79 82 21 	      ADC	PrDec24Tens+1,Y
     86  2150		       85 53		      STA	R0+1
     87  2152		       a5 54		      LDA	R0+2
     88  2154		       79 83 21 	      ADC	PrDec24Tens+2,Y
     89  2157		       85 54		      STA	R0+2
     90  2159		       8a		      TXA
     91  215a		       d0 07		      BNE	PrDec24Digit	; Not zero, print it
     92  215c		       ad 80 21 	      LDA	pad
     93  215f		       d0 09		      BNE	PrDec24Print
     94  2161		       f0 0a		      BEQ	PrDec24Next	; pad<>0, use it
     95  2163				   PrDec24Digit
     96  2163		       a2 30		      LDX	#'0
     97  2165		       8e 80 21 	      STX	pad	; No more zero padding
     98  2168		       09 30		      ORA	#'0	; Print this digit
     99  216a				   PrDec24Print
    100  216a		       20 5e 1a 	      JSR	VOUTCH
    101  216d				   PrDec24Next
    102  216d		       88		      DEY
    103  216e		       88		      DEY
    104  216f		       88		      DEY
    105  2170		       f0 07		      beq	PrDec24LastDigit
    106  2172		       10 b5		      BPL	PrDec24Lp1	; Loop for next digit
    107  2174		       68		      pla
    108  2175		       a8		      tay
    109  2176		       68		      pla
    110  2177		       aa		      tax
    111  2178		       60		      RTS
    112  2179				   PrDec24LastDigit
    113  2179		       a2 30		      LDX	#'0
    114  217b		       8e 80 21 	      STX	pad	; No more zero padding
    115  217e		       d0 a9		      BNE	PrDec24Lp1	; Loop for last digit
    116  2180
      0  2180				   pad	      db	0
      1  2180		       00		      .byte.b	0
    118  2181
    119  2181				   PrDec24Tens
      0  2181					      dw	1
      1  2181		       01 00		      .word.w	1
      0  2183					      db	(1 / 65536)
      1  2183		       00		      .byte.b	(1 / 65536)
      0  2184					      dw	10
      1  2184		       0a 00		      .word.w	10
      0  2186					      db	(10 / 65536)
      1  2186		       00		      .byte.b	(10 / 65536)
      0  2187					      dw	100
      1  2187		       64 00		      .word.w	100
      0  2189					      db	(100 / 65536)
      1  2189		       00		      .byte.b	(100 / 65536)
      0  218a					      dw	1000
      1  218a		       e8 03		      .word.w	1000
      0  218c					      db	(1000 / 65536)
      1  218c		       00		      .byte.b	(1000 / 65536)
      0  218d					      dw	10000
      1  218d		       10 27		      .word.w	10000
      0  218f					      db	(10000 / 65536)
      1  218f		       00		      .byte.b	(10000 / 65536)
      0  2190					      dw	100000
      1  2190		       a0 86		      .word.w	100000
      0  2192					      db	(100000 / 65536)
      1  2192		       01		      .byte.b	(100000 / 65536)
      0  2193					      dw	1000000
      1  2193		       40 42		      .word.w	1000000
      0  2195					      db	(1000000 / 65536)
      1  2195		       0f		      .byte.b	(1000000 / 65536)
      0  2196					      dw	10000000
      1  2196		       80 96		      .word.w	10000000
      0  2198					      db	(10000000 / 65536)
      1  2198		       98		      .byte.b	(10000000 / 65536)
    136  2199							;=====================================================
    137  2199							; Print character in A as two hex digits to the Console
    138  2199
    139  2199		       48	   HexToOut   pha		;save return value
    140  219a		       48		      pha
    141  219b		       4a		      lsr		;a  ;move top nibble to bottom
    142  219c		       4a		      lsr		;a
    143  219d		       4a		      lsr		;a
    144  219e		       4a		      lsr		;a
    145  219f		       20 a8 21 	      jsr	hexta	;output nibble
    146  21a2		       68		      pla
    147  21a3		       20 a8 21 	      jsr	hexta
    148  21a6		       68		      pla		;restore
    149  21a7		       60		      rts
    150  21a8							;
    151  21a8		       29 0f	   hexta      and	#%0001111
    152  21aa		       c9 0a		      cmp	#$0a
    153  21ac		       18		      clc
    154  21ad		       30 02		      bmi	hexta1
    155  21af		       69 07		      adc	#7
    156  21b1		       69 30	   hexta1     adc	#'0	;then fall into...
    157  21b3		       4c 5e 1a 	      jmp	VOUTCH
    158  21b6							;
    159  21b6							;=====================================================
    160  21b6							; Print the string that immediately follows the JSR to
    161  21b6							; this function.  Stops when a null byte is found,
    162  21b6							; then returns to the instruction immediately
    163  21b6							; following the null.
    164  21b6							;
    165  21b6							; Thanks to Ross Archer for this code.
    166  21b6							; http://www.6502.org/source/io/primm.htm
    167  21b6							;
    168  21b6
    169  21b6		       68	   tbputs     pla		;Get the low part of "return" address
    170  21b7							;(data start address)
    171  21b7		       85 5e		      sta	PrtFrom
    172  21b9		       68		      pla
    173  21ba		       85 5f		      sta	PrtFrom+1	;Get the high part of "return" address
    174  21bc							;(data start address)
    175  21bc							;Note: actually we're pointing one short
    176  21bc		       a0 01	   PSINB      ldy	#1
    177  21be		       b1 5e		      lda	(PrtFrom),y	;Get the next string character
    178  21c0		       e6 5e		      inc	PrtFrom	;update the pointer
    179  21c2		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
    180  21c4		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    181  21c6		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
    182  21c8							;   Accumulator
    183  21c8		       f0 06		      beq	PSIX1	;don't print the final NULL
    184  21ca		       20 5e 1a 	      jsr	VOUTCH	;write it out
    185  21cd		       4c bc 21 	      jmp	PSINB	;back around
    186  21d0		       e6 5e	   PSIX1      inc	PrtFrom
    187  21d2		       d0 02		      bne	PSIX2
    188  21d4		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    189  21d6		       6c 5e 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
    190  21d9
    191  21d9							;+
    192  21d9							;====================================================
    193  21d9		       43 44	   PrtTerm    equ	tempy
    194  21d9
    195  21d9							; on exit Print Y has the offset to use
    196  21d9							; input y =	 addr low
    197  21d9							;	 x =	 addr high
    198  21d9							;	 a =	 termination string
    199  21d9
    200  21d9
    201  21d9				   PrtQuoted		; Print a quoted string from the current program space
    202  21d9		       a9 22		      lda	#'"
    203  21db		       a4 51		      ldy	CUROFF
    204  21dd		       d1 4f		      cmp	(CURPTR),y	; the opening quote, can to " or ' so long as they match
    205  21df		       d0 03		      bne	PrtNoInc
    206  21e1		       c8		      iny
    207  21e2		       84 51		      sty	CUROFF
    208  21e4				   PrtNoInc
    209  21e4		       8d 44 43 	      sta	PrtTerm
    210  21e7
    211  21e7				   PrtPrgString 		; Print a terminated string from the static program space
    212  21e7		       a4 51		      ldy	CUROFF
    213  21e9		       a5 4f		      lda	CURPTR
    214  21eb		       85 5e		      sta	PrtFrom
    215  21ed		       a5 50		      lda	CURPTR+1
    216  21ef		       85 5f		      sta	PrtFrom+1
    217  21f1		       4c fd 21 	      jmp	PrtLoop
    218  21f4
    219  21f4							; Print a string pointed to by x= h, y=l terminated by value in  accumulator
    220  21f4							; Return y as the length
    221  21f4
    222  21f4		       86 5f	   PrtStr     stx	PrtFrom+1
    223  21f6		       84 5e		      sty	PrtFrom
    224  21f8		       8d 44 43 	      sta	PrtTerm
    225  21fb		       a0 00		      ldy	#0
    226  21fd							;
    227  21fd							; On entry here ptrfrom and prtterm point to area to print
    228  21fd							;
    229  21fd		       b1 5e	   PrtLoop    lda	(PrtFrom),y
    230  21ff		       cd 44 43 	      cmp	PrtTerm
    231  2202		       f0 0b		      beq	PrtEnd
    232  2204		       c9 00		      cmp	#0	; always end if 0 is found
    233  2206		       f0 07		      beq	PrtEnd
    234  2208		       20 5e 1a 	      jsr	VOUTCH
    235  220b		       c8		      iny
    236  220c		       4c fd 21 	      jmp	PrtLoop
    237  220f		       c8	   PrtEnd     iny		;return byte after the write
    238  2210		       60		      rts
    239  2211
    240  2211							;
    241  2211							;=======================================================
    242  2211							; Print all Variables
    243  2211				   PrintAllVars
    244  2211		       a0 00		      ldy	#0
    245  2213		       a9 41		      lda	#'A
    246  2215				   PrintAllVarsLoop
    247  2215		       48		      pha
    248  2216		       b1 41		      lda	(VARIABLES),y
    249  2218		       85 52		      sta	R0
    250  221a		       c8		      iny
    251  221b		       b1 41		      lda	(VARIABLES),y
    252  221d		       85 53		      sta	R0+1
    253  221f
    254  221f		       68		      pla		;get the current letter
    255  2220		       48		      pha
    256  2221		       20 5e 1a 	      jsr	VOUTCH
    257  2224		       20 b6 21 	      jsr	puts
      0  2227					      db	"=",0
      1  2227		       3d 00		      .byte.b	"=",0
    259  2229		       68		      pla
    260  222a		       aa		      tax
    261  222b		       e8		      inx
    262  222c		       8a		      txa
    263  222d		       48		      pha		;
    264  222e
    265  222e		       98		      tya
    266  222f		       48		      pha
    267  2230		       20 e5 20 	      jsr	PrintDecimal
    268  2233		       20 b6 21 	      jsr	puts
      0  2236					      db	" ",0
      1  2236		       20 00		      .byte.b	" ",0
    270  2238		       68		      pla
    271  2239		       a8		      tay
    272  223a		       c8		      iny
    273  223b		       c0 34		      cpy	#26<<1	; A-Z 2 bytes each
    274  223d		       90 d6		      bcc	PrintAllVarsLoop
    275  223f		       20 96 2d 	      jsr	CRLF
    276  2242
    277  2242		       68		      pla
    278  2243		       60		      rts
    279  2244							;==========================================================================================================
    280  2244							;Debug   Print a Program Line from compile buffer
    281  2244							;
    282  2244				   DebugPrintProgramLine
    283  2244		       48		      pha
    284  2245		       a9 56		      lda	#TOKENBUFFER&$FF
    285  2247		       85 59		      sta	dpl
    286  2249		       a9 1c		      lda	#TOKENBUFFER>>8
    287  224b		       85 5a		      sta	dpl+1
    288  224d		       68		      pla
    289  224e
    290  224e							; Decode and print a line of program text
    291  224e							; on entry	 dpl points to line of code to print
    292  224e							; on exit	 no change in reg or dpl
    293  224e							;
    294  224e				   PrintProgramLine
    295  224e
    296  224e		       8e 56 1d 	      stx	printStorage
    297  2251		       8c 57 1d 	      sty	printStorage+1
    298  2254		       48		      pha
    299  2255
    300  2255		       a0 01		      ldy	#1	; index into the token buffer
    301  2257		       84 58		      sty	R2	; print unsigned decimal
    302  2259		       a0 00		      ldy	#0
    303  225b		       b1 59		      lda	(dpl),y	; get number of bytes
    304  225d		       aa		      tax		; place pointer into x
    305  225e		       c8		      iny
    306  225f		       ca		      dex		; Deduct the length byte
    307  2260		       20 42 1f 	      jsr	DPL2R0	; Print the line number
    308  2263		       20 e5 20 	      jsr	PrintDecimal
    309  2266		       a9 20		      lda	#$20
    310  2268		       20 5e 1a 	      jsr	VOUTCH
    311  226b
    312  226b				   PrintProgLoop
    313  226b		       b1 59		      lda	(dpl),y	; Get a character
    314  226d		       f0 4a		      beq	PrintProgramComplete	; If zero then at end of line
    315  226f		       29 80		      and	#%10000000	; check for Keyword or Variable/operator
    316  2271		       f0 76		      beq	PrintKeyword	; It uses the index in a to find a keyword
    317  2273
    318  2273				   PrintProgVars
    319  2273		       b1 59		      lda	(dpl),y
    320  2275		       29 e0		      and	#$E0	; Check for operators and punctuation
    321  2277		       c9 e0		      cmp	#$E0
    322  2279		       f0 6b		      beq	PrintProgOperatorVect
    323  227b
    324  227b		       b1 59		      lda	(dpl),y	; Get char back again and check for var
    325  227d		       c9 9e		      cmp	#$9D+1
    326  227f		       90 62		      bcc	PrintProgVariableVec
    327  2281		       29 a0		      and	#$A0	; Check for a valid datatype
    328  2283		       c9 a0		      cmp	#$A0
    329  2285		       f0 06		      beq	PrintDataType	; if not just print the character
    330  2287		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    331  2289		       ca		      dex		; Ok we are processing it
    332  228a		       c8		      iny
    333  228b		       d0 25		      bne	PrintContinue	; Print and do the next character
    334  228d
    335  228d				   PrintDataType
    336  228d		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    337  228f		       c9 a0		      cmp	#tString
    338  2291		       f0 31		      beq	PrintStringVariable
    339  2293
    340  2293				   PrintProgNumber
    341  2293		       c8		      iny		; we have a numerical integer value
    342  2294		       ca		      dex
    343  2295		       48		      pha
    344  2296		       a9 00		      lda	#0
    345  2298		       85 53		      sta	R0+1
    346  229a		       85 58		      sta	R2	; Set to print signed number
    347  229c		       b1 59		      lda	(dpl),y
    348  229e		       85 52		      sta	R0
    349  22a0		       68		      pla
    350  22a1		       c9 a4		      cmp	#tInteger
    351  22a3		       d0 06		      bne	PrintProgNumDone
    352  22a5		       c8		      iny
    353  22a6		       ca		      dex
    354  22a7		       b1 59		      lda	(dpl),y
    355  22a9		       85 53		      sta	R0+1
    356  22ab
    357  22ab				   PrintProgNumDone
    358  22ab		       c8		      iny
    359  22ac		       ca		      dex
    360  22ad		       20 e5 20 	      jsr	PrintDecimal
    361  22b0
    362  22b0				   PrintProgNext
    363  22b0		       a9 20		      lda	#$20
    364  22b2				   PrintContinue
    365  22b2		       20 5e 1a 	      jsr	VOUTCH
    366  22b5				   PrintProgSkipSpace
    367  22b5		       e0 00		      cpx	#0
    368  22b7		       d0 b2		      bne	PrintProgLoop
    369  22b9				   PrintProgramComplete
    370  22b9		       20 96 2d 	      jsr	CRLF
    371  22bc
    372  22bc		       ae 56 1d 	      ldx	printStorage
    373  22bf		       ac 57 1d 	      ldy	printStorage+1
    374  22c2		       68		      pla
    375  22c3
    376  22c3		       60		      rts
    377  22c4							;=================================================================================================================
    378  22c4							; Print a string variable including the quotes
    379  22c4							; On Input	 y is offset into buffer
    380  22c4							; On Exit	 y is updated to new offset
    381  22c4
    382  22c4				   PrintStringVariable
    383  22c4		       c8		      iny
    384  22c5		       a9 22		      lda	#'"
    385  22c7		       20 5e 1a 	      jsr	VOUTCH
    386  22ca		       c8		      iny
    387  22cb		       a5 59		      lda	dpl
    388  22cd		       85 5e		      sta	PrtFrom
    389  22cf		       a5 5a		      lda	dpl+1
    390  22d1		       85 5f		      sta	PrtFrom+1
    391  22d3		       a9 22		      lda	#'"
    392  22d5		       8d 44 43 	      sta	PrtTerm
    393  22d8		       20 fd 21 	      jsr	PrtLoop
    394  22db		       a9 22		      lda	#'"
    395  22dd		       20 5e 1a 	      jsr	VOUTCH
    396  22e0		       4c b0 22 	      jmp	PrintProgNext
    397  22e3
    398  22e3				   PrintProgVariableVec
    399  22e3		       4c 83 23 	      jmp	PrintProgVariable
    400  22e6
    401  22e6				   PrintProgOperatorVect
    402  22e6		       4c 5a 23 	      jmp	PrintProgOperator
    403  22e9							;===============================================================================================================
    404  22e9							; On entry dpl points to the buffer we are printing from
    405  22e9							;	    y	current offset into the dpl buffer
    406  22e9							; all registers preserved
    407  22e9							;
    408  22e9				   PrintKeyword
    409  22e9
    410  22e9		       b1 59		      lda	(dpl),y	; Get the Keyword token to lookup
    411  22eb		       85 52		      sta	R0	; The value we are looking for
    412  22ed		       c9 07		      cmp	#kGoto	; Test if we must skip an extra two bytes for branch type instructions
    413  22ef		       f0 0c		      beq	PrintKeyBranch
    414  22f1		       c9 08		      cmp	#kGosub
    415  22f3		       f0 08		      beq	PrintKeyBranch
    416  22f5		       c9 2f		      cmp	#kTask
    417  22f7		       f0 04		      beq	PrintKeyBranch
    418  22f9		       c9 37		      cmp	#kGofn
    419  22fb		       d0 04		      bne	PrintKeySkipped
    420  22fd				   PrintKeyBranch
    421  22fd		       c8		      iny		; Skip the compiled memory address
    422  22fe		       c8		      iny
    423  22ff		       ca		      dex		; Change number of bytes to print
    424  2300		       ca		      dex		; Remove the bytes to print
    425  2301
    426  2301				   PrintKeySkipped
    427  2301		       c8		      iny		; Inc y to point to the next char to be printed
    428  2302		       ca		      dex		; Reduce number of bytes to print
    429  2303		       98		      tya		; Save y and x for the return
    430  2304		       48		      pha
    431  2305		       8a		      txa
    432  2306		       48		      pha
    433  2307
    434  2307		       a9 19		      lda	#KeyWordTable&$FF	; R1 to point to the entry in the keyword table
    435  2309		       85 54		      sta	R1
    436  230b		       a9 1b		      lda	#KeyWordTable>>8
    437  230d		       85 55		      sta	R1+1
    438  230f
    439  230f
    440  230f				   PrintKeyLoop
    441  230f		       a0 00		      ldy	#0	; Index into the keyword entry
    442  2311		       b1 54		      lda	(R1),y	; Get token value for this entry
    443  2313		       c8		      iny		; Point to first byte of key
    444  2314		       c5 52		      cmp	R0	; Compare to the token we are looking for
    445  2316		       f0 16		      Beq	PrintKeyFound	; We have the correct Token, now print it
    446  2318
    447  2318				   PrintKeyNext
    448  2318		       b1 54		      lda	(R1),y	; Get key letter
    449  231a		       c8		      iny		; Point to next byte always
    450  231b		       29 20		      and	#%00100000	; Check for last character in key work
    451  231d		       d0 f9		      bne	PrintKeyNext	; If it is not set then get next character
    452  231f
    453  231f		       98		      tya		; Trabsfer y to a for the addition
    454  2320		       18		      clc		; Table > 256 bytes
    455  2321		       65 54		      adc	R1
    456  2323		       85 54		      sta	R1
    457  2325		       a9 00		      lda	#0
    458  2327		       65 55		      adc	R1+1
    459  2329		       85 55		      sta	R1+1
    460  232b		       4c 0f 23 	      jmp	PrintKeyLoop
    461  232e
    462  232e				   PrintKeyFound
    463  232e		       b1 54		      lda	(R1),y	; letter from key table
    464  2330		       48		      pha		; Save it for later check
    465  2331		       09 20		      ora	#%00100000	; Force it to lower case
    466  2333		       20 5e 1a 	      jsr	VOUTCH	; Print it out
    467  2336		       c8		      iny		; Point to next character
    468  2337		       68		      pla		; Restore the value
    469  2338		       29 20		      and	#%00100000	; Check if it was last char in keyword
    470  233a		       d0 f2		      bne	PrintKeyFound	; Yes, then goto all done printing
    471  233c
    472  233c		       68		      pla		; Restore the x and y values
    473  233d		       aa		      tax
    474  233e		       68		      pla
    475  233f		       a8		      tay
    476  2340
    477  2340				   PrintChkRem
    478  2340		       a9 0a		      lda	#kRem
    479  2342		       c5 52		      cmp	R0
    480  2344		       d0 11		      bne	PrintKeyDone
    481  2346				   PrintKeyRem
    482  2346		       a5 59		      lda	dpl	; if it is a rem then we must print the entire line
    483  2348		       85 5e		      sta	PrtFrom
    484  234a		       a5 5a		      lda	dpl+1
    485  234c		       85 5f		      sta	PrtFrom+1
    486  234e		       a9 00		      lda	#0
    487  2350		       8d 44 43 	      sta	PrtTerm
    488  2353		       20 fd 21 	      jsr	PrtLoop
    489  2356		       88		      dey		; point back to the terminating null value
    490  2357				   PrintKeyDone
    491  2357		       4c b0 22 	      jmp	PrintProgNext
    492  235a							;==================================================================================================================
    493  235a							;Print Variable, number or operator
    494  235a				   PrintProgOperator
    495  235a		       b1 59		      lda	(dpl),y
    496  235c		       c8		      iny
    497  235d		       ca		      dex
    498  235e		       8e 58 1d 	      stx	printStorage+2
    499  2361		       a2 00		      ldx	#0
    500  2363				   PrintOprLoop
    501  2363		       dd fb 1a 	      cmp	OperValues,x
    502  2366		       f0 03		      beq	PrintOprFound
    503  2368		       e8		      inx
    504  2369		       d0 f8		      bne	PrintOprLoop
    505  236b				   PrintOprFound
    506  236b		       8a		      txa
    507  236c		       0a		      asl
    508  236d		       aa		      tax
    509  236e		       bd bd 1a 	      lda	Operators,x
    510  2371		       20 5e 1a 	      jsr	VOUTCH
    511  2374		       e8		      inx
    512  2375		       bd bd 1a 	      lda	Operators,x
    513  2378		       f0 03		      beq	PrintOprDone
    514  237a		       20 5e 1a 	      jsr	VOUTCH
    515  237d				   PrintOprDone
    516  237d		       ae 58 1d 	      ldx	printStorage+2
    517  2380		       4c b0 22 	      jmp	PrintProgNext
    518  2383
    519  2383							;=================================================================================================================
    520  2383							;KeywordsMax	    equ     128 		   ; Allow to be range	1 to 127  key words, high order bit must be 0 for it to be a key word
    521  2383							;tVa		    equ     128 		   ; Variable A = 1, .... Z = 26   ^ = 27
    522  2383							;tVb		    equ     130 		   ; Variables 128 - 157  $80-$9D
    523  2383							;tVhat 	    equ     155 		   ; Variable ^
    524  2383							;tVhash	    equ     156 		   ; Variable #
    525  2383							;tVat		    equ     157 		   ; Variable @ = 0
    526  2383				   PrintProgVariable
    527  2383		       b1 59		      lda	(dpl),y
    528  2385		       c8		      iny
    529  2386		       ca		      dex
    530  2387		       c9 9b		      cmp	#tVhat
    531  2389		       d0 04		      bne	PrintProgChkHash
    532  238b		       a9 5e		      lda	#'^
    533  238d		       d0 15		      bne	PrintTheVar
    534  238f				   PrintProgChkHash
    535  238f		       c9 9c		      cmp	#tVhash
    536  2391		       d0 04		      bne	PrintProgChkAt
    537  2393		       a9 23		      lda	#'#
    538  2395		       d0 0d		      bne	PrintTheVar
    539  2397				   PrintProgChkAt
    540  2397		       c9 9d		      cmp	#tVat
    541  2399		       d0 04		      bne	PrintProgVarLetter
    542  239b		       a9 40		      lda	#'@
    543  239d		       d0 05		      bne	PrintTheVar
    544  239f				   PrintProgVarLetter
    545  239f		       29 7f		      and	#%01111111
    546  23a1		       18		      clc
    547  23a2		       69 41		      adc	#'A
    548  23a4				   PrintTheVar
    549  23a4		       20 5e 1a 	      jsr	VOUTCH
    550  23a7		       4c b0 22 	      jmp	PrintProgNext
    551  23aa
    552  23aa
    553  23aa							;==================================================================================================
    554  23aa							; Size of print functions
    555  23aa		       02 c5	   PrintFunctionsSize equ	* - PrintDecimal	; should use label of first fuction in file
------- FILE mytb.asm
------- FILE mem.asm LEVEL 2 PASS 6
      0  23aa					      include	"mem.asm"
      1  23aa							;===================================================================
      2  23aa							;This file contains the memory allocation and free functions
      3  23aa							; This is the management of free memory in the system
      4  23aa							; the interface to these functions
      5  23aa							; a,x returns or provides the low hi bytes of the managed addresses
      6  23aa							; This uses the programend, to memory end as the area to manage
      7  23aa							;===================================================================
      8 U368f					      Seg.u	TBData
      9 U368f							;
     10 U368f							;=====================================================
     11 U368f							;Pointers for memory Management
     12 U368f							;Allocated block are not chained but can be followed for all memory by the associated length
     13 U368f							; Mem block format is
     14 U368f							;	 0-1   pointer to next block for free blocks
     15 U368f							;	 0-1   for allocated blocks
     16 U368f							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
     17 U368f							;	   1   refrence counter ... lol only up to 256 but it is something
     18 U368f							;	 2-3   length constant for exevy type of memory block
     19 U368f							; Memory is recombined as it is released
     20 U368f							; The memory manager is not interupted durring allocation
     21 U368f							; or freeing of memory
     22 U368f							;====================================================
     23 U368f		       00 00	   MemFreeList ds	2	; list of free blocks of memory
     24 U3691		       00 00	   MemR0      ds	2	; source for copy/move/Init
     25 U3693		       00 00	   MemR1      ds	2	; Destination for copy/move
     26 U3695							;=====================================================
     27  23aa					      Seg	Code
     28  23aa							;=====================================================
     29  23aa				   MemInit
     30  23aa		       a9 5a		      lda	#FreeMemStart&$FF
     31  23ac		       8d 50 43 	      sta	ProgramStart
     32  23af		       8d 52 43 	      sta	ProgramEnd
     33  23b2		       a9 43		      lda	#FreeMemStart>>8
     34  23b4		       8d 51 43 	      sta	ProgramStart+1
     35  23b7		       8d 53 43 	      sta	ProgramEnd+1
     36  23ba
     37  23ba		       20 c4 23 	      jsr	GetSizes
     38  23bd		       20 cf 23 	      jsr	MemFree
     39  23c0		       20 e7 23 	      jsr	MemUsed
     40  23c3				   MemInitEnd
     41  23c3		       60		      rts
     42  23c4
     43  23c4
     44  23c4							;
     45  23c4							;=====================================================
     46  23c4							; This function might go away eventually, but was
     47  23c4							; added to provide data for other pieces of code.
     48  23c4							; It has some ties to the operating environment that
     49  23c4							; will need to be customized for the target system.
     50  23c4							;
     51  23c4				   GetSizes
     52  23c4							;
     53  23c4							; Here is machine specific code to get the highest
     54  23c4							; memory location that can be used by BASIC.
     55  23c4							;
     56  23c4				  -	      if	ProgramStart < $2000
     57  23c4				  -	      lda	#$ff
     58  23c4				  -	      sta	HighMem	;$13ff for KIM-1
     59  23c4				  -	      sta	MemFreeList
     60  23c4				  -	      lda	#$DE	;#$13
     61  23c4				  -	      sta	HighMem+1
     62  23c4				  -	      sta	MemFreeList+1
     63  23c4					      else
     64  23c4		       a9 ff		      lda	#$ff
     65  23c6		       8d 54 43 	      sta	HighMem	;$CFFF otherwise
     66  23c9		       a9 cf		      lda	#$cf
     67  23cb		       8d 55 43 	      sta	HighMem+1
     68  23ce					      endif
     69  23ce		       60		      rts
     70  23cf							;
     71  23cf							; This computes the available memory remaining.
     72  23cf							;
     73  23cf				   MemFree
     74  23cf		       38		      sec
     75  23d0		       ad 54 43 	      lda	HighMem
     76  23d3		       ed 52 43 	      sbc	ProgramEnd
     77  23d6		       8d 58 43 	      sta	FreeMem
     78  23d9		       85 52		      sta	R0
     79  23db		       ad 55 43 	      lda	HighMem+1
     80  23de		       ed 53 43 	      sbc	ProgramEnd+1
     81  23e1		       8d 59 43 	      sta	FreeMem+1
     82  23e4		       85 53		      sta	R0+1
     83  23e6		       60		      rts
     84  23e7							;
     85  23e7							; This computes the size of the current user program.
     86  23e7							;
     87  23e7				   MemUsed
     88  23e7		       38		      sec
     89  23e8		       ad 52 43 	      lda	ProgramEnd
     90  23eb		       ed 50 43 	      sbc	ProgramStart
     91  23ee		       8d 56 43 	      sta	UsedMem
     92  23f1		       85 52		      sta	R0
     93  23f3		       ad 53 43 	      lda	ProgramEnd+1
     94  23f6		       ed 51 43 	      sbc	ProgramStart+1
     95  23f9		       8d 57 43 	      sta	UsedMem+1
     96  23fc		       85 53		      sta	R0+1
     97  23fe							;
     98  23fe		       60		      rts
     99  23ff							;
    100  23ff							;=====================================================
    101  23ff							; Set a block of memory to a value
    102  23ff		       8a	   iSetBlock  txa
    103  2400		       48		      pha
    104  2401		       98		      tya
    105  2402		       48		      pha
    106  2403		       20 dd 2c 	      jsr	popR0	; the address to write to
    107  2406		       a5 52		      lda	R0
    108  2408		       85 59		      sta	dpl
    109  240a		       a5 53		      lda	R0+1
    110  240c		       85 5a		      sta	dpl+1
    111  240e		       20 f5 2c 	      jsr	popR1	; Number of bytes to write
    112  2411		       20 dd 2c 	      jsr	popR0	; Get the value to store into memory
    113  2414		       20 52 2a 	      jsr	getILByte
    114  2417		       85 58		      sta	R2	; store the data type into R2
    115  2419		       c9 a4		      cmp	#tInteger
    116  241b		       f0 08		      beq	memset	; skip this if we have an integer
    117  241d		       a5 52		      lda	R0	; Revers the order so they can be copied in correct order
    118  241f		       a6 53		      ldx	R0+1
    119  2421		       86 52		      stx	R0
    120  2423		       85 53		      sta	R0+1
    121  2425
    122  2425				   memset
    123  2425		       a0 00		      ldy	#0	; Set for length of block to copy
    124  2427		       a2 00		      ldx	#0	; set for number of block of 256 to copy
    125  2429
    126  2429		       a5 58	   iSetBlockLoop lda	R2	; Get Datatype
    127  242b		       c9 a2		      cmp	#tByte
    128  242d		       f0 09		      beq	iSetBlockB
    129  242f
    130  242f		       a5 52	   iSetBlockW lda	R0
    131  2431		       91 59		      sta	(dpl),y
    132  2433		       20 48 24 	      jsr	iSetBlockEnd
    133  2436		       f0 09		      beq	iSetBlockComplete
    134  2438
    135  2438		       a5 53	   iSetBlockB lda	R0+1
    136  243a		       91 59		      sta	(dpl),y
    137  243c		       20 48 24 	      jsr	iSetBlockEnd
    138  243f		       d0 e8		      bne	iSetBlockLoop
    139  2441
    140  2441				   iSetBlockComplete
    141  2441		       68		      pla
    142  2442		       a8		      tay
    143  2443		       68		      pla
    144  2444		       aa		      tax
    145  2445		       4c b1 02 	      jmp	NextIL
    146  2448							;
    147  2448							; Check if we have reached the end of the initialization/Copy
    148  2448							;
    149  2448		       c8	   iSetBlockEnd iny
    150  2449		       d0 03		      bne	iSetBlockEndChk
    151  244b		       e8		      inx
    152  244c		       e6 5a		      inc	dpl+1
    153  244e				   iSetBlockEndChk
    154  244e		       c4 54		      cpy	R1
    155  2450		       d0 02		      bne	iSetBlockEndExit
    156  2452		       e4 55		      cpx	R1+1
    157  2454				   iSetBlockEndExit
    158  2454		       60		      rts
    159  2455							;
    160  2455							;================================================================
    161  2455							; Copy a block of memory from one location to another
    162  2455							;
    163  2455		       8a	   iCopyBlock txa
    164  2456		       48		      pha
    165  2457		       98		      tya
    166  2458		       48		      pha
    167  2459		       20 dd 2c 	      jsr	popR0	; get the source address
    168  245c		       20 f5 2c 	      jsr	popR1	; Destination address
    169  245f		       a5 54		      lda	R1
    170  2461		       85 59		      sta	dpl
    171  2463		       a5 55		      lda	R1+1
    172  2465		       85 5a		      sta	dpl+1
    173  2467		       20 f5 2c 	      jsr	popR1	; Number of bytes to copy
    174  246a				   memcpy
    175  246a		       a2 00		      ldx	#0
    176  246c		       a0 00		      ldy	#0
    177  246e				   iCopyBlockLoop
    178  246e		       b1 52		      lda	(R0),y	;  Get the byte to copy
    179  2470		       91 59		      sta	(dpl),y	;  Store the byte
    180  2472		       c8		      iny
    181  2473		       d0 05		      bne	iCopyChkEnd
    182  2475		       e8		      inx
    183  2476		       e6 53		      inc	R0+1
    184  2478		       e6 5a		      inc	dpl+1
    185  247a		       c4 54	   iCopyChkEnd cpy	R1
    186  247c		       d0 f0		      bne	iCopyBlockLoop
    187  247e		       e4 55		      cpx	R1+1
    188  2480		       d0 ec		      bne	iCopyBlockLoop
    189  2482				   iCopyBlockDone
    190  2482		       68		      pla
    191  2483		       a8		      tay
    192  2484		       68		      pla
    193  2485		       aa		      tax
    194  2486		       4c b1 02 	      jmp	NextIL
    195  2489							;
    196  2489							;=============================================================================
    197  2489							; Compare memory block location
    198  2489							; returns on the stack
    199  2489							; 0 - equals
    200  2489							; -1 - s1  <  s2
    201  2489							; 1   s1  >  s2
    202  2489		       8a	   iCmpBlock  txa
    203  248a		       48		      pha
    204  248b		       98		      tya
    205  248c		       48		      pha
    206  248d		       20 f5 2c 	      jsr	popR1	; Get the Source 2 pointer
    207  2490		       a5 54		      lda	R1
    208  2492		       85 59		      sta	dpl	; store the secon source in dpl
    209  2494		       a5 55		      lda	R1+1
    210  2496		       85 5a		      sta	dpl+1
    211  2498		       20 dd 2c 	      jsr	popR0	; Get the Source 1 pointer
    212  249b		       20 f5 2c 	      jsr	popR1	; Get the length of the compare to do
    213  249e		       a0 00		      ldy	#0
    214  24a0		       a2 00		      ldx	#0
    215  24a2		       4c af 24 	      jmp	iCmpCheckEnd
    216  24a5
    217  24a5		       b1 59	   iCmpLoop   lda	(dpl),y
    218  24a7		       d1 52		      cmp	(R0),y
    219  24a9		       d0 19		      bne	iCmpDone
    220  24ab		       c8		      iny
    221  24ac		       d0 01		      bne	iCmpCheckEnd
    222  24ae		       e8		      inx
    223  24af				   iCmpCheckEnd
    224  24af		       c4 54		      cpy	R1
    225  24b1		       d0 f2		      bne	iCmpLoop
    226  24b3		       e4 55		      cpx	R1+1
    227  24b5		       d0 ee		      bne	iCmpLoop
    228  24b7		       a5 00		      lda	0
    229  24b9		       85 53		      sta	R0+1
    230  24bb		       85 52		      sta	R0
    231  24bd				   iCmpReturn
    232  24bd		       68		      pla
    233  24be		       a8		      tay
    234  24bf		       68		      pla
    235  24c0		       aa		      tax
    236  24c1		       4c 1d 07 	      jmp	pushR0nextIl
    237  24c4
    238  24c4				   iCmpDone
    239  24c4		       90 0a		      bcc	iCmpGreater
    240  24c6				   iCmpLess
    241  24c6		       a9 00		      lda	#0
    242  24c8		       85 53		      sta	R0+1
    243  24ca		       a9 01		      lda	#1
    244  24cc		       85 52		      sta	R0
    245  24ce		       d0 ed		      bne	iCmpReturn
    246  24d0				   iCmpGreater
    247  24d0		       a9 ff		      lda	#-1
    248  24d2		       85 52		      sta	R0
    249  24d4		       85 53		      sta	R0+1
    250  24d6		       d0 e5		      bne	iCmpReturn
    251  24d8
------- FILE mytb.asm
------- FILE gosub_def.inc LEVEL 2 PASS 6
      0  24d8					      include	"gosub_def.inc"
      1  24d8							; Gosub stack definitions and structure information
      2  24d8							; The gosub stack is used by, while, for, gosub, function parameters
      3  24d8							; Task parameter passing as well, math stack frame info
      4  24d8							;
      5  24d8							;==================================================================
      6  24d8							; gosub stack entry formats, always contains a typw identifier
      7  24d8							; gosub: no return value, no parameters
      8  24d8							; byte 0   : Math Stack pointer
      9  24d8							; byte 1   : The number of parameters being passed on the math stack always 0
     10  24d8							; byte 2   : Not used always 0
     11  24d8							; byte 3   : type of entry #GOSUB_STACK_FRAME
     12  24d8							;
     13  24d8							; gosub with parameters, no return value
     14  24d8							; byte 0   : Math Stack pointer
     15  24d8							; byte 1   : The number of parameters being passed on the math stack 1-255
     16  24d8							; byte 2   : Not used always 0
     17  24d8							; byte 3   : type of entry #GOSUB_STACK_FRAME
     18  24d8
     19  24d8							; gosub with parameters, return value
     20  24d8							; byte 0   : Math Stack pointer
     21  24d8							; byte 1   : The number of parameters being passed on the math stack 1-255
     22  24d8							; byte 2   : Not used always 0
     23  24d8							; byte 3   : type of entry #GOSUB_STACK_FRAME
     24  24d8							; Value is return in R0
     25  24d8							;
     26  24d8							; Task with parameters, return value always in variable array
     27  24d8							;  For tasks just like gosub calls, the parameters are stored onto the match stack
     28  24d8							;  and the parameter stack frame is stored onto the gosub stack
     29  24d8
     30  24d8							; For next step, continue, break
     31  24d8							; byte: 0,1  pc counter to return to test
     32  24d8							; byte: 2,3  pc counter to exit to
     33  24d8							; byte: 4    type of entry #GOSUB_FOR
     34  24d8
     35  24d8							; while..wend, continue, break
     36  24d8							; byte: 0,1  pc counter to return to test
     37  24d8							; byte: 2.3  pc counter to exit to
     38  24d8							; byte: 4    type of entry #GOSUB_WHILE
     39  24d8
     40  24d8							;
     41  24d8							; Gosub entry types
     42  24d8
     43  24d8		       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
     44  24d8		       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
     45  24d8		       00 02	   GOSUB_FOR  equ	2	; Return point for FOR..Next
     46  24d8		       00 03	   GOSUB_While equ	3	; Return point for the While.. wend
     47  24d8		       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
     48  24d8		       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
     49  24d8							; 0 byte is the original stack offset, byte 1 is the parameter count
     50  24d8							; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
     51  24d8		       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
     52  24d8		       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
     53  24d8
------- FILE mytb.asm
------- FILE gosub.asm LEVEL 2 PASS 6
      0  24d8					      include	"gosub.asm"
      1  24d8					      seg	Code
      2  24d8
      3  24d8							; Gosub and return related functions, While ..  Wend
      4  24d8							;==========================================================
      5  24d8							; Push the current math stack frame onto the gosub stack
      6  24d8							;   the frame is really just the information about the area on the
      7  24d8							;   math stack that contains the passed values as parameters
      8  24d8				   iPushMathStack
      9  24d8		       98		      tya
     10  24d9		       48		      pha
     11  24da		       a4 4d		      ldy	GOSUBSTACKPTR
     12  24dc		       a5 4a		      lda	MATHSTACKPTR
     13  24de		       91 4b		      sta	(GOSUBSTACK),y	; place the current Math stack ptr onto the stack
     14  24e0		       a9 00		      lda	#0
     15  24e2		       c8		      iny
     16  24e3		       91 4b		      sta	(GOSUBSTACK),y	; place a zero for the number of current parameters
     17  24e5		       c8		      iny
     18  24e6		       91 4b		      sta	(GOSUBSTACK),y	; Place a zero for the next byte
     19  24e8		       c8		      iny
     20  24e9		       a9 05		      lda	#GOSUB_STACK_FRAME
     21  24eb		       91 4b		      sta	(GOSUBSTACK),y	; store the type of entry on the stack as the last byte
     22  24ed		       c8		      iny
     23  24ee		       84 4d		      sty	GOSUBSTACKPTR	; save the pointer into the gosub stack
     24  24f0		       68		      pla
     25  24f1		       a8		      tay
     26  24f2		       4c b1 02 	      jmp	NextIL
     27  24f5							;
     28  24f5							;==========================================================
     29  24f5							; Increment parameter count. Assume Stack frame is top of stack
     30  24f5				   iIncParmCount
     31  24f5		       98		      tya
     32  24f6		       48		      pha
     33  24f7
     34  24f7		       a4 4d		      ldy	GOSUBSTACKPTR	; get the pointer to update the stack entry
     35  24f9		       88		      dey		; point to the type of entry #GOSUB_STACK_FRAME
     36  24fa		       88		      dey		; point to the previous byte
     37  24fb		       88		      dey		; point to the count of parameters up to 255
     38  24fc		       b1 4b		      lda	(GOSUBSTACK),y	; get the count
     39  24fe		       18		      clc
     40  24ff		       69 01		      adc	#1	; increment the count
     41  2501		       91 4b		      sta	(GOSUBSTACK),y	; save the updated count
     42  2503
     43  2503		       68		      pla
     44  2504		       a8		      tay
     45  2505		       4c b1 02 	      jmp	NextIL
     46  2508							;
     47  2508							;==========================================================
     48  2508							;Restore the math stack frame, removing parameters from stop
     49  2508							;of the math stack
     50  2508							;
     51  2508		       20 0e 25    iPopMathStack jsr	PopMathStackNow
     52  250b		       4c b1 02 	      jmp	NextIL
     53  250e
     54  250e				   PopMathStackNow
     55  250e		       98		      tya
     56  250f		       48		      pha
     57  2510
     58  2510		       a4 4d		      ldy	GOSUBSTACKPTR
     59  2512		       88		      dey
     60  2513		       b1 4b		      lda	(GOSUBSTACK),y
     61  2515		       c9 05		      cmp	#GOSUB_STACK_FRAME
     62  2517		       d0 09		      bne	iPopMathStackNoFrame
     63  2519		       88		      dey
     64  251a		       88		      dey
     65  251b		       88		      dey
     66  251c		       b1 4b		      lda	(GOSUBSTACK),y
     67  251e		       85 4a		      sta	MATHSTACKPTR
     68  2520		       84 4d		      sty	GOSUBSTACKPTR
     69  2522
     70  2522				   iPopMathStackNoFrame
     71  2522
     72  2522		       68		      pla
     73  2523		       a8		      tay
     74  2524		       60		      rts
     75  2525
     76  2525
     77  2525							;==========================================================
     78  2525							; Push the current math stack information onto the gosub stack
     79  2525				   iSaveMathStack
     80  2525		       98		      tya
     81  2526		       48		      pha
     82  2527
     83  2527		       a4 4d		      ldy	GOSUBSTACKPTR
     84  2529		       a5 4a		      lda	MATHSTACKPTR
     85  252b		       91 4b		      sta	(GOSUBSTACK),y
     86  252d		       a5 48		      lda	MATHSTACK
     87  252f		       c8		      iny
     88  2530
     89  2530		       91 4b		      sta	(GOSUBSTACK),y
     90  2532		       c8		      iny
     91  2533
     92  2533		       a5 49		      lda	MATHSTACK+1
     93  2535		       91 4b		      sta	(GOSUBSTACK),y
     94  2537		       c8		      iny
     95  2538
     96  2538		       a9 06		      lda	#GOSUB_STACK_SAVE
     97  253a		       91 4b		      sta	(GOSUBSTACK),y
     98  253c		       c8		      iny
     99  253d
    100  253d		       84 4d		      sty	GOSUBSTACKPTR
    101  253f
    102  253f		       68		      pla
    103  2540		       a8		      tay
    104  2541		       4c b1 02 	      jmp	NextIL
    105  2544							;
    106  2544							;==========================================================
    107  2544							;Restore the math stack information from the gosub stack
    108  2544				   iRestoreMathStack
    109  2544		       98		      tya
    110  2545		       48		      pha
    111  2546
    112  2546		       a5 4a		      lda	MATHSTACKPTR
    113  2548		       85 58		      sta	R2	; save the current offset for whatever task to R2
    114  254a
    115  254a		       a4 4d		      ldy	GOSUBSTACKPTR
    116  254c		       88		      dey
    117  254d		       b1 4b		      lda	(GOSUBSTACK),y
    118  254f		       c9 06		      cmp	#GOSUB_STACK_SAVE
    119  2551		       d0 16		      bne	iPopMathStack_Err
    120  2553		       88		      dey
    121  2554		       b1 4b		      lda	(GOSUBSTACK),y
    122  2556		       85 49		      sta	MATHSTACK+1
    123  2558		       88		      dey
    124  2559		       b1 4b		      lda	(GOSUBSTACK),y
    125  255b		       85 48		      sta	MATHSTACK
    126  255d		       88		      dey
    127  255e		       b1 4b		      lda	(GOSUBSTACK),y
    128  2560		       85 4a		      sta	MATHSTACKPTR
    129  2562		       84 4d		      sty	GOSUBSTACKPTR
    130  2564
    131  2564		       68		      pla
    132  2565		       a8		      tay
    133  2566		       4c b1 02 	      jmp	NextIL
    134  2569
    135  2569				   iPopMathStack_Err
    136  2569		       68		      pla
    137  256a		       a8		      tay
    138  256b		       a9 00		      lda	#0
    139  256d		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    140  256f		       4c 7d 06 	      jmp	iErr2
    141  2572							;===========================================================
    142  2572							; For functions and tasks the variable address of # means
    143  2572							; a passed parameter so #[0] is the first parameter etc
    144  2572							; will try for a better way later
    145  2572							;============================================================
    146  2572							; On entry il, branch to if function
    147  2572							;	    il+1, value to be returned or not true or false
    148  2572							;
    149  2572							; Return from GOSUB  or function function
    150  2572							; format   RSTR 0   --- return form gosub
    151  2572							;	    RSTR 1   --- return from Function
    152  2572							;
    153  2572		       20 52 2a    iRSTR      jsr	getILByte	; get where to go if 0 = gosub/1=function call
    154  2575		       8d 48 43 	      sta	offset
    155  2578		       20 35 2c 	      jsr	saveIL	; for later jump if needed add extra entry to	the return stack
    156  257b
    157  257b		       20 8e 2c 	      jsr	popLN	; get the next item from the stack into curptr and curroff, returns call type func or stmt
    158  257e		       85 54		      sta	R1	; keep the type of call returning from
    159  2580		       b0 2b		      bcs	iRSTRErr	; stack underflow error possible
    160  2582
    161  2582		       20 52 2a 	      jsr	getILByte	; get if a value is being returned
    162  2585
    163  2585		       48		      pha		; save if a value was passed to be returned
    164  2586
    165  2586		       c9 00		      cmp	#0	; yes attemping to return a value
    166  2588		       f0 03		      beq	iRSTRPOP	; no value to return
    167  258a		       20 dd 2c 	      jsr	popR0	; Get the value from the stack save if needed
    168  258d
    169  258d				   iRSTRPOP
    170  258d		       20 0e 25 	      jsr	PopMathStackNow	; adjust the stack frame from the call
    171  2590		       a5 54		      lda	R1	; called as a statement ?
    172  2592		       c9 01		      cmp	#GOSUB_RTN	; Called as a statement
    173  2594		       f0 13		      beq	iRSTRExit
    174  2596
    175  2596		       68		      pla		; get back if value returned or not
    176  2597		       c9 01		      cmp	#1	; we have a value to return
    177  2599		       f0 05		      beq	iRSTRVALUE
    178  259b
    179  259b		       a2 13		      ldx	#ERR_NO_RETURN_VALUE_PROVIDED	; well no value provided and we need one
    180  259d		       4c 12 05 	      jmp	iSAVErr2	; jump to general error reporting function
    181  25a0
    182  25a0				   iRSTRVALUE
    183  25a0		       20 4b 2c 	      jsr	pushR0	; return value back to top of stack
    184  25a3		       20 40 2c 	      jsr	restoreIL	; get the correct il
    185  25a6		       4c e0 0b 	      jmp	tstBranch	; And called as a function
    186  25a9
    187  25a9				   iRSTRExit
    188  25a9		       68		      pla		; throw away gosub/func flag
    189  25aa		       4c b1 02 	      jmp	NextIL
    190  25ad
    191  25ad				   iRSTRNORETURNVALUE
    192  25ad
    193  25ad
    194  25ad		       ad d7 36    iRSTRErr   lda	taskPtr	; Check if this is task zero
    195  25b0		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    196  25b2		       a5 56		      lda	MQ
    197  25b4		       d0 03		      bne	taskRet
    198  25b6		       20 18 2f 	      jsr	pushFalse	; the result code by default is 0
    199  25b9				   taskRet
    200  25b9		       4c 4b 28 	      jmp	iETask	; not task zero then do a task end instead
    201  25bc				   taskZeroEnd
    202  25bc		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    203  25be		       4c 12 05 	      jmp	iSAVErr2
    204  25c1							;
    205  25c1							;==========================================================================================
    206  25c1							; Find the next gosub function parameter info	position on the stack
    207  25c1							; Returns y = index and c set if found clear c otherwise
    208  25c1		       a4 4d	   GosubFindParms ldy	GOSUBSTACKPTR	;Get the Pointer to the top of stack
    209  25c3		       88		      dey		;Point to stack entry type
    210  25c4
    211  25c4							;Veryify the stack size and position for the call
    212  25c4							;Loops here until it finds a GOSUB with value entry or gosub-rtn entry
    213  25c4
    214  25c4		       c0 00	   GosubFindLoop cpy	#0	;If we reach the top of the stack then no parametrs
    215  25c6		       f0 2d		      beq	GosubNotFunc
    216  25c8		       c0 10		      cpy	#GOSUBSTACKSIZE	;Tst if we are outside the stack size
    217  25ca		       b0 29		      bcs	GosubNotFunc	;Not valid
    218  25cc
    219  25cc							;Look for the	 GOSUB_RTN_VALUE stack position
    220  25cc		       b1 4b		      lda	(GOSUBSTACK),y	;Get the type of call - if it is not a fn call error
    221  25ce		       c9 01		      cmp	#GOSUB_RTN	;if we find this then this function had no parameters
    222  25d0		       f0 0f		      beq	GosubParmFnd	;We can pass parameters to a function that returns nothing
    223  25d2
    224  25d2		       c9 81		      cmp	#GOSUB_RTN_VALUE	;Parameters with the gosub call
    225  25d4		       f0 0b		      beq	GosubParmFnd	;Skip any non Gosub related entries
    226  25d6
    227  25d6		       c9 05		      cmp	#GOSUB_STACK_FRAME	;Stack frame pointer So should contain the start position of Variables
    228  25d8		       f0 13		      beq	GosubParmSkip	;We have a stackframe good
    229  25da
    230  25da		       88		      dey
    231  25db		       88		      dey
    232  25dc		       88		      dey
    233  25dd		       88		      dey
    234  25de		       4c c4 25 	      jmp	GosubFindLoop
    235  25e1
    236  25e1		       c0 03	   GosubParmFnd cpy	#3	; Check if we are outside the stack
    237  25e3		       90 10		      bcc	GosubNotFunc	; if y < 3 then error not found
    238  25e5		       c0 10		      cpy	#GOSUBSTACKSIZE	; Largest value
    239  25e7		       b0 0c		      bcs	GosubNotFunc	; no parameters passed
    240  25e9
    241  25e9		       88		      dey		; Point to hopefully Math Stack frame information
    242  25ea		       88		      dey
    243  25eb		       88		      dey
    244  25ec		       88		      dey
    245  25ed				   GosubParmSkip
    246  25ed		       b1 4b		      lda	(GOSUBSTACK),y	;This should be a stack frame pointer
    247  25ef		       c9 05		      cmp	#GOSUB_STACK_FRAME	;Stack frame pointer So should contain the start position of Variables
    248  25f1		       d0 02		      bne	GosubNotFunc	;No parameters passed but expected
    249  25f3		       38		      sec
    250  25f4		       60		      rts
    251  25f5
    252  25f5		       18	   GosubNotFunc clc
    253  25f6		       60		      rts
    254  25f7
    255  25f7							;==========================================================================
    256  25f7							; This section support while..wend, for x = <expr> to <expr> [ step <expr> ] ... next
    257  25f7							;
    258  25f7							;===========================================================================
    259  25f7							;Jump end Block if top of math stack is false(0)
    260  25f7							;
    261  25f7		       20 dd 2c    iJmpEndFalse jsr	popR0	; get the top of the math stack
    262  25fa		       a5 52		      lda	R0
    263  25fc		       05 53		      ora	R0+1	; check if they are zero
    264  25fe		       f0 03		      beq	JmpEndBlock	; it is zero so we are done in the Loops
    265  2600		       4c b1 02 	      jmp	NextIL	; if true then
    266  2603				   JmpEndBlock
    267  2603		       4c b1 02 	      jmp	NextIL	; ignore for now
    268  2606
    269  2606
    270  2606							;===========================================================================
    271  2606							; Jump back to the start of a block
    272  2606							; next or wend encountered
    273  2606		       20 dd 2c    iJmpStart  jsr	popR0	; get the top of the math stack
    274  2609		       a5 52		      lda	R0
    275  260b		       05 53		      ora	R0+1	; check if they are zero
    276  260d		       f0 03		      beq	JmpStartBlock	; it is zero so we are done in the Loops
    277  260f		       4c b1 02 	      jmp	NextIL	; if true then
    278  2612				   JmpStartBlock
    279  2612		       4c b1 02 	      jmp	NextIL	; ignore for now
    280  2615
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  2615					      include	"tasks.asm"
      1  2615							;=====================================================
      2  2615							; Tiny Basic IL task management
      3  2615							; Data required by task management
      4  2615							; currently each context is about 30 bytes and is swapped
      5  2615							; into and out of page zero on each task switch....
      6  2615							; LOL yes it is slow, but works for this iteration.
      7  2615							;
      8  2615
      9  2615					      Seg	Code
     10  2615							;=====================================================
     11  2615							; Sets the pointers to the math,IL and gosub stacks
     12  2615							; Creates the initial Context for each task slot
     13  2615				   taskSetStacks
     14  2615		       a9 d7		      lda	#mathStack&$FF
     15  2617		       85 48		      sta	MATHSTACK
     16  2619		       a9 37		      lda	#mathStack>>8
     17  261b		       85 49		      sta	MATHSTACK+1
     18  261d
     19  261d		       a9 67		      lda	#ilStack&$ff
     20  261f		       85 45		      sta	ILSTACK
     21  2621		       a9 39		      lda	#ilStack>>8
     22  2623		       85 46		      sta	ILSTACK+1
     23  2625
     24  2625		       a9 4f		      lda	#gosubStack&$FF
     25  2627		       85 4b		      sta	GOSUBSTACK
     26  2629		       a9 3d		      lda	#gosubStack>>8
     27  262b		       85 4c		      sta	GOSUBSTACK+1
     28  262d
     29  262d		       a9 cf		      lda	#variableStack&$FF
     30  262f		       85 41		      sta	VARIABLES
     31  2631		       a9 3f		      lda	#variableStack>>8
     32  2633		       85 42		      sta	VARIABLES+1
     33  2635		       a2 0a		      ldx	#TASKCOUNT
     34  2637		       a0 00		      ldy	#0
     35  2639		       20 09 29 	      jsr	ContextSave	; Save the Task 0 context
     36  263c
     37  263c		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  263e		       b0 3a		      bcs	taskSetDone
     39  2640
     40  2640		       a5 4b		      lda	GOSUBSTACK
     41  2642		       18		      clc
     42  2643		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  2645		       85 4b		      sta	GOSUBSTACK
     44  2647		       a5 4c		      lda	GOSUBSTACK+1
     45  2649		       69 00		      adc	#0
     46  264b		       85 4c		      sta	GOSUBSTACK+1
     47  264d
     48  264d		       a5 45		      lda	ILSTACK	; must be less than 256
     49  264f		       18		      clc
     50  2650		       69 64		      adc	#ILSTACKSIZE*2
     51  2652		       85 45		      sta	ILSTACK
     52  2654		       a5 46		      lda	ILSTACK+1
     53  2656		       69 00		      adc	#0
     54  2658		       85 46		      sta	ILSTACK+1
     55  265a
     56  265a		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  265c		       18		      clc
     58  265d		       69 28		      adc	#MATHSTACKSIZE*2
     59  265f		       85 48		      sta	MATHSTACK
     60  2661		       a5 49		      lda	MATHSTACK+1
     61  2663		       69 00		      adc	#0
     62  2665		       85 49		      sta	MATHSTACK+1
     63  2667
     64  2667		       a5 41		      lda	VARIABLES	; must be less than 256
     65  2669		       18		      clc
     66  266a		       69 4a		      adc	#VARIABLESSIZE*2
     67  266c		       85 41		      sta	VARIABLES
     68  266e		       a5 42		      lda	VARIABLES+1
     69  2670		       69 00		      adc	#0
     70  2672		       85 42		      sta	VARIABLES+1
     71  2674		       20 09 29 	      jsr	ContextSave
     72  2677		       4c 3c 26 	      jmp	taskSetLoop
     73  267a
     74  267a				   taskSetDone
     75  267a		       a0 00		      ldy	#0	; reload the main loop context
     76  267c		       20 18 29 	      jsr	ContextLoad
     77  267f		       60		      rts
     78  2680							;
     79  2680							;============================================================
     80  2680							; Saves the io block to the context
     81  2680
     82  2680
     83  2680		       98	   SaveIOblock tya
     84  2681		       48		      pha
     85  2682		       8a		      txa
     86  2683		       48		      pha
     87  2684
     88  2684
     89  2684
     90  2684		       68		      pla
     91  2685		       aa		      tax
     92  2686		       68		      pla
     93  2687		       a8		      tay
     94  2688		       60		      rts
     95  2689
     96  2689							;
     97  2689							;=====================================================
     98  2689							; In some error cases the math stacks may be left pointing to the wrong stack
     99  2689							; This function will reset those stack addresses but not the actual pointer
    100  2689				   taskResetStacks
    101  2689		       a0 00		      ldy	#0
    102  268b		       20 18 29 	      jsr	ContextLoad
    103  268e		       4c 15 26 	      jmp	taskSetStacks
    104  2691							;
    105  2691							;=====================================================
    106  2691							; Clear all task entries and task stacks
    107  2691		       98	   taskReset  tya		; Save Y
    108  2692		       48		      pha
    109  2693		       a9 01		      lda	#1
    110  2695		       8d d6 37 	      sta	taskCounter	; Set number of active tasks to 1
    111  2698		       ac d7 36 	      ldy	taskPtr	; Set the active task to 0 MAIN
    112  269b		       c0 00		      cpy	#0	; check if we are the main context
    113  269d		       f0 08		      beq	taskResetCont	; if we are just continue
    114  269f
    115  269f		       a0 00		      ldy	#0	; else we need to switch to the main context
    116  26a1		       8c d7 36 	      sty	taskPtr
    117  26a4		       20 18 29 	      jsr	ContextLoad	; load the System Task context
    118  26a7				   taskResetCont
    119  26a7		       a0 19		      ldy	#CONTEXTLEN	; Start at the second task +1 account for task control byte
    120  26a9
    121  26a9				   taskResetLoop
    122  26a9		       a9 00		      lda	#TASKINACTIVE
    123  26ab		       99 d8 36 	      sta	taskTable,y	; Ensure that the task is made inactive
    124  26ae		       18		      clc
    125  26af		       98		      tya
    126  26b0		       69 19		      adc	#CONTEXTLEN
    127  26b2		       a8		      tay
    128  26b3		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    129  26b5		       90 f2		      bcc	taskResetLoop	; Go for more
    130  26b7
    131  26b7				   taskResetComplete
    132  26b7
    133  26b7		       68		      pla		; Restore y
    134  26b8		       a8		      tay
    135  26b9		       60		      rts
    136  26ba
    137  26ba							;
    138  26ba							;======================================================
    139  26ba							; iTaskSwitch	 switch to new task if not interrupt and
    140  26ba							;		 count is exceded for task time slice gets here
    141  26ba							;		 when time slice has reached zero
    142  26ba							;
    143  26ba		       98	   iTaskSwitch tya
    144  26bb		       48		      pha
    145  26bc
    146  26bc		       ad d4 37 	      lda	taskResetValue	; Always reset the counter value
    147  26bf		       8d d2 37 	      sta	taskCurrentCycles	; Update the counter with the new value
    148  26c2		       ce d3 37 	      dec	taskCurrentCycles+1	; dec high order byte
    149  26c5		       d0 44		      bne	iTaskSwitchDone	; Exit if not zero
    150  26c7
    151  26c7		       ad d5 37 	      lda	taskResetValue+1
    152  26ca		       8d d3 37 	      sta	taskCurrentCycles+1
    153  26cd
    154  26cd		       ad c1 19 	      lda	IRQPending	; Skip this if we are processing an irq
    155  26d0		       0d 4a 43 	      ora	taskIOPending	; If set then don't switch
    156  26d3		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    157  26d5
    158  26d5		       ad d6 37    iTaskMain  lda	taskCounter	; Number of tasks
    159  26d8		       c9 01		      cmp	#1	; if there is only one task must be main
    160  26da		       d0 07		      bne	itasknext	; if it some other number continue to next
    161  26dc
    162  26dc		       ac d7 36 	      ldy	taskPtr	; check if we have not just ended some other task
    163  26df		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    164  26e1		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    165  26e3							;
    166  26e3							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    167  26e3							;
    168  26e3				   itasknext
    169  26e3		       ac d7 36 	      ldy	taskPtr
    170  26e6		       20 09 29 	      jsr	ContextSave	; Save the current context, y points to next context
    171  26e9				   itaskLoop
    172  26e9		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    173  26eb		       90 04		      bcc	iTaskNextChk
    174  26ed
    175  26ed		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    176  26ef		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    177  26f1
    178  26f1				   iTaskNextChk
    179  26f1		       b9 d8 36 	      lda	taskTable,y	; there is always at least one entry in table
    180  26f4		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    181  26f6		       18	   iTaskNext  clc
    182  26f7		       98		      tya
    183  26f8		       69 19		      adc	#CONTEXTLEN	; Next Table entry
    184  26fa		       a8		      tay
    185  26fb		       4c e9 26 	      jmp	itaskLoop	; Check for busy entry
    186  26fe
    187  26fe		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    188  2700		       59 d8 36 	      eor	taskTable,y	; Check for anything waiting io
    189  2703		       d0 f1		      bne	iTaskNext
    190  2705		       20 18 29 	      jsr	ContextLoad	; load the next context
    191  2708		       8c d7 36 	      sty	taskPtr	; update the task pointer
    192  270b
    193  270b				   iTaskSwitchDone
    194  270b		       68		      pla
    195  270c		       a8		      tay
    196  270d		       60		      rts
    197  270e							;
    198  270e							;================================================================
    199  270e							; Task Set task number to line number to start
    200  270e							; on entry stack contains, type of line description and  memvector or linenumber
    201  270e							; Task Table structure:
    202  270e							;    byte 0	-   Active inactive
    203  270e							;    byte 1-2	-   Basic code line pointer
    204  270e							;    byte 3	-   Offset on current line
    205  270e		       98	   iTaskSet   tya		;preserve Y
    206  270f		       48		      pha		; push a
    207  2710		       20 f5 2c 	      jsr	popR1	; Get if compiled or line number expression
    208  2713		       20 dd 2c 	      jsr	popR0	; Get the line number to be saved
    209  2716
    210  2716
    211  2716
    212  2716		       ac d7 36 	      ldy	taskPtr	; find out where we are
    213  2719		       20 09 29 	      jsr	ContextSave	; Save the current context
    214  271c
    215  271c							;Find the pointer to the line we need to start at
    216  271c		       a5 54		      lda	R1
    217  271e		       f0 0b		      beq	iTaskLineNum
    218  2720		       a5 52		      lda	R0
    219  2722		       85 4f		      sta	CURPTR
    220  2724		       a5 53		      lda	R0+1
    221  2726		       85 50		      sta	CURPTR+1
    222  2728		       4c 3b 27 	      jmp	iTaskCont
    223  272b
    224  272b				   iTaskLineNum
    225  272b		       20 97 2a 	      jsr	findLine	; Get the offset of the line to start task at
    226  272e		       f0 0b		      beq	iTaskCont
    227  2730
    228  2730		       ac d7 36 	      ldy	taskPtr	; Restore the original Context Error Exit
    229  2733		       20 18 29 	      jsr	ContextLoad
    230  2736
    231  2736		       68		      pla		; pop a - exit
    232  2737		       a8		      tay
    233  2738		       4c f3 0d 	      jmp	iSetIrqErr	; Bad line number provided
    234  273b
    235  273b				   iTaskCont
    236  273b		       20 db 28 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    237  273e		       90 49		      bcc	iTaskNoEmpty	; There are no more empty slots
    238  2740
    239  2740		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    240  2742		       99 d8 36 	      sta	taskTable,y	; new task as active
    241  2745
    242  2745		       a5 4f		      lda	CURPTR
    243  2747		       48		      pha		; push a
    244  2748		       a5 50		      lda	CURPTR+1
    245  274a		       48		      pha		; push a
    246  274b
    247  274b		       20 18 29 	      jsr	ContextLoad	; load the context of the new task
    248  274e
    249  274e		       68		      pla		; pop a
    250  274f		       85 50		      sta	CURPTR+1
    251  2751		       68		      pla		; pop a
    252  2752		       85 4f		      sta	CURPTR
    253  2754		       a9 03		      lda	#3	; Offset to first instruction
    254  2756		       85 51		      sta	CUROFF
    255  2758
    256  2758		       a9 00		      lda	#0
    257  275a		       85 47		      sta	ILSTACKPTR
    258  275c		       85 4a		      sta	MATHSTACKPTR
    259  275e		       85 4d		      sta	GOSUBSTACKPTR
    260  2760		       a9 40		      lda	#GOSUBSTACKSIZE*4
    261  2762		       85 4e		      sta	MESSAGEPTR
    262  2764
    263  2764		       20 75 09 	      jsr	subVINIT	; Clear the variables
    264  2767
    265  2767		       a9 28		      lda	#STMT&$FF
    266  2769		       85 43		      sta	ILPC
    267  276b		       a9 32		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    268  276d		       85 44		      sta	ILPC+1
    269  276f
    270  276f		       98		      tya		; Save the new context offset to return to user
    271  2770		       48		      pha		; push a
    272  2771
    273  2771		       20 09 29    itaskSetSave jsr	ContextSave	; save the updated context
    274  2774		       ee d6 37 	      inc	taskCounter	; Update the number of Tasks running
    275  2777
    276  2777		       ac d7 36 	      ldy	taskPtr
    277  277a		       20 18 29 	      jsr	ContextLoad	; restore the original context
    278  277d
    279  277d		       a9 00		      lda	#0	; Set the R0 upper to zero
    280  277f		       85 53		      sta	R0+1
    281  2781		       68		      pla		; Get the task pid we stored				 ; pop a
    282  2782		       85 52		      sta	R0	; Get the table entry value
    283  2784
    284  2784		       68		      pla		; Restore the y register we saved			 ; pop a   - exit
    285  2785		       a8		      tay
    286  2786
    287  2786		       4c 1d 07 	      jmp	pushR0nextIl	; Push R0 and continue
    288  2789				   iTaskNoEmpty
    289  2789		       ac d7 36 	      ldy	taskPtr
    290  278c		       20 18 29 	      jsr	ContextLoad
    291  278f
    292  278f		       68		      pla		; pop a    -- exit
    293  2790		       a8		      tay
    294  2791
    295  2791		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    296  2793		       a9 00		      lda	#0
    297  2795		       4c 7d 06 	      jmp	iErr2
    298  2798							;
    299  2798							;===============================================================
    300  2798							; Run the task whos PID is on the stack, preserve the stack
    301  2798							;
    302  2798				   iTaskEnable
    303  2798		       98		      tya
    304  2799		       48		      pha
    305  279a		       20 f5 2c 	      jsr	popR1
    306  279d		       20 c3 2c 	      jsr	pushR1
    307  27a0		       20 0f 2a 	      jsr	ipc_getcontext	; get context pointer into mq
    308  27a3		       a0 00		      ldy	#0
    309  27a5		       b1 56		      lda	(MQ),y
    310  27a7		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    311  27a9		       09 80		      ora	#TASKACTIVE
    312  27ab		       91 56		      sta	(MQ),y
    313  27ad		       68		      pla
    314  27ae		       a8		      tay
    315  27af		       4c b1 02 	      jmp	NextIL
    316  27b2
    317  27b2							;
    318  27b2							;===============================================================
    319  27b2							; Suspend the task whos PID  is on the stack, preserve the stack
    320  27b2							;
    321  27b2				   iTaskSuspend
    322  27b2		       98		      tya
    323  27b3		       48		      pha
    324  27b4		       20 f5 2c 	      jsr	popR1
    325  27b7		       20 c3 2c 	      jsr	pushR1
    326  27ba		       20 0f 2a 	      jsr	ipc_getcontext	; get context pointer into mq
    327  27bd		       a0 00		      ldy	#0
    328  27bf		       b1 56		      lda	(MQ),y
    329  27c1		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    330  27c3		       09 80		      ora	#TASKACTIVE
    331  27c5		       68		      pla
    332  27c6		       a8		      tay
    333  27c7		       4c b1 02 	      jmp	NextIL
    334  27ca
    335  27ca							;================================================================
    336  27ca							; Returns task Status
    337  27ca				   iTaskStat
    338  27ca		       98		      tya
    339  27cb		       48		      pha
    340  27cc		       20 de 27 	      jsr	iTaskValid	; returns pointer to task entry
    341  27cf		       b9 d8 36 	      lda	taskTable,y
    342  27d2		       f0 05		      beq	iTaskStatExit
    343  27d4		       68		      pla
    344  27d5		       a8		      tay
    345  27d6		       4c 83 0d 	      jmp	iTruth
    346  27d9				   iTaskStatExit
    347  27d9		       68		      pla
    348  27da		       a8		      tay
    349  27db		       4c 8c 0d 	      jmp	iFalse
    350  27de
    351  27de							;
    352  27de							;================================================================
    353  27de							; Validate the task number on top of the stack
    354  27de							; on exit y points to the requested task entry
    355  27de							;
    356  27de		       20 dd 2c    iTaskValid jsr	popR0	; get result of the multiply
    357  27e1		       a5 53		      lda	R0+1
    358  27e3		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    359  27e5		       a5 52		      lda	R0
    360  27e7		       c9 fa		      cmp	#TASKTABLELEN
    361  27e9		       90 09		      bcc	iTaskIsValid
    362  27eb
    363  27eb		       68	   iTaskValidErr pla		;remove return address
    364  27ec		       68		      pla
    365  27ed		       a2 10		      ldx	#ERR_INVALID_PID
    366  27ef		       a9 00		      lda	#0
    367  27f1		       4c 7d 06 	      jmp	iErr2
    368  27f4
    369  27f4		       a8	   iTaskIsValid tay
    370  27f5		       60		      rts
    371  27f6							;
    372  27f6							;================================================================
    373  27f6							; Kill a running task, do nothing if already stopped
    374  27f6		       20 de 27    iTaskKill  jsr	iTaskValid
    375  27f9		       a9 00		      lda	#0
    376  27fb		       99 d8 36 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    377  27fe							;
    378  27fe							;================================================================
    379  27fe							;Skip to next task
    380  27fe				   iNTask
    381  27fe		       a9 01		      lda	#1
    382  2800		       8d d2 37 	      sta	taskCurrentCycles
    383  2803		       8d d3 37 	      sta	taskCurrentCycles+1
    384  2806		       4c b1 02 	      jmp	NextIL
    385  2809							;
    386  2809							;=======================================================
    387  2809							; Wait for a task to complete
    388  2809				   iWTASK
    389  2809		       20 52 2a 	      jsr	getILByte
    390  280c		       8d 48 43 	      sta	offset
    391  280f							;
    392  280f		       20 35 2c 	      jsr	saveIL	;in case of failure
    393  2812
    394  2812		       20 de 27 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    395  2815		       b9 d8 36 	      lda	taskTable,y
    396  2818		       d0 03		      bne	iWTASKWAIT
    397  281a				   iWTASKEXITED
    398  281a		       4c b1 02 	      jmp	NextIL
    399  281d				   iWTASKWAIT
    400  281d		       20 4b 2c 	      jsr	pushR0	; Push R0 back onto the stack
    401  2820		       a9 01		      lda	#1
    402  2822		       8d d2 37 	      sta	taskCurrentCycles	; Give up the cycles
    403  2825		       8d d3 37 	      sta	taskCurrentCycles+1
    404  2828		       20 40 2c 	      jsr	restoreIL
    405  282b		       4c e0 0b 	      jmp	tstBranch
    406  282e							;
    407  282e							;=======================================================
    408  282e							; Set task io lock
    409  282e		       ee 4a 43    iStartIO   inc	taskIOPending
    410  2831		       4c b1 02 	      jmp	NextIL
    411  2834							;
    412  2834							;=======================================================
    413  2834							; Release the io lock
    414  2834		       ad 4a 43    iEndIO     lda	taskIOPending
    415  2837		       f0 03		      beq	iEndIOExit
    416  2839		       ce 4a 43 	      dec	taskIOPending
    417  283c		       4c b1 02    iEndIOExit jmp	NextIL
    418  283f							;
    419  283f							;===============================================================
    420  283f							; Return the task PID
    421  283f				   iTASKPID
    422  283f		       a9 00		      lda	#0
    423  2841		       85 53		      sta	R0+1
    424  2843		       ad d7 36 	      lda	taskPtr
    425  2846		       85 52		      sta	R0
    426  2848		       4c 1d 07 	      jmp	pushR0nextIl
    427  284b							;
    428  284b							;================================================================
    429  284b							; Terminate a task
    430  284b		       ac d7 36    iETask     ldy	taskPtr
    431  284e		       c0 00		      cpy	#0
    432  2850		       d0 03		      bne	iETaskCont
    433  2852		       4c 02 06 	      jmp	iFIN	; if the main task does a ETASK then stop
    434  2855				   iETaskCont
    435  2855		       a9 00		      lda	#TASKINACTIVE
    436  2857		       99 d8 36 	      sta	taskTable,y	; mark entry as free
    437  285a		       ce d6 37 	      dec	taskCounter	; reduce the number of active tasks
    438  285d		       a9 01		      lda	#1
    439  285f		       8d d2 37 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    440  2862		       8d d3 37 	      sta	taskCurrentCycles+1
    441  2865		       20 f6 28 	      jsr	TaskSetExitCode
    442  2868				   iETaskExit
    443  2868		       4c b1 02 	      jmp	NextIL
    444  286b							;================================================================
    445  286b							; make the current tasks math stack equal another tasks stack
    446  286b							; The task to get is stored on the math stack
    447  286b
    448  286b				   iTaskGetMathStack
    449  286b		       20 1c 2f 	      jsr	CopyStackR1	; Get the top of stack to R1
    450  286e		       20 0f 2a 	      jsr	ipc_getcontext	; MQ now has the context address
    451  2871		       a0 0a		      ldy	#MATHSTACKPTRPOS
    452  2873		       b1 56		      lda	(MQ),y
    453  2875		       85 4a		      sta	MATHSTACKPTR
    454  2877		       a0 08		      ldy	#MATHSTACKPOS
    455  2879		       b1 56		      lda	(MQ),y
    456  287b		       85 48		      sta	MATHSTACK
    457  287d		       c8		      iny
    458  287e		       b1 56		      lda	(MQ),y
    459  2880		       85 49		      sta	MATHSTACK+1
    460  2882		       4c b1 02 	      jmp	NextIL
    461  2885							;==================================================================
    462  2885							; Updates the tasks math stack pointer with contents of R2
    463  2885							; PID is on top of the stack
    464  2885				   iTaskPutMathPtr
    465  2885		       20 1c 2f 	      jsr	CopyStackR1	; Get the top of stack to R1
    466  2888		       20 0f 2a 	      jsr	ipc_getcontext	; MQ now has the context address
    467  288b		       a5 58		      lda	R2	; R2 contains the number of parameters/offset
    468  288d		       a0 0a		      ldy	#MATHSTACKPTRPOS	; Pointer to new tasks stack pointer
    469  288f		       91 56		      sta	(MQ),y	; update it to point to the free space on stack
    470  2891							;if parm count > 0 then we need to create a parameter block on the tasks gosubStack
    471  2891		       c9 00		      cmp	#0	; if no parameters then
    472  2893		       f0 26		      beq	iTaskPutMathPtrExit	; just get out of here
    473  2895
    474  2895		       a0 0b		      ldy	#GOSUBSTKPOS
    475  2897		       b1 56		      lda	(MQ),y	; get the address of the new tasks gosub stack into R1
    476  2899		       85 54		      sta	R1
    477  289b		       c8		      iny
    478  289c		       b1 56		      lda	(MQ),y
    479  289e		       85 55		      sta	R1+1
    480  28a0
    481  28a0		       a9 00		      lda	#0	; Store the math stack offset into new gosub stack, always 0
    482  28a2		       91 54		      sta	(R1),y
    483  28a4
    484  28a4		       c8		      iny
    485  28a5		       18		      clc		; We need to turn stack ptr to actual parm count
    486  28a6		       e9 01		      sbc	#1	; Stack pointer always point to next free byte
    487  28a8		       0a		      asl
    488  28a9		       91 54		      sta	(R1),y
    489  28ab
    490  28ab		       c8		      iny
    491  28ac		       a9 ff		      lda	#$FF	; Dummy field, not used
    492  28ae		       91 54		      sta	(R1),y
    493  28b0		       c8		      iny
    494  28b1		       a9 05		      lda	#GOSUB_STACK_FRAME	; Tell its a stack frame, ie identify param cnt etc
    495  28b3		       91 54		      sta	(R1),y
    496  28b5		       c8		      iny
    497  28b6		       98		      tya
    498  28b7		       a0 0d		      ldy	#GOSUBPTRPOS
    499  28b9		       91 56		      sta	(MQ),y	; update the new tasks gosub stk pointer
    500  28bb
    501  28bb				   iTaskPutMathPtrExit
    502  28bb		       4c b1 02 	      jmp	NextIL
    503  28be							;
    504  28be							;================================================================
    505  28be							; Set the time slice for each task
    506  28be				   iSLICE
    507  28be		       20 dd 2c 	      jsr	popR0
    508  28c1		       a5 52		      lda	R0
    509  28c3		       8d d4 37 	      sta	taskResetValue
    510  28c6		       a5 53		      lda	R0+1
    511  28c8		       8d d5 37 	      sta	taskResetValue+1
    512  28cb		       d0 0b		      bne	iSliceSet
    513  28cd		       ee d5 37 	      inc	taskResetValue+1	; must be at least 1 high counter
    514  28d0		       a9 01		      lda	#1
    515  28d2		       8d d2 37 	      sta	taskCurrentCycles
    516  28d5		       8d d3 37 	      sta	taskCurrentCycles+1
    517  28d8				   iSliceSet
    518  28d8		       4c b1 02 	      jmp	NextIL
    519  28db							;================================================================
    520  28db							; Find an empty slot in the taskTable
    521  28db							; Return the index in y
    522  28db							; on exit   c set if an empty slot is found
    523  28db							;	     c clear if not found
    524  28db							;================================================================
    525  28db							;
    526  28db		       ad d6 37    TaskEmpty  lda	taskCounter
    527  28de		       c9 0a		      cmp	#TASKCOUNT
    528  28e0		       b0 10		      bcs	TaskNoSlot
    529  28e2		       a0 19		      ldy	#CONTEXTLEN	;The first slot is always the main line SKIP
    530  28e4				   TaskLoop
    531  28e4		       b9 d8 36 	      lda	taskTable,y
    532  28e7		       f0 0b		      beq	TaskEmptyFnd
    533  28e9		       98		      tya
    534  28ea		       18		      clc
    535  28eb		       69 19		      adc	#CONTEXTLEN
    536  28ed		       a8		      tay
    537  28ee		       c0 fa		      cpy	#TASKTABLELEN
    538  28f0		       90 f2		      bcc	TaskLoop	; Y is never zero
    539  28f2				   TaskNoSlot
    540  28f2		       18		      clc
    541  28f3		       60		      rts
    542  28f4				   TaskEmptyFnd
    543  28f4		       38		      sec
    544  28f5		       60		      rts
    545  28f6							;====================================================
    546  28f6							; Set the task exit code called from the return command
    547  28f6							; on entry stack top hold exit value
    548  28f6				   TaskSetExitCode
    549  28f6		       98		      tya
    550  28f7		       48		      pha
    551  28f8		       20 dd 2c 	      jsr	popR0
    552  28fb		       a0 48		      ldy	#TASKEXITCODE
    553  28fd		       a5 52		      lda	R0
    554  28ff		       91 41		      sta	(VARIABLES),y
    555  2901		       c8		      iny
    556  2902		       a5 53		      lda	R0+1
    557  2904		       91 41		      sta	(VARIABLES),y
    558  2906		       68		      pla
    559  2907		       98		      tya
    560  2908		       60		      rts
    561  2909
    562  2909							;
    563  2909							;=====================================================
    564  2909							; Save Context Store the context to the TASK Table
    565  2909							; on entry y contains the task table entry to save to
    566  2909							; on exit y points to next task table entry
    567  2909							;	   x contains the number of bytes copied
    568  2909		       a2 00	   ContextSave ldx	#0
    569  290b		       c8		      iny		;inc past the task flags
    570  290c		       b5 41	   ContextSvLoop lda	CONTEXT,x
    571  290e		       99 d8 36 	      sta	taskTable,y
    572  2911		       c8		      iny
    573  2912		       e8		      inx
    574  2913		       e0 18		      cpx	#[CONTEXTLEN-1]
    575  2915		       90 f5		      bcc	ContextSvLoop
    576  2917		       60		      rts
    577  2918							;
    578  2918							; Load Context transfer context from task table to the Current Context
    579  2918							; on entry y contains the task table entry to transfer
    580  2918							; on exit y points to the original task table entry
    581  2918							;	   x contains the number of bytes copied
    582  2918		       98	   ContextLoad tya
    583  2919		       48		      pha
    584  291a		       a2 00		      ldx	#0
    585  291c		       c8		      iny		;inc past the task flags
    586  291d		       b9 d8 36    ContextLDLoop lda	taskTable,y
    587  2920		       95 41		      sta	CONTEXT,x
    588  2922		       c8		      iny
    589  2923		       e8		      inx
    590  2924		       e0 18		      cpx	#[CONTEXTLEN-1]
    591  2926		       90 f5		      bcc	ContextLDLoop
    592  2928		       68		      pla
    593  2929		       a8		      tay
    594  292a		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  292b					      include	"ipc.asm"
      1  292b							;======================================================
      2  292b							; Inter process communications.
      3  292b							; Tasks may write/read integer messages among
      4  292b							; them selves.
      5  292b							; This uses each tasks gosub stack as a message queue
      6  292b							; Gosub calls start at the highest address and the
      7  292b							; msg queue starts at the highest address.
      8  292b							;
      9  292b							;======================================================
     10  292b							; ipcs   - Send msg to another task or many tasks
     11  292b							; on entry  math stack contains the  top PID
     12  292b							;				      2ND Message value
     13  292b							; on exit   math stack contain top True-good or False-failed
     14  292b							;
     15  292b							; it may not be sent if queue is full
     16  292b							;
     17  292b							; a = ipcs(<message-expression>,<task PID-expression>)
     18  292b							;
     19  292b				   iIPCS
     20  292b		       98		      tya
     21  292c		       48		      pha
     22  292d		       20 94 29 	      jsr	ipc_enqueue
     23  2930		       b0 08		      bcs	iIPC_BAD
     24  2932		       20 0e 2f 	      jsr	pushTrue
     25  2935		       68		      pla
     26  2936		       a8		      tay
     27  2937		       4c b1 02 	      jmp	NextIL
     28  293a				   iIPC_BAD
     29  293a		       68		      pla
     30  293b		       a8		      tay
     31  293c		       20 18 2f 	      jsr	pushFalse
     32  293f		       4c b1 02 	      jmp	NextIL
     33  2942
     34  2942							;======================================================
     35  2942							; ipcr   - Recieve msg from task
     36  2942							; on exit  the message value is returned from message queue
     37  2942							;	    message -1	is reserved meaning no entry found
     38  2942							; The provided variable contains the pid of the sending
     39  2942							; task. This is optional. This always waits for a message
     40  2942							; before returning.
     41  2942							;
     42  2942							; a = ipcr(<variable name>)
     43  2942							;
     44  2942				   iIPCR
     45  2942		       98		      tya
     46  2943		       48		      pha
     47  2944		       20 d6 29 	      jsr	ipc_dequeue
     48  2947		       b0 05		      bcs	iIPCR_Q_Empty
     49  2949		       68		      pla
     50  294a		       a8		      tay
     51  294b		       4c b1 02 	      jmp	NextIL
     52  294e				   iIPCR_Q_Empty
     53  294e		       68		      pla
     54  294f		       a8		      tay
     55  2950		       20 0e 2f 	      jsr	pushTrue	; puts -1 on the stack
     56  2953		       4c b1 02 	      jmp	NextIL
     57  2956
     58  2956							;=======================================================
     59  2956							; ipcc   - Check if message available
     60  2956							; on exit  Stack contains number of messages
     61  2956							;
     62  2956							; a = ipcc()
     63  2956							;
     64  2956				   iIPCC
     65  2956		       98		      tya
     66  2957		       48		      pha
     67  2958		       20 81 29 	      jsr	ipc_queue_count
     68  295b		       20 4b 2c 	      jsr	pushR0	; return the count
     69  295e		       68		      pla
     70  295f		       a8		      tay
     71  2960		       4c b1 02 	      jmp	NextIL
     72  2963
     73  2963							;=======================================================
     74  2963							;ipcio    Turns on the tasks wait ips if nothing in queue
     75  2963				   iIPCIO
     76  2963		       98		      tya
     77  2964		       48		      pha
     78  2965		       20 81 29 	      jsr	ipc_queue_count
     79  2968		       a5 52		      lda	R0
     80  296a		       d0 10		      bne	iIPCIO_No_Halt
     81  296c		       a9 01		      lda	#1
     82  296e		       8d d2 37 	      sta	taskCurrentCycles	; force a task switch
     83  2971		       a9 01		      lda	#TASKWAITIPC
     84  2973		       ac d7 36 	      ldy	taskPtr
     85  2976		       19 d8 36 	      ora	taskTable,y
     86  2979		       99 d8 36 	      sta	taskTable,y
     87  297c
     88  297c				   iIPCIO_No_Halt
     89  297c		       68		      pla
     90  297d		       a8		      tay
     91  297e		       4c b1 02 	      jmp	NextIL
     92  2981							;======================================================
     93  2981							;ipc_queue_count returns number of entries on the queue
     94  2981							; waiting to be recieved
     95  2981							;======================================================
     96  2981				   ipc_queue_count
     97  2981		       a5 4e		      lda	MESSAGEPTR
     98  2983		       18		      clc
     99  2984		       4a		      lsr		; divide by 4
    100  2985		       4a		      lsr
    101  2986		       85 52		      sta	R0	; store into R0
    102  2988		       a9 10		      lda	#GOSUBSTACKSIZE
    103  298a		       38		      sec
    104  298b		       e5 52		      sbc	R0	; Get how many entries on queue
    105  298d		       85 52		      sta	R0
    106  298f		       a9 00		      lda	#0
    107  2991		       85 53		      sta	R0+1
    108  2993		       60		      rts
    109  2994							;=======================================================
    110  2994							; Support functions for messaging
    111  2994							;
    112  2994							; Enqueue message -> onto PID's MSG Q
    113  2994							; on entry top of stack contains the PID
    114  2994							;	    second contains the Message of the task
    115  2994							; on exit contains c set if failed
    116  2994							;		    c cleared if success
    117  2994							;		    PID's MSG Q PTR points to the message
    118  2994							;===========================================================
    119  2994				   ipc_enqueue
    120  2994		       20 f5 2c 	      jsr	popR1	; Get the pid
    121  2997		       20 0f 2a 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    122  299a
    123  299a		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    124  299c		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    125  299e		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    126  29a0		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    127  29a2		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    128  29a4
    129  29a4
    130  29a4							; Get the PID'S stack address into R0
    131  29a4		       a0 0b		      ldy	#GOSUBSTKPOS
    132  29a6		       b1 56		      lda	(MQ),y
    133  29a8		       85 52		      sta	R0
    134  29aa		       c8		      iny
    135  29ab		       b1 56		      lda	(MQ),y
    136  29ad		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    137  29af
    138  29af							; Set y to point to the msg q entry
    139  29af		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    140  29b1		       b1 56		      lda	(MQ),y	; Get the index
    141  29b3		       a8		      tay		; Set y to queue offset
    142  29b4
    143  29b4							; enqueue the message
    144  29b4		       88		      dey		; First byte to save to
    145  29b5		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    146  29b7		       91 52		      sta	(R0),y	; Set the entry type
    147  29b9
    148  29b9		       88		      dey
    149  29ba		       ad d7 36 	      lda	taskPtr	; Store the PID into queue
    150  29bd		       91 52		      sta	(R0),y
    151  29bf		       20 f5 2c 	      jsr	popR1	; Get the actual message value
    152  29c2		       20 43 2a 	      jsr	ipc_pushR1	; Store Message value into queue
    153  29c5
    154  29c5		       98		      tya		; Save the new q ptr
    155  29c6		       a0 0e		      ldy	#MSGPTRPOS
    156  29c8		       91 56		      sta	(MQ),y	; Update the message stack pointer
    157  29ca		       a0 00		      ldy	#0	; points to context root
    158  29cc		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    159  29ce		       51 56		      eor	(MQ),y	; Turn off the bit
    160  29d0		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    161  29d2		       18		      clc
    162  29d3		       60		      rts
    163  29d4				   ipc_enq_full
    164  29d4		       38		      sec
    165  29d5		       60		      rts
    166  29d6							;=============================================================
    167  29d6							; De-queue for message stack -> local tasks msg q
    168  29d6							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    169  29d6							;  message into
    170  29d6							;  on exit   math stack contains value of message
    171  29d6							;				  Variable if provided is pid
    172  29d6				   ipc_dequeue
    173  29d6		       20 0c 2d 	      jsr	popMQ	; Variable address to put PID into
    174  29d9
    175  29d9		       a4 4e		      ldy	MESSAGEPTR
    176  29db		       c0 38		      cpy	#[[GOSUBSTACKSIZE - 2] * 4]	; see if anything to pop from stack
    177  29dd		       b0 2e		      bcs	ipc_deq_empty
    178  29df		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    179  29e1		       85 52		      sta	R0
    180  29e3		       c8		      iny
    181  29e4		       b1 4b		      lda	(GOSUBSTACK),y
    182  29e6		       85 53		      sta	R0+1
    183  29e8		       c8		      iny
    184  29e9		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    185  29eb		       85 54		      sta	R1
    186  29ed		       c8		      iny
    187  29ee		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    188  29f0		       c8		      iny
    189  29f1		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    190  29f3
    191  29f3		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    192  29f5		       d0 16		      bne	ipc_deq_empty
    193  29f7
    194  29f7		       20 4b 2c 	      jsr	pushR0	; place value on stack
    195  29fa
    196  29fa		       a5 56		      lda	MQ
    197  29fc		       05 57		      ora	MQ+1
    198  29fe		       f0 0b		      beq	ipc_deq_done
    199  2a00		       a5 54		      lda	R1
    200  2a02		       a0 00		      ldy	#0
    201  2a04		       91 56		      sta	(MQ),y
    202  2a06		       c8		      iny
    203  2a07		       a9 00		      lda	#0
    204  2a09		       91 56		      sta	(MQ),y
    205  2a0b				   ipc_deq_done
    206  2a0b		       18		      clc
    207  2a0c		       60		      rts
    208  2a0d
    209  2a0d				   ipc_deq_empty
    210  2a0d		       38		      sec
    211  2a0e		       60		      rts
    212  2a0f
    213  2a0f							;=============================================
    214  2a0f							;  Get the context address into MQ from R1 with
    215  2a0f							;  context/index/pid
    216  2a0f				   ipc_getcontext
    217  2a0f		       18		      clc		; Get pointer to Task context
    218  2a10		       a9 d8		      lda	#taskTable&$FF	; change ptr to address
    219  2a12		       65 54		      adc	R1
    220  2a14		       85 56		      sta	MQ
    221  2a16		       a9 36		      lda	#taskTable>>8
    222  2a18		       65 55		      adc	R1+1
    223  2a1a		       85 57		      sta	MQ+1	; We now have a pointer into the context
    224  2a1c		       60		      rts
    225  2a1d							;
    226  2a1d							;==============================================
    227  2a1d							; on entry R1 has a context value,
    228  2a1d							; on exit c is set if fails
    229  2a1d							;
    230  2a1d				   ipc_CONTEXTVALUES
      0  2a1d					      db	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      1  2a1d		       00 19 32 4b	      .byte.b	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      0  2a21					      db	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      1  2a21		       64 7d 96 af	      .byte.b	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      0  2a25					      db	(CONTEXTLEN*8),(CONTEXTLEN*9)
      1  2a25		       c8 e1		      .byte.b	(CONTEXTLEN*8),(CONTEXTLEN*9)
    234  2a27
    235  2a27				   ipc_ValidateContext
    236  2a27		       48		      pha
    237  2a28		       8a		      txa
    238  2a29		       48		      pha
    239  2a2a		       a5 55		      lda	R1+1
    240  2a2c		       d0 0e		      bne	ipc_Validate_Fail
    241  2a2e		       a2 00		      ldx	#0
    242  2a30		       a5 54		      lda	R1
    243  2a32				   ipc_ValidateLoop
    244  2a32		       dd 1d 2a 	      cmp	ipc_CONTEXTVALUES,x
    245  2a35		       f0 09		      beq	ipc_Valid_Context
    246  2a37		       e8		      inx
    247  2a38		       e0 0a		      cpx	#TASKCOUNT
    248  2a3a		       90 f6		      bcc	ipc_ValidateLoop
    249  2a3c
    250  2a3c				   ipc_Validate_Fail
    251  2a3c		       68		      pla
    252  2a3d		       aa		      tax
    253  2a3e		       68		      pla
    254  2a3f		       60		      rts
    255  2a40
    256  2a40				   ipc_Valid_Context
    257  2a40		       18		      clc
    258  2a41		       90 f9		      bcc	ipc_Validate_Fail
    259  2a43							;
    260  2a43							;==============================================
    261  2a43							;Push R1 onto the stack
    262  2a43							;on entry y = next entry
    263  2a43							;R0 points to the stack space
    264  2a43							;on exit y points to next free byte
    265  2a43				   ipc_pushR1
    266  2a43		       88		      dey
    267  2a44		       a5 55		      lda	R1+1	; PID first
    268  2a46		       91 52		      sta	(R0),y
    269  2a48		       88		      dey
    270  2a49		       a5 54		      lda	R1
    271  2a4b		       91 52		      sta	(R0),y
    272  2a4d		       60		      rts
    273  2a4e
    274  2a4e
    275  2a4e
    276  2a4e
    277  2a4e
    278  2a4e
    279  2a4e
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  2a4e					      include	"support.asm"
      1  2a4e							;
      2  2a4e							;=====================================================
      3  2a4e							;=====================================================
      4  2a4e							;=====================================================
      5  2a4e							; This marks the start of support functions used by
      6  2a4e							; the IL opcodes.  These are support functions, NOT
      7  2a4e							; the IL code.
      8  2a4e							;=====================================================
      9  2a4e							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  2a4e							;=====================================================
     11  2a4e					      Seg	Code
     12  2a4e							;=====================================================
     13  2a4e							; This gets the next two bytes pointed to by ILPC and
     14  2a4e							; returns them; X contains LSB, A contains MSB.  ILPC
     15  2a4e							; is advanced by two, and Y contains 0 on return.
     16  2a4e
     17  2a4e							;
     18  2a4e		       20 52 2a    getILWord  jsr	getILByte	;LSB
     19  2a51		       aa		      tax
     20  2a52							;
     21  2a52							;=====================================================
     22  2a52							; This gets the next byte pointed to by ILPC and
     23  2a52							; returns it in A.  On return, X is unchanged but Y
     24  2a52							; contains 0.
     25  2a52							;
     26  2a52		       a0 00	   getILByte  ldy	#0
     27  2a54		       b1 43		      lda	(ILPC),y	;get byte
     28  2a56		       08		      php		;save status
     29  2a57		       e6 43		      inc	ILPC	;inc LSB
     30  2a59		       d0 02		      bne	getILb2	;branch if no overflow
     31  2a5b		       e6 44		      inc	ILPC+1	;inc MSB
     32  2a5d		       28	   getILb2    plp		;restore status
     33  2a5e		       60		      rts
     34  2a5f							;
     35  2a5f							;=====================================================
     36  2a5f							; Decrement ILPC by one.
     37  2a5f							;
     38  2a5f		       a5 43	   decIL      lda	ILPC
     39  2a61		       d0 02		      bne	decIL2
     40  2a63		       c6 44		      dec	ILPC+1
     41  2a65		       c6 43	   decIL2     dec	ILPC
     42  2a67		       60		      rts
     43  2a68							;
     44  2a68							;=====================================================
     45  2a68							; Push the ILPC onto the return stack.  Actually, this
     46  2a68							; pushes the address of ILPC+2 since that's the next
     47  2a68							; address to execute.
     48  2a68							;
     49  2a68		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  2a6a		       c0 64		      cpy	#ILSTACKSIZE<<1
     51  2a6c		       b0 15		      bcs	pushErr
     52  2a6e		       a5 43		      lda	ILPC
     53  2a70		       18		      clc
     54  2a71		       69 02		      adc	#2
     55  2a73		       91 45		      sta	(ILSTACK),y
     56  2a75		       08		      php		;save C bit
     57  2a76		       c8		      iny
     58  2a77		       a5 44		      lda	ILPC+1
     59  2a79		       28		      plp		;restore C
     60  2a7a		       69 00		      adc	#0
     61  2a7c		       91 45		      sta	(ILSTACK),y
     62  2a7e		       c8		      iny
     63  2a7f		       84 47		      sty	ILSTACKPTR
     64  2a81		       18		      clc
     65  2a82		       60		      rts
     66  2a83				   pushErr
     67  2a83		       38		      sec
     68  2a84		       60		      rts
     69  2a85							;
     70  2a85							;=====================================================
     71  2a85							; Pull the top entry from return stack and put into
     72  2a85							; ILPC.
     73  2a85							;
     74  2a85		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  2a87		       f0 fa		      beq	pushErr
     76  2a89		       88		      dey
     77  2a8a		       b1 45		      lda	(ILSTACK),y
     78  2a8c		       85 44		      sta	ILPC+1
     79  2a8e		       88		      dey
     80  2a8f		       b1 45		      lda	(ILSTACK),y
     81  2a91		       85 43		      sta	ILPC
     82  2a93		       84 47		      sty	ILSTACKPTR
     83  2a95		       18		      clc
     84  2a96		       60		      rts
     85  2a97							;
     86  2a97							;=====================================================
     87  2a97							; This searches for a specific line number that is in
     88  2a97							; R0.	There are three possible return conditions:
     89  2a97							; Line numbers are now the third byte, the first byte is now
     90  2a97							; a pointer to the next line, of course no longer than 255 byte
     91  2a97							; per line.
     92  2a97							;
     93  2a97							; Exact match was found:
     94  2a97							;    * Z set
     95  2a97							;    * CURPTR points to two-byte line number for that
     96  2a97							;	line.
     97  2a97							;
     98  2a97							; Next highest line found:
     99  2a97							;    * Z cleared
    100  2a97							;    * C set
    101  2a97							;    * CURPTR points to two-byte line number for that
    102  2a97							;	line.
    103  2a97							;
    104  2a97							; End of program reached:
    105  2a97							;    * Z cleared
    106  2a97							;    * C cleared
    107  2a97							;    * CURPTR points to first free byte at end of
    108  2a97							;	program.  Ie, it has save value as PROGRAMEND.
    109  2a97							;
    110  2a97							; A, X, and Y are all undefined on return.
    111  2a97							;
    112  2a97
    113  2a97				   findLine
    114  2a97		       ad 50 43 	      lda	ProgramStart	;Start of program -> CURPTR
    115  2a9a		       85 4f		      sta	CURPTR
    116  2a9c		       ad 51 43 	      lda	ProgramStart+1
    117  2a9f		       85 50		      sta	CURPTR+1
    118  2aa1							;
    119  2aa1							; At end of code?
    120  2aa1							;
    121  2aa1				   iXFER1
    122  2aa1		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  2aa3		       cd 52 43 	      cmp	ProgramEnd	; at end of program then stop run
    124  2aa6		       d0 0b		      bne	xfer2	; not end
    125  2aa8		       a5 50		      lda	CURPTR+1
    126  2aaa		       cd 53 43 	      cmp	ProgramEnd+1
    127  2aad		       d0 04		      bne	xfer2	;Not at end
    128  2aaf							;
    129  2aaf							; Line not found and the end of the program was
    130  2aaf							; reached.  Return Z and C both clear.
    131  2aaf							;
    132  2aaf		       a9 01		      lda	#1	;clear Z
    133  2ab1		       18		      clc		;clear C
    134  2ab2		       60		      rts
    135  2ab3							;
    136  2ab3							; Check for an exact line number match
    137  2ab3							;
    138  2ab3		       a5 52	   xfer2      lda	R0
    139  2ab5		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  2ab7		       d1 4f		      cmp	(CURPTR),y
    141  2ab9		       d0 08		      bne	xfernotit
    142  2abb		       c8		      iny
    143  2abc		       a5 53		      lda	R0+1
    144  2abe		       d1 4f		      cmp	(CURPTR),y
    145  2ac0		       d0 01		      bne	xfernotit	; not a matching line number
    146  2ac2							;
    147  2ac2							; This is exactly the line we want.
    148  2ac2							;
    149  2ac2		       60		      rts		;it matches exactly
    150  2ac3							;
    151  2ac3							; See if this line is greater than the one we're
    152  2ac3							; searching for.
    153  2ac3							;
    154  2ac3		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and least significat digit
    155  2ac5		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  2ac7		       c5 53		      cmp	R0+1
    157  2ac9		       90 0b		      bcc	xfer3
    158  2acb		       d0 07		      bne	xfer4
    159  2acd		       88		      dey
    160  2ace		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  2ad0		       c5 52		      cmp	R0
    162  2ad2		       90 02		      bcc	xfer3
    163  2ad4							;
    164  2ad4							; This line is greater than the one we want, so
    165  2ad4							; return Z clear and C set.
    166  2ad4							;
    167  2ad4		       38	   xfer4      sec		;We found a line number greater
    168  2ad5		       60		      rts		;both conditions set
    169  2ad6							;
    170  2ad6							; Not the line (or droid) we're looking for.  Move to
    171  2ad6							; the next line.
    172  2ad6							;
    173  2ad6		       20 dc 2a    xfer3      jsr	FindNextLine
    174  2ad9		       4c a1 2a 	      jmp	iXFER1
    175  2adc							;
    176  2adc							;=====================================================
    177  2adc							; This advances CURPTR to the next line.  If there
    178  2adc							; are no more lines, this leaves CURPTR equal to
    179  2adc							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  2adc							; CURPTR is pointing to a valid line on entry.  This
    181  2adc							; pointer points to the two-byte line number.
    182  2adc							; Update this points to the 1 byte line length  ****************
    183  2adc							;
    184  2adc				   FindNextLine
    185  2adc		       a0 03		      ldy	#3	;skip line number and length byte
    186  2ade		       84 51		      sty	CUROFF	;this is the new offset
    187  2ae0		       a0 00		      ldy	#0
    188  2ae2		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  2ae4		       18		      clc
    190  2ae5		       65 4f		      adc	CURPTR
    191  2ae7		       85 4f		      sta	CURPTR
    192  2ae9		       a5 50		      lda	CURPTR+1
    193  2aeb		       69 00		      adc	#0
    194  2aed		       85 50		      sta	CURPTR+1
    195  2aef		       60	   FindNext4  rts
    196  2af0							;
    197  2af0							;=====================================================
    198  2af0							; This compares CURPTR to PROGRAMEND and returns Z set
    199  2af0							; if they are equal, Z clear if not.
    200  2af0							;
    201  2af0		       a5 4f	   AtEnd      lda	CURPTR
    202  2af2		       cd 52 43 	      cmp	ProgramEnd
    203  2af5		       d0 05		      bne	atendexit
    204  2af7		       a5 50		      lda	CURPTR+1
    205  2af9		       cd 53 43 	      cmp	ProgramEnd+1
    206  2afc		       60	   atendexit  rts
    207  2afd							;
    208  2afd
    209  2afd							;
    210  2afd							;=====================================================
    211  2afd							; Convert an ASCII string to a number.  On input,
    212  2afd							; (CURPTR),Y points to the first digit.  This gets
    213  2afd							; digit-by-digit until finding a non-number.  Returns
    214  2afd							; Y pointing to the non-digit, and R0 contains the
    215  2afd							; number.  This does NOT check for valid ranges, so
    216  2afd							; a value like "123456789" will produce something,
    217  2afd							; but not what you had expected.
    218  2afd							;
    219  2afd		       a9 00	   getDecimal lda	#0
    220  2aff		       85 52		      sta	R0
    221  2b01		       85 53		      sta	R0+1
    222  2b03		       85 59		      sta	dpl	;temporary negative flag
    223  2b05							;
    224  2b05							; See if it's negative...
    225  2b05							;
    226  2b05							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    227  2b05		       b1 4f		      lda	(CURPTR),y
    228  2b07		       c9 2d		      cmp	#'-
    229  2b09		       d0 02		      bne	getDecLoop
    230  2b0b		       e6 59		      inc	dpl	;it's negative
    231  2b0d							;
    232  2b0d		       b1 4f	   getDecLoop lda	(CURPTR),y
    233  2b0f		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    234  2b11		       c9 30		      cmp	#'0
    235  2b13		       90 36		      bcc	getDdone
    236  2b15		       c9 3a		      cmp	#'9+1
    237  2b17		       b0 32		      bcs	getDdone
    238  2b19		       38		      sec
    239  2b1a		       e9 30		      sbc	#'0	;convert to binary
    240  2b1c		       48		      pha
    241  2b1d							;
    242  2b1d							; Now multiply R0 by 10.  Remember that
    243  2b1d							; 2*N + 8*N = 10*N.
    244  2b1d							;
    245  2b1d		       06 52		      asl	R0
    246  2b1f		       26 53		      rol	R0+1	;*2
    247  2b21		       a5 52		      lda	R0
    248  2b23		       85 54		      sta	R1
    249  2b25		       a5 53		      lda	R0+1
    250  2b27		       85 55		      sta	R1+1
    251  2b29		       06 52		      asl	R0
    252  2b2b		       26 53		      rol	R0+1	;*4
    253  2b2d		       06 52		      asl	R0
    254  2b2f		       26 53		      rol	R0+1	;*8
    255  2b31		       18		      clc		;now add the partial sums...
    256  2b32		       a5 52		      lda	R0	;...to get *10
    257  2b34		       65 54		      adc	R1
    258  2b36		       85 52		      sta	R0
    259  2b38		       a5 53		      lda	R0+1
    260  2b3a		       65 55		      adc	R1+1
    261  2b3c		       85 53		      sta	R0+1
    262  2b3e							;
    263  2b3e							; Add in the new digit
    264  2b3e							;
    265  2b3e		       68		      pla
    266  2b3f		       18		      clc
    267  2b40		       65 52		      adc	R0
    268  2b42		       85 52		      sta	R0
    269  2b44		       90 02		      bcc	getD2
    270  2b46		       e6 53		      inc	R0+1
    271  2b48							;
    272  2b48							; Move to next character
    273  2b48							;
    274  2b48		       c8	   getD2      iny
    275  2b49		       d0 c2		      bne	getDecLoop
    276  2b4b							;
    277  2b4b							; All done with digits, so now deal with it being
    278  2b4b							; negative.  If zero, then don't check for negative
    279  2b4b							; flag.  Ie, -0 is stored as 0.
    280  2b4b							;
    281  2b4b		       a5 52	   getDdone   lda	R0
    282  2b4d		       05 53		      ora	R0+1
    283  2b4f		       f0 16		      beq	getDone2	;zero
    284  2b51		       a5 59		      lda	dpl
    285  2b53		       f0 12		      beq	getDone2	;positive
    286  2b55							;
    287  2b55							; Invert all the bits, then add one.
    288  2b55							;
    289  2b55		       a5 52		      lda	R0
    290  2b57		       49 ff		      eor	#$ff
    291  2b59		       85 52		      sta	R0
    292  2b5b		       a5 53		      lda	R0+1
    293  2b5d		       49 ff		      eor	#$ff
    294  2b5f		       85 53		      sta	R0+1
    295  2b61							;
    296  2b61		       e6 52		      inc	R0
    297  2b63		       d0 02		      bne	getDone2
    298  2b65		       e6 53		      inc	R0+1
    299  2b67				   getDone2
    300  2b67							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    301  2b67							;lda	  R0
    302  2b67							;sta	  $0010
    303  2b67							;lda	  R0+1
    304  2b67							;sta	  $0011
    305  2b67							;lda	  dpl
    306  2b67							;sta	  $012
    307  2b67
    308  2b67		       60		      rts
    309  2b68
    310  2b68							;=====================================================
    311  2b68							; Gets a line of input into LINBUF.
    312  2b68							;
    313  2b68							; On entry:
    314  2b68							;    A contains the prompt character, or 0 if none.
    315  2b68							;    X = 1 Background read
    316  2b68							;    x = 0 Forground read with wait
    317  2b68							;
    318  2b68							; On exit:
    319  2b68							;    CURPTR points to LINBUF
    320  2b68							;    LINBUF contains the line with 0 at the end.
    321  2b68							;    Y has offset to first non-space character
    322  2b68							;    CURROFF has the same as Y.
    323  2b68							;
    324  2b68		       20 b7 2b    GetLine    jsr	ReadPrompt
    325  2b6b		       e0 00		      cpx	#0
    326  2b6d		       f0 14		      beq	GetLineRetry
    327  2b6f		       ae d7 36 	      ldx	taskPtr
    328  2b72		       bd d8 36 	      lda	taskTable,x
    329  2b75		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    330  2b77		       d0 3d		      bne	taskWaitingIO
    331  2b79		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    332  2b7b		       9d d8 36 	      sta	taskTable,x	;Mark the state for task as waiting io
    333  2b7e		       ce b6 2b 	      dec	taskWaitingIO	;Start polling the input and make task wait
    334  2b81		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    335  2b83
    336  2b83							;
    337  2b83							; Now read a line and wait for the CR
    338  2b83							;
    339  2b83				   GetLineRetry
    340  2b83		       a9 00		      lda	#0	;Wait for input to complete
    341  2b85		       20 cf 2b 	      jsr	ReadLine
    342  2b88
    343  2b88							;
    344  2b88							; Point to the line we just read
    345  2b88							; Set the current pointer to point to the input line
    346  2b88							;
    347  2b88		       a0 00	   ReadComplete ldy	#0
    348  2b8a		       84 51		      sty	CUROFF
    349  2b8c		       a2 b3		      ldx	#LINBUF&$ff
    350  2b8e		       86 4f		      stx	CURPTR
    351  2b90		       a2 42		      ldx	#LINBUF>>8
    352  2b92		       86 50		      stx	CURPTR+1
    353  2b94							;
    354  2b94							; Output a CR/LF
    355  2b94							;
    356  2b94		       20 96 2d 	      jsr	CRLF
    357  2b97							;
    358  2b97							; If a blank line, prompt again.
    359  2b97							;
    360  2b97		       20 8d 2d 	      jsr	SkipSpaces
    361  2b9a		       b1 4f		      lda	(CURPTR),y
    362  2b9c		       d0 10		      bne	GetLineDone	;We have data then exit
    363  2b9e		       20 ba 2b 	      jsr	ReadPromptRetry
    364  2ba1		       ae d7 36 	      ldx	taskPtr	;if this task is waiting for IO
    365  2ba4		       bd d8 36 	      lda	taskTable,x	;then get out, wait for line to
    366  2ba7		       29 40		      and	#TASKWAITIO	;Complete again
    367  2ba9		       d0 0b		      bne	taskWaitingIO
    368  2bab		       4c 83 2b 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    369  2bae
    370  2bae				   GetLineDone
    371  2bae		       ae d7 36 	      ldx	taskPtr
    372  2bb1		       a9 80		      lda	#TASKACTIVE
    373  2bb3		       9d d8 36 	      sta	taskTable,x	;IO is complete
    374  2bb6
    375  2bb6				   taskWaitingIO
    376  2bb6		       60		      rts
    377  2bb7
    378  2bb7							;
    379  2bb7							;=======================================================================
    380  2bb7							; Display the prompt character
    381  2bb7							; On entry
    382  2bb7							;	    A contains the prompt character
    383  2bb7							; On exit
    384  2bb7							;	    The readbuffer index is reset to 0
    385  2bb7							;
    386  2bb7		       8d 3a 43    ReadPrompt sta	promptChar
    387  2bba
    388  2bba							;
    389  2bba							; Prompt
    390  2bba							;
    391  2bba
    392  2bba		       ad 3a 43    ReadPromptRetry lda	promptChar
    393  2bbd		       09 00		      ora	#0	;any prompt?
    394  2bbf		       f0 08		      beq	getlinenp
    395  2bc1		       20 5e 1a 	      jsr	VOUTCH
    396  2bc4		       a9 20		      lda	#$20
    397  2bc6		       20 5e 1a 	      jsr	VOUTCH	;Space after prompt
    398  2bc9							;
    399  2bc9		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    400  2bcb		       8e 37 43 	      stx	getlinx
    401  2bce		       60		      rts
    402  2bcf							;
    403  2bcf							;===============================================================
    404  2bcf							; This fuction is the driver for the line input
    405  2bcf							; on call if a = 0 then it waits for all input
    406  2bcf							;	      a = 1 then nowait for input
    407  2bcf							; On exit
    408  2bcf							;		       c clear if not complete line
    409  2bcf							;		       c set if it was a complete line
    410  2bcf
    411  2bcf				   ReadLine
    412  2bcf		       8d 39 43 	      sta	inputNoWait
    413  2bd2		       c9 00		      cmp	#0
    414  2bd4		       f0 05		      beq	getline1
    415  2bd6		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    416  2bd9		       f0 2b		      beq	GetLineNoWait
    417  2bdb		       20 61 1a    getline1   jsr	VGETCH
    418  2bde					      if	CTMON65
    419  2bde		       48		      pha
    420  2bdf		       20 5e 1a 	      jsr	VOUTCH	;echo echo echo
    421  2be2		       68		      pla
    422  2be3					      endif
    423  2be3		       c9 0d		      cmp	#CR
    424  2be5		       f0 15		      beq	getlind	;end of line
    425  2be7		       c9 08		      cmp	#BS	;backspace?
    426  2be9		       f0 1d		      beq	getlinebs
    427  2beb		       ae 37 43 	      ldx	getlinx
    428  2bee		       9d b3 42 	      sta	LINBUF,x
    429  2bf1		       e8		      inx
    430  2bf2		       8e 37 43 	      stx	getlinx
    431  2bf5		       ad 39 43 	      lda	inputNoWait
    432  2bf8		       f0 e1		      beq	getline1
    433  2bfa		       d0 0a		      bne	GetLineNoWait
    434  2bfc							;
    435  2bfc							; CR was hit
    436  2bfc							;
    437  2bfc		       a9 00	   getlind    lda	#0	; set the end pf buffer
    438  2bfe		       ae 37 43 	      ldx	getlinx
    439  2c01		       9d b3 42 	      sta	LINBUF,x
    440  2c04
    441  2c04		       38		      sec		; Carry set then cr received
    442  2c05		       60		      rts
    443  2c06
    444  2c06				   GetLineNoWait
    445  2c06		       18		      clc		; Carry clear no end of line
    446  2c07		       60		      rts
    447  2c08							;
    448  2c08							; Backspace was hit
    449  2c08							;
    450  2c08		       ae 37 43    getlinebs  ldx	getlinx
    451  2c0b		       f0 0e		      beq	getlineEOL	;at start of line
    452  2c0d		       ca		      dex
    453  2c0e		       8e 37 43 	      stx	getlinx
    454  2c11		       20 b6 21    getlinepbs jsr	puts
      0  2c14					      db	27,"[K",0
      1  2c14		       1b 5b 4b 00	      .byte.b	27,"[K",0
    456  2c18		       4c db 2b 	      jmp	getline1
    457  2c1b		       a9 20	   getlineEOL lda	#SPACE
    458  2c1d		       20 5e 1a 	      jsr	VOUTCH
    459  2c20		       d0 ef		      bne	getlinepbs
    460  2c22							;
    461  2c22							;=====================================================
    462  2c22							; Count the length of the line currently in LINBUF
    463  2c22							; starting at offset Y.  Returns the length in X.  The
    464  2c22							; starting offset in Y should point past the ASCII
    465  2c22							; line number.  Also counts the trailing NULL and two
    466  2c22							; extra bytes for where the line number will be.
    467  2c22							; Update must now include leading length byte not the null at end ****************
    468  2c22							;
    469  2c22				   getLineLength
    470  2c22		       a2 00		      ldx	#0	;size
    471  2c24		       b9 b3 42    getLineL2  lda	LINBUF,y
    472  2c27		       f0 04		      beq	getLineL3
    473  2c29		       c8		      iny
    474  2c2a		       e8		      inx
    475  2c2b		       d0 f7		      bne	getLineL2
    476  2c2d		       e8	   getLineL3  inx		;count null at end
    477  2c2e		       e8		      inx		;line number LSB
    478  2c2f		       e8		      inx		;MSB
    479  2c30		       e8		      inx		;change: count new leading line length
    480  2c31		       8e 49 43 	      stx	lineLength
    481  2c34		       60		      rts
    482  2c35							;
    483  2c35							;=====================================================
    484  2c35							; Count the length of the line pointed to by CURPTR.
    485  2c35							; This also counts the line number and the terminating
    486  2c35							; null.  Ie, this string returns 8:
    487  2c35							;
    488  2c35							; <lineLow><lineHi>Hello<null>
    489  2c35							;
    490  2c35							; Another way of looking at it: add the return value
    491  2c35							; to the CURPTR and it'll point to the next line's
    492  2c35							; line number.  Returns the value in Y.
    493  2c35							; Update to ject get the leading byte length ********************
    494  2c35							;
    495  2c35							;getCURPTRLength
    496  2c35							;		ldy	CURPTR
    497  2c35							;		ldy	#3	;change: skip line number and leading length byte
    498  2c35							;getCLineL2	lda	(CURPTR),y
    499  2c35							;		beq	getCLineL3
    500  2c35							;		iny
    501  2c35							;		bne	getCLineL2
    502  2c35							;getCLineL3	iny		;count null at end
    503  2c35							;		rts
    504  2c35
    505  2c35							;
    506  2c35							;=====================================================
    507  2c35							; This saves ILPC.  This saves to a single save area,
    508  2c35							; so it can't be called more than once.
    509  2c35							;
    510  2c35		       a5 43	   saveIL     lda	ILPC
    511  2c37		       8d 45 43 	      sta	tempIL
    512  2c3a		       a5 44		      lda	ILPC+1
    513  2c3c		       8d 46 43 	      sta	tempIL+1
    514  2c3f		       60		      rts
    515  2c40							;
    516  2c40							;=====================================================
    517  2c40							; This restores ILPC.
    518  2c40							;
    519  2c40		       ad 45 43    restoreIL  lda	tempIL
    520  2c43		       85 43		      sta	ILPC
    521  2c45		       ad 46 43 	      lda	tempIL+1
    522  2c48		       85 44		      sta	ILPC+1
    523  2c4a		       60		      rts
    524  2c4b							;
    525  2c4b							;=====================================================
    526  2c4b							; This pushes R0 onto the stack.
    527  2c4b							;
    528  2c4b		       8c 40 43    pushR0     sty	rtemp1
    529  2c4e		       a4 4a		      ldy	MATHSTACKPTR
    530  2c50		       c0 28		      cpy	#MATHSTACKSIZE<<1
    531  2c52		       b0 38		      bcs	pusherr
    532  2c54		       a5 52		      lda	R0
    533  2c56		       91 48		      sta	(MATHSTACK),y
    534  2c58		       c8		      iny
    535  2c59		       a5 53		      lda	R0+1
    536  2c5b		       91 48		      sta	(MATHSTACK),y
    537  2c5d		       c8		      iny
    538  2c5e		       84 4a		      sty	MATHSTACKPTR
    539  2c60		       ac 40 43 	      ldy	rtemp1
    540  2c63		       18		      clc
    541  2c64		       60		      rts
    542  2c65
    543  2c65							;=====================================================
    544  2c65							; This pushes curptr basic current line onto the call stack.
    545  2c65							; and CUROFF. Also marks entry type as 1 = GOSUB
    546  2c65
    547  2c65				   pushLN
    548  2c65		       8d 41 43 	      STA	rtemp1+1	; Store type of push being done
    549  2c68		       8c 40 43 	      sty	rtemp1
    550  2c6b		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    551  2c6d		       c5 4d		      cmp	GOSUBSTACKPTR
    552  2c6f		       90 1b		      bcc	pusherr	; No error
    553  2c71		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    554  2c73		       a2 00		      ldx	#0	; Start of bytes to copy
    555  2c75				   pushLoop
    556  2c75		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    557  2c77		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    558  2c79		       c8		      iny		; Next destination
    559  2c7a		       e8		      inx		; Next Source byte
    560  2c7b		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    561  2c7d		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    562  2c7f
    563  2c7f		       ad 41 43    pushDone   lda	rtemp1+1	; Type of stack entry
    564  2c82		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    565  2c84		       c8		      iny		; Next entry
    566  2c85
    567  2c85		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    568  2c87		       ac 40 43 	      ldy	rtemp1
    569  2c8a		       18		      clc
    570  2c8b		       60		      rts
    571  2c8c				   pusherr
    572  2c8c		       38		      sec
    573  2c8d		       60		      rts
    574  2c8e							;=====================================================
    575  2c8e							; This pops Top Off gosub call Stack and
    576  2c8e							; places it in CURPTR/CUROFF.
    577  2c8e							; This checks if the type = 1 GOSUB
    578  2c8e							; if not it removes what ever is on the stack
    579  2c8e							; until it finds the next return. Allowing
    580  2c8e							; a return from within a for/next
    581  2c8e							; on exit a contains the type of return from, gosub_rtn, gosub_rtn_value....
    582  2c8e		       8c 40 43    popLN      sty	rtemp1
    583  2c91		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    584  2c93		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    585  2c95
    586  2c95				   popContinue
    587  2c95		       c0 04		      cpy	#4	; if less than 4 on stack then error
    588  2c97		       90 22		      bcc	poperr	; Process an error
    589  2c99
    590  2c99		       88		      dey		; Position to read entry type
    591  2c9a		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    592  2c9c		       8d 41 43 	      sta	rtemp1+1	; Save to be returned
    593  2c9f		       c9 01		      cmp	#GOSUB_RTN	; Type is a gosub entry
    594  2ca1		       f0 04		      beq	popLoop	; Restore the line
    595  2ca3		       c9 81		      cmp	#GOSUB_RTN_VALUE	; Also restore the line
    596  2ca5		       d0 16		      bne	popSkipEntry	; No then just skip this
    597  2ca7
    598  2ca7				   popLoop
    599  2ca7		       88		      dey
    600  2ca8		       ca		      dex
    601  2ca9		       b1 4b		      lda	(GOSUBSTACK),y
    602  2cab		       95 4f		      sta	CURPTR,x
    603  2cad		       e0 00		      cpx	#0
    604  2caf		       d0 f6		      bne	popLoop	; Loop until all moved
    605  2cb1
    606  2cb1
    607  2cb1		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    608  2cb3		       ac 40 43 	      ldy	rtemp1
    609  2cb6		       ad 41 43 	      lda	rtemp1+1	; get the type of return
    610  2cb9		       18		      clc
    611  2cba		       60		      rts
    612  2cbb
    613  2cbb		       38	   poperr     sec
    614  2cbc		       60		      rts
    615  2cbd
    616  2cbd		       88	   popSkipEntry dey
    617  2cbe		       88		      dey
    618  2cbf		       88		      dey
    619  2cc0		       4c 95 2c 	      jmp	popContinue
    620  2cc3
    621  2cc3							;
    622  2cc3							;=====================================================
    623  2cc3							; This pushes R1 onto the stack
    624  2cc3							;
    625  2cc3		       8c 40 43    pushR1     sty	rtemp1
    626  2cc6		       a4 4a		      ldy	MATHSTACKPTR
    627  2cc8		       c0 28		      cpy	#MATHSTACKSIZE<<1
    628  2cca		       b0 ef		      bcs	poperr
    629  2ccc		       a5 54		      lda	R1
    630  2cce		       91 48		      sta	(MATHSTACK),y
    631  2cd0		       c8		      iny
    632  2cd1		       a5 55		      lda	R1+1
    633  2cd3		       91 48		      sta	(MATHSTACK),y
    634  2cd5		       c8		      iny
    635  2cd6		       84 4a		      sty	MATHSTACKPTR
    636  2cd8		       ac 40 43 	      ldy	rtemp1
    637  2cdb		       18		      clc
    638  2cdc		       60		      rts
    639  2cdd							;
    640  2cdd							;=====================================================
    641  2cdd							; This pops Top Of Stack and places it in R0.
    642  2cdd							;
    643  2cdd		       8c 40 43    popR0      sty	rtemp1
    644  2ce0		       a4 4a		      ldy	MATHSTACKPTR
    645  2ce2		       f0 d7		      beq	poperr
    646  2ce4		       88		      dey
    647  2ce5		       b1 48		      lda	(MATHSTACK),y
    648  2ce7		       85 53		      sta	R0+1
    649  2ce9		       88		      dey
    650  2cea		       b1 48		      lda	(MATHSTACK),y
    651  2cec		       85 52		      sta	R0
    652  2cee		       84 4a		      sty	MATHSTACKPTR
    653  2cf0		       ac 40 43 	      ldy	rtemp1
    654  2cf3		       18		      clc
    655  2cf4		       60		      rts
    656  2cf5
    657  2cf5							;
    658  2cf5							;=====================================================
    659  2cf5							; This pops TOS and places it in R1.
    660  2cf5							;
    661  2cf5		       8c 40 43    popR1      sty	rtemp1
    662  2cf8		       a4 4a		      ldy	MATHSTACKPTR
    663  2cfa		       f0 bf		      beq	poperr
    664  2cfc		       88		      dey
    665  2cfd		       b1 48		      lda	(MATHSTACK),y
    666  2cff		       85 55		      sta	R1+1
    667  2d01		       88		      dey
    668  2d02		       b1 48		      lda	(MATHSTACK),y
    669  2d04		       85 54		      sta	R1
    670  2d06		       84 4a		      sty	MATHSTACKPTR
    671  2d08		       ac 40 43 	      ldy	rtemp1
    672  2d0b		       60		      rts
    673  2d0c							;
    674  2d0c							;=====================================================
    675  2d0c							; This pops TOS and places it in MQ.
    676  2d0c							;
    677  2d0c		       8c 40 43    popMQ      sty	rtemp1
    678  2d0f		       a4 4a		      ldy	MATHSTACKPTR
    679  2d11		       f0 a8		      beq	poperr
    680  2d13		       88		      dey
    681  2d14		       b1 48		      lda	(MATHSTACK),y
    682  2d16		       85 57		      sta	MQ+1
    683  2d18		       88		      dey
    684  2d19		       b1 48		      lda	(MATHSTACK),y
    685  2d1b		       85 56		      sta	MQ
    686  2d1d		       84 4a		      sty	MATHSTACKPTR
    687  2d1f		       ac 40 43 	      ldy	rtemp1
    688  2d22		       60		      rts
    689  2d23							;
    690  2d23							;=====================================================
    691  2d23							; This assists with multiplication and division by
    692  2d23							; looking at R0 and R1 and saving a flag as to what
    693  2d23							; sign the result will be.  Math is always done on
    694  2d23							; positive numbers, so this converts negative numbers
    695  2d23							; into positives.  On exit, R0 and R1 are both
    696  2d23							; positive.  If the signs were different then 'signs'
    697  2d23							; will be non-zero.
    698  2d23							;
    699  2d23		       a9 00	   SaveSigns  lda	#0
    700  2d25		       8d 3f 43 	      sta	sign	;assume positive
    701  2d28		       a5 53		      lda	R0+1	;MSB
    702  2d2a		       10 13		      bpl	SaveSigns1
    703  2d2c		       ee 3f 43 	      inc	sign	;it's negative
    704  2d2f		       49 ff		      eor	#$ff	;flip bits
    705  2d31		       85 53		      sta	R0+1
    706  2d33		       a5 52		      lda	R0
    707  2d35		       49 ff		      eor	#$ff
    708  2d37		       85 52		      sta	R0
    709  2d39		       e6 52		      inc	R0
    710  2d3b		       d0 02		      bne	SaveSigns1
    711  2d3d		       e6 53		      inc	R0+1
    712  2d3f		       a5 55	   SaveSigns1 lda	R1+1
    713  2d41		       10 1a		      bpl	SaveSigns2
    714  2d43		       48		      pha
    715  2d44		       ad 3f 43 	      lda	sign
    716  2d47		       49 01		      eor	#1
    717  2d49		       8d 3f 43 	      sta	sign
    718  2d4c		       68		      pla
    719  2d4d		       49 ff		      eor	#$ff	;flip bits
    720  2d4f		       85 55		      sta	R1+1
    721  2d51		       a5 54		      lda	R1
    722  2d53		       49 ff		      eor	#$ff
    723  2d55		       85 54		      sta	R1
    724  2d57		       e6 54		      inc	R1
    725  2d59		       d0 02		      bne	SaveSigns2
    726  2d5b		       e6 55		      inc	R1+1
    727  2d5d		       60	   SaveSigns2 rts
    728  2d5e							;
    729  2d5e							;=====================================================
    730  2d5e							; This looks at the value of 'signs' and will convert
    731  2d5e							; both R0 and R1 to negative if set.
    732  2d5e							;
    733  2d5e				   RestoreSigns
    734  2d5e		       ad 3f 43 	      lda	sign
    735  2d61		       f0 28		      beq	restoresigns2
    736  2d63							;
    737  2d63		       a5 52		      lda	R0
    738  2d65		       d0 02		      bne	restoresigns3
    739  2d67		       c6 53		      dec	R0+1
    740  2d69				   restoresigns3
    741  2d69		       c6 52		      dec	R0
    742  2d6b		       a5 52		      lda	R0
    743  2d6d		       49 ff		      eor	#$ff
    744  2d6f		       85 52		      sta	R0
    745  2d71		       a5 53		      lda	R0+1
    746  2d73		       49 ff		      eor	#$ff
    747  2d75		       85 53		      sta	R0+1
    748  2d77							;
    749  2d77		       a5 54		      lda	R1
    750  2d79		       d0 02		      bne	restoresigns4
    751  2d7b		       c6 55		      dec	R1+1
    752  2d7d				   restoresigns4
    753  2d7d		       c6 54		      dec	R1
    754  2d7f		       a5 54		      lda	R1
    755  2d81		       49 ff		      eor	#$ff
    756  2d83		       85 54		      sta	R1
    757  2d85		       a5 55		      lda	R1+1
    758  2d87		       49 ff		      eor	#$ff
    759  2d89		       85 55		      sta	R1+1
    760  2d8b							;
    761  2d8b				   restoresigns2
    762  2d8b		       60		      rts
    763  2d8c							;
    764  2d8c							;=====================================================
    765  2d8c							; Skip over spaces.  Returns Y with the offset to
    766  2d8c							; either the last character in the line, or the first
    767  2d8c							; non-space character.
    768  2d8c							;
    769  2d8c
    770  2d8c		       c8	   skipsp2    iny
    771  2d8d		       b1 4f	   SkipSpaces lda	(CURPTR),y
    772  2d8f		       f0 04		      beq	Skip3	;end of line
    773  2d91		       c9 20		      cmp	#SPACE
    774  2d93		       f0 f7		      beq	skipsp2
    775  2d95		       60	   Skip3      rts
    776  2d96							;*********************************************************
    777  2d96							; Output a CR/LF combination to the console.  Preserves
    778  2d96							; all registers.
    779  2d96							;
    780  2d96		       48	   tbcrlf     pha
    781  2d97		       a9 0d		      lda	#CR
    782  2d99		       20 5e 1a 	      jsr	VOUTCH
    783  2d9c		       a9 0a		      lda	#LF
    784  2d9e		       20 5e 1a 	      jsr	VOUTCH
    785  2da1		       68		      pla
    786  2da2		       60		      rts
    787  2da3							;
    788  2da3							;=====================================================
    789  2da3							; Some logic to print the Line of basic code being executed
    790  2da3		       24 40	   idbgBasic  bit	ILTrace
    791  2da5		       50 75		      bvc	dbgBasicNone
    792  2da7		       98		      tya
    793  2da8		       48		      pha
    794  2da9		       20 31 2f 	      jsr	SetOutDebug
    795  2dac
    796  2dac		       a5 4f		      lda	CURPTR
    797  2dae		       85 59		      sta	dpl
    798  2db0		       a5 50		      lda	CURPTR+1
    799  2db2		       85 5a		      sta	dpl+1
    800  2db4
    801  2db4		       20 4e 22 	      jsr	PrintProgramLine
    802  2db7
    803  2db7		       a5 40		      lda	ILTrace
    804  2db9		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    805  2dbb		       f0 5a		      beq	dbgBasicDone
    806  2dbd		       20 48 2f 	      jsr	SetInDebug
    807  2dc0		       20 b6 21 	      jsr	puts
      0  2dc3					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  2dc3		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    809  2e00				   dbgBasicLoop
    810  2e00		       20 61 1a 	      jsr	VGETCH
    811  2e03		       20 96 2d 	      jsr	CRLF
    812  2e06		       20 6c 2f 	      jsr	SetInDebugEnd
    813  2e09
    814  2e09		       c9 73		      cmp	#'s	; Quit program
    815  2e0b		       f0 12		      beq	dbgBasicStop
    816  2e0d
    817  2e0d		       c9 64		      cmp	#'d	; Display Variables
    818  2e0f		       d0 06		      bne	dbgBasicDone
    819  2e11
    820  2e11		       20 11 22 	      jsr	PrintAllVars
    821  2e14		       18		      clc
    822  2e15		       90 e9		      bcc	dbgBasicLoop	; Next char
    823  2e17
    824  2e17		       20 5f 2f    dbgBasicDone jsr	SetOutDebugEnd
    825  2e1a		       68		      pla
    826  2e1b		       a8		      tay
    827  2e1c		       4c b1 02    dbgBasicNone jmp	NextIL
    828  2e1f
    829  2e1f				   dbgBasicStop
    830  2e1f		       20 5f 2f 	      jsr	SetOutDebugEnd
    831  2e22		       68		      pla
    832  2e23		       a8		      tay
    833  2e24		       4c 02 06 	      jmp	iFIN
    834  2e27							;
    835  2e27							;=====================================================
    836  2e27							; This is some debug logic which displays the current
    837  2e27							; value of the ILPC and the line buffer.
    838  2e27							;
    839  2e27		       24 40	   dbgLine    bit	ILTrace
    840  2e29		       30 01		      bmi	dbgPrt
    841  2e2b		       60		      rts
    842  2e2c				   dbgPrt
    843  2e2c		       20 31 2f 	      jsr	SetOutDebug
    844  2e2f		       20 b6 21 	      jsr	puts
      0  2e32					      db	"ILPC:",0
      1  2e32		       49 4c 50 43*	      .byte.b	"ILPC:",0
    846  2e38		       a5 44		      lda	ILPC+1
    847  2e3a		       20 99 21 	      jsr	OUTHEX
    848  2e3d		       a5 43		      lda	ILPC
    849  2e3f		       20 99 21 	      jsr	OUTHEX
    850  2e42		       a9 20		      lda	#SPACE
    851  2e44		       20 5e 1a 	      jsr	VOUTCH
    852  2e47
    853  2e47		       a0 00		      ldy	#0
    854  2e49		       b1 43		      lda	(ILPC),y	;Get the il pcode value
    855  2e4b					      if	IL_DEBUG_TEXT
    856  2e4b		       20 14 19 	      jsr	PrintILText
    857  2e4e				  -	      else
    858  2e4e				  -	      jsr	OUTHEX
    859  2e4e					      endif
    860  2e4e		       20 b6 21 	      jsr	puts
      0  2e51					      db	" ILSP:",0
      1  2e51		       20 49 4c 53*	      .byte.b	" ILSP:",0
    862  2e58		       a5 47		      lda	ILSTACKPTR
    863  2e5a		       20 99 21 	      jsr	OUTHEX
    864  2e5d		       a9 20		      lda	#SPACE
    865  2e5f		       20 5e 1a 	      jsr	VOUTCH
    866  2e62
    867  2e62							; Display the CURPTR value and offset
    868  2e62							;
    869  2e62		       20 b6 21 	      jsr	puts
      0  2e65					      db	", CURPTR: ",0
      1  2e65		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    871  2e70		       a5 50		      lda	CURPTR+1
    872  2e72		       20 99 21 	      jsr	OUTHEX
    873  2e75		       a5 4f		      lda	CURPTR
    874  2e77		       20 99 21 	      jsr	OUTHEX
    875  2e7a		       a9 2b		      lda	#'+
    876  2e7c		       20 5e 1a 	      jsr	VOUTCH
    877  2e7f		       a5 51		      lda	CUROFF
    878  2e81		       20 99 21 	      jsr	OUTHEX
    879  2e84							;
    880  2e84		       20 96 2d 	      jsr	CRLF
    881  2e87		       20 5f 2f 	      jsr	SetOutDebugEnd
    882  2e8a		       20 bd 2e 	      jsr	ILChkRange
    883  2e8d		       b0 02		      bcs	dbgLineErr
    884  2e8f		       18		      clc
    885  2e90		       60		      rts
    886  2e91
    887  2e91				   dbgLineErr
    888  2e91		       20 31 2f 	      jsr	SetOutDebug
    889  2e94		       20 b6 21 	      jsr	puts
      0  2e97					      db	"Outside Valid IL Address Range",CR,LF,0
      1  2e97		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    891  2eb8		       20 5f 2f 	      jsr	SetOutDebugEnd
    892  2ebb		       38		      sec
    893  2ebc		       60		      rts
    894  2ebd
    895  2ebd		       a5 44	   ILChkRange lda	ILPC+1
    896  2ebf		       c9 32		      cmp	#IL>>8
    897  2ec1		       90 18		      bcc	ILBadRange
    898  2ec3		       d0 06		      bne	ILChkHigh
    899  2ec5
    900  2ec5		       a5 43		      lda	ILPC
    901  2ec7		       c9 1a		      cmp	#IL&$ff
    902  2ec9		       90 10		      bcc	ILBadRange
    903  2ecb
    904  2ecb		       a5 44	   ILChkHigh  lda	ILPC+1
    905  2ecd		       c9 36		      cmp	#ILEND>>8
    906  2ecf		       90 08		      bcc	ILGoodRange
    907  2ed1		       d0 08		      bne	ILBadRange
    908  2ed3
    909  2ed3		       a5 43		      lda	ILPC
    910  2ed5		       c9 84		      cmp	#ILEND&$ff
    911  2ed7		       b0 02		      bcs	ILBadRange
    912  2ed9
    913  2ed9		       18	   ILGoodRange clc
    914  2eda		       60		      rts
    915  2edb				   ILBadRange
    916  2edb		       38		      sec
    917  2edc		       60		      rts
    918  2edd
    919  2edd
    920  2edd							;=====================================================
    921  2edd							; Set output vector to the console output function
    922  2edd							;
    923  2edd				   SetOutConsole
    924  2edd		       48		      pha
    925  2ede		       a9 0c		      lda	#OUTCH&$ff
    926  2ee0		       8d 89 36 	      sta	BOutVec
    927  2ee3		       a9 f0		      lda	#OUTCH>>8
    928  2ee5		       8d 8a 36 	      sta	BOutVec+1
    929  2ee8		       68		      pla
    930  2ee9		       60		      rts
    931  2eea
    932  2eea				   SetInConsole
    933  2eea		       48		      pha
    934  2eeb		       a9 09		      lda	#GETCH&$ff
    935  2eed		       8d 87 36 	      sta	BInVec
    936  2ef0		       a9 f0		      lda	#GETCH>>8
    937  2ef2		       8d 88 36 	      sta	BInVec+1
    938  2ef5		       68		      pla
    939  2ef6		       60		      rts
    940  2ef7
    941  2ef7
    942  2ef7
    943  2ef7							;====================================================
    944  2ef7							;Clear the terminal assume it is ansii or vt100
    945  2ef7							;
    946  2ef7				   iCLEARSCREEN
    947  2ef7		       20 b6 21 	      jsr	puts
      0  2efa					      db	$1b,'[,'2,'J,$1b,'[,'1,';,'1,'H,$1b,'[,'?,'2,'5,'h,0
      1  2efa		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,$1b,'[,'1,';,'1,'H,$1b,'[,'?,'2,'5,'h,0
    949  2f0b		       4c b1 02 	      jmp	NextIL
    950  2f0e
    951  2f0e							;====================================================
    952  2f0e							; Push true and false onto math stack
    953  2f0e				   pushTrue
    954  2f0e		       a9 ff		      lda	#$ff
    955  2f10		       85 52	   pushTF     sta	R0
    956  2f12		       85 53		      sta	R0+1
    957  2f14		       20 4b 2c 	      jsr	pushR0
    958  2f17		       60		      rts
    959  2f18		       a9 00	   pushFalse  lda	#0
    960  2f1a		       f0 f4		      beq	pushTF
    961  2f1c
    962  2f1c							;======================================================
    963  2f1c							; Copy stack top to R1
    964  2f1c				   CopyStackR1
    965  2f1c		       98		      tya
    966  2f1d		       48		      pha
    967  2f1e		       a4 4a		      ldy	MATHSTACKPTR
    968  2f20		       88		      dey
    969  2f21		       b1 48		      lda	(MATHSTACK),y
    970  2f23		       85 55		      sta	R1+1
    971  2f25		       88		      dey
    972  2f26		       b1 48		      lda	(MATHSTACK),y
    973  2f28		       85 54		      sta	R1
    974  2f2a		       68		      pla
    975  2f2b		       a8		      tay
    976  2f2c		       60		      rts
    977  2f2d
    978  2f2d
    979  2f2d							;====================================================
    980  2f2d							;Swap the out debug call for standard calls
    981  2f2d		       00 00	   DebugIOSave ds	2
    982  2f2f		       00 00	   DebugInSave ds	2
    983  2f31				   SetOutDebug
    984  2f31		       ad 89 36 	      lda	BOutVec
    985  2f34		       8d 2d 2f 	      sta	DebugIOSave
    986  2f37		       ad 8a 36 	      lda	BOutVec+1
    987  2f3a		       8d 2e 2f 	      sta	DebugIOSave+1
    988  2f3d		       a9 c5		      lda	#OUTDEBUG&$ff	; Put the Debug output
    989  2f3f		       8d 89 36 	      sta	BOutVec
    990  2f42		       a9 2f		      lda	#OUTDEBUG>>8
    991  2f44		       8d 8a 36 	      sta	BOutVec+1
    992  2f47		       60		      rts
    993  2f48				   SetInDebug
    994  2f48		       ad 87 36 	      lda	BInVec
    995  2f4b		       8d 2f 2f 	      sta	DebugInSave
    996  2f4e		       ad 88 36 	      lda	BInVec+1
    997  2f51		       8d 30 2f 	      sta	DebugInSave+1
    998  2f54		       a9 c9		      lda	#INDEBUG&$ff
    999  2f56		       8d 87 36 	      sta	BInVec
   1000  2f59		       a9 2f		      lda	#INDEBUG>>8
   1001  2f5b		       8d 88 36 	      sta	BInVec+1
   1002  2f5e		       60		      rts
   1003  2f5f				   SetOutDebugEnd
   1004  2f5f		       ad 2d 2f 	      lda	DebugIOSave
   1005  2f62		       8d 89 36 	      sta	BOutVec
   1006  2f65		       ad 2e 2f 	      lda	DebugIOSave+1
   1007  2f68		       8d 8a 36 	      sta	BOutVec+1
   1008  2f6b		       60		      rts
   1009  2f6c				   SetInDebugEnd
   1010  2f6c		       ad 2f 2f 	      lda	DebugInSave
   1011  2f6f		       8d 87 36 	      sta	BInVec
   1012  2f72		       ad 30 2f 	      lda	DebugInSave+1
   1013  2f75		       8d 88 36 	      sta	BInVec+1
   1014  2f78		       60		      rts
   1015  2f79							;
   1016  2f79							;====================================================
   1017  2f79							; Set the input and output terminal address
   1018  2f79							; The math stack stack byte is the output io slot
   1019  2f79							; The math stack  is the input io slot
   1020  2f79
   1021  2f79				   iSetTerminal
   1022  2f79		       20 dd 2c 	      jsr	popR0	; Process the output io addresses
   1023  2f7c		       20 a6 2f 	      jsr	CalcSlot
   1024  2f7f		       a5 52		      lda	R0
   1025  2f81		       09 01		      ora	#1
   1026  2f83		       8d c6 2f 	      sta	TerminalOutputPort
   1027  2f86		       a5 53		      lda	R0+1
   1028  2f88		       8d c7 2f 	      sta	TerminalOutputPort+1
   1029  2f8b
   1030  2f8b		       20 dd 2c 	      jsr	popR0	; Process the input io address
   1031  2f8e		       20 a6 2f 	      jsr	CalcSlot
   1032  2f91		       a5 52		      lda	R0
   1033  2f93		       8d ca 2f 	      sta	TerminalStatusPort
   1034  2f96		       09 01		      ora	#1
   1035  2f98		       8d d1 2f 	      sta	TerminalInputPort
   1036  2f9b		       a5 53		      lda	R0+1
   1037  2f9d		       8d d2 2f 	      sta	TerminalInputPort+1
   1038  2fa0		       8d cb 2f 	      sta	TerminalStatusPort+1
   1039  2fa3		       4c b1 02 	      jmp	NextIL
   1040  2fa6
   1041  2fa6							;===================================================
   1042  2fa6							; Calculate the slot address the the slot number
   1043  2fa6							; R0 contains the slot number 0-255
   1044  2fa6
   1045  2fa6				   CalcSlot
   1046  2fa6		       8a		      txa
   1047  2fa7		       48		      pha
   1048  2fa8
   1049  2fa8		       a2 04		      ldx	#4
   1050  2faa				   CalcSlotLoop
   1051  2faa		       18		      clc
   1052  2fab		       26 52		      rol	R0
   1053  2fad		       26 53		      rol	R0+1
   1054  2faf		       ca		      dex
   1055  2fb0		       d0 f8		      bne	CalcSlotLoop
   1056  2fb2
   1057  2fb2		       a9 e0		      lda	#$E0
   1058  2fb4		       05 53		      ora	R0+1
   1059  2fb6		       85 53		      sta	R0+1
   1060  2fb8		       68		      pla
   1061  2fb9
   1062  2fb9		       aa		      tax
   1063  2fba		       60		      rts
   1064  2fbb							;
   1065  2fbb							;====================================================
   1066  2fbb							; Output to the Terminal/Debug console
   1067  2fbb							;     x = high address byte
   1068  2fbb							;     y = low address byte
   1069  2fbb							;     a = Terminator for string
   1070  2fbb				   TerminalWrite
   1071  2fbb				   DebugWrite
   1072  2fbb		       20 31 2f 	      jsr	SetOutDebug
   1073  2fbe		       20 f4 21 	      jsr	PrtStr
   1074  2fc1		       20 5f 2f 	      jsr	SetOutDebugEnd
   1075  2fc4		       60		      rts
   1076  2fc5
   1077  2fc5				   TerminalIOblock
   1078  2fc5				   OUTDEBUG
   1079  2fc5		       8d		      .byte.b	$8D	; STA
   1080  2fc6				   TerminalOutputPort
   1081  2fc6		       21 e0	   DEBUGPORT  .word.w	$E021	; Dont check anything just output the byte
   1082  2fc8		       60		      RTS
   1083  2fc9
   1084  2fc9				   TerminalRead
   1085  2fc9				   INDEBUG
   1086  2fc9		       ad		      .byte.b	$AD	; LDA
   1087  2fca				   TerminalStatusPort
   1088  2fca		       20 e0	   DEBUGPORTSTATUS .word.w	$E020
   1089  2fcc
   1090  2fcc		       29 01		      and	#$01
   1091  2fce		       f0 f9		      beq	INDEBUG
   1092  2fd0
   1093  2fd0		       ad		      .byte.b	$AD	; LDA
   1094  2fd1				   TerminalInputPort
   1095  2fd1		       21 e0	   DEBUGPORTIN .word.w	$E021
   1096  2fd3		       60		      rts
   1097  2fd4				   TerminalIOblockEnd
   1098  2fd4							;======================================================================
   1099  2fd4							;Copy Quoted string to buffer, terminate with 0 byte
   1100  2fd4							; R0  Source tring points to tString type
   1101  2fd4							; x is terminator
   1102  2fd4							; R1 points to destinition location
   1103  2fd4							; On exit R0 contains length of copy Plus Term and leading bytes
   1104  2fd4
   1105  2fd4				   qstrcpy
   1106  2fd4		       20 4b 2c 	      jsr	pushR0
   1107  2fd7		       20 24 30 	      jsr	IncR0	; point past the tString
   1108  2fda		       20 24 30 	      jsr	IncR0	; Point Past the opening "
   1109  2fdd		       a2 22		      ldx	#'"	; copy Termination
   1110  2fdf		       20 f9 2f 	      jsr	pstrcpy
   1111  2fe2		       20 24 30 	      jsr	IncR0	; point to "
   1112  2fe5		       20 24 30 	      jsr	IncR0	; Point to next free byte
   1113  2fe8		       20 f5 2c 	      jsr	popR1
   1114  2feb		       38		      sec
   1115  2fec		       a5 52		      lda	R0
   1116  2fee		       e5 54		      sbc	R1
   1117  2ff0		       85 52		      sta	R0
   1118  2ff2		       a5 53		      lda	R0+1
   1119  2ff4		       e5 55		      sbc	R1+1
   1120  2ff6		       85 53		      sta	R0+1
   1121  2ff8		       60		      rts
   1122  2ff9
   1123  2ff9							;=========================================================================
   1124  2ff9							;Copy string from R0 to R1, terminator in x
   1125  2ff9							; On exit    R0 contains the length of the copy
   1126  2ff9				   pstrcpy
   1127  2ff9		       a0 00		      ldy	#0
   1128  2ffb		       86 58		      stx	R2
   1129  2ffd
   1130  2ffd				   strcpyLoop
   1131  2ffd		       b1 52		      lda	(R0),y
   1132  2fff		       c5 58		      cmp	R2
   1133  3001		       f0 0a		      beq	strcpyDone
   1134  3003		       91 54		      sta	(R1),y
   1135  3005		       20 24 30 	      jsr	IncR0
   1136  3008		       20 12 30 	      jsr	IncR1
   1137  300b		       90 f0		      bcc	strcpyLoop
   1138  300d				   strcpyDone
   1139  300d		       a9 00		      lda	#0
   1140  300f		       91 54		      sta	(R1),y
   1141  3011
   1142  3011		       60		      rts
   1143  3012
   1144  3012							;=========================================================================
   1145  3012							; on exit c is set on overflow
   1146  3012				   IncR1
   1147  3012		       48		      pha
   1148  3013		       18		      clc
   1149  3014		       a9 01		      lda	#1
   1150  3016		       65 54		      adc	R1
   1151  3018		       85 54		      sta	R1
   1152  301a		       90 06		      bcc	IncR1Done
   1153  301c		       a9 00		      lda	#0
   1154  301e		       65 55		      adc	R1+1
   1155  3020		       85 55		      sta	R1+1
   1156  3022				   IncR1Done
   1157  3022		       68		      pla
   1158  3023		       60		      rts
   1159  3024							;=========================================================================
   1160  3024							; on exit c is set on overflow
   1161  3024				   IncR0
   1162  3024		       48		      pha
   1163  3025		       18		      clc
   1164  3026		       a9 01		      lda	#1
   1165  3028		       65 52		      adc	R0
   1166  302a		       85 52		      sta	R0
   1167  302c		       90 06		      bcc	IncR0Done
   1168  302e		       a9 00		      lda	#0
   1169  3030		       65 53		      adc	R0+1
   1170  3032		       85 53		      sta	R0+1
   1171  3034				   IncR0Done
   1172  3034		       68		      pla
   1173  3035		       60		      rts
   1174  3036
   1175  3036
   1176  3036
   1177  3036
   1178  3036
   1179  3036
   1180  3036
   1181  3036
   1182  3036
   1183  3036
   1184  3036
   1185  3036
   1186  3036
   1187  3036
   1188  3036
   1189  3036
------- FILE mytb.asm
   2481  3036
   2482  3036					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  3036					      include	"storage.asm"
      1  3036							;
      2  3036							;=====================================================
      3  3036							;=====================================================
      4  3036							;=====================================================
      5  3036							; This file contains the functions for saving and
      6  3036							; restoring programs from some sort of mass storage
      7  3036							; device.  This particular version is for using the
      8  3036							; Corsham Tech SD Card System.
      9  3036							;=====================================================
     10  3036							;=====================================================
     11  3036							;=====================================================
     12  3036
     13 U3695					      seg.u	TBData
     14 U3695		       00	   diskBufLength ds	1
     15 U3696		       00	   diskBufOffset ds	1
     16 U3697		       00 00 00 00*DiskFileName ds	64
     17 U36d7
     18  3036					      SEG	Code
     19  3036
     20  3036							;
     21  3036							;=====================================================
     22  3036							; Open a file for reading as a program.  The next
     23  3036							; thing on the line should be the filename.
     24  3036							;
     25  3036				   iOPENREAD
     26  3036					      if	XKIM || CTMON65
     27  3036		       20 50 30 	      jsr	setFileName	;Set the file name to open
     28  3039		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     29  303c		       90 07		      bcc	Ropenok	;branch if opened ok
     30  303e							;
     31  303e							; Open failed
     32  303e							;
     33  303e		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     34  3040		       a9 00	   Rdfail2    lda	#0
     35  3042		       4c 7d 06 	      jmp	iErr2
     36  3045							;
     37  3045							; Clear counts and offsets so the next read will
     38  3045							; cause the file to be read.
     39  3045							;
     40  3045		       a9 00	   Ropenok    lda	#0
     41  3047		       8d 96 36 	      sta	diskBufOffset
     42  304a		       8d 95 36 	      sta	diskBufLength
     43  304d		       4c b1 02 	      jmp	NextIL
     44  3050					      endif
     45  3050
     46  3050							;===============================================================
     47  3050							; Set file name
     48  3050				   setFileName
     49  3050		       a4 51		      ldy	CUROFF
     50  3052		       b1 4f		      lda	(CURPTR),y
     51  3054		       c9 a0		      cmp	#tString	;Must be a quoted string
     52  3056		       d0 24		      bne	setFileNameNotFound	;Must be a filename
     53  3058
     54  3058		       18		      clc
     55  3059		       98		      tya
     56  305a		       65 4f		      adc	CURPTR
     57  305c		       85 52		      sta	R0	;LSB
     58  305e		       a5 50		      lda	CURPTR+1
     59  3060		       69 00		      adc	#0
     60  3062		       85 53		      sta	R0+1
     61  3064		       a9 97		      lda	#DiskFileName&$ff
     62  3066		       85 54		      sta	R1
     63  3068		       a9 36		      lda	#DiskFileName>>8
     64  306a		       85 55		      sta	R1+1
     65  306c		       20 d4 2f 	      jsr	qstrcpy	; on exit R0 contains the total copy length index accross source not dest
     66  306f		       a5 52		      lda	R0
     67  3071		       18		      clc
     68  3072		       65 51		      adc	CUROFF	; add the current offset
     69  3074		       85 51		      sta	CUROFF	; Update the buffer pointer after complete
     70  3076				   ResetFileName
     71  3076		       a0 97		      ldy	#DiskFileName&$ff
     72  3078		       a2 36		      ldx	#DiskFileName>>8
     73  307a		       18		      clc
     74  307b		       60		      rts
     75  307c
     76  307c				   setFileNameNotFound
     77  307c		       68		      pla
     78  307d		       68		      pla		; remove the return address from the stack
     79  307e		       a9 00		      lda	#0
     80  3080		       a2 09		      ldx	#ERR_NO_FILENAME
     81  3082		       4c 7d 06 	      jmp	iErr2
     82  3085
     83  3085							;
     84  3085							;==============================JUSTLOSTINTIME 08/02/2022========
     85  3085							;Remove a file from the disk
     86  3085				   iRMFILE
     87  3085					      if	XKIM || CTMON65
     88  3085		       20 50 30 	      jsr	setFileName
     89  3088		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     90  308b		       90 07		      bcc	wrmOk	;branch if removed ok
     91  308d		       a9 00		      lda	#0
     92  308f		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     93  3091		       4c 7d 06 	      jmp	iErr2
     94  3094				   wrmOk
     95  3094		       4c b1 02 	      jmp	NextIL
     96  3097
     97  3097					      endif
     98  3097							;
     99  3097							;=====================================================
    100  3097				   iOPENWRITE
    101  3097					      if	XKIM || CTMON65
    102  3097		       20 50 30 	      jsr	setFileName
    103  309a		       20 52 2a 	      jsr	getILByte	;get the append or create byte
    104  309d		       c9 01		      cmp	#1	;create/truncate
    105  309f		       d0 06		      bne	iopencont
    106  30a1		       20 76 30 	      jsr	ResetFileName	;point back to the file name
    107  30a4		       20 45 f0 	      jsr	DiskRmFile	;by default files opened for write are append
    108  30a7
    109  30a7				   iopencont
    110  30a7		       20 76 30 	      jsr	ResetFileName	;point back to the file name
    111  30aa		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    112  30ad		       90 07		      bcc	Wopenok	;branch if opened ok
    113  30af							;
    114  30af							; Open failed
    115  30af							;
    116  30af		       a9 00	   Wdfail     lda	#0
    117  30b1		       a2 08		      ldx	#ERR_WRITE_FAIL
    118  30b3		       4c 7d 06 	      jmp	iErr2
    119  30b6							;
    120  30b6		       4c b1 02    Wopenok    jmp	NextIL
    121  30b9					      endif
    122  30b9							;
    123  30b9							;=====================================================
    124  30b9							; Gets a line of input from the disk file and puts it
    125  30b9							; into LINBUF.
    126  30b9							;
    127  30b9							; On exit:
    128  30b9							;    CURPTR points to LINBUF
    129  30b9							;    LINBUF contains the line with 0 at the end.
    130  30b9							;    Y has offset to first non-space character
    131  30b9							;    CURROFF has the same as Y.
    132  30b9							;
    133  30b9				   iDGETLINE
    134  30b9					      if	XKIM || CTMON65
    135  30b9		       a2 b3		      ldx	#LINBUF&$ff
    136  30bb		       86 4f		      stx	CURPTR
    137  30bd		       a2 42		      ldx	#LINBUF>>8
    138  30bf		       86 50		      stx	CURPTR+1
    139  30c1							;
    140  30c1		       a2 00		      ldx	#0	;offset
    141  30c3		       8e 37 43    iDgetLoop  stx	getlinx
    142  30c6		       20 31 31 	      jsr	getNextFileByte
    143  30c9		       b0 16		      bcs	iGetEOF
    144  30cb		       c9 0d		      cmp	#CR
    145  30cd		       f0 0d		      beq	iGetEOL
    146  30cf		       c9 0a		      cmp	#LF
    147  30d1		       f0 09		      beq	iGetEOL
    148  30d3		       ae 37 43 	      ldx	getlinx
    149  30d6		       9d b3 42 	      sta	LINBUF,x
    150  30d9		       e8		      inx
    151  30da		       d0 e7		      bne	iDgetLoop
    152  30dc							;
    153  30dc							; Handle end of line.	If the line has nothing, loop
    154  30dc							; back and get another line.
    155  30dc							;
    156  30dc		       ae 37 43    iGetEOL    ldx	getlinx	;blank line?
    157  30df		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    158  30e1							;
    159  30e1							; This can fall through when there is a line, or
    160  30e1							; called directly when EOF is encountered.
    161  30e1							;
    162  30e1		       ae 37 43    iGetEOF    ldx	getlinx
    163  30e4		       a9 00		      lda	#0
    164  30e6		       9d b3 42 	      sta	LINBUF,x
    165  30e9		       a0 00		      ldy	#0
    166  30eb		       20 8d 2d 	      jsr	SkipSpaces
    167  30ee		       20 59 1d 	      jsr	ParseInputLine
    168  30f1		       a9 56		      lda	#TOKENBUFFER&$ff
    169  30f3		       85 4f		      sta	CURPTR
    170  30f5		       a9 1c		      lda	#TOKENBUFFER>>8
    171  30f7		       85 50		      sta	CURPTR+1
    172  30f9		       a9 01		      lda	#1
    173  30fb		       85 51		      sta	CUROFF
    174  30fd		       4c b1 02 	      jmp	NextIL
    175  3100					      endif
    176  3100
    177  3100							;
    178  3100							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    179  3100							; DISK
    180  3100							;
    181  3100				   iDDIR
    182  3100					      if	XKIM || CTMON65
    183  3100		       20 30 f0 	      jsr	DiskDir
    184  3103							;
    185  3103							; Get/Display each entry
    186  3103							;
    187  3103		       a2 36	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    188  3105		       a0 97		      ldy	#DiskFileName&$ff
    189  3107		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    190  310a		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    191  310c		       20 b6 21 	      jsr	puts
      0  310f					      db	"   ",0
      1  310f		       20 20 20 00	      .byte.b	"   ",0
    193  3113							; Print the line to the console
    194  3113		       a2 36		      ldx	#DiskFileName>>8	;pointer to buffer
    195  3115		       a0 97		      ldy	#DiskFileName&$ff
    196  3117		       a5 00		      lda	0
    197  3119		       20 f4 21 	      jsr	PrtStr	;else print name
    198  311c		       20 18 f0 	      jsr	crlf
    199  311f
    200  311f		       4c 03 31 	      jmp	DiskDirLoop	;do next entry
    201  3122
    202  3122		       4c b1 02    DiskDirEnd jmp	NextIL
    203  3125					      endif
    204  3125							;
    205  3125							;=====================================================
    206  3125							; Does a LIST to a Disk file.
    207  3125							;
    208  3125				   iDLIST
    209  3125					      if	XKIM || CTMON65
    210  3125		       20 60 31 	      jsr	SetOutDisk
    211  3128		       4c 3d 08 	      jmp	iLST2
    212  312b					      endif
    213  312b							;
    214  312b							;=====================================================
    215  312b							; Closes any pending disk file.  Okay to call if there
    216  312b							; is no open file.
    217  312b							;
    218  312b				   iDCLOSE
    219  312b					      if	XKIM || CTMON65
    220  312b		       20 42 f0 	      jsr	DiskClose
    221  312e		       4c b1 02 	      jmp	NextIL
    222  3131					      endif
    223  3131							;
    224  3131							;=====================================================
    225  3131							; This gets the next byte from an open disk file.  If
    226  3131							; there are no more bytes left, this returns C set.
    227  3131							; Else, C is clear and A contains the character.
    228  3131							;
    229  3131				   getNextFileByte
    230  3131					      if	XKIM || CTMON65
    231  3131		       ae 96 36 	      ldx	diskBufOffset
    232  3134		       ec 95 36 	      cpx	diskBufLength
    233  3137		       d0 14		      bne	hasdata	;branch if still data
    234  3139							;
    235  3139							; There is no data left in the buffer, so read a
    236  3139							; block from the SD system.
    237  3139							;
    238  3139		       a9 84		      lda	#BUFFER_SIZE
    239  313b		       a2 df		      ldx	#buffer>>8
    240  313d		       a0 0a		      ldy	#buffer&$ff
    241  313f		       20 3c f0 	      jsr	DiskRead
    242  3142		       b0 12		      bcs	getNextEof
    243  3144							;
    244  3144							; A contains the number of bytes actually read.
    245  3144							;
    246  3144		       8d 95 36 	      sta	diskBufLength	;save length
    247  3147		       c9 00		      cmp	#0	;shouldn't happen
    248  3149		       f0 0b		      beq	getNextEof
    249  314b							;
    250  314b		       a2 00		      ldx	#0
    251  314d		       bd 0a df    hasdata    lda	buffer,x
    252  3150		       e8		      inx
    253  3151		       8e 96 36 	      stx	diskBufOffset
    254  3154		       18		      clc
    255  3155		       60		      rts
    256  3156							;
    257  3156		       a9 00	   getNextEof lda	#0
    258  3158		       8d 96 36 	      sta	diskBufOffset
    259  315b		       8d 95 36 	      sta	diskBufLength
    260  315e		       38		      sec
    261  315f		       60		      rts
    262  3160							;
    263  3160							;=====================================================
    264  3160							; Set output vector to the disk output function
    265  3160							;
    266  3160		       a9 6b	   SetOutDisk lda	#DOUT&$ff
    267  3162		       8d 89 36 	      sta	BOutVec
    268  3165		       a9 31		      lda	#DOUT/256
    269  3167		       8d 8a 36 	      sta	BOutVec+1
    270  316a		       60		      rts
    271  316b							;
    272  316b							;=====================================================
    273  316b							; input a contains charater to write to open file
    274  316b							; output:
    275  316b							;	    C flag clear if no error
    276  316b							;
    277  316b		       8e 97 36    DOUT       stx	DiskFileName	; Save the x value, fulename not used
    278  316e		       8c 98 36 	      sty	DiskFileName+1	; Save the y value  filename not actually used
    279  3171		       8d 0a df 	      sta	buffer	; Store the byte to send into the buffer
    280  3174		       a9 01		      lda	#1	; set number of bytes to send to 1
    281  3176		       a0 0a		      ldy	#buffer&$ff	; Load the low order address of buffer to y
    282  3178		       a2 df		      ldx	#buffer>>8	; Load the high order address of buffer to x
    283  317a		       20 3f f0 	      jsr	DiskWrite	; Place the character to disk if a file is open
    284  317d		       ae 97 36 	      ldx	DiskFileName	; Restore the x value that was saved
    285  3180		       ac 98 36 	      ldy	DiskFileName+1	; Restore the y value saved
    286  3183		       60		      rts
    287  3184							;=======================================================
    288  3184							; output:
    289  3184							;	  c flag is clear if no error, a contains bytes read
    290  3184							;	  c flag set Reached eof, a undefined
    291  3184							;
    292  3184		       8e 97 36    DIN	      stx	DiskFileName	; Save the x value, filename not used just storage
    293  3187		       8c 98 36 	      sty	DiskFileName+1	; Save the y value  filename not actually used
    294  318a		       a9 01		      lda	#1	; set number of bytes to read to 1
    295  318c		       a0 0a		      ldy	#buffer&$ff	; Load the low order address of buffer to y
    296  318e		       a2 df		      ldx	#buffer>>8	; Load the high order address of buffer to x
    297  3190		       20 3c f0 	      jsr	DiskRead
    298  3193		       ad 0a df 	      lda	buffer	; Get the byte just read
    299  3196		       ae 97 36 	      ldx	DiskFileName
    300  3199		       ac 98 36 	      ldy	DiskFileName+1
    301  319c		       60		      rts
    302  319d
    303  319d							;========================================================
    304  319d							; Dstat / open/close/stat files
    305  319d				   DSTAT
    306  319d		       60		      rts
    307  319e							;========================================================
    308  319e					      endif
------- FILE mytb.asm
   2484  319e					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  319e					      include	"IL.inc"
      1  319e
      2  319e							;=====================================================
      3  319e							; IL.inc
      4  319e							; These are macros for IL instructions
      5  319e							;
      6  319e					      mac	dw
      7  319e					      .word	{0}
      8  319e					      endm
      9  319e					      mac	db
     10  319e					      .byte	{0}
     11  319e					      endm
     12  319e					      macro	xinit
     13  319e					      db	0
     14  319e					      endm		;reset the il to start clear all
     15  319e							;
     16  319e					      macro	done
     17  319e					      db	1
     18  319e					      endm		;print an error if not end of line
     19  319e							;
     20  319e					      macro	prs
     21  319e					      db	2
     22  319e					      endm		;print a quoted string
     23  319e							;
     24  319e					      macro	prn
     25  319e					      db	3
     26  319e					      endm		;print a number
     27  319e							;
     28  319e					      macro	spc
     29  319e					      db	4
     30  319e					      endm		;print space til new tabstop
     31  319e							;
     32  319e					      macro	nline
     33  319e					      db	5
     34  319e					      endm		;print a new line crlf
     35  319e							;
     36  319e							; My NXT is a bit different in that it takes one
     37  319e							; parameter, which is an address.  If the BASIC
     38  319e							; program is currently running then move to the
     39  319e							; next line and continue execution.  However, if
     40  319e							; in direct mode, jump to the specified IL label.
     41  319e							;
     42  319e					      macro	nxt
     43  319e					      db	6
     44  319e					      dw	{1}	; addr
     45  319e					      endm		; addr
     46  319e							;
     47  319e					      macro	xfer
     48  319e					      db	7
     49  319e					      endm
     50  319e							;
     51  319e					      macro	sav
     52  319e					      db	8
     53  319e					      db	{1}
     54  319e					      endm
     55  319e							;
     56  319e							;  Passed jump if function called, and true false value returned
     57  319e					      macro	rstr
     58  319e					      db	9
     59  319e					      db	({1}-*)-1	;(addr-*)-1
     60  319e					      db	{2}
     61  319e					      endm
     62  319e							;
     63  319e					      macro	cmpr
     64  319e					      db	10
     65  319e					      endm
     66  319e							;
     67  319e					      macro	innum
     68  319e					      db	11
     69  319e					      endm
     70  319e							;
     71  319e					      macro	fin
     72  319e					      db	12
     73  319e					      endm
     74  319e							;
     75  319e							; ERR is followed by an error number.	The error
     76  319e							; code is printed along with the line number.
     77  319e							; Control is passed to the statement set with
     78  319e							; the ERRGOTO statement.
     79  319e							;
     80  319e					      macro	errmsg
     81  319e					      db	13
     82  319e					      dw	{1}	;ecode
     83  319e					      endm		;ecode
     84  319e							;
     85  319e					      macro	add
     86  319e					      db	14
     87  319e					      endm
     88  319e							;
     89  319e					      macro	sub
     90  319e					      db	15
     91  319e					      endm
     92  319e							;
     93  319e					      macro	neg
     94  319e					      db	16
     95  319e					      endm
     96  319e							;
     97  319e					      macro	mul
     98  319e					      db	17
     99  319e					      endm
    100  319e							;
    101  319e					      macro	div
    102  319e					      db	18
    103  319e					      endm
    104  319e							;
    105  319e					      macro	store
    106  319e					      db	19
    107  319e					      endm
    108  319e							;
    109  319e					      macro	ind
    110  319e					      db	20
    111  319e					      endm
    112  319e							;
    113  319e					      macro	lst
    114  319e					      db	21
    115  319e					      endm
    116  319e							;
    117  319e					      macro	init
    118  319e					      db	22
    119  319e					      endm
    120  319e							;
    121  319e					      macro	getline
    122  319e					      db	23
    123  319e					      endm
    124  319e							;
    125  319e					      macro	insert
    126  319e					      db	24
    127  319e					      endm
    128  319e							;
    129  319e					      macro	rtn
    130  319e					      db	25
    131  319e					      endm
    132  319e							;
    133  319e					      macro	exit
    134  319e					      db	26
    135  319e					      endm
    136  319e							;
    137  319e					      macro	lit
    138  319e					      db	27
    139  319e					      dw	{1}	;value
    140  319e					      endm		; value LIT
    141  319e							;
    142  319e					      macro	call
    143  319e					      db	28
    144  319e					      dw	{1}	;addr
    145  319e					      endm		;addr
    146  319e							;
    147  319e							; IJMP will set the IL PC to the specified value.
    148  319e							;
    149  319e					      macro	ijmp
    150  319e					      db	29
    151  319e					      dw	{1}	;addr
    152  319e					      endm		;addr
    153  319e							;
    154  319e					      macro	vinit
    155  319e					      db	30
    156  319e					      endm
    157  319e							;
    158  319e							; ERRGOTO sets the point in the code where the IL
    159  319e							; interpreter will go after any error.
    160  319e							;
    161  319e					      macro	errgoto
    162  319e					      db	31
    163  319e					      dw	{1}	;addr
    164  319e					      endm		;addr
    165  319e							;
    166  319e					      macro	tst
    167  319e					      db	32
    168  319e					      db	({1}-*)-1	;(addr-*)-1
    169  319e					      db	{2},0	;string,0
    170  319e					      endm		;addr,string
    171  319e							;
    172  319e					      macro	tstv
    173  319e					      db	33
    174  319e					      db	({1}-*)-1	;(addr-*)-1
    175  319e					      endm		;addr
    176  319e							;
    177  319e					      macro	tstl
    178  319e					      db	34
    179  319e					      db	({1}-*)-1	;(addr-*)-1
    180  319e					      endm		;addr
    181  319e							;
    182  319e					      macro	tstn
    183  319e					      db	35
    184  319e					      db	({1}-*)-1	;(addr-*)-1
    185  319e					      endm		;addr
    186  319e							;
    187  319e							; FREE returns the amount of free RAM on top of
    188  319e							; the stack.  This is the amount of room the user
    189  319e							; program has available.
    190  319e							;
    191  319e					      macro	free
    192  319e					      db	36
    193  319e					      endm
    194  319e							;
    195  319e							; RANDOM takes the top item off the stack and
    196  319e							; replaces it with a random number that is
    197  319e							; MOD the initial value.  Ie, if the TOS is
    198  319e							; 42 then RANDOM returns a value from 0 to 41.
    199  319e							;
    200  319e					      macro	random
    201  319e					      db	37
    202  319e					      endm
    203  319e							;
    204  319e							; ABS will replace the top of stack with the
    205  319e							; absolute value.
    206  319e							;
    207  319e					      macro	abs
    208  319e					      db	38
    209  319e					      endm
    210  319e							;
    211  319e							; OPENREAD opens a file for reading, as in getting
    212  319e							; statements from it.
    213  319e							;
    214  319e					      macro	openread
    215  319e					      db	39
    216  319e					      endm
    217  319e							;
    218  319e							; OPENWRITE opens a file for writing, as in saving
    219  319e							; the current program to it.
    220  319e							;
    221  319e					      macro	openwrite
    222  319e					      db	40
    223  319e					      db	{1}	; 0= append 1 = create/truncate
    224  319e					      endm
    225  319e							;
    226  319e							; DCLOSE closes any open disk file.
    227  319e							;
    228  319e					      macro	dclose
    229  319e					      db	41
    230  319e					      endm
    231  319e							;
    232  319e							; DGETLINE gets one line from the disk file and puts it
    233  319e							; into LINBUFF.
    234  319e							;
    235  319e					      macro	dgetline
    236  319e					      db	42
    237  319e					      endm
    238  319e							;
    239  319e							; DLIST saves the program to an open disk file.
    240  319e							;
    241  319e					      macro	dlist
    242  319e					      db	43
    243  319e					      endm
    244  319e							; DDIR list the current directory
    245  319e							;
    246  319e					      macro	ddir
    247  319e					      db	44
    248  319e					      endm
    249  319e
    250  319e							; RMFILE remove a fle from disk
    251  319e					      macro	rmfile
    252  319e					      db	45
    253  319e					      endm
    254  319e
    255  319e							; CLEARSCREEN clear the screen
    256  319e					      macro	clearscreen
    257  319e					      db	46
    258  319e					      endm
    259  319e							; POKEMEM Poke value into memory
    260  319e					      macro	pokemem
    261  319e					      db	47
    262  319e					      endm
    263  319e							; PEEKMEM peek at value in memory
    264  319e					      macro	peekmem
    265  319e					      db	48
    266  319e					      endm
    267  319e							; TSTLET Test if the statement is a let without the keyword let
    268  319e					      macro	tstlet
    269  319e					      db	49
    270  319e					      db	({1}-*)-1	;(addr-*)-1
    271  319e					      endm		;addr
    272  319e							; TSTDONE if we reach the end of a statement
    273  319e					      macro	tstdone
    274  319e					      db	50
    275  319e					      db	({1}-*)-1	;(addr-*)-1
    276  319e					      endm		;addr
    277  319e							; GETCHAR	get a character from the input line leave it in RO
    278  319e					      macro	getchar
    279  319e					      db	51
    280  319e					      endm
    281  319e							; PUTCHAR	Put a character to the terminal
    282  319e					      macro	putchar
    283  319e					      db	52
    284  319e					      endm
    285  319e							; Call		Call a machine function return a to stack
    286  319e					      macro	callfunc
    287  319e					      db	53
    288  319e					      endm
    289  319e
    290  319e							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    291  319e					      macro	ibranch
    292  319e					      db	54
    293  319e					      endm
    294  319e
    295  319e							; TSTSTR	 Tests for the open quote in a string
    296  319e					      macro	tststr
    297  319e					      db	55
    298  319e					      db	({1}-*)-1	;(addr-*)-1
    299  319e					      endm
    300  319e							; SETIRQ	Sets the line number to run when an irq happens irq 550
    301  319e					      macro	setirq
    302  319e					      db	56
    303  319e					      endm
    304  319e
    305  319e							; TSTIRQ	Test for irq pending,
    306  319e							;		if so push the IRQ LINE NUMBER into RO, onto stack
    307  319e					      macro	tstirq
    308  319e					      db	57
    309  319e					      db	({1}-*)-1	;(addr-*)-1
    310  319e					      endm
    311  319e
    312  319e							; IRET    return from interupt service
    313  319e					      macro	iret
    314  319e					      db	58
    315  319e					      endm
    316  319e
    317  319e							; INSTR   read a string from the input
    318  319e					      macro	instr
    319  319e					      db	59
    320  319e					      endm
    321  319e
    322  319e							; MODULO Returns the remainder of the division
    323  319e					      macro	modulo
    324  319e					      db	60
    325  319e					      endm
    326  319e							; Set a task line
    327  319e					      macro	taskcreate
    328  319e					      db	61
    329  319e					      endm
    330  319e							; End a task
    331  319e					      macro	etask
    332  319e					      db	62
    333  319e					      endm
    334  319e							; Skip to next task
    335  319e					      macro	ntask
    336  319e					      db	63
    337  319e					      endm
    338  319e							; Subscript
    339  319e					      macro	subscript
    340  319e					      db	64
    341  319e					      db	{1}
    342  319e					      endm
    343  319e							; KILL Task
    344  319e					      macro	taskkill
    345  319e					      db	65
    346  319e					      endm
    347  319e							; STAT Task
    348  319e					      macro	taskstat
    349  319e					      db	66
    350  319e					      endm
    351  319e							;  output value as hex
    352  319e					      macro	hexprt
    353  319e					      db	67
    354  319e					      endm
    355  319e							;  Read in background has completed
    356  319e					      macro	readcomplete
    357  319e					      db	68
    358  319e					      endm
    359  319e							;  ReadInput line
    360  319e					      macro	readstart
    361  319e					      db	69
    362  319e					      endm
    363  319e							; Startio request
    364  319e					      macro	startio
    365  319e					      db	70
    366  319e					      endm
    367  319e							; Endio
    368  319e					      macro	endio
    369  319e					      db	71
    370  319e					      endm
    371  319e							; Logical not
    372  319e					      macro	lognot
    373  319e					      db	72
    374  319e					      endm
    375  319e							; Logical OR
    376  319e					      macro	logor
    377  319e					      db	73
    378  319e					      endm
    379  319e							;Logical and
    380  319e					      macro	logand
    381  319e					      db	74
    382  319e					      endm
    383  319e							;Logical XOR
    384  319e					      macro	logxor
    385  319e					      db	75
    386  319e					      endm
    387  319e							;Wait for task to complete, or list of tasks
    388  319e					      macro	wtask
    389  319e					      db	76
    390  319e					      db	({1}-*)-1	;(addr-*)-1
    391  319e					      endm
    392  319e							;Get the current task id
    393  319e					      MACRO	taskpid
    394  319e					      db	77
    395  319e					      endm
    396  319e							;Trace the basic execution
    397  319e					      Macro	traceprogram
    398  319e					      db	78
    399  319e					      endm
    400  319e							;Do a basic program Trace
    401  319e					      Macro	debugbasic
    402  319e					      db	79
    403  319e					      endm
    404  319e
    405  319e							; Inter Process communications instructions
    406  319e					      Macro	ipcsend
    407  319e					      db	80
    408  319e					      endm
    409  319e					      Macro	ipcreceive
    410  319e					      db	81
    411  319e					      endm
    412  319e					      Macro	ipccheck
    413  319e					      db	82
    414  319e					      endm
    415  319e					      Macro	ipcio
    416  319e					      db	83
    417  319e					      endm
    418  319e					      Macro	pushmathstack
    419  319e					      db	84
    420  319e					      endm
    421  319e					      Macro	popmathstack
    422  319e					      db	85
    423  319e					      endm
    424  319e					      Macro	savemathstack
    425  319e					      db	86
    426  319e					      endm
    427  319e					      Macro	restoremathstack
    428  319e					      db	87
    429  319e					      endm
    430  319e					      Macro	incparmcount
    431  319e					      db	88
    432  319e					      endm
    433  319e					      Macro	taskgetmathstack
    434  319e					      db	89
    435  319e					      endm
    436  319e					      Macro	taskenable
    437  319e					      db	90
    438  319e					      endm
    439  319e					      Macro	tasksuspend
    440  319e					      db	91
    441  319e					      endm
    442  319e					      Macro	taskputmathptr
    443  319e					      db	92
    444  319e					      endm
    445  319e							; Test for an extension type of variable that allows access to a tasks variables
    446  319e							; Using  PID!<Var name>
    447  319e					      Macro	tstvt
    448  319e					      db	93
    449  319e					      db	({1}-*)-1	;(addr-*)-1
    450  319e					      endm
    451  319e
    452  319e							; Provide access to R2 for the IL program
    453  319e					      Macro	setr2
    454  319e					      db	94
    455  319e					      db	{1}	; R2 is only one byte
    456  319e					      endm
    457  319e
    458  319e							;Move stack top to temp
    459  319e					      Macro	stk2tmp
    460  319e					      db	95
    461  319e					      endm
    462  319e
    463  319e					      Macro	tmp2stk
    464  319e					      db	96
    465  319e					      endm
    466  319e
    467  319e					      Macro	tstbyte
    468  319e					      db	97
    469  319e					      db	({1}-*)-1	; (addr-*)-1 goto if match
    470  319e					      dw	{2}	; address to check
    471  319e					      db	{3}	; Value to compare
    472  319e					      endm
    473  319e
    474  319e					      Macro	incvar
    475  319e					      db	98
    476  319e					      endm
    477  319e					      Macro	decvar
    478  319e					      db	99
    479  319e					      endm
    480  319e
    481  319e					      Macro	slice
    482  319e					      db	100
    483  319e					      endm
    484  319e
    485  319e					      Macro	tstb
    486  319e					      db	101
    487  319e					      db	({1}-*)-1
    488  319e					      db	{2}
    489  319e					      endm
    490  319e
    491  319e					      Macro	tstw
    492  319e					      db	102
    493  319e					      db	({1}-*)-1
    494  319e					      dw	{2}
    495  319e					      endm
    496  319e
    497  319e					      Macro	ongoto
    498  319e					      db	103
    499  319e					      dw	{1}
    500  319e					      dw	{2}
    501  319e					      endm
    502  319e
    503  319e					      Macro	tstrelop
    504  319e					      db	104
    505  319e					      db	({1}-*)-1
    506  319e					      endm
    507  319e
    508  319e					      Macro	repeatline
    509  319e					      db	105
    510  319e					      endm
    511  319e
    512  319e							; Check for a precompiled branch, will take branch if precompiled value present
    513  319e					      Macro	tstbranch
    514  319e					      db	106
    515  319e					      db	({1}-*)-1
    516  319e					      endm
    517  319e
    518  319e					      Macro	fastxfer
    519  319e					      db	107
    520  319e					      endm
    521  319e
    522  319e							; Set all io to to a terminal for input output
    523  319e							; SETTERMINAL outterm,interm	 ; the numbers corrispond to the ct65 slot number each slot id 16 bytes,
    524  319e							; so 0 = 0, 1 = io address 16, 2 = io address 32 .... etc
    525  319e					      Macro	setterminal
    526  319e					      db	108
    527  319e					      endm
    528  319e
    529  319e							;Fetch a single byte from memory
    530  319e					      Macro	indb
    531  319e					      db	109
    532  319e					      endm
    533  319e
    534  319e							; Set a block of memory to a fixed value, byte or word
    535  319e							; Stack must contain destiniation address, length to set in bytes, value {byte of word} to initialize to
    536  319e					      Macro	setblock
    537  319e					      db	110
    538  319e					      db	{1}	; the data type to initialize	tByte or tInteger
    539  319e					      endm
    540  319e
    541  319e							; Copy a block of memory
    542  319e							; Stack must contain source address, destination address, length in bytes
    543  319e					      Macro	copyblock
    544  319e					      db	111
    545  319e					      endm
    546  319e
    547  319e							; Compare one block of memory to another
    548  319e							; Stack contains Length, Source1 Source 2
    549  319e							; Place on stack 0 equal, 1 s1>s2, -1 s1 < s2
    550  319e					      Macro	cmpmem
    551  319e					      db	112
    552  319e					      endm
    553  319e
    554  319e							; Shift Left and Right
    555  319e					      Macro	shift
    556  319e					      db	113
    557  319e					      db	{1}	; direction  0 = left 1 = right
    558  319e					      endm
    559  319e
    560  319e							; set of timer macros
    561  319e					      Macro	timerset
    562  319e					      db	114,1
    563  319e					      db	{1}	; value 9 = 1 second, 1-5 = value * 10ms 6 = 10ms, 7=250ms, 8=500ms
    564  319e					      endm
    565  319e
    566  319e					      Macro	timerstop
    567  319e					      db	114,0,0
    568  319e					      endm
    569  319e
    570  319e					      Macro	timervaluelow
    571  319e					      db	114,2,0
    572  319e					      endm
    573  319e
    574  319e					      Macro	timervaluehigh
    575  319e					      db	114,3,0
    576  319e					      endm
    577  319e
    578  319e					      Macro	timer
    579  319e					      db	114
    580  319e					      endm
    581  319e
    582  319e					      Macro	jmpendfalse
    583  319e					      db	115
    584  319e					      endm		; jump to end of block if false
    585  319e					      Macro	jmpstart
    586  319e					      db	116
    587  319e					      endm		; Jump to start of block if exists
------- FILE mytb.asm
   2486  319e							;
   2487  319e				  -	      if	FIXED
   2488  319e				  -	      org	$1000
   2489  319e					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  319e					      include	"basic.il"
      1  319e					      seg	Code
      2  319e							; on goto table
      3  319e							; format :   first byte is value Base, subtracted from value found
      4  319e							;	      second byte is the number of entries in the table max is 128... always a limit somewhere... lol
      5  319e				   BasicStmts
      0  319e					      db	kBeginKey,(kKeyCount+1)	; Base address of table, length of table
      1  319e		       01 23		      .byte.b	kBeginKey,(kKeyCount+1)
      0  31a0					      dw	ekLet
      1  31a0		       2d 32		      .word.w	ekLet
      0  31a2					      dw	ekInc
      1  31a2		       5f 32		      .word.w	ekInc
      0  31a4					      dw	ekDec
      1  31a4		       6c 32		      .word.w	ekDec
      0  31a6					      dw	ekIreturn
      1  31a6		       79 32		      .word.w	ekIreturn
      0  31a8					      dw	ekIf
      1  31a8		       7e 32		      .word.w	ekIf
      0  31aa					      dw	ekThen
      1  31aa		       84 32		      .word.w	ekThen
      0  31ac					      dw	ekGoto
      1  31ac		       88 32		      .word.w	ekGoto
      0  31ae					      dw	ekGosub
      1  31ae		       2b 36		      .word.w	ekGosub
      0  31b0					      dw	ekReturn
      1  31b0		       39 36		      .word.w	ekReturn
      0  31b2					      dw	ekRem
      1  31b2		       9c 32		      .word.w	ekRem
      0  31b4					      dw	ekPrint	; should be entry for print
      1  31b4		       b2 32		      .word.w	ekPrint
      0  31b6					      dw	ekTaske
      1  31b6		       ff 32		      .word.w	ekTaske
      0  31b8					      dw	ekTaskn
      1  31b8		       15 33		      .word.w	ekTaskn
      0  31ba					      dw	ekTaskw
      1  31ba		       1c 33		      .word.w	ekTaskw
      0  31bc					      dw	ekPoke
      1  31bc		       37 33		      .word.w	ekPoke
      0  31be					      dw	ekPutch
      1  31be		       99 33		      .word.w	ekPutch
      0  31c0					      dw	ekCls
      1  31c0		       a4 33		      .word.w	ekCls
      0  31c2					      dw	ekInput
      1  31c2		       ab 33		      .word.w	ekInput
      0  31c4					      dw	ekEnd
      1  31c4		       d9 33		      .word.w	ekEnd
      0  31c6					      dw	ekIrq
      1  31c6		       dd 33		      .word.w	ekIrq
      0  31c8					      dw	ekKill
      1  31c8		       e8 33		      .word.w	ekKill
      0  31ca					      dw	ekList
      1  31ca		       f3 33		      .word.w	ekList
      0  31cc					      dw	ekRun
      1  31cc		       f8 33		      .word.w	ekRun
      0  31ce					      dw	ekNew
      1  31ce		       01 34		      .word.w	ekNew
      0  31d0					      dw	ekSlice
      1  31d0		       05 34		      .word.w	ekSlice
      0  31d2					      dw	ekTrace
      1  31d2		       10 34		      .word.w	ekTrace
      0  31d4					      dw	ekExit
      1  31d4		       21 34		      .word.w	ekExit
      0  31d6					      dw	ekSave
      1  31d6		       22 34		      .word.w	ekSave
      0  31d8					      dw	ekLoad
      1  31d8		       29 34		      .word.w	ekLoad
      0  31da					      dw	ekErase
      1  31da		       39 34		      .word.w	ekErase
      0  31dc					      dw	ekDir
      1  31dc		       35 34		      .word.w	ekDir
      0  31de					      dw	ekSetTerm
      1  31de		       a2 32		      .word.w	ekSetTerm
      0  31e0					      dw	ekSetMemB
      1  31e0		       4e 33		      .word.w	ekSetMemB
      0  31e2					      dw	ekSetMemW
      1  31e2		       5a 33		      .word.w	ekSetMemW
      0  31e4					      dw	ekCopyMem
      1  31e4		       7c 33		      .word.w	ekCopyMem
     42  31e6							;
     43  31e6							; Logical operators
      0  31e6				   BasicLogical db	kOr,3
      1  31e6		       25 03		      .byte.b	kOr,3
      0  31e8					      dw	ekOr
      1  31e8		       6e 34		      .word.w	ekOr
      0  31ea					      dw	ekXor
      1  31ea		       73 34		      .word.w	ekXor
      0  31ec					      dw	ekAnd
      1  31ec		       69 34		      .word.w	ekAnd
     48  31ee
      0  31ee				   BasicShift db	kShr,2
      1  31ee		       28 02		      .byte.b	kShr,2
      0  31f0					      dw	ekShiftRight
      1  31f0		       5e 34		      .word.w	ekShiftRight
      0  31f2					      dw	ekShiftLeft
      1  31f2		       58 34		      .word.w	ekShiftLeft
     52  31f4
     53  31f4							;functions returning values
     54  31f4
      0  31f4				   BasicFuncs db	kBeginFunc,kFuncCount
      1  31f4		       2a 12		      .byte.b	kBeginFunc,kFuncCount
      0  31f6					      dw	ekTrue
      1  31f6		       c8 34		      .word.w	ekTrue
      0  31f8					      dw	ekFalse
      1  31f8		       cc 34		      .word.w	ekFalse
      0  31fa					      dw	ekFree
      1  31fa		       d0 34		      .word.w	ekFree
      0  31fc					      dw	ekGetch
      1  31fc		       d8 34		      .word.w	ekGetch
      0  31fe					      dw	ekPeek
      1  31fe		       1d 35		      .word.w	ekPeek
      0  3200					      dw	ekTask
      1  3200		       28 35		      .word.w	ekTask
      0  3202					      dw	ekIpcc
      1  3202		       74 35		      .word.w	ekIpcc
      0  3204					      dw	ekIpcs
      1  3204		       4f 35		      .word.w	ekIpcs
      0  3206					      dw	ekIpcr
      1  3206		       60 35		      .word.w	ekIpcr
      0  3208					      dw	ekRnd
      1  3208		       7f 35		      .word.w	ekRnd
      0  320a					      dw	ekStat
      1  320a		       9d 35		      .word.w	ekStat
      0  320c					      dw	ekAbs
      1  320c		       92 35		      .word.w	ekAbs
      0  320e					      dw	ekCall
      1  320e		       aa 35		      .word.w	ekCall
      0  3210					      dw	ekGofn
      1  3210		       32 36		      .word.w	ekGofn
      0  3212					      dw	ekPid
      1  3212		       a8 35		      .word.w	ekPid
      0  3214					      dw	ekAddr
      1  3214		       e0 34		      .word.w	ekAddr
      0  3216					      dw	ekCmpMem
      1  3216		       ef 34		      .word.w	ekCmpMem
      0  3218					      dw	eKTimer
      1  3218		       06 35		      .word.w	eKTimer
     74  321a							;====================================================
     75  321a							; file constants
     76  321a		       00 00	   OPEN_APPEND equ	0	; append to file
     77  321a		       00 01	   OPEN_CREATE equ	1	; truncate/create file
     78  321a
     79  321a							;=====================================================
     80  321a							; This is the IL of the BASIC (or whatever) language.
     81  321a							; Because of the way macros are implemented by as65,
     82  321a							; labels can't be on the same line as a macro
     83  321a							; invocation, so that's why labels are on separate
     84  321a							; lines.
     85  321a							;
     86  321a		       32 1a	   IL	      equ	*
     87  321a
     88  321a							;THE IL CONTROL SECTION
     89  321a
     90  321a				   START
      0  321a					      INIT		;INITIALIZE
      0  321a					      db	22
      1  321a		       16		      .byte.b	22
      0  321b					      NLINE		;WRITE CRLF
      0  321b					      db	5
      1  321b		       05		      .byte.b	5
      0  321c					      ERRGOTO	CO	;where to go after an error
      0  321c					      db	31
      1  321c		       1f		      .byte.b	31
      0  321d					      dw	CO
      1  321d		       20 32		      .word.w	CO
      0  321f					      VINIT		;clear all variables
      0  321f					      db	30
      1  321f		       1e		      .byte.b	30
     95  3220							;
     96  3220							; This is where we jump to get a line of commands or
     97  3220							; a program from the user.
     98  3220							;
     99  3220				   CO
      0  3220					      GETLINE		;WRITE PROMPT AND GET LINE
      0  3220					      db	23
      1  3220		       17		      .byte.b	23
      0  3221					      TSTL	XEC	;TEST FOR LINE NUMBER, if none then execute the line
      0  3221					      db	34
      1  3221		       22		      .byte.b	34
      0  3222					      db	(XEC-*)-1
      1  3222		       04		      .byte.b	(XEC-*)-1
      0  3223					      INSERT		;INSERT IT (MAY BE DELETE)
      0  3223					      db	24
      1  3223		       18		      .byte.b	24
      0  3224					      IJMP	CO
      0  3224					      db	29
      1  3224		       1d		      .byte.b	29
      0  3225					      dw	CO
      1  3225		       20 32		      .word.w	CO
    104  3227				   XEC
      0  3227					      XINIT		;INITIALIZE
      0  3227					      db	0
      1  3227		       00		      .byte.b	0
    106  3228							;============================================================================
    107  3228							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
    108  3228							;
    109  3228				   STMT
      0  3228					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  3228					      db	57
      1  3228		       39		      .byte.b	57
      0  3229					      db	(notirq-*)-1
      1  3229		       00		      .byte.b	(notirq-*)-1
    111  322a							;==========================================================================================
    112  322a							; Process a let statement implied or explicit.
    113  322a							;
    114  322a				   notirq
      0  322a					      DEBUGBASIC		;Check if we are doing a debug for this session
      0  322a					      db	79
      1  322a		       4f		      .byte.b	79
      0  322b					      TSTLET	DoVector	; Test if Let keyword or a variable
      0  322b					      db	49
      1  322b		       31		      .byte.b	49
      0  322c					      db	(DoVector-*)-1
      1  322c		       2d		      .byte.b	(DoVector-*)-1
    117  322d				   ekLet
      0  322d					      TSTV	DoVector	; Test for variable
      0  322d					      db	33
      1  322d		       21		      .byte.b	33
      0  322e					      db	(DoVector-*)-1
      1  322e		       2b		      .byte.b	(DoVector-*)-1
      0  322f					      CALL	FactVarPtrNoTst	; get a pointer to the variable
      0  322f					      db	28
      1  322f		       1c		      .byte.b	28
      0  3230					      dw	FactVarPtrNoTst
      1  3230		       f1 35		      .word.w	FactVarPtrNoTst
    120  3232
    121  3232				   LETINDEX_ALL
      0  3232					      TSTB	ERRMissingEquals,oEqual	; (This line originally omitted)
      0  3232					      db	101
      1  3232		       65		      .byte.b	101
      0  3233					      db	(ERRMissingEquals-*)-1
      1  3233		       20		      .byte.b	(ERRMissingEquals-*)-1
      0  3234					      db	oEqual
      1  3234		       f2		      .byte.b	oEqual
    123  3235				   LETBE
      0  3235					      TSTBYTE	LETAssignByte,R2,tByte	; Check for a byte conversion
      0  3235					      db	97
      1  3235		       61		      .byte.b	97
      0  3236					      db	(LETAssignByte-*)-1
      1  3236		       10		      .byte.b	(LETAssignByte-*)-1
      0  3237					      dw	R2
      1  3237		       58 00		      .word.w	R2
      0  3239					      db	tByte
      1  3239		       a2		      .byte.b	tByte
      0  323a					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  323a					      db	28
      1  323a		       1c		      .byte.b	28
      0  323b					      dw	EXPR
      1  323b		       41 34		      .word.w	EXPR
      0  323d					      DONE		; REPORT ERROR IF NOT NEXT
      0  323d					      db	1
      1  323d		       01		      .byte.b	1
      0  323e					      SETR2	tInteger	; Store an integer type
      0  323e					      db	94
      1  323e		       5e		      .byte.b	94
      0  323f					      db	tInteger
      1  323f		       a4		      .byte.b	tInteger
      0  3240					      STORE		; STORE RESULT at variable address
      0  3240					      db	19
      1  3240		       13		      .byte.b	19
      0  3241					      NXT	CO	; AND SEQUENCE TO NEXT
      0  3241					      db	6
      1  3241		       06		      .byte.b	6
      0  3242					      dw	CO
      1  3242		       20 32		      .word.w	CO
      0  3244					      IJMP	STMT	; Next statement
      0  3244					      db	29
      1  3244		       1d		      .byte.b	29
      0  3245					      dw	STMT
      1  3245		       28 32		      .word.w	STMT
    131  3247
    132  3247				   LETAssignByte
      0  3247					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  3247					      db	28
      1  3247		       1c		      .byte.b	28
      0  3248					      dw	EXPR
      1  3248		       41 34		      .word.w	EXPR
      0  324a					      DONE		; REPORT ERROR IF NOT NEXT
      0  324a					      db	1
      1  324a		       01		      .byte.b	1
      0  324b					      SETR2	tByte	; Set to store a byte value
      0  324b					      db	94
      1  324b		       5e		      .byte.b	94
      0  324c					      db	tByte
      1  324c		       a2		      .byte.b	tByte
      0  324d					      STORE		; STORE RESULT at variable address
      0  324d					      db	19
      1  324d		       13		      .byte.b	19
      0  324e					      NXT	CO	; AND SEQUENCE TO NEXT
      0  324e					      db	6
      1  324e		       06		      .byte.b	6
      0  324f					      dw	CO
      1  324f		       20 32		      .word.w	CO
      0  3251					      IJMP	STMT	; Next statement
      0  3251					      db	29
      1  3251		       1d		      .byte.b	29
      0  3252					      dw	STMT
      1  3252		       28 32		      .word.w	STMT
    139  3254
    140  3254				   ERRMissingEquals
      0  3254					      ERRMSG	ERR_MISSINGEQUALSIGN	; Missing asignment
      0  3254					      db	13
      1  3254		       0d		      .byte.b	13
      0  3255					      dw	ERR_MISSINGEQUALSIGN
      1  3255		       18 00		      .word.w	ERR_MISSINGEQUALSIGN
    142  3257
    143  3257				   ERRVEC2
      0  3257					      IJMP	UNKNOWN
      0  3257					      db	29
      1  3257		       1d		      .byte.b	29
      0  3258					      dw	UNKNOWN
      1  3258		       3d 34		      .word.w	UNKNOWN
    145  325a							;=============================================================
    146  325a							;Branch on a valid statement start
    147  325a				   DoVector
      0  325a					      OnGoto	BasicStmts,UNKNOWN	; use the table provided if not in table branch to unknown
      0  325a					      db	103
      1  325a		       67		      .byte.b	103
      0  325b					      dw	BasicStmts
      1  325b		       9e 31		      .word.w	BasicStmts
      0  325d					      dw	UNKNOWN
      1  325d		       3d 34		      .word.w	UNKNOWN
    149  325f							;This will never return here!
    150  325f							;=============================================================
    151  325f							; Inc or dec a variable
    152  325f				   ekInc
      0  325f					      TSTV	ERRVEC2	; Verify we have a variable
      0  325f					      db	33
      1  325f		       21		      .byte.b	33
      0  3260					      db	(ERRVEC2-*)-1
      1  3260		       f6		      .byte.b	(ERRVEC2-*)-1
      0  3261					      CALL	FactVarPtrNoTst	; Get a pointer to the memory location to increment
      0  3261					      db	28
      1  3261		       1c		      .byte.b	28
      0  3262					      dw	FactVarPtrNoTst
      1  3262		       f1 35		      .word.w	FactVarPtrNoTst
    155  3264							;	  TSTB	     eDoInc,oBang		    ; Allow to inc or dec other tasks variables
    156  3264							;	  IND					    ; we just got a pid
    157  3264							;	  TSTVT      ERRVEC2			    ; if it is not another variabe then error, Call test var. task
    158  3264				   eDoInc
      0  3264					      INCVAR		; Do the increment of the variable
      0  3264					      db	98
      1  3264		       62		      .byte.b	98
      0  3265					      DONE		; Test for end of line or end of statement ":"
      0  3265					      db	1
      1  3265		       01		      .byte.b	1
      0  3266					      NXT	CO	; Get the next statement, branch CO if end of program
      0  3266					      db	6
      1  3266		       06		      .byte.b	6
      0  3267					      dw	CO
      1  3267		       20 32		      .word.w	CO
      0  3269					      IJMP	STMT	; Process the next statement
      0  3269					      db	29
      1  3269		       1d		      .byte.b	29
      0  326a					      dw	STMT
      1  326a		       28 32		      .word.w	STMT
    163  326c							;S1Dec:
    164  326c							;	  TSTB	     S1Iret,kDec		    ; Dec variable
    165  326c				   ekDec
      0  326c					      TSTV	ERRVEC2	; Must be followed by a variable
      0  326c					      db	33
      1  326c		       21		      .byte.b	33
      0  326d					      db	(ERRVEC2-*)-1
      1  326d		       e9		      .byte.b	(ERRVEC2-*)-1
      0  326e					      CALL	FactVarPtrNoTst	; Get a pointer to the variable to update
      0  326e					      db	28
      1  326e		       1c		      .byte.b	28
      0  326f					      dw	FactVarPtrNoTst
      1  326f		       f1 35		      .word.w	FactVarPtrNoTst
    168  3271							;	  TSTB	     eDoDec,oBang		    ; Allow to inc or dec other tasks variables
    169  3271							;	  IND					    ; we just got a pid
    170  3271							;	  TSTVT      ERRVEC2			    ; if it is not another variabe then error, Call test var. task
    171  3271				   eDoDec
      0  3271					      DECVAR		; Decrement the actual variable
      0  3271					      db	99
      1  3271		       63		      .byte.b	99
      0  3272					      DONE		; Test if end of line or : statement
      0  3272					      db	1
      1  3272		       01		      .byte.b	1
      0  3273					      NXT	CO	; If at end of program then got the console
      0  3273					      db	6
      1  3273		       06		      .byte.b	6
      0  3274					      dw	CO
      1  3274		       20 32		      .word.w	CO
      0  3276					      IJMP	STMT	; Process the next statement of command line
      0  3276					      db	29
      1  3276		       1d		      .byte.b	29
      0  3277					      dw	STMT
      1  3277		       28 32		      .word.w	STMT
    176  3279							;=============================================================================================================================
    177  3279							; iret or ireturn, Return from interupt process
    178  3279							;
    179  3279							;S1Iret:
    180  3279							;	  TSTB	     S1S1,kIreturn		 ; test return from interupt
    181  3279							;S1Sa:
    182  3279				   ekIreturn
      0  3279					      DONE		; Must be only thing on the line
      0  3279					      db	1
      1  3279		       01		      .byte.b	1
      0  327a					      IRET		; RESTORE LINE NUMBER OF CALL
      0  327a					      db	58
      1  327a		       3a		      .byte.b	58
      0  327b					      IJMP	STMT
      0  327b					      db	29
      1  327b		       1d		      .byte.b	29
      0  327c					      dw	STMT
      1  327c		       28 32		      .word.w	STMT
    186  327e							;==============================================================================================================================
    187  327e							;Process if statement, if true then process all statements until end of line reached
    188  327e							;S1S1:
    189  327e							;	  TSTB	     S1Z,kIf			    ; IF STATEMENT
    190  327e				   ekIf
      0  327e					      CALL	EXPR	; GET EXPRESSION rel ops now valid expression 0 false, everything else true
      0  327e					      db	28
      1  327e		       1c		      .byte.b	28
      0  327f					      dw	EXPR
      1  327f		       41 34		      .word.w	EXPR
      0  3281					      TSTB	S1W,kThen	; (This line originally omitted) not required
      0  3281					      db	101
      1  3281		       65		      .byte.b	101
      0  3282					      db	(S1W-*)-1
      1  3282		       01		      .byte.b	(S1W-*)-1
      0  3283					      db	kThen
      1  3283		       06		      .byte.b	kThen
    193  3284				   ekThen
    194  3284				   S1W
      0  3284					      IBRANCH		; PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  3284					      db	54
      1  3284		       36		      .byte.b	54
      0  3285					      IJMP	STMT
      0  3285					      db	29
      1  3285		       1d		      .byte.b	29
      0  3286					      dw	STMT
      1  3286		       28 32		      .word.w	STMT
    197  3288							;===============================================================================================================================
    198  3288							; Test for GOTO
    199  3288							;S1Z:
    200  3288							;	  TSTB	     S2,kGoto			    ; YES...TO, OR...SUB
    201  3288							;
    202  3288				   ekGoto
      0  3288					      TSTBRANCH	ekGotoCompiled	; test the two byte vector following the goto if zero then normal line lookup
      0  3288					      db	106
      1  3288		       6a		      .byte.b	106
      0  3289					      db	(ekGotoCompiled-*)-1
      1  3289		       0e		      .byte.b	(ekGotoCompiled-*)-1
    204  328a							; Else we have the address and just goto that address
      0  328a					      TSTB	ekGotoLine,oPeriod	; If it is a period, then just go to start of this line
      0  328a					      db	101
      1  328a		       65		      .byte.b	101
      0  328b					      db	(ekGotoLine-*)-1
      1  328b		       05		      .byte.b	(ekGotoLine-*)-1
      0  328c					      db	oPeriod
      1  328c		       e9		      .byte.b	oPeriod
      0  328d					      REPEATLINE		; Repeat the same line again
      0  328d					      db	105
      1  328d		       69		      .byte.b	105
      0  328e					      IJMP	STMT	; Go do the statement
      0  328e					      db	29
      1  328e		       1d		      .byte.b	29
      0  328f					      dw	STMT
      1  328f		       28 32		      .word.w	STMT
    208  3291
    209  3291				   ekGotoLine
      0  3291					      CALL	EXPR	; GET LABEL
      0  3291					      db	28
      1  3291		       1c		      .byte.b	28
      0  3292					      dw	EXPR
      1  3292		       41 34		      .word.w	EXPR
      0  3294					      lit	0	; Place indicator for line num on stack
      0  3294					      db	27
      1  3294		       1b		      .byte.b	27
      0  3295					      dw	0
      1  3295		       00 00		      .word.w	0
      0  3297					      FASTXFER
      0  3297					      db	107
      1  3297		       6b		      .byte.b	107
    213  3298				   ekGotoCompiled
      0  3298					      lit	1	; tell it that mempointer on the stack
      0  3298					      db	27
      1  3298		       1b		      .byte.b	27
      0  3299					      dw	1
      1  3299		       01 00		      .word.w	1
      0  329b					      FASTXFER		; put top of stack into curptr
      0  329b					      db	107
      1  329b		       6b		      .byte.b	107
    216  329c
    217  329c
    218  329c							;==================================================================================================================================
    219  329c							; Process REM statement
    220  329c							;
    221  329c							;S2a:
    222  329c							;	  TSTB	     S3,kRem			    ; REMark.  Skip rest of line
    223  329c				   ekRem
      0  329c					      NXT	CO	; The rest of the line is ignored
      0  329c					      db	6
      1  329c		       06		      .byte.b	6
      0  329d					      dw	CO
      1  329d		       20 32		      .word.w	CO
      0  329f					      IJMP	STMT	; Process the next statement
      0  329f					      db	29
      1  329f		       1d		      .byte.b	29
      0  32a0					      dw	STMT
      1  32a0		       28 32		      .word.w	STMT
    226  32a2							;====================================================================================================================================
    227  32a2							; Set the Task input output slot each slot is 16 byte starting at e000
    228  32a2							; so 0,1,...
    229  32a2				   ekSetTerm
      0  32a2					      CALL	EXPR
      0  32a2					      db	28
      1  32a2		       1c		      .byte.b	28
      0  32a3					      dw	EXPR
      1  32a3		       41 34		      .word.w	EXPR
      0  32a5					      TSTB	ERRVEC,oComma
      0  32a5					      db	101
      1  32a5		       65		      .byte.b	101
      0  32a6					      db	(ERRVEC-*)-1
      1  32a6		       2f		      .byte.b	(ERRVEC-*)-1
      0  32a7					      db	oComma
      1  32a7		       e2		      .byte.b	oComma
      0  32a8					      CALL	EXPR
      0  32a8					      db	28
      1  32a8		       1c		      .byte.b	28
      0  32a9					      dw	EXPR
      1  32a9		       41 34		      .word.w	EXPR
      0  32ab					      SETTERMINAL
      0  32ab					      db	108
      1  32ab		       6c		      .byte.b	108
      0  32ac					      NXT	CO	;Next statement to execute
      0  32ac					      db	6
      1  32ac		       06		      .byte.b	6
      0  32ad					      dw	CO
      1  32ad		       20 32		      .word.w	CO
      0  32af					      IJMP	STMT
      0  32af					      db	29
      1  32af		       1d		      .byte.b	29
      0  32b0					      dw	STMT
      1  32b0		       28 32		      .word.w	STMT
    236  32b2							;==================================================================================================================================
    237  32b2							; Print statement
    238  32b2							;
    239  32b2							;S3:
    240  32b2							;	  TSTB	     S8,kPrint			    ; ? or Print symonym for print
    241  32b2				   ekPrint
      0  32b2					      STARTIO		; Lock task until io completes
      0  32b2					      db	70
      1  32b2		       46		      .byte.b	70
    243  32b3				   S4
      0  32b3					      TSTDONE	S4a	; Test if we just want crlf printed
      0  32b3					      db	50
      1  32b3		       32		      .byte.b	50
      0  32b4					      db	(S4a-*)-1
      1  32b4		       03		      .byte.b	(S4a-*)-1
      0  32b5					      IJMP	S6
      0  32b5					      db	29
      1  32b5		       1d		      .byte.b	29
      0  32b6					      dw	S6
      1  32b6		       cd 32		      .word.w	S6
    246  32b8
    247  32b8				   S4a
      0  32b8					      TSTB	S7,tString	; TEST FOR QUOTED String
      0  32b8					      db	101
      1  32b8		       65		      .byte.b	101
      0  32b9					      db	(S7-*)-1
      1  32b9		       1f		      .byte.b	(S7-*)-1
      0  32ba					      db	tString
      1  32ba		       a0		      .byte.b	tString
      0  32bb					      PRS		; PRINT STRING
      0  32bb					      db	2
      1  32bb		       02		      .byte.b	2
    250  32bc				   S5
      0  32bc					      TSTB	S6A,oComma	; IS THERE MORE?
      0  32bc					      db	101
      1  32bc		       65		      .byte.b	101
      0  32bd					      db	(S6A-*)-1
      1  32bd		       07		      .byte.b	(S6A-*)-1
      0  32be					      db	oComma
      1  32be		       e2		      .byte.b	oComma
      0  32bf					      SPC		; SPACE TO NEXT ZONE
      0  32bf					      db	4
      1  32bf		       04		      .byte.b	4
      0  32c0					      TSTDONE	S4	; Not end of line jump back
      0  32c0					      db	50
      1  32c0		       32		      .byte.b	50
      0  32c1					      db	(S4-*)-1
      1  32c1		       f1		      .byte.b	(S4-*)-1
      0  32c2					      IJMP	S6Z	; YES JUMP BACK
      0  32c2					      db	29
      1  32c2		       1d		      .byte.b	29
      0  32c3					      dw	S6Z
      1  32c3		       cf 32		      .word.w	S6Z
    255  32c5
    256  32c5							;
    257  32c5							; If a semicolon, don't do anything.
    258  32c5							;
    259  32c5				   S6A
      0  32c5					      TSTB	S6,oSemiColon	; IF semicolon also check if end of line
      0  32c5					      db	101
      1  32c5		       65		      .byte.b	101
      0  32c6					      db	(S6-*)-1
      1  32c6		       06		      .byte.b	(S6-*)-1
      0  32c7					      db	oSemiColon
      1  32c7		       e3		      .byte.b	oSemiColon
      0  32c8					      TSTDONE	S4	; Jump Back if not end of line
      0  32c8					      db	50
      1  32c8		       32		      .byte.b	50
      0  32c9					      db	(S4-*)-1
      1  32c9		       e9		      .byte.b	(S4-*)-1
      0  32ca					      IJMP	S6Z
      0  32ca					      db	29
      1  32ca		       1d		      .byte.b	29
      0  32cb					      dw	S6Z
      1  32cb		       cf 32		      .word.w	S6Z
    263  32cd
    264  32cd				   S6
    265  32cd
      0  32cd					      DONE		; ERROR IF CR NOT NEXT
      0  32cd					      db	1
      1  32cd		       01		      .byte.b	1
      0  32ce					      NLINE
      0  32ce					      db	5
      1  32ce		       05		      .byte.b	5
    268  32cf				   S6Z
      0  32cf					      ENDIO		; release task io completed
      0  32cf					      db	71
      1  32cf		       47		      .byte.b	71
      0  32d0					      NXT	CO	; exit here if , or ; at end of print
      0  32d0					      db	6
      1  32d0		       06		      .byte.b	6
      0  32d1					      dw	CO
      1  32d1		       20 32		      .word.w	CO
      0  32d3					      IJMP	STMT
      0  32d3					      db	29
      1  32d3		       1d		      .byte.b	29
      0  32d4					      dw	STMT
      1  32d4		       28 32		      .word.w	STMT
    272  32d6							;
    273  32d6							; A jump for code too far away for relative branch
    274  32d6							;
    275  32d6				   ERRVEC
      0  32d6					      IJMP	UNKNOWN
      0  32d6					      db	29
      1  32d6		       1d		      .byte.b	29
      0  32d7					      dw	UNKNOWN
      1  32d7		       3d 34		      .word.w	UNKNOWN
    277  32d9							;
    278  32d9							; Get here if there is an expression to print
    279  32d9				   S7
      0  32d9					      TSTB	S7AUnsigned,oDollar	; Print the value in Hex format
      0  32d9					      db	101
      1  32d9		       65		      .byte.b	101
      0  32da					      db	(S7AUnsigned-*)-1
      1  32da		       08		      .byte.b	(S7AUnsigned-*)-1
      0  32db					      db	oDollar
      1  32db		       e7		      .byte.b	oDollar
      0  32dc					      CALL	EXPR
      0  32dc					      db	28
      1  32dc		       1c		      .byte.b	28
      0  32dd					      dw	EXPR
      1  32dd		       41 34		      .word.w	EXPR
      0  32df					      HEXPRT
      0  32df					      db	67
      1  32df		       43		      .byte.b	67
      0  32e0					      IJMP	S5
      0  32e0					      db	29
      1  32e0		       1d		      .byte.b	29
      0  32e1					      dw	S5
      1  32e1		       bc 32		      .word.w	S5
    284  32e3
    285  32e3				   S7AUnsigned
    286  32e3
      0  32e3					      TSTB	S7A,oPercent	; Print the value as an unsigned number
      0  32e3					      db	101
      1  32e3		       65		      .byte.b	101
      0  32e4					      db	(S7A-*)-1
      1  32e4		       0a		      .byte.b	(S7A-*)-1
      0  32e5					      db	oPercent
      1  32e5		       ed		      .byte.b	oPercent
      0  32e6					      CALL	EXPR
      0  32e6					      db	28
      1  32e6		       1c		      .byte.b	28
      0  32e7					      dw	EXPR
      1  32e7		       41 34		      .word.w	EXPR
      0  32e9					      SETR2	tUint
      0  32e9					      db	94
      1  32e9		       5e		      .byte.b	94
      0  32ea					      db	tUint
      1  32ea		       a9		      .byte.b	tUint
      0  32eb					      PRN
      0  32eb					      db	3
      1  32eb		       03		      .byte.b	3
      0  32ec					      IJMP	S5
      0  32ec					      db	29
      1  32ec		       1d		      .byte.b	29
      0  32ed					      dw	S5
      1  32ed		       bc 32		      .word.w	S5
    292  32ef
    293  32ef				   S7A
    294  32ef
      0  32ef					      CALL	EXPR
      0  32ef					      db	28
      1  32ef		       1c		      .byte.b	28
      0  32f0					      dw	EXPR
      1  32f0		       41 34		      .word.w	EXPR
      0  32f2					      TSTB	S7B,oDollar	; Print the value as a single character
      0  32f2					      db	101
      1  32f2		       65		      .byte.b	101
      0  32f3					      db	(S7B-*)-1
      1  32f3		       05		      .byte.b	(S7B-*)-1
      0  32f4					      db	oDollar
      1  32f4		       e7		      .byte.b	oDollar
      0  32f5					      PUTCHAR
      0  32f5					      db	52
      1  32f5		       34		      .byte.b	52
      0  32f6					      IJMP	S5
      0  32f6					      db	29
      1  32f6		       1d		      .byte.b	29
      0  32f7					      dw	S5
      1  32f7		       bc 32		      .word.w	S5
    299  32f9
    300  32f9				   S7B
      0  32f9					      SETR2	tInteger	; Print the value as a signed number
      0  32f9					      db	94
      1  32f9		       5e		      .byte.b	94
      0  32fa					      db	tInteger
      1  32fa		       a4		      .byte.b	tInteger
      0  32fb					      PRN		; PRINT IT
      0  32fb					      db	3
      1  32fb		       03		      .byte.b	3
      0  32fc					      IJMP	S5	; IS THERE MORE?
      0  32fc					      db	29
      1  32fc		       1d		      .byte.b	29
      0  32fd					      dw	S5
      1  32fd		       bc 32		      .word.w	S5
    304  32ff							;
    305  32ff							;===========================================================
    306  32ff							; PROCESS ALL THE TASK STATEMENTS
    307  32ff							;
    308  32ff							;S8:
    309  32ff							;	  TSTB	      S8G,kTaske		 ; End Task
    310  32ff				   ekTaske
      0  32ff					      TSTB	S8NoParm,oLeftBracket
      0  32ff					      db	101
      1  32ff		       65		      .byte.b	101
      0  3300					      db	(S8NoParm-*)-1
      1  3300		       0c		      .byte.b	(S8NoParm-*)-1
      0  3301					      db	oLeftBracket
      1  3301		       e0		      .byte.b	oLeftBracket
      0  3302					      CALL	EXPR
      0  3302					      db	28
      1  3302		       1c		      .byte.b	28
      0  3303					      dw	EXPR
      1  3303		       41 34		      .word.w	EXPR
      0  3305					      TSTB	UNKNOWNLnk,oRightBracket
      0  3305					      db	101
      1  3305		       65		      .byte.b	101
      0  3306					      db	(UNKNOWNLnk-*)-1
      1  3306		       2d		      .byte.b	(UNKNOWNLnk-*)-1
      0  3307					      db	oRightBracket
      1  3307		       e1		      .byte.b	oRightBracket
      0  3308					      ETASK
      0  3308					      db	62
      1  3308		       3e		      .byte.b	62
      0  3309					      DONE
      0  3309					      db	1
      1  3309		       01		      .byte.b	1
      0  330a					      IJMP	STMT
      0  330a					      db	29
      1  330a		       1d		      .byte.b	29
      0  330b					      dw	STMT
      1  330b		       28 32		      .word.w	STMT
    317  330d				   S8NoParm
      0  330d					      LIT	0
      0  330d					      db	27
      1  330d		       1b		      .byte.b	27
      0  330e					      dw	0
      1  330e		       00 00		      .word.w	0
      0  3310					      ETASK
      0  3310					      db	62
      1  3310		       3e		      .byte.b	62
      0  3311					      DONE		; Must be last thing on a line
      0  3311					      db	1
      1  3311		       01		      .byte.b	1
      0  3312					      IJMP	STMT
      0  3312					      db	29
      1  3312		       1d		      .byte.b	29
      0  3313					      dw	STMT
      1  3313		       28 32		      .word.w	STMT
    322  3315							;
    323  3315							;===========================================================
    324  3315							; The task gives up the rest of the cycles
    325  3315							;S8G:
    326  3315							;	  TSTB	      S8a,kTaskn	 ;Next task
    327  3315				   ekTaskn
      0  3315					      NTASK
      0  3315					      db	63
      1  3315		       3f		      .byte.b	63
      0  3316					      NXT	CO	;Next statement to execute
      0  3316					      db	6
      1  3316		       06		      .byte.b	6
      0  3317					      dw	CO
      1  3317		       20 32		      .word.w	CO
      0  3319					      IJMP	STMT
      0  3319					      db	29
      1  3319		       1d		      .byte.b	29
      0  331a					      dw	STMT
      1  331a		       28 32		      .word.w	STMT
    331  331c							;
    332  331c							;===========================================================
    333  331c							; Waits for a task or list of tasks to complete
    334  331c
    335  331c				   ekTaskw
      0  331c					      TSTB	UNKNOWNLnk,oLeftBracket
      0  331c					      db	101
      1  331c		       65		      .byte.b	101
      0  331d					      db	(UNKNOWNLnk-*)-1
      1  331d		       16		      .byte.b	(UNKNOWNLnk-*)-1
      0  331e					      db	oLeftBracket
      1  331e		       e0		      .byte.b	oLeftBracket
    337  331f				   S8TSK
      0  331f					      Call	EXPR	;Gets the PID of task to wait for
      0  331f					      db	28
      1  331f		       1c		      .byte.b	28
      0  3320					      dw	EXPR
      1  3320		       41 34		      .word.w	EXPR
    339  3322				   S8LOOP
      0  3322					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  3322					      db	76
      1  3322		       4c		      .byte.b	76
      0  3323					      db	(S8LOOP-*)-1
      1  3323		       fe		      .byte.b	(S8LOOP-*)-1
      0  3324					      TSTB	S8aa,oComma	;Checks for more tasks
      0  3324					      db	101
      1  3324		       65		      .byte.b	101
      0  3325					      db	(S8aa-*)-1
      1  3325		       04		      .byte.b	(S8aa-*)-1
      0  3326					      db	oComma
      1  3326		       e2		      .byte.b	oComma
      0  3327					      IJMP	S8TSK	;Go for the next task number
      0  3327					      db	29
      1  3327		       1d		      .byte.b	29
      0  3328					      dw	S8TSK
      1  3328		       1f 33		      .word.w	S8TSK
    343  332a				   S8aa
      0  332a					      TSTB	UNKNOWNLnk,oRightBracket	;end of list
      0  332a					      db	101
      1  332a		       65		      .byte.b	101
      0  332b					      db	(UNKNOWNLnk-*)-1
      1  332b		       08		      .byte.b	(UNKNOWNLnk-*)-1
      0  332c					      db	oRightBracket
      1  332c		       e1		      .byte.b	oRightBracket
      0  332d					      DONE
      0  332d					      db	1
      1  332d		       01		      .byte.b	1
      0  332e					      NXT	CO
      0  332e					      db	6
      1  332e		       06		      .byte.b	6
      0  332f					      dw	CO
      1  332f		       20 32		      .word.w	CO
      0  3331					      IJMP	STMT	;Next Statement
      0  3331					      db	29
      1  3331		       1d		      .byte.b	29
      0  3332					      dw	STMT
      1  3332		       28 32		      .word.w	STMT
    348  3334
    349  3334
    350  3334
    351  3334				   UNKNOWNLnk
      0  3334					      iJMP	UNKNOWN
      0  3334					      db	29
      1  3334		       1d		      .byte.b	29
      0  3335					      dw	UNKNOWN
      1  3335		       3d 34		      .word.w	UNKNOWN
    353  3337
    354  3337							;
    355  3337							;===========================================================
    356  3337							; Update a memory location with a value
    357  3337							;  Use @[offset] to write a word value to memory
    358  3337							;
    359  3337							;S8a1:
    360  3337							;	  TSTB	      S8b,kPoke 			  ; Poke a value into memory
    361  3337				   ekPoke
      0  3337					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  3337					      db	101
      1  3337		       65		      .byte.b	101
      0  3338					      db	(UNKNOWNV-*)-1
      1  3338		       a1		      .byte.b	(UNKNOWNV-*)-1
      0  3339					      db	oLeftBracket
      1  3339		       e0		      .byte.b	oLeftBracket
      0  333a					      CALL	EXPR	; Get address to write to
      0  333a					      db	28
      1  333a		       1c		      .byte.b	28
      0  333b					      dw	EXPR
      1  333b		       41 34		      .word.w	EXPR
      0  333d					      TSTB	UNKNOWNV,oComma	; Must have a coma
      0  333d					      db	101
      1  333d		       65		      .byte.b	101
      0  333e					      db	(UNKNOWNV-*)-1
      1  333e		       9b		      .byte.b	(UNKNOWNV-*)-1
      0  333f					      db	oComma
      1  333f		       e2		      .byte.b	oComma
      0  3340					      CALL	EXPR	; Get the value to poke
      0  3340					      db	28
      1  3340		       1c		      .byte.b	28
      0  3341					      dw	EXPR
      1  3341		       41 34		      .word.w	EXPR
      0  3343					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  3343					      db	101
      1  3343		       65		      .byte.b	101
      0  3344					      db	(UNKNOWNV-*)-1
      1  3344		       95		      .byte.b	(UNKNOWNV-*)-1
      0  3345					      db	oRightBracket
      1  3345		       e1		      .byte.b	oRightBracket
      0  3346					      POKEMEM
      0  3346					      db	47
      1  3346		       2f		      .byte.b	47
      0  3347					      DONE
      0  3347					      db	1
      1  3347		       01		      .byte.b	1
      0  3348					      NXT	CO	;AND SEQUENCE TO NEXT
      0  3348					      db	6
      1  3348		       06		      .byte.b	6
      0  3349					      dw	CO
      1  3349		       20 32		      .word.w	CO
      0  334b					      IJMP	STMT
      0  334b					      db	29
      1  334b		       1d		      .byte.b	29
      0  334c					      dw	STMT
      1  334c		       28 32		      .word.w	STMT
    371  334e							;
    372  334e							;================================================================
    373  334e							; Set a block of memory to a value word or byte
    374  334e							; SetMem(Value, Length, Destination)
    375  334e				   ekSetMemB
      0  334e					      CALL	ekSetMem
      0  334e					      db	28
      1  334e		       1c		      .byte.b	28
      0  334f					      dw	ekSetMem
      1  334f		       66 33		      .word.w	ekSetMem
      0  3351					      SETBLOCK	tByte	; set value as byte
      0  3351					      db	110
      1  3351		       6e		      .byte.b	110
      0  3352					      db	tByte
      1  3352		       a2		      .byte.b	tByte
      0  3353					      DONE
      0  3353					      db	1
      1  3353		       01		      .byte.b	1
      0  3354					      NXT	CO
      0  3354					      db	6
      1  3354		       06		      .byte.b	6
      0  3355					      dw	CO
      1  3355		       20 32		      .word.w	CO
      0  3357					      IJMP	STMT
      0  3357					      db	29
      1  3357		       1d		      .byte.b	29
      0  3358					      dw	STMT
      1  3358		       28 32		      .word.w	STMT
    381  335a
    382  335a				   ekSetMemW
      0  335a					      CALL	ekSetMem
      0  335a					      db	28
      1  335a		       1c		      .byte.b	28
      0  335b					      dw	ekSetMem
      1  335b		       66 33		      .word.w	ekSetMem
      0  335d					      SETBLOCK	tInteger	; set value as byte
      0  335d					      db	110
      1  335d		       6e		      .byte.b	110
      0  335e					      db	tInteger
      1  335e		       a4		      .byte.b	tInteger
      0  335f					      DONE
      0  335f					      db	1
      1  335f		       01		      .byte.b	1
      0  3360					      NXT	CO
      0  3360					      db	6
      1  3360		       06		      .byte.b	6
      0  3361					      dw	CO
      1  3361		       20 32		      .word.w	CO
      0  3363					      IJMP	STMT
      0  3363					      db	29
      1  3363		       1d		      .byte.b	29
      0  3364					      dw	STMT
      1  3364		       28 32		      .word.w	STMT
    388  3366
    389  3366				   ekSetMem
      0  3366					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  3366					      db	101
      1  3366		       65		      .byte.b	101
      0  3367					      db	(UNKNOWNV-*)-1
      1  3367		       72		      .byte.b	(UNKNOWNV-*)-1
      0  3368					      db	oLeftBracket
      1  3368		       e0		      .byte.b	oLeftBracket
      0  3369					      CALL	EXPR	; Value to set
      0  3369					      db	28
      1  3369		       1c		      .byte.b	28
      0  336a					      dw	EXPR
      1  336a		       41 34		      .word.w	EXPR
      0  336c					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  336c					      db	101
      1  336c		       65		      .byte.b	101
      0  336d					      db	(UNKNOWNV-*)-1
      1  336d		       6c		      .byte.b	(UNKNOWNV-*)-1
      0  336e					      db	oComma
      1  336e		       e2		      .byte.b	oComma
      0  336f					      CALL	EXPR	; Get The Length
      0  336f					      db	28
      1  336f		       1c		      .byte.b	28
      0  3370					      dw	EXPR
      1  3370		       41 34		      .word.w	EXPR
      0  3372					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  3372					      db	101
      1  3372		       65		      .byte.b	101
      0  3373					      db	(UNKNOWNV-*)-1
      1  3373		       66		      .byte.b	(UNKNOWNV-*)-1
      0  3374					      db	oComma
      1  3374		       e2		      .byte.b	oComma
      0  3375					      CALL	EXPR	; GET the address to start at
      0  3375					      db	28
      1  3375		       1c		      .byte.b	28
      0  3376					      dw	EXPR
      1  3376		       41 34		      .word.w	EXPR
      0  3378					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  3378					      db	101
      1  3378		       65		      .byte.b	101
      0  3379					      db	(UNKNOWNV-*)-1
      1  3379		       60		      .byte.b	(UNKNOWNV-*)-1
      0  337a					      db	oRightBracket
      1  337a		       e1		      .byte.b	oRightBracket
      0  337b					      RTN
      0  337b					      db	25
      1  337b		       19		      .byte.b	25
    398  337c							;
    399  337c							;================================================================
    400  337c							; Copy a block of memory
    401  337c							; CopyMem(Length, Destination, Source)
    402  337c				   ekCopyMem
      0  337c					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  337c					      db	101
      1  337c		       65		      .byte.b	101
      0  337d					      db	(UNKNOWNV-*)-1
      1  337d		       5c		      .byte.b	(UNKNOWNV-*)-1
      0  337e					      db	oLeftBracket
      1  337e		       e0		      .byte.b	oLeftBracket
      0  337f					      CALL	EXPR	; Length
      0  337f					      db	28
      1  337f		       1c		      .byte.b	28
      0  3380					      dw	EXPR
      1  3380		       41 34		      .word.w	EXPR
      0  3382					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  3382					      db	101
      1  3382		       65		      .byte.b	101
      0  3383					      db	(UNKNOWNV-*)-1
      1  3383		       56		      .byte.b	(UNKNOWNV-*)-1
      0  3384					      db	oComma
      1  3384		       e2		      .byte.b	oComma
      0  3385					      CALL	EXPR	; Destination
      0  3385					      db	28
      1  3385		       1c		      .byte.b	28
      0  3386					      dw	EXPR
      1  3386		       41 34		      .word.w	EXPR
      0  3388					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  3388					      db	101
      1  3388		       65		      .byte.b	101
      0  3389					      db	(UNKNOWNV-*)-1
      1  3389		       50		      .byte.b	(UNKNOWNV-*)-1
      0  338a					      db	oComma
      1  338a		       e2		      .byte.b	oComma
      0  338b					      CALL	EXPR	; Source
      0  338b					      db	28
      1  338b		       1c		      .byte.b	28
      0  338c					      dw	EXPR
      1  338c		       41 34		      .word.w	EXPR
      0  338e					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  338e					      db	101
      1  338e		       65		      .byte.b	101
      0  338f					      db	(UNKNOWNV-*)-1
      1  338f		       4a		      .byte.b	(UNKNOWNV-*)-1
      0  3390					      db	oRightBracket
      1  3390		       e1		      .byte.b	oRightBracket
      0  3391					      COPYBLOCK		; Copy the memory
      0  3391					      db	111
      1  3391		       6f		      .byte.b	111
      0  3392					      DONE
      0  3392					      db	1
      1  3392		       01		      .byte.b	1
      0  3393					      NXT	CO
      0  3393					      db	6
      1  3393		       06		      .byte.b	6
      0  3394					      dw	CO
      1  3394		       20 32		      .word.w	CO
      0  3396					      IJMP	STMT
      0  3396					      db	29
      1  3396		       1d		      .byte.b	29
      0  3397					      dw	STMT
      1  3397		       28 32		      .word.w	STMT
    414  3399
    415  3399							;================================================================
    416  3399							; Write a single byte to the output device
    417  3399							;
    418  3399				   ekPutch
      0  3399					      CALL	EXPR
      0  3399					      db	28
      1  3399		       1c		      .byte.b	28
      0  339a					      dw	EXPR
      1  339a		       41 34		      .word.w	EXPR
      0  339c					      PUTCHAR
      0  339c					      db	52
      1  339c		       34		      .byte.b	52
      0  339d					      DONE
      0  339d					      db	1
      1  339d		       01		      .byte.b	1
      0  339e					      NXT	CO	;AND SEQUENCE TO NEXT
      0  339e					      db	6
      1  339e		       06		      .byte.b	6
      0  339f					      dw	CO
      1  339f		       20 32		      .word.w	CO
      0  33a1					      IJMP	STMT
      0  33a1					      db	29
      1  33a1		       1d		      .byte.b	29
      0  33a2					      dw	STMT
      1  33a2		       28 32		      .word.w	STMT
    424  33a4							;================================================================
    425  33a4							; Clear the screen lines
    426  33a4							;  Uses the vt100 control seq, so must be connected to vt100 terminal
    427  33a4							;
    428  33a4				   ekCls
      0  33a4					      CLEARSCREEN
      0  33a4					      db	46
      1  33a4		       2e		      .byte.b	46
      0  33a5					      NXT	CO	;AND SEQUENCE TO NEXT
      0  33a5					      db	6
      1  33a5		       06		      .byte.b	6
      0  33a6					      dw	CO
      1  33a6		       20 32		      .word.w	CO
      0  33a8					      IJMP	STMT
      0  33a8					      db	29
      1  33a8		       1d		      .byte.b	29
      0  33a9					      dw	STMT
      1  33a9		       28 32		      .word.w	STMT
    432  33ab							;==================================================================
    433  33ab							; Get input from the terminal
    434  33ab							;   Reads from the currently active input device
    435  33ab							;
    436  33ab				   ekInput
    437  33ab				   S10
      0  33ab					      TSTB	S10A,tString	;If there is a string print the prompt
      0  33ab					      db	101
      1  33ab		       65		      .byte.b	101
      0  33ac					      db	(S10A-*)-1
      1  33ac		       05		      .byte.b	(S10A-*)-1
      0  33ad					      db	tString
      1  33ad		       a0		      .byte.b	tString
      0  33ae					      PRS
      0  33ae					      db	2
      1  33ae		       02		      .byte.b	2
      0  33af					      TSTB	S10Z,oSemiColon	;Must follow the prompt
      0  33af					      db	101
      1  33af		       65		      .byte.b	101
      0  33b0					      db	(S10Z-*)-1
      1  33b0		       1e		      .byte.b	(S10Z-*)-1
      0  33b1					      db	oSemiColon
      1  33b1		       e3		      .byte.b	oSemiColon
    441  33b2				   S10A
      0  33b2					      TSTB	InNoString,oDollar	; Check if we are reading characters
      0  33b2					      db	101
      1  33b2		       65		      .byte.b	101
      0  33b3					      db	(InNoString-*)-1
      1  33b3		       0c		      .byte.b	(InNoString-*)-1
      0  33b4					      db	oDollar
      1  33b4		       e7		      .byte.b	oDollar
      0  33b5					      TSTV	UNKNOWN
      0  33b5					      db	33
      1  33b5		       21		      .byte.b	33
      0  33b6					      db	(UNKNOWN-*)-1
      1  33b6		       86		      .byte.b	(UNKNOWN-*)-1
      0  33b7					      CALL	FactVarPtrNoTst
      0  33b7					      db	28
      1  33b7		       1c		      .byte.b	28
      0  33b8					      dw	FactVarPtrNoTst
      1  33b8		       f1 35		      .word.w	FactVarPtrNoTst
      0  33ba					      INSTR		;Move character From tty to AESTK
      0  33ba					      db	59
      1  33ba		       3b		      .byte.b	59
      0  33bb					      SETR2	tByte
      0  33bb					      db	94
      1  33bb		       5e		      .byte.b	94
      0  33bc					      db	tByte
      1  33bc		       a2		      .byte.b	tByte
      0  33bd					      IJMP	S10A2
      0  33bd					      db	29
      1  33bd		       1d		      .byte.b	29
      0  33be					      dw	S10A2
      1  33be		       c8 33		      .word.w	S10A2
    448  33c0
    449  33c0				   InNoString
      0  33c0					      TSTV	UNKNOWN	; GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  33c0					      db	33
      1  33c0		       21		      .byte.b	33
      0  33c1					      db	(UNKNOWN-*)-1
      1  33c1		       7b		      .byte.b	(UNKNOWN-*)-1
      0  33c2					      CALL	FactVarPtrNoTst
      0  33c2					      db	28
      1  33c2		       1c		      .byte.b	28
      0  33c3					      dw	FactVarPtrNoTst
      1  33c3		       f1 35		      .word.w	FactVarPtrNoTst
      0  33c5					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  33c5					      db	11
      1  33c5		       0b		      .byte.b	11
      0  33c6					      SETR2	tInteger
      0  33c6					      db	94
      1  33c6		       5e		      .byte.b	94
      0  33c7					      db	tInteger
      1  33c7		       a4		      .byte.b	tInteger
    454  33c8
    455  33c8				   S10A2
      0  33c8					      STORE		;STORE IT
      0  33c8					      db	19
      1  33c8		       13		      .byte.b	19
      0  33c9					      TSTB	S11,oComma	;IS THERE MORE?
      0  33c9					      db	101
      1  33c9		       65		      .byte.b	101
      0  33ca					      db	(S11-*)-1
      1  33ca		       07		      .byte.b	(S11-*)-1
      0  33cb					      db	oComma
      1  33cb		       e2		      .byte.b	oComma
      0  33cc					      IJMP	S10	;YES
      0  33cc					      db	29
      1  33cc		       1d		      .byte.b	29
      0  33cd					      dw	S10
      1  33cd		       ab 33		      .word.w	S10
    459  33cf				   S10Z
      0  33cf					      iJMP	UNKNOWN
      0  33cf					      db	29
      1  33cf		       1d		      .byte.b	29
      0  33d0					      dw	UNKNOWN
      1  33d0		       3d 34		      .word.w	UNKNOWN
    461  33d2				   S11
      0  33d2					      DONE		;MUST BE CR
      0  33d2					      db	1
      1  33d2		       01		      .byte.b	1
      0  33d3					      NXT	CO	;SEQUENCE TO NEXT
      0  33d3					      db	6
      1  33d3		       06		      .byte.b	6
      0  33d4					      dw	CO
      1  33d4		       20 32		      .word.w	CO
      0  33d6					      IJMP	STMT
      0  33d6					      db	29
      1  33d6		       1d		      .byte.b	29
      0  33d7					      dw	STMT
      1  33d7		       28 32		      .word.w	STMT
    465  33d9							;=====================================================================
    466  33d9							; End of program, return to command line process
    467  33d9							; Main Task may also use taske or return to stopped
    468  33d9							;
    469  33d9				   ekEnd
      0  33d9					      FIN
      0  33d9					      db	12
      1  33d9		       0c		      .byte.b	12
    471  33da				   UNKNOWNV
      0  33da					      IJMP	UNKNOWN
      0  33da					      db	29
      1  33da		       1d		      .byte.b	29
      0  33db					      dw	UNKNOWN
      1  33db		       3d 34		      .word.w	UNKNOWN
    473  33dd							;====================================================================
    474  33dd							; IRQ <IRQ-HANDLER-Line expression>
    475  33dd							;   Specify a line number subroutine to call when an interupt is processed
    476  33dd							;   These subroutines must use iret to return.
    477  33dd							;
    478  33dd				   ekIrq
      0  33dd					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  33dd					      db	28
      1  33dd		       1c		      .byte.b	28
      0  33de					      dw	EXPR
      1  33de		       41 34		      .word.w	EXPR
      0  33e0					      DONE		;must be CR
      0  33e0					      db	1
      1  33e0		       01		      .byte.b	1
      0  33e1					      SETIRQ		;Set the line number now
      0  33e1					      db	56
      1  33e1		       38		      .byte.b	56
      0  33e2					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  33e2					      db	6
      1  33e2		       06		      .byte.b	6
      0  33e3					      dw	CO
      1  33e3		       20 32		      .word.w	CO
      0  33e5					      IJMP	STMT
      0  33e5					      db	29
      1  33e5		       1d		      .byte.b	29
      0  33e6					      dw	STMT
      1  33e6		       28 32		      .word.w	STMT
    484  33e8
    485  33e8							;=========================================================================
    486  33e8							; KILL PID-expression	 kill a running task
    487  33e8							;  ignored of task has already stopped
    488  33e8							;
    489  33e8				   ekKill
      0  33e8					      CALL	EXPR
      0  33e8					      db	28
      1  33e8		       1c		      .byte.b	28
      0  33e9					      dw	EXPR
      1  33e9		       41 34		      .word.w	EXPR
      0  33eb					      DONE
      0  33eb					      db	1
      1  33eb		       01		      .byte.b	1
      0  33ec					      TASKKILL
      0  33ec					      db	65
      1  33ec		       41		      .byte.b	65
      0  33ed					      NXT	CO
      0  33ed					      db	6
      1  33ed		       06		      .byte.b	6
      0  33ee					      dw	CO
      1  33ee		       20 32		      .word.w	CO
      0  33f0					      IJMP	STMT
      0  33f0					      db	29
      1  33f0		       1d		      .byte.b	29
      0  33f1					      dw	STMT
      1  33f1		       28 32		      .word.w	STMT
    495  33f3
    496  33f3							;============================================================================
    497  33f3							; List all program lines
    498  33f3							;
    499  33f3				   ekList
      0  33f3					      DONE
      0  33f3					      db	1
      1  33f3		       01		      .byte.b	1
      0  33f4					      LST
      0  33f4					      db	21
      1  33f4		       15		      .byte.b	21
      0  33f5					      IJMP	CO
      0  33f5					      db	29
      1  33f5		       1d		      .byte.b	29
      0  33f6					      dw	CO
      1  33f6		       20 32		      .word.w	CO
    503  33f8							;=======================================================================
    504  33f8							;RUN begin to executed the program in memory
    505  33f8							;
    506  33f8				   ekRun
      0  33f8					      DONE
      0  33f8					      db	1
      1  33f8		       01		      .byte.b	1
      0  33f9					      VINIT		;clear variables compile the line numbers
      0  33f9					      db	30
      1  33f9		       1e		      .byte.b	30
      0  33fa					      LIT	1	;GOTO line 1
      0  33fa					      db	27
      1  33fa		       1b		      .byte.b	27
      0  33fb					      dw	1
      1  33fb		       01 00		      .word.w	1
      0  33fd					      XFER		;Bob's addition
      0  33fd					      db	7
      1  33fd		       07		      .byte.b	7
    511  33fe							; EXIT
      0  33fe					      IJMP	STMT	;and run!
      0  33fe					      db	29
      1  33fe		       1d		      .byte.b	29
      0  33ff					      dw	STMT
      1  33ff		       28 32		      .word.w	STMT
    513  3401							;=========================================================================
    514  3401							;Clear the program memory, delete all proram lines
    515  3401							;
    516  3401				   ekNew
      0  3401					      DONE
      0  3401					      db	1
      1  3401		       01		      .byte.b	1
      0  3402					      IJMP	START
      0  3402					      db	29
      1  3402		       1d		      .byte.b	29
      0  3403					      dw	START
      1  3403		       1a 32		      .word.w	START
    519  3405
    520  3405							;========================================================================
    521  3405							; Slice(slice legth expression)
    522  3405							;   set the length of time between task switches
    523  3405							;
    524  3405				   ekSlice
      0  3405					      CALL	EXPR
      0  3405					      db	28
      1  3405		       1c		      .byte.b	28
      0  3406					      dw	EXPR
      1  3406		       41 34		      .word.w	EXPR
      0  3408					      SLICE
      0  3408					      db	100
      1  3408		       64		      .byte.b	100
      0  3409					      DONE
      0  3409					      db	1
      1  3409		       01		      .byte.b	1
      0  340a					      NXT	CO
      0  340a					      db	6
      1  340a		       06		      .byte.b	6
      0  340b					      dw	CO
      1  340b		       20 32		      .word.w	CO
      0  340d					      IJMP	STMT
      0  340d					      db	29
      1  340d		       1d		      .byte.b	29
      0  340e					      dw	STMT
      1  340e		       28 32		      .word.w	STMT
    530  3410							;==========================================================================
    531  3410							; Turn off and on the thrace functions
    532  3410							; a debug terminal needs to be available
    533  3410							; Trace( Trace flag expression)
    534  3410							;	128 trace IL code, 64 trace basic code, 1 turn on interactive debug
    535  3410							;	for individual lines of basic code. These can be combined
    536  3410				   ekTrace
      0  3410					      TSTB	UNKNOWN,oLeftBracket	;Are we going to trace
      0  3410					      db	101
      1  3410		       65		      .byte.b	101
      0  3411					      db	(UNKNOWN-*)-1
      1  3411		       2b		      .byte.b	(UNKNOWN-*)-1
      0  3412					      db	oLeftBracket
      1  3412		       e0		      .byte.b	oLeftBracket
      0  3413					      CALL	EXPR
      0  3413					      db	28
      1  3413		       1c		      .byte.b	28
      0  3414					      dw	EXPR
      1  3414		       41 34		      .word.w	EXPR
      0  3416					      TSTB	UNKNOWN,oRightBracket
      0  3416					      db	101
      1  3416		       65		      .byte.b	101
      0  3417					      db	(UNKNOWN-*)-1
      1  3417		       25		      .byte.b	(UNKNOWN-*)-1
      0  3418					      db	oRightBracket
      1  3418		       e1		      .byte.b	oRightBracket
      0  3419					      TRACEPROGRAM
      0  3419					      db	78
      1  3419		       4e		      .byte.b	78
      0  341a					      DONE
      0  341a					      db	1
      1  341a		       01		      .byte.b	1
      0  341b					      NXT	CO
      0  341b					      db	6
      1  341b		       06		      .byte.b	6
      0  341c					      dw	CO
      1  341c		       20 32		      .word.w	CO
      0  341e					      IJMP	STMT
      0  341e					      db	29
      1  341e		       1d		      .byte.b	29
      0  341f					      dw	STMT
      1  341f		       28 32		      .word.w	STMT
    544  3421							;=====================================================================
    545  3421							; Exit basic to machine monitor
    546  3421							;
    547  3421				   ekExit
      0  3421					      EXIT
      0  3421					      db	26
      1  3421		       1a		      .byte.b	26
    549  3422
    550  3422							;=======================================================================
    551  3422							; Commands related to saving/restoring programs
    552  3422							; to/from mass storage.
    553  3422							;=======================================================================
    554  3422							; Save a program file
    555  3422							;
    556  3422					      if	(XKIM || CTMON65) && DISK_ACCESS
    557  3422
    558  3422				   ekSave
      0  3422					      OPENWRITE	OPEN_CREATE
      0  3422					      db	40
      1  3422		       28		      .byte.b	40
      0  3423					      db	OPEN_CREATE
      1  3423		       01		      .byte.b	OPEN_CREATE
      0  3424					      DLIST
      0  3424					      db	43
      1  3424		       2b		      .byte.b	43
      0  3425					      DCLOSE
      0  3425					      db	41
      1  3425		       29		      .byte.b	41
      0  3426					      IJMP	CO
      0  3426					      db	29
      1  3426		       1d		      .byte.b	29
      0  3427					      dw	CO
      1  3427		       20 32		      .word.w	CO
    563  3429							;=========================================================================
    564  3429							; Load a program file
    565  3429							;
    566  3429				   ekLoad
      0  3429					      OPENREAD
      0  3429					      db	39
      1  3429		       27		      .byte.b	39
    568  342a				   S17CLP
      0  342a					      DGETLINE		;get line from file
      0  342a					      db	42
      1  342a		       2a		      .byte.b	42
      0  342b					      TSTL	S17EOL	;no line num means EOL
      0  342b					      db	34
      1  342b		       22		      .byte.b	34
      0  342c					      db	(S17EOL-*)-1
      1  342c		       04		      .byte.b	(S17EOL-*)-1
      0  342d					      INSERT		;put it into the program
      0  342d					      db	24
      1  342d		       18		      .byte.b	24
      0  342e					      IJMP	S17CLP	;keep going
      0  342e					      db	29
      1  342e		       1d		      .byte.b	29
      0  342f					      dw	S17CLP
      1  342f		       2a 34		      .word.w	S17CLP
    573  3431				   S17EOL
      0  3431					      DCLOSE		;close disk file
      0  3431					      db	41
      1  3431		       29		      .byte.b	41
      0  3432					      IJMP	CO	;back to start
      0  3432					      db	29
      1  3432		       1d		      .byte.b	29
      0  3433					      dw	CO
      1  3433		       20 32		      .word.w	CO
    576  3435							;=========================================================================
    577  3435							; Display the directory content
    578  3435							;
    579  3435				   ekDir
      0  3435					      DDIR		;Display the directory content
      0  3435					      db	44
      1  3435		       2c		      .byte.b	44
      0  3436					      IJMP	CO
      0  3436					      db	29
      1  3436		       1d		      .byte.b	29
      0  3437					      dw	CO
      1  3437		       20 32		      .word.w	CO
    582  3439							;=========================================================================
    583  3439							; Erase a file from disk
    584  3439							;
    585  3439				   ekErase
      0  3439					      RMFILE		;Erase the file from the disk
      0  3439					      db	45
      1  3439		       2d		      .byte.b	45
      0  343a					      IJMP	CO
      0  343a					      db	29
      1  343a		       1d		      .byte.b	29
      0  343b					      dw	CO
      1  343b		       20 32		      .word.w	CO
    588  343d
    589  343d					      endif
    590  343d
    591  343d							;===========================================================================
    592  343d							; Else, unknown command.
    593  343d							;
    594  343d				   UNKNOWN
      0  343d					      ENDIO
      0  343d					      db	71
      1  343d		       47		      .byte.b	71
    596  343e
    597  343e				   NotKnownStatement
    598  343e
      0  343e					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  343e					      db	13
      1  343e		       0d		      .byte.b	13
      0  343f					      dw	ERR_SYNTAX
      1  343f		       05 00		      .word.w	ERR_SYNTAX
    600  3441
    601  3441							;=======================================================
    602  3441							; Process Expresions, precidence is represented by the
    603  3441							; various call levels
    604  3441							;
    605  3441				   EXPR
      0  3441					      TSTB	EXPRLOGS,kNot
      0  3441					      db	101
      1  3441		       65		      .byte.b	101
      0  3442					      db	(EXPRLOGS-*)-1
      1  3442		       06		      .byte.b	(EXPRLOGS-*)-1
      0  3443					      db	kNot
      1  3443		       24		      .byte.b	kNot
    607  3444				   ekNot
      0  3444					      Call	EXPR
      0  3444					      db	28
      1  3444		       1c		      .byte.b	28
      0  3445					      dw	EXPR
      1  3445		       41 34		      .word.w	EXPR
      0  3447					      LOGNOT
      0  3447					      db	72
      1  3447		       48		      .byte.b	72
      0  3448					      RTN
      0  3448					      db	25
      1  3448		       19		      .byte.b	25
    611  3449
    612  3449							;=========================================================
    613  3449							;Look for logical operators, but does get first part of expression
    614  3449				   EXPRLOGS
      0  3449					      Call	EXPR2	; get the left first expression
      0  3449					      db	28
      1  3449		       1c		      .byte.b	28
      0  344a					      dw	EXPR2
      1  344a		       78 34		      .word.w	EXPR2
      0  344c					      TSTRELOP	EXPSHIFT	; Exit level if no rel ops found
      0  344c					      db	104
      1  344c		       68		      .byte.b	104
      0  344d					      db	(EXPSHIFT-*)-1
      1  344d		       05		      .byte.b	(EXPSHIFT-*)-1
    617  344e							;	  TSTB	     iR0,oEqual
    618  344e							;	  LIT	     2		     ;=
    619  344e							;	  IJMP	     iRFound
    620  344e							;iR0:
    621  344e							;	  TSTB	      iR1,oLessEqual
    622  344e							;	  LIT	      3 	      ;<=
    623  344e							;	  IJMP	     iRFound
    624  344e							;iR1:
    625  344e							;	  TSTB	     iR3,oNotEqual
    626  344e							;	  LIT	     5		      ;<>
    627  344e							;	      IJMP	  iRFound
    628  344e							;iR3:
    629  344e							;	  TSTB	     iR4,oLess
    630  344e							;	  LIT	     1		     ;<
    631  344e							;	      IJMP	  iRFound
    632  344e							;iR4:
    633  344e							;	  TST	     iR5,oGreaterEqual
    634  344e							;	  LIT	     6		     ;>=
    635  344e							;	      IJMP	  iRFound
    636  344e							;iR5:
    637  344e							;	  TSTB	     iRDone,oGreater
    638  344e							;	  LIT	     4		     ;>
    639  344e				   iRFound
      0  344e					      Call	EXPR2	; EXPR; get the right side of the expression
      0  344e					      db	28
      1  344e		       1c		      .byte.b	28
      0  344f					      dw	EXPR2
      1  344f		       78 34		      .word.w	EXPR2
      0  3451					      CMPR		; Push the value of the true false onto the stack
      0  3451					      db	10
      1  3451		       0a		      .byte.b	10
      0  3452					      RTN
      0  3452					      db	25
      1  3452		       19		      .byte.b	25
    643  3453
    644  3453							;=========================================================
    645  3453							;Look for shift left and shift right level
    646  3453				   EXPSHIFT
      0  3453					      OnGoto	BasicShift,EXPRLOGICAL
      0  3453					      db	103
      1  3453		       67		      .byte.b	103
      0  3454					      dw	BasicShift
      1  3454		       ee 31		      .word.w	BasicShift
      0  3456					      dw	EXPRLOGICAL
      1  3456		       64 34		      .word.w	EXPRLOGICAL
    648  3458
    649  3458				   ekShiftLeft
      0  3458					      Call	EXPR
      0  3458					      db	28
      1  3458		       1c		      .byte.b	28
      0  3459					      dw	EXPR
      1  3459		       41 34		      .word.w	EXPR
      0  345b					      SHIFT	0
      0  345b					      db	113
      1  345b		       71		      .byte.b	113
      0  345c					      db	0
      1  345c		       00		      .byte.b	0
      0  345d					      RTN
      0  345d					      db	25
      1  345d		       19		      .byte.b	25
    653  345e
    654  345e				   ekShiftRight
      0  345e					      Call	EXPR
      0  345e					      db	28
      1  345e		       1c		      .byte.b	28
      0  345f					      dw	EXPR
      1  345f		       41 34		      .word.w	EXPR
      0  3461					      SHIFT	1
      0  3461					      db	113
      1  3461		       71		      .byte.b	113
      0  3462					      db	1
      1  3462		       01		      .byte.b	1
      0  3463					      RTN
      0  3463					      db	25
      1  3463		       19		      .byte.b	25
    658  3464
    659  3464							;======================================================================
    660  3464				   EXPRLOGICAL
      0  3464					      OnGoto	BasicLogical,iLOGExit
      0  3464					      db	103
      1  3464		       67		      .byte.b	103
      0  3465					      dw	BasicLogical
      1  3465		       e6 31		      .word.w	BasicLogical
      0  3467					      dw	iLOGExit
      1  3467		       77 34		      .word.w	iLOGExit
    662  3469				   ekAnd
      0  3469					      Call	EXPR
      0  3469					      db	28
      1  3469		       1c		      .byte.b	28
      0  346a					      dw	EXPR
      1  346a		       41 34		      .word.w	EXPR
      0  346c					      LOGAND
      0  346c					      db	74
      1  346c		       4a		      .byte.b	74
      0  346d					      RTN
      0  346d					      db	25
      1  346d		       19		      .byte.b	25
    666  346e				   ekOr
      0  346e					      Call	EXPR
      0  346e					      db	28
      1  346e		       1c		      .byte.b	28
      0  346f					      dw	EXPR
      1  346f		       41 34		      .word.w	EXPR
      0  3471					      LOGOR
      0  3471					      db	73
      1  3471		       49		      .byte.b	73
      0  3472					      RTN
      0  3472					      db	25
      1  3472		       19		      .byte.b	25
    670  3473				   ekXor
      0  3473					      Call	EXPR
      0  3473					      db	28
      1  3473		       1c		      .byte.b	28
      0  3474					      dw	EXPR
      1  3474		       41 34		      .word.w	EXPR
      0  3476					      LOGXOR
      0  3476					      db	75
      1  3476		       4b		      .byte.b	75
    673  3477				   iLOGExit
      0  3477					      RTN
      0  3477					      db	25
      1  3477		       19		      .byte.b	25
    675  3478
    676  3478							; get the right part of an expression
    677  3478				   EXPR2
      0  3478					      TSTB	E0,oMinus	; Look for leading - to negate term
      0  3478					      db	101
      1  3478		       65		      .byte.b	101
      0  3479					      db	(E0-*)-1
      1  3479		       08		      .byte.b	(E0-*)-1
      0  347a					      db	oMinus
      1  347a		       eb		      .byte.b	oMinus
      0  347b					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  347b					      db	28
      1  347b		       1c		      .byte.b	28
      0  347c					      dw	TERM
      1  347c		       9e 34		      .word.w	TERM
      0  347e					      NEG		; Make value negated
      0  347e					      db	16
      1  347e		       10		      .byte.b	16
      0  347f					      IJMP	E1	; We have Left term process operators next
      0  347f					      db	29
      1  347f		       1d		      .byte.b	29
      0  3480					      dw	E1
      1  3480		       88 34		      .word.w	E1
    682  3482				   E0
      0  3482					      TSTB	E1A,oPlus	; Look for a leading + for value and disgard it if found
      0  3482					      db	101
      1  3482		       65		      .byte.b	101
      0  3483					      db	(E1A-*)-1
      1  3483		       01		      .byte.b	(E1A-*)-1
      0  3484					      db	oPlus
      1  3484		       ea		      .byte.b	oPlus
    684  3485				   E1A
      0  3485					      CALL	TERM	; Get the left term if it was not negated
      0  3485					      db	28
      1  3485		       1c		      .byte.b	28
      0  3486					      dw	TERM
      1  3486		       9e 34		      .word.w	TERM
    686  3488				   E1
      0  3488					      TST	E2,oPlus	; Check if we are adding left term to something
      0  3488					      db	32
      1  3488		       20		      .byte.b	32
      0  3489					      db	(E2-*)-1
      1  3489		       09		      .byte.b	(E2-*)-1
      0  348a					      db	oPlus,0
      1  348a		       ea 00		      .byte.b	oPlus,0
      0  348c					      CALL	TERM	; if adding then get the right side term
      0  348c					      db	28
      1  348c		       1c		      .byte.b	28
      0  348d					      dw	TERM
      1  348d		       9e 34		      .word.w	TERM
      0  348f					      ADD		; Add it to left term
      0  348f					      db	14
      1  348f		       0e		      .byte.b	14
      0  3490					      IJMP	E1	; look for next + or -
      0  3490					      db	29
      1  3490		       1d		      .byte.b	29
      0  3491					      dw	E1
      1  3491		       88 34		      .word.w	E1
    691  3493				   E2
      0  3493					      TSTB	E3,oMinus	; Check if we are subtractig something
      0  3493					      db	101
      1  3493		       65		      .byte.b	101
      0  3494					      db	(E3-*)-1
      1  3494		       08		      .byte.b	(E3-*)-1
      0  3495					      db	oMinus
      1  3495		       eb		      .byte.b	oMinus
      0  3496					      CALL	TERM	; get right side to subtract Diffrence
      0  3496					      db	28
      1  3496		       1c		      .byte.b	28
      0  3497					      dw	TERM
      1  3497		       9e 34		      .word.w	TERM
      0  3499					      SUB		; Subtract the value
      0  3499					      db	15
      1  3499		       0f		      .byte.b	15
      0  349a					      IJMP	E1	; Look for next + or -
      0  349a					      db	29
      1  349a		       1d		      .byte.b	29
      0  349b					      dw	E1
      1  349b		       88 34		      .word.w	E1
    696  349d				   E3			; Finish processing the expression
      0  349d					      RTN		; We are finished processing the Expression
      0  349d					      db	25
      1  349d		       19		      .byte.b	25
    698  349e							;
    699  349e							; Get one of the terms of an expression
    700  349e							;
    701  349e				   TERM
      0  349e					      CALL	FACT	; Get a value
      0  349e					      db	28
      1  349e		       1c		      .byte.b	28
      0  349f					      dw	FACT
      1  349f		       c3 34		      .word.w	FACT
    703  34a1				   T0			; Check for higher precidence operators
      0  34a1					      TSTB	T1,oMultiply	; Check for *
      0  34a1					      db	101
      1  34a1		       65		      .byte.b	101
      0  34a2					      db	(T1-*)-1
      1  34a2		       08		      .byte.b	(T1-*)-1
      0  34a3					      db	oMultiply
      1  34a3		       ee		      .byte.b	oMultiply
      0  34a4					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  34a4					      db	28
      1  34a4		       1c		      .byte.b	28
      0  34a5					      dw	FACT
      1  34a5		       c3 34		      .word.w	FACT
      0  34a7					      MUL		; Multiply factors
      0  34a7					      db	17
      1  34a7		       11		      .byte.b	17
      0  34a8					      IJMP	T0	; Check for * or /
      0  34a8					      db	29
      1  34a8		       1d		      .byte.b	29
      0  34a9					      dw	T0
      1  34a9		       a1 34		      .word.w	T0
    708  34ab				   T1
      0  34ab					      TSTB	T2,oDivide	; Check for a division
      0  34ab					      db	101
      1  34ab		       65		      .byte.b	101
      0  34ac					      db	(T2-*)-1
      1  34ac		       08		      .byte.b	(T2-*)-1
      0  34ad					      db	oDivide
      1  34ad		       ec		      .byte.b	oDivide
      0  34ae					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  34ae					      db	28
      1  34ae		       1c		      .byte.b	28
      0  34af					      dw	FACT
      1  34af		       c3 34		      .word.w	FACT
      0  34b1					      DIV		; do division
      0  34b1					      db	18
      1  34b1		       12		      .byte.b	18
      0  34b2					      IJMP	T0	; check for more * or /
      0  34b2					      db	29
      1  34b2		       1d		      .byte.b	29
      0  34b3					      dw	T0
      1  34b3		       a1 34		      .word.w	T0
    713  34b5				   T2
      0  34b5					      TSTB	T3,oModulo	; Check for a division
      0  34b5					      db	101
      1  34b5		       65		      .byte.b	101
      0  34b6					      db	(T3-*)-1
      1  34b6		       08		      .byte.b	(T3-*)-1
      0  34b7					      db	oModulo
      1  34b7		       ed		      .byte.b	oModulo
      0  34b8					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  34b8					      db	28
      1  34b8		       1c		      .byte.b	28
      0  34b9					      dw	FACT
      1  34b9		       c3 34		      .word.w	FACT
      0  34bb					      MODULO		; do division for remainder
      0  34bb					      db	60
      1  34bb		       3c		      .byte.b	60
      0  34bc					      IJMP	T0	; check for more * or / or %
      0  34bc					      db	29
      1  34bc		       1d		      .byte.b	29
      0  34bd					      dw	T0
      1  34bd		       a1 34		      .word.w	T0
    718  34bf				   T3			; Finish processing the Term
      0  34bf					      RTN
      0  34bf					      db	25
      1  34bf		       19		      .byte.b	25
    720  34c0
    721  34c0				   UNKNOWNVEC
      0  34c0					      IJMP	UNKNOWN
      0  34c0					      db	29
      1  34c0		       1d		      .byte.b	29
      0  34c1					      dw	UNKNOWN
      1  34c1		       3d 34		      .word.w	UNKNOWN
    723  34c3
    724  34c3							;=============================================================================================
    725  34c3							; Factor an expression.  Always test for functions
    726  34c3							; first or else they'll be confused for variables.
    727  34c3							;
    728  34c3				   FACT
      0  34c3					      OnGoto	BasicFuncs,FactNumber
      0  34c3					      db	103
      1  34c3		       67		      .byte.b	103
      0  34c4					      dw	BasicFuncs
      1  34c4		       f4 31		      .word.w	BasicFuncs
      0  34c6					      dw	FactNumber
      1  34c6		       c3 35		      .word.w	FactNumber
    730  34c8
    731  34c8							;FACTCONTINUE:
    732  34c8							;	  TSTB	     F1AA,kTrue
    733  34c8				   ekTrue
      0  34c8					      LIT	-1
      0  34c8					      db	27
      1  34c8		       1b		      .byte.b	27
      0  34c9					      dw	-1
      1  34c9		       ff ff		      .word.w	-1
      0  34cb					      RTN
      0  34cb					      db	25
      1  34cb		       19		      .byte.b	25
    736  34cc							;F1AA:
    737  34cc							;	  TSTB	     F1AB,kFalse
    738  34cc				   ekFalse
      0  34cc					      LIT	0
      0  34cc					      db	27
      1  34cc		       1b		      .byte.b	27
      0  34cd					      dw	0
      1  34cd		       00 00		      .word.w	0
      0  34cf					      RTN
      0  34cf					      db	25
      1  34cf		       19		      .byte.b	25
    741  34d0							;==================================================================================
    742  34d0							; Returns the amount of free SPACE
    743  34d0				   ekFree
      0  34d0					      TSTB	UNKNOWNVEC,oLeftBracket
      0  34d0					      db	101
      1  34d0		       65		      .byte.b	101
      0  34d1					      db	(UNKNOWNVEC-*)-1
      1  34d1		       ee		      .byte.b	(UNKNOWNVEC-*)-1
      0  34d2					      db	oLeftBracket
      1  34d2		       e0		      .byte.b	oLeftBracket
      0  34d3					      TSTB	UNKNOWNVEC,oRightBracket
      0  34d3					      db	101
      1  34d3		       65		      .byte.b	101
      0  34d4					      db	(UNKNOWNVEC-*)-1
      1  34d4		       eb		      .byte.b	(UNKNOWNVEC-*)-1
      0  34d5					      db	oRightBracket
      1  34d5		       e1		      .byte.b	oRightBracket
      0  34d6					      FREE
      0  34d6					      db	36
      1  34d6		       24		      .byte.b	36
      0  34d7					      RTN
      0  34d7					      db	25
      1  34d7		       19		      .byte.b	25
    748  34d8							;===================================================================================
    749  34d8							; getch() read a character from the input device
    750  34d8							;
    751  34d8				   ekGetch
      0  34d8					      TSTB	UNKNOWNVEC,oLeftBracket
      0  34d8					      db	101
      1  34d8		       65		      .byte.b	101
      0  34d9					      db	(UNKNOWNVEC-*)-1
      1  34d9		       e6		      .byte.b	(UNKNOWNVEC-*)-1
      0  34da					      db	oLeftBracket
      1  34da		       e0		      .byte.b	oLeftBracket
      0  34db					      TSTB	UNKNOWNVEC,oRightBracket
      0  34db					      db	101
      1  34db		       65		      .byte.b	101
      0  34dc					      db	(UNKNOWNVEC-*)-1
      1  34dc		       e3		      .byte.b	(UNKNOWNVEC-*)-1
      0  34dd					      db	oRightBracket
      1  34dd		       e1		      .byte.b	oRightBracket
      0  34de					      GETCHAR
      0  34de					      db	51
      1  34de		       33		      .byte.b	51
      0  34df					      RTN
      0  34df					      db	25
      1  34df		       19		      .byte.b	25
    756  34e0							;
    757  34e0							;====================================================================================
    758  34e0							; addr(variable definition)
    759  34e0							; Returns the address of a variable on top of the stack
    760  34e0				   ekAddr
      0  34e0					      TSTB	UNKNOWNVEC,oLeftBracket
      0  34e0					      db	101
      1  34e0		       65		      .byte.b	101
      0  34e1					      db	(UNKNOWNVEC-*)-1
      1  34e1		       de		      .byte.b	(UNKNOWNVEC-*)-1
      0  34e2					      db	oLeftBracket
      1  34e2		       e0		      .byte.b	oLeftBracket
      0  34e3					      TSTV	ExpectedVariable
      0  34e3					      db	33
      1  34e3		       21		      .byte.b	33
      0  34e4					      db	(ExpectedVariable-*)-1
      1  34e4		       07		      .byte.b	(ExpectedVariable-*)-1
      0  34e5					      CALL	FactVarPtrNoTst
      0  34e5					      db	28
      1  34e5		       1c		      .byte.b	28
      0  34e6					      dw	FactVarPtrNoTst
      1  34e6		       f1 35		      .word.w	FactVarPtrNoTst
      0  34e8					      TSTB	UNKNOWNVEC,oRightBracket
      0  34e8					      db	101
      1  34e8		       65		      .byte.b	101
      0  34e9					      db	(UNKNOWNVEC-*)-1
      1  34e9		       d6		      .byte.b	(UNKNOWNVEC-*)-1
      0  34ea					      db	oRightBracket
      1  34ea		       e1		      .byte.b	oRightBracket
      0  34eb					      RTN
      0  34eb					      db	25
      1  34eb		       19		      .byte.b	25
    766  34ec
    767  34ec				   ExpectedVariable
      0  34ec					      ERRMSG	ERR_SYNTAX	;Expected Variable
      0  34ec					      db	13
      1  34ec		       0d		      .byte.b	13
      0  34ed					      dw	ERR_SYNTAX
      1  34ed		       05 00		      .word.w	ERR_SYNTAX
    769  34ef							;
    770  34ef							;================================================================
    771  34ef							; Compare a block of memory
    772  34ef							; CmpMem(Length, Source 1, Source 2)
    773  34ef							; returns on the stack 0 equal, 1 s1>s2, -1 s1<s2
    774  34ef				   ekCmpMem
      0  34ef					      TSTB	UNKNOWNVEC,oLeftBracket	; opening bracket
      0  34ef					      db	101
      1  34ef		       65		      .byte.b	101
      0  34f0					      db	(UNKNOWNVEC-*)-1
      1  34f0		       cf		      .byte.b	(UNKNOWNVEC-*)-1
      0  34f1					      db	oLeftBracket
      1  34f1		       e0		      .byte.b	oLeftBracket
      0  34f2					      CALL	EXPR	; Length
      0  34f2					      db	28
      1  34f2		       1c		      .byte.b	28
      0  34f3					      dw	EXPR
      1  34f3		       41 34		      .word.w	EXPR
      0  34f5					      TSTB	UNKNOWNVEC,oComma	; Must have a comma
      0  34f5					      db	101
      1  34f5		       65		      .byte.b	101
      0  34f6					      db	(UNKNOWNVEC-*)-1
      1  34f6		       c9		      .byte.b	(UNKNOWNVEC-*)-1
      0  34f7					      db	oComma
      1  34f7		       e2		      .byte.b	oComma
      0  34f8					      CALL	EXPR	; Source 1
      0  34f8					      db	28
      1  34f8		       1c		      .byte.b	28
      0  34f9					      dw	EXPR
      1  34f9		       41 34		      .word.w	EXPR
      0  34fb					      TSTB	UNKNOWNVEC,oComma	; Must have a comma
      0  34fb					      db	101
      1  34fb		       65		      .byte.b	101
      0  34fc					      db	(UNKNOWNVEC-*)-1
      1  34fc		       c3		      .byte.b	(UNKNOWNVEC-*)-1
      0  34fd					      db	oComma
      1  34fd		       e2		      .byte.b	oComma
      0  34fe					      CALL	EXPR	; Source 2
      0  34fe					      db	28
      1  34fe		       1c		      .byte.b	28
      0  34ff					      dw	EXPR
      1  34ff		       41 34		      .word.w	EXPR
      0  3501					      TSTB	UNKNOWNVEC,oRightBracket	; closing bracket
      0  3501					      db	101
      1  3501		       65		      .byte.b	101
      0  3502					      db	(UNKNOWNVEC-*)-1
      1  3502		       bd		      .byte.b	(UNKNOWNVEC-*)-1
      0  3503					      db	oRightBracket
      1  3503		       e1		      .byte.b	oRightBracket
      0  3504					      CMPMEM		; Compare the memory
      0  3504					      db	112
      1  3504		       70		      .byte.b	112
      0  3505					      RTN
      0  3505					      db	25
      1  3505		       19		      .byte.b	25
    784  3506							;
    785  3506							;===============================================================================
    786  3506							; Set/stop/return timer values
    787  3506							;value 9 = 1 second, 1-5 = value * 10ms 6 = 10ms, 7=250ms, 8=500ms
    788  3506							;cmd	0 =
    789  3506				   eKTimer
      0  3506					      TSTB	UNKNOWNVEC,oLeftBracket	; opening bracket
      0  3506					      db	101
      1  3506		       65		      .byte.b	101
      0  3507					      db	(UNKNOWNVEC-*)-1
      1  3507		       b8		      .byte.b	(UNKNOWNVEC-*)-1
      0  3508					      db	oLeftBracket
      1  3508		       e0		      .byte.b	oLeftBracket
      0  3509					      CALL	EXPR	; purpose 0-4
      0  3509					      db	28
      1  3509		       1c		      .byte.b	28
      0  350a					      dw	EXPR
      1  350a		       41 34		      .word.w	EXPR
      0  350c					      TSTB	eKTimerZero,oComma	; Must have a comma if more than one value
      0  350c					      db	101
      1  350c		       65		      .byte.b	101
      0  350d					      db	(eKTimerZero-*)-1
      1  350d		       07		      .byte.b	(eKTimerZero-*)-1
      0  350e					      db	oComma
      1  350e		       e2		      .byte.b	oComma
      0  350f					      CALL	EXPR	; only used by set parameters
      0  350f					      db	28
      1  350f		       1c		      .byte.b	28
      0  3510					      dw	EXPR
      1  3510		       41 34		      .word.w	EXPR
      0  3512					      iJMP	eKTimerOut	; get out
      0  3512					      db	29
      1  3512		       1d		      .byte.b	29
      0  3513					      dw	eKTimerOut
      1  3513		       18 35		      .word.w	eKTimerOut
    795  3515				   eKTimerZero
      0  3515					      lit	0	; no second parameter
      0  3515					      db	27
      1  3515		       1b		      .byte.b	27
      0  3516					      dw	0
      1  3516		       00 00		      .word.w	0
    797  3518				   eKTimerOut
      0  3518					      TSTB	UNKNOWNVEC,oRightBracket	; closing bracket
      0  3518					      db	101
      1  3518		       65		      .byte.b	101
      0  3519					      db	(UNKNOWNVEC-*)-1
      1  3519		       a6		      .byte.b	(UNKNOWNVEC-*)-1
      0  351a					      db	oRightBracket
      1  351a		       e1		      .byte.b	oRightBracket
      0  351b					      Timer
      0  351b					      db	114
      1  351b		       72		      .byte.b	114
      0  351c					      RTN
      0  351c					      db	25
      1  351c		       19		      .byte.b	25
    801  351d
    802  351d							;====================================================================================
    803  351d							; peek(mem address) return the value of a byte in memory
    804  351d							; @[offset] return a word value from offset -- see tstv
    805  351d							;
    806  351d							;F1A2:
    807  351d							;	  TSTB	      F2AZ,kPeek		      ;Return a value from memory
    808  351d				   ekPeek
      0  351d					      TSTB	UNKNOWNVEC,oLeftBracket
      0  351d					      db	101
      1  351d		       65		      .byte.b	101
      0  351e					      db	(UNKNOWNVEC-*)-1
      1  351e		       a1		      .byte.b	(UNKNOWNVEC-*)-1
      0  351f					      db	oLeftBracket
      1  351f		       e0		      .byte.b	oLeftBracket
      0  3520					      CALL	EXPR	;Get the address to write to
      0  3520					      db	28
      1  3520		       1c		      .byte.b	28
      0  3521					      dw	EXPR
      1  3521		       41 34		      .word.w	EXPR
      0  3523					      TSTB	UNKNOWNVEC,oRightBracket
      0  3523					      db	101
      1  3523		       65		      .byte.b	101
      0  3524					      db	(UNKNOWNVEC-*)-1
      1  3524		       9b		      .byte.b	(UNKNOWNVEC-*)-1
      0  3525					      db	oRightBracket
      1  3525		       e1		      .byte.b	oRightBracket
      0  3526					      PEEKMEM
      0  3526					      db	48
      1  3526		       30		      .byte.b	48
      0  3527					      RTN
      0  3527					      db	25
      1  3527		       19		      .byte.b	25
    814  3528							;=======================================================================================
    815  3528							; TASK(line-num expr,[Parm1,....]) start a task with or without Parameters
    816  3528							;
    817  3528							;F2AZ:
    818  3528							;	  TSTB	      F2AZ1,kTask		      ;Check if we are setting a task start
    819  3528				   ekTask
      0  3528					      TSTBRANCH	ekTaskCompiled
      0  3528					      db	106
      1  3528		       6a		      .byte.b	106
      0  3529					      db	(ekTaskCompiled-*)-1
      1  3529		       0c		      .byte.b	(ekTaskCompiled-*)-1
      0  352a					      TSTB	UNKNOWNVEC,oLeftBracket
      0  352a					      db	101
      1  352a		       65		      .byte.b	101
      0  352b					      db	(UNKNOWNVEC-*)-1
      1  352b		       94		      .byte.b	(UNKNOWNVEC-*)-1
      0  352c					      db	oLeftBracket
      1  352c		       e0		      .byte.b	oLeftBracket
      0  352d					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  352d					      db	28
      1  352d		       1c		      .byte.b	28
      0  352e					      dw	EXPR
      1  352e		       41 34		      .word.w	EXPR
      0  3530					      lit	0
      0  3530					      db	27
      1  3530		       1b		      .byte.b	27
      0  3531					      dw	0
      1  3531		       00 00		      .word.w	0
      0  3533					      iJMP	ekTaskLinenum
      0  3533					      db	29
      1  3533		       1d		      .byte.b	29
      0  3534					      dw	ekTaskLinenum
      1  3534		       39 35		      .word.w	ekTaskLinenum
    825  3536
    826  3536				   ekTaskCompiled
      0  3536					      lit	1
      0  3536					      db	27
      1  3536		       1b		      .byte.b	27
      0  3537					      dw	1
      1  3537		       01 00		      .word.w	1
    828  3539
    829  3539				   ekTaskLinenum
      0  3539					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  3539					      db	61
      1  3539		       3d		      .byte.b	61
      0  353a					      TSTB	F2AZNoParms,oComma	;Parameters to be passed to task
      0  353a					      db	101
      1  353a		       65		      .byte.b	101
      0  353b					      db	(F2AZNoParms-*)-1
      1  353b		       0e		      .byte.b	(F2AZNoParms-*)-1
      0  353c					      db	oComma
      1  353c		       e2		      .byte.b	oComma
      0  353d					      SAVEMATHSTACK		;Push The mathstack
      0  353d					      db	86
      1  353d		       56		      .byte.b	86
      0  353e					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  353e					      db	89
      1  353e		       59		      .byte.b	89
    834  353f
    835  353f				   F2AZLOOP
      0  353f					      CALL	EXPR
      0  353f					      db	28
      1  353f		       1c		      .byte.b	28
      0  3540					      dw	EXPR
      1  3540		       41 34		      .word.w	EXPR
      0  3542					      TSTB	F2AZEndParm,oComma	;Parameters to be passed tp task
      0  3542					      db	101
      1  3542		       65		      .byte.b	101
      0  3543					      db	(F2AZEndParm-*)-1
      1  3543		       04		      .byte.b	(F2AZEndParm-*)-1
      0  3544					      db	oComma
      1  3544		       e2		      .byte.b	oComma
      0  3545					      IJMP	F2AZLOOP	;check for more
      0  3545					      db	29
      1  3545		       1d		      .byte.b	29
      0  3546					      dw	F2AZLOOP
      1  3546		       3f 35		      .word.w	F2AZLOOP
    839  3548
    840  3548				   F2AZEndParm
      0  3548					      RESTOREMATHSTACK		;Back to normal stack
      0  3548					      db	87
      1  3548		       57		      .byte.b	87
      0  3549					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  3549					      db	92
      1  3549		       5c		      .byte.b	92
    843  354a
    844  354a				   F2AZNoParms
      0  354a					      TSTB	UNKNOWNVEC,oRightBracket	;must be )
      0  354a					      db	101
      1  354a		       65		      .byte.b	101
      0  354b					      db	(UNKNOWNVEC-*)-1
      1  354b		       74		      .byte.b	(UNKNOWNVEC-*)-1
      0  354c					      db	oRightBracket
      1  354c		       e1		      .byte.b	oRightBracket
    846  354d
      0  354d					      TASKENABLE		;Enable the task to execute
      0  354d					      db	90
      1  354d		       5a		      .byte.b	90
    848  354e
      0  354e					      RTN		;Returns the Task number
      0  354e					      db	25
      1  354e		       19		      .byte.b	25
    850  354f							;=========================================================================================
    851  354f							; Check for IPC interproccess instructions
    852  354f							;   IPCS  - Send a message
    853  354f							;
    854  354f							;F2AZ1:
    855  354f							;	  TSTB	      F2AZa,kIpcs		      ;Test if one of the IPC functions
    856  354f				   ekIpcs
      0  354f					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  354f					      db	101
      1  354f		       65		      .byte.b	101
      0  3550					      db	(UNKNOWNVEC-*)-1
      1  3550		       6f		      .byte.b	(UNKNOWNVEC-*)-1
      0  3551					      db	oLeftBracket
      1  3551		       e0		      .byte.b	oLeftBracket
      0  3552					      CALL	EXPR	;Get the message value
      0  3552					      db	28
      1  3552		       1c		      .byte.b	28
      0  3553					      dw	EXPR
      1  3553		       41 34		      .word.w	EXPR
      0  3555					      TSTB	UNKNOWNVEC,oComma
      0  3555					      db	101
      1  3555		       65		      .byte.b	101
      0  3556					      db	(UNKNOWNVEC-*)-1
      1  3556		       69		      .byte.b	(UNKNOWNVEC-*)-1
      0  3557					      db	oComma
      1  3557		       e2		      .byte.b	oComma
      0  3558					      CALL	EXPR	;Get pid of task to send to
      0  3558					      db	28
      1  3558		       1c		      .byte.b	28
      0  3559					      dw	EXPR
      1  3559		       41 34		      .word.w	EXPR
      0  355b					      TSTB	UNKNOWNVEC,oRightBracket
      0  355b					      db	101
      1  355b		       65		      .byte.b	101
      0  355c					      db	(UNKNOWNVEC-*)-1
      1  355c		       63		      .byte.b	(UNKNOWNVEC-*)-1
      0  355d					      db	oRightBracket
      1  355d		       e1		      .byte.b	oRightBracket
      0  355e					      IPCSEND		;Send msg and clear pid msg pending
      0  355e					      db	80
      1  355e		       50		      .byte.b	80
      0  355f					      RTN
      0  355f					      db	25
      1  355f		       19		      .byte.b	25
    864  3560							;================================================================================
    865  3560							; IPCR() --- recieve a message, IPCR(VARIABLE) -- receive msg and return pid in var
    866  3560							;
    867  3560				   ekIpcr
      0  3560					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  3560					      db	101
      1  3560		       65		      .byte.b	101
      0  3561					      db	(UNKNOWNVEC-*)-1
      1  3561		       5e		      .byte.b	(UNKNOWNVEC-*)-1
      0  3562					      db	oLeftBracket
      1  3562		       e0		      .byte.b	oLeftBracket
      0  3563					      TSTB	F2AZa1,oRightBracket
      0  3563					      db	101
      1  3563		       65		      .byte.b	101
      0  3564					      db	(F2AZa1-*)-1
      1  3564		       07		      .byte.b	(F2AZa1-*)-1
      0  3565					      db	oRightBracket
      1  3565		       e1		      .byte.b	oRightBracket
      0  3566					      LIT	0	;We dont want the pid returned to us
      0  3566					      db	27
      1  3566		       1b		      .byte.b	27
      0  3567					      dw	0
      1  3567		       00 00		      .word.w	0
      0  3569					      IJMP	ekIpcrComplete
      0  3569					      db	29
      1  3569		       1d		      .byte.b	29
      0  356a					      dw	ekIpcrComplete
      1  356a		       71 35		      .word.w	ekIpcrComplete
    872  356c				   F2AZa1
      0  356c					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  356c					      db	33
      1  356c		       21		      .byte.b	33
      0  356d					      db	(UNKNOWNVEC-*)-1
      1  356d		       52		      .byte.b	(UNKNOWNVEC-*)-1
      0  356e					      TSTB	UNKNOWNVEC,oRightBracket
      0  356e					      db	101
      1  356e		       65		      .byte.b	101
      0  356f					      db	(UNKNOWNVEC-*)-1
      1  356f		       50		      .byte.b	(UNKNOWNVEC-*)-1
      0  3570					      db	oRightBracket
      1  3570		       e1		      .byte.b	oRightBracket
    875  3571
    876  3571				   ekIpcrComplete
      0  3571					      IPCIO		;Set the io bit and exit task till message
      0  3571					      db	83
      1  3571		       53		      .byte.b	83
      0  3572					      IPCRECEIVE		;Get the message
      0  3572					      db	81
      1  3572		       51		      .byte.b	81
      0  3573					      RTN
      0  3573					      db	25
      1  3573		       19		      .byte.b	25
    880  3574							;===============================================================================
    881  3574							; IPCC ---- check if a message is available
    882  3574				   ekIpcc
      0  3574					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3574					      db	101
      1  3574		       65		      .byte.b	101
      0  3575					      db	(UNKNOWNVEC-*)-1
      1  3575		       4a		      .byte.b	(UNKNOWNVEC-*)-1
      0  3576					      db	oLeftBracket
      1  3576		       e0		      .byte.b	oLeftBracket
      0  3577					      TSTB	UNKNOWNVEC,oRightBracket
      0  3577					      db	101
      1  3577		       65		      .byte.b	101
      0  3578					      db	(UNKNOWNVEC-*)-1
      1  3578		       47		      .byte.b	(UNKNOWNVEC-*)-1
      0  3579					      db	oRightBracket
      1  3579		       e1		      .byte.b	oRightBracket
      0  357a					      IPCCHECK
      0  357a					      db	82
      1  357a		       52		      .byte.b	82
      0  357b					      RTN
      0  357b					      db	25
      1  357b		       19		      .byte.b	25
    887  357c
    888  357c				   UNKNOWNID
      0  357c					      IJMP	UNKNOWN
      0  357c					      db	29
      1  357c		       1d		      .byte.b	29
      0  357d					      dw	UNKNOWN
      1  357d		       3d 34		      .word.w	UNKNOWN
    890  357f							;============================================================
    891  357f							; RND() is supposed to have an argument but if none
    892  357f							; was provided, just assume a large value.
    893  357f							;
    894  357f				   ekRnd
      0  357f					      TSTB	UNKNOWNVEC,oLeftBracket
      0  357f					      db	101
      1  357f		       65		      .byte.b	101
      0  3580					      db	(UNKNOWNVEC-*)-1
      1  3580		       3f		      .byte.b	(UNKNOWNVEC-*)-1
      0  3581					      db	oLeftBracket
      1  3581		       e0		      .byte.b	oLeftBracket
      0  3582					      TSTB	F2A1,oRightBracket
      0  3582					      db	101
      1  3582		       65		      .byte.b	101
      0  3583					      db	(F2A1-*)-1
      1  3583		       06		      .byte.b	(F2A1-*)-1
      0  3584					      db	oRightBracket
      1  3584		       e1		      .byte.b	oRightBracket
      0  3585					      LIT	32766
      0  3585					      db	27
      1  3585		       1b		      .byte.b	27
      0  3586					      dw	32766
      1  3586		       fe 7f		      .word.w	32766
      0  3588					      RANDOM
      0  3588					      db	37
      1  3588		       25		      .byte.b	37
      0  3589					      RTN
      0  3589					      db	25
      1  3589		       19		      .byte.b	25
    900  358a
    901  358a				   F2A1
      0  358a					      CALL	EXPR	;GET RANGE
      0  358a					      db	28
      1  358a		       1c		      .byte.b	28
      0  358b					      dw	EXPR
      1  358b		       41 34		      .word.w	EXPR
      0  358d					      TSTB	UNKNOWNVEC,oRightBracket
      0  358d					      db	101
      1  358d		       65		      .byte.b	101
      0  358e					      db	(UNKNOWNVEC-*)-1
      1  358e		       31		      .byte.b	(UNKNOWNVEC-*)-1
      0  358f					      db	oRightBracket
      1  358f		       e1		      .byte.b	oRightBracket
      0  3590					      RANDOM
      0  3590					      db	37
      1  3590		       25		      .byte.b	37
      0  3591					      RTN
      0  3591					      db	25
      1  3591		       19		      .byte.b	25
    906  3592							;==========================================================
    907  3592							;	Return absolute value of expresion
    908  3592							;
    909  3592				   ekAbs
      0  3592					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3592					      db	101
      1  3592		       65		      .byte.b	101
      0  3593					      db	(UNKNOWNVEC-*)-1
      1  3593		       2c		      .byte.b	(UNKNOWNVEC-*)-1
      0  3594					      db	oLeftBracket
      1  3594		       e0		      .byte.b	oLeftBracket
      0  3595					      CALL	EXPR	;get value
      0  3595					      db	28
      1  3595		       1c		      .byte.b	28
      0  3596					      dw	EXPR
      1  3596		       41 34		      .word.w	EXPR
      0  3598					      TSTB	UNKNOWNVEC,oRightBracket
      0  3598					      db	101
      1  3598		       65		      .byte.b	101
      0  3599					      db	(UNKNOWNVEC-*)-1
      1  3599		       26		      .byte.b	(UNKNOWNVEC-*)-1
      0  359a					      db	oRightBracket
      1  359a		       e1		      .byte.b	oRightBracket
      0  359b					      ABS
      0  359b					      db	38
      1  359b		       26		      .byte.b	38
      0  359c					      RTN
      0  359c					      db	25
      1  359c		       19		      .byte.b	25
    915  359d							;============================================================
    916  359d							;     Return the the status of a task, provide the PID
    917  359d							;
    918  359d				   ekStat
      0  359d					      TSTB	UNKNOWNVEC,oLeftBracket
      0  359d					      db	101
      1  359d		       65		      .byte.b	101
      0  359e					      db	(UNKNOWNVEC-*)-1
      1  359e		       21		      .byte.b	(UNKNOWNVEC-*)-1
      0  359f					      db	oLeftBracket
      1  359f		       e0		      .byte.b	oLeftBracket
      0  35a0					      Call	EXPR
      0  35a0					      db	28
      1  35a0		       1c		      .byte.b	28
      0  35a1					      dw	EXPR
      1  35a1		       41 34		      .word.w	EXPR
      0  35a3					      TSTB	UNKNOWNVEC,oRightBracket
      0  35a3					      db	101
      1  35a3		       65		      .byte.b	101
      0  35a4					      db	(UNKNOWNVEC-*)-1
      1  35a4		       1b		      .byte.b	(UNKNOWNVEC-*)-1
      0  35a5					      db	oRightBracket
      1  35a5		       e1		      .byte.b	oRightBracket
      0  35a6					      TASKSTAT
      0  35a6					      db	66
      1  35a6		       42		      .byte.b	66
      0  35a7					      RTN
      0  35a7					      db	25
      1  35a7		       19		      .byte.b	25
    924  35a8							;==============================================================
    925  35a8							; Return the current tasks pid
    926  35a8							;
    927  35a8				   ekPid
      0  35a8					      TASKPID
      0  35a8					      db	77
      1  35a8		       4d		      .byte.b	77
      0  35a9					      RTN
      0  35a9					      db	25
      1  35a9		       19		      .byte.b	25
    930  35aa							;===========================================================================
    931  35aa							; Call a machine function, provide the address to call and optionally
    932  35aa							; the value to be passed in reg A
    933  35aa				   ekCall
      0  35aa					      TSTB	UNKNOWNVEC,oLeftBracket
      0  35aa					      db	101
      1  35aa		       65		      .byte.b	101
      0  35ab					      db	(UNKNOWNVEC-*)-1
      1  35ab		       14		      .byte.b	(UNKNOWNVEC-*)-1
      0  35ac					      db	oLeftBracket
      1  35ac		       e0		      .byte.b	oLeftBracket
      0  35ad					      CALL	EXPR
      0  35ad					      db	28
      1  35ad		       1c		      .byte.b	28
      0  35ae					      dw	EXPR
      1  35ae		       41 34		      .word.w	EXPR
      0  35b0					      TSTB	F2B2A,oComma
      0  35b0					      db	101
      1  35b0		       65		      .byte.b	101
      0  35b1					      db	(F2B2A-*)-1
      1  35b1		       09		      .byte.b	(F2B2A-*)-1
      0  35b2					      db	oComma
      1  35b2		       e2		      .byte.b	oComma
      0  35b3					      CALL	EXPR
      0  35b3					      db	28
      1  35b3		       1c		      .byte.b	28
      0  35b4					      dw	EXPR
      1  35b4		       41 34		      .word.w	EXPR
      0  35b6					      TSTB	UNKNOWNVEC,oRightBracket
      0  35b6					      db	101
      1  35b6		       65		      .byte.b	101
      0  35b7					      db	(UNKNOWNVEC-*)-1
      1  35b7		       08		      .byte.b	(UNKNOWNVEC-*)-1
      0  35b8					      db	oRightBracket
      1  35b8		       e1		      .byte.b	oRightBracket
      0  35b9					      CALLFUNC
      0  35b9					      db	53
      1  35b9		       35		      .byte.b	53
      0  35ba					      RTN
      0  35ba					      db	25
      1  35ba		       19		      .byte.b	25
    941  35bb							; Run the gosub within this function
    942  35bb				   F2B2A
      0  35bb					      TSTB	UNKNOWNID,oRightBracket
      0  35bb					      db	101
      1  35bb		       65		      .byte.b	101
      0  35bc					      db	(UNKNOWNID-*)-1
      1  35bc		       bf		      .byte.b	(UNKNOWNID-*)-1
      0  35bd					      db	oRightBracket
      1  35bd		       e1		      .byte.b	oRightBracket
      0  35be					      LIT	0	; No parameter passed so just load zero to A
      0  35be					      db	27
      1  35be		       1b		      .byte.b	27
      0  35bf					      dw	0
      1  35bf		       00 00		      .word.w	0
      0  35c1					      CALLFUNC
      0  35c1					      db	53
      1  35c1		       35		      .byte.b	53
      0  35c2					      RTN
      0  35c2					      db	25
      1  35c2		       19		      .byte.b	25
    947  35c3
    948  35c3
    949  35c3							;=================================================================================
    950  35c3							;Check for a number !
    951  35c3							;
    952  35c3				   FactNumber
      0  35c3					      TSTN	FactVariable	;NUMBER, GET ITS VALUE.
      0  35c3					      db	35
      1  35c3		       23		      .byte.b	35
      0  35c4					      db	(FactVariable-*)-1
      1  35c4		       0f		      .byte.b	(FactVariable-*)-1
      0  35c5					      RTN
      0  35c5					      db	25
      1  35c5		       19		      .byte.b	25
    955  35c6
    956  35c6				   FactWithBracket
      0  35c6					      TSTB	F2RTN,oLeftBracket	;PARENTHESIZED EXPR.
      0  35c6					      db	101
      1  35c6		       65		      .byte.b	101
      0  35c7					      db	(F2RTN-*)-1
      1  35c7		       08		      .byte.b	(F2RTN-*)-1
      0  35c8					      db	oLeftBracket
      1  35c8		       e0		      .byte.b	oLeftBracket
      0  35c9					      CALL	EXPR
      0  35c9					      db	28
      1  35c9		       1c		      .byte.b	28
      0  35ca					      dw	EXPR
      1  35ca		       41 34		      .word.w	EXPR
      0  35cc					      TST	F2,oRightBracket
      0  35cc					      db	32
      1  35cc		       20		      .byte.b	32
      0  35cd					      db	(F2-*)-1
      1  35cd		       03		      .byte.b	(F2-*)-1
      0  35ce					      db	oRightBracket,0
      1  35ce		       e1 00		      .byte.b	oRightBracket,0
    960  35d0				   F2RTN
      0  35d0					      RTN
      0  35d0					      db	25
      1  35d0		       19		      .byte.b	25
    962  35d1
    963  35d1				   F2
      0  35d1					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  35d1					      db	13
      1  35d1		       0d		      .byte.b	13
      0  35d2					      dw	ERR_SYNTAX
      1  35d2		       05 00		      .word.w	ERR_SYNTAX
    965  35d4							;
    966  35d4							;=============================================================================
    967  35d4							; See if this is just a simple variable
    968  35d4							;  Allow a subscript for any variable
    969  35d4							;
    970  35d4				   FactVariable
    971  35d4
      0  35d4					      SETR2	tInteger
      0  35d4					      db	94
      1  35d4		       5e		      .byte.b	94
      0  35d5					      db	tInteger
      1  35d5		       a4		      .byte.b	tInteger
      0  35d6					      TSTV	FactWithBracket
      0  35d6					      db	33
      1  35d6		       21		      .byte.b	33
      0  35d7					      db	(FactWithBracket-*)-1
      1  35d7		       ee		      .byte.b	(FactWithBracket-*)-1
      0  35d8					      TSTBYTE	FactFNParm,R2,GOSUB_RTN_VALUE
      0  35d8					      db	97
      1  35d8		       61		      .byte.b	97
      0  35d9					      db	(FactFNParm-*)-1
      1  35d9		       08		      .byte.b	(FactFNParm-*)-1
      0  35da					      dw	R2
      1  35da		       58 00		      .word.w	R2
      0  35dc					      db	GOSUB_RTN_VALUE
      1  35dc		       81		      .byte.b	GOSUB_RTN_VALUE
      0  35dd					      CALL	FactVarPTR
      0  35dd					      db	28
      1  35dd		       1c		      .byte.b	28
      0  35de					      dw	FactVarPTR
      1  35de		       f1 35		      .word.w	FactVarPTR
    976  35e0							;	  CALL	      FactVariableValue
      0  35e0					      IND		; get the variable value
      0  35e0					      db	20
      1  35e0		       14		      .byte.b	20
      0  35e1					      RTN
      0  35e1					      db	25
      1  35e1		       19		      .byte.b	25
    979  35e2
    980  35e2				   FactFNParm
      0  35e2					      TSTB	FactExpectedOpeningBracket,oLeftSQBracket
      0  35e2					      db	101
      1  35e2		       65		      .byte.b	101
      0  35e3					      db	(FactExpectedOpeningBracket-*)-1
      1  35e3		       44		      .byte.b	(FactExpectedOpeningBracket-*)-1
      0  35e4					      db	oLeftSQBracket
      1  35e4		       e4		      .byte.b	oLeftSQBracket
      0  35e5					      CALL	EXPR
      0  35e5					      db	28
      1  35e5		       1c		      .byte.b	28
      0  35e6					      dw	EXPR
      1  35e6		       41 34		      .word.w	EXPR
      0  35e8					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  35e8					      db	101
      1  35e8		       65		      .byte.b	101
      0  35e9					      db	(FactMissingRightBracket-*)-1
      1  35e9		       3b		      .byte.b	(FactMissingRightBracket-*)-1
      0  35ea					      db	oRightSQBracket
      1  35ea		       e5		      .byte.b	oRightSQBracket
      0  35eb					      SUBSCRIPT	GOSUB_RTN_VALUE
      0  35eb					      db	64
      1  35eb		       40		      .byte.b	64
      0  35ec					      db	GOSUB_RTN_VALUE
      1  35ec		       81		      .byte.b	GOSUB_RTN_VALUE
      0  35ed					      SETR2	tInteger
      0  35ed					      db	94
      1  35ed		       5e		      .byte.b	94
      0  35ee					      db	tInteger
      1  35ee		       a4		      .byte.b	tInteger
      0  35ef					      IND
      0  35ef					      db	20
      1  35ef		       14		      .byte.b	20
      0  35f0					      RTN
      0  35f0					      db	25
      1  35f0		       19		      .byte.b	25
    988  35f1
    989  35f1				   FactVarPTR
    990  35f1				   FactVarPtrNoTst
      0  35f1					      TSTB	F2CLocalTask,oBang
      0  35f1					      db	101
      1  35f1		       65		      .byte.b	101
      0  35f2					      db	(F2CLocalTask-*)-1
      1  35f2		       04		      .byte.b	(F2CLocalTask-*)-1
      0  35f3					      db	oBang
      1  35f3		       e8		      .byte.b	oBang
      0  35f4					      IND		; we just got a pid
      0  35f4					      db	20
      1  35f4		       14		      .byte.b	20
      0  35f5					      TSTVT	UNKNOWNID	; if it is not another variable then error, Call test var. task
      0  35f5					      db	93
      1  35f5		       5d		      .byte.b	93
      0  35f6					      db	(UNKNOWNID-*)-1
      1  35f6		       85		      .byte.b	(UNKNOWNID-*)-1
    994  35f7
    995  35f7				   F2CLocalTask
      0  35f7					      SETR2	tInteger	; Sets the default type to integer
      0  35f7					      db	94
      1  35f7		       5e		      .byte.b	94
      0  35f8					      db	tInteger
      1  35f8		       a4		      .byte.b	tInteger
      0  35f9					      TSTB	F2INTEGER,oDollar	; Check if this will be a byte array @$[index] or a..z$[index] use a byte array
      0  35f9					      db	101
      1  35f9		       65		      .byte.b	101
      0  35fa					      db	(F2INTEGER-*)-1
      1  35fa		       11		      .byte.b	(F2INTEGER-*)-1
      0  35fb					      db	oDollar
      1  35fb		       e7		      .byte.b	oDollar
      0  35fc					      SETR2	tByte
      0  35fc					      db	94
      1  35fc		       5e		      .byte.b	94
      0  35fd					      db	tByte
      1  35fd		       a2		      .byte.b	tByte
      0  35fe					      TSTB	F2PTRLOADED,oLeftSQBracket
      0  35fe					      db	101
      1  35fe		       65		      .byte.b	101
      0  35ff					      db	(F2PTRLOADED-*)-1
      1  35ff		       22		      .byte.b	(F2PTRLOADED-*)-1
      0  3600					      db	oLeftSQBracket
      1  3600		       e4		      .byte.b	oLeftSQBracket
      0  3601					      CALL	EXPR
      0  3601					      db	28
      1  3601		       1c		      .byte.b	28
      0  3602					      dw	EXPR
      1  3602		       41 34		      .word.w	EXPR
      0  3604					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  3604					      db	101
      1  3604		       65		      .byte.b	101
      0  3605					      db	(FactMissingRightBracket-*)-1
      1  3605		       1f		      .byte.b	(FactMissingRightBracket-*)-1
      0  3606					      db	oRightSQBracket
      1  3606		       e5		      .byte.b	oRightSQBracket
      0  3607					      SUBSCRIPT	tByte	; Byte type array
      0  3607					      db	64
      1  3607		       40		      .byte.b	64
      0  3608					      db	tByte
      1  3608		       a2		      .byte.b	tByte
      0  3609					      SETR2	tByte	; Set byte data type
      0  3609					      db	94
      1  3609		       5e		      .byte.b	94
      0  360a					      db	tByte
      1  360a		       a2		      .byte.b	tByte
      0  360b					      RTN
      0  360b					      db	25
      1  360b		       19		      .byte.b	25
   1005  360c
   1006  360c				   F2INTEGER
      0  360c					      TSTB	F2PTRLOADED,oLeftSQBracket
      0  360c					      db	101
      1  360c		       65		      .byte.b	101
      0  360d					      db	(F2PTRLOADED-*)-1
      1  360d		       14		      .byte.b	(F2PTRLOADED-*)-1
      0  360e					      db	oLeftSQBracket
      1  360e		       e4		      .byte.b	oLeftSQBracket
      0  360f					      CALL	EXPR
      0  360f					      db	28
      1  360f		       1c		      .byte.b	28
      0  3610					      dw	EXPR
      1  3610		       41 34		      .word.w	EXPR
      0  3612					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  3612					      db	101
      1  3612		       65		      .byte.b	101
      0  3613					      db	(FactMissingRightBracket-*)-1
      1  3613		       11		      .byte.b	(FactMissingRightBracket-*)-1
      0  3614					      db	oRightSQBracket
      1  3614		       e5		      .byte.b	oRightSQBracket
      0  3615					      SUBSCRIPT	tInteger	; Integer type array
      0  3615					      db	64
      1  3615		       40		      .byte.b	64
      0  3616					      db	tInteger
      1  3616		       a4		      .byte.b	tInteger
      0  3617					      SETR2	tInteger	; Set word datatype
      0  3617					      db	94
      1  3617		       5e		      .byte.b	94
      0  3618					      db	tInteger
      1  3618		       a4		      .byte.b	tInteger
      0  3619					      TSTB	F2PTRLOADED,oBang	; for a word it can be fillowed by a! as ref to other task variables
      0  3619					      db	101
      1  3619		       65		      .byte.b	101
      0  361a					      db	(F2PTRLOADED-*)-1
      1  361a		       07		      .byte.b	(F2PTRLOADED-*)-1
      0  361b					      db	oBang
      1  361b		       e8		      .byte.b	oBang
      0  361c					      IND		; Get the value of the task context to access
      0  361c					      db	20
      1  361c		       14		      .byte.b	20
      0  361d					      TSTVT	UNKNOWNID	; if it is not another variable name then it is a halt error
      0  361d					      db	93
      1  361d		       5d		      .byte.b	93
      0  361e					      db	(UNKNOWNID-*)-1
      1  361e		       5d		      .byte.b	(UNKNOWNID-*)-1
      0  361f					      IJMP	FactVarPTR	; Process the value on the other side
      0  361f					      db	29
      1  361f		       1d		      .byte.b	29
      0  3620					      dw	FactVarPTR
      1  3620		       f1 35		      .word.w	FactVarPTR
   1016  3622				   F2PTRLOADED
      0  3622					      RTN
      0  3622					      db	25
      1  3622		       19		      .byte.b	25
   1018  3623
   1019  3623				   FactVariableValue
      0  3623					      IND		; YES, GET THE VALUE as word
      0  3623					      db	20
      1  3623		       14		      .byte.b	20
      0  3624					      RTN
      0  3624					      db	25
      1  3624		       19		      .byte.b	25
   1022  3625
   1023  3625				   FactMissingRightBracket
      0  3625					      IJMP	ReturnExpectBracket
      0  3625					      db	29
      1  3625		       1d		      .byte.b	29
      0  3626					      dw	ReturnExpectBracket
      1  3626		       59 36		      .word.w	ReturnExpectBracket
   1025  3628				   FactExpectedOpeningBracket
      0  3628					      ERRMSG	ERR_EXPECTED_OPENING_BRACKET
      0  3628					      db	13
      1  3628		       0d		      .byte.b	13
      0  3629					      dw	ERR_EXPECTED_OPENING_BRACKET
      1  3629		       1a 00		      .word.w	ERR_EXPECTED_OPENING_BRACKET
   1027  362b							;===============================================================================================================================
   1028  362b							;========================= Gosub and function interface ========================================================================
   1029  362b							; Process gosub 1000(Parm1, ...) no return value
   1030  362b							;
   1031  362b				   ekGosub
      0  362b					      CALL	GOSUBSTATEMENT	; Do the gosub
      0  362b					      db	28
      1  362b		       1c		      .byte.b	28
      0  362c					      dw	GOSUBSTATEMENT
      1  362c		       5d 36		      .word.w	GOSUBSTATEMENT
      0  362e					      DONE		; ERROR IF CR NOT NEXT
      0  362e					      db	1
      1  362e		       01		      .byte.b	1
      0  362f					      SAV	GOSUB_RTN	; SAVE RETURN LINE
      0  362f					      db	8
      1  362f		       08		      .byte.b	8
      0  3630					      db	GOSUB_RTN
      1  3630		       01		      .byte.b	GOSUB_RTN
      0  3631					      FASTXFER		; AND JUMP to sub rtn
      0  3631					      db	107
      1  3631		       6b		      .byte.b	107
   1036  3632							;
   1037  3632							; End of gosub processing
   1038  3632							;===========================================================================
   1039  3632							; Same as gosub but expects a return value
   1040  3632							;   FN 1000(parm1, ....)  Expects an integer to be returned
   1041  3632							;
   1042  3632				   ekGofn
      0  3632					      Call	GOSUBSTATEMENT
      0  3632					      db	28
      1  3632		       1c		      .byte.b	28
      0  3633					      dw	GOSUBSTATEMENT
      1  3633		       5d 36		      .word.w	GOSUBSTATEMENT
      0  3635					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  3635					      db	8
      1  3635		       08		      .byte.b	8
      0  3636					      db	GOSUB_RTN_VALUE
      1  3636		       81		      .byte.b	GOSUB_RTN_VALUE
      0  3637					      FASTXFER
      0  3637					      db	107
      1  3637		       6b		      .byte.b	107
   1046  3638
   1047  3638				   GOFNRet
      0  3638					      RTN
      0  3638					      db	25
      1  3638		       19		      .byte.b	25
   1049  3639							;===============================================================================================================================
   1050  3639							; Return from a gosub
   1051  3639							;
   1052  3639				   ekReturn
      0  3639					      TSTB	S2NoReturnValue,oLeftBracket	; Check if we will return some value
      0  3639					      db	101
      1  3639		       65		      .byte.b	101
      0  363a					      db	(S2NoReturnValue-*)-1
      1  363a		       11		      .byte.b	(S2NoReturnValue-*)-1
      0  363b					      db	oLeftBracket
      1  363b		       e0		      .byte.b	oLeftBracket
      0  363c					      CALL	EXPR
      0  363c					      db	28
      1  363c		       1c		      .byte.b	28
      0  363d					      dw	EXPR
      1  363d		       41 34		      .word.w	EXPR
      0  363f					      TSTB	ReturnExpectBracket,oRightBracket	; Now a value is on the stack
      0  363f					      db	101
      1  363f		       65		      .byte.b	101
      0  3640					      db	(ReturnExpectBracket-*)-1
      1  3640		       18		      .byte.b	(ReturnExpectBracket-*)-1
      0  3641					      db	oRightBracket
      1  3641		       e1		      .byte.b	oRightBracket
      0  3642					      DONE
      0  3642					      db	1
      1  3642		       01		      .byte.b	1
      0  3643					      RSTR	S2RetFunc,1	; decides if call was a func or statement, branch on func, return value
      0  3643					      db	9
      1  3643		       09		      .byte.b	9
      0  3644					      db	(S2RetFunc-*)-1
      1  3644		       11		      .byte.b	(S2RetFunc-*)-1
      0  3645					      db	1
      1  3645		       01		      .byte.b	1
      0  3646					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  3646					      db	6
      1  3646		       06		      .byte.b	6
      0  3647					      dw	CO
      1  3647		       20 32		      .word.w	CO
      0  3649					      IJMP	STMT	; Process the new statement
      0  3649					      db	29
      1  3649		       1d		      .byte.b	29
      0  364a					      dw	STMT
      1  364a		       28 32		      .word.w	STMT
   1060  364c
   1061  364c				   S2NoReturnValue
      0  364c					      DONE
      0  364c					      db	1
      1  364c		       01		      .byte.b	1
      0  364d					      RSTR	S2RetFunc,0	; decides if call was a func or statement, branch on func, no return value
      0  364d					      db	9
      1  364d		       09		      .byte.b	9
      0  364e					      db	(S2RetFunc-*)-1
      1  364e		       07		      .byte.b	(S2RetFunc-*)-1
      0  364f					      db	0
      1  364f		       00		      .byte.b	0
      0  3650					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  3650					      db	6
      1  3650		       06		      .byte.b	6
      0  3651					      dw	CO
      1  3651		       20 32		      .word.w	CO
      0  3653					      IJMP	STMT	; Process the new statement
      0  3653					      db	29
      1  3653		       1d		      .byte.b	29
      0  3654					      dw	STMT
      1  3654		       28 32		      .word.w	STMT
   1066  3656
   1067  3656				   S2RetFunc
      0  3656					      IJMP	GOFNRet	; Back into the Function
      0  3656					      db	29
      1  3656		       1d		      .byte.b	29
      0  3657					      dw	GOFNRet
      1  3657		       38 36		      .word.w	GOFNRet
   1069  3659
   1070  3659				   ReturnExpectBracket
      0  3659					      ENDIO
      0  3659					      db	71
      1  3659		       47		      .byte.b	71
      0  365a					      ERRMSG	ERR_CLOSINGBRACKET
      0  365a					      db	13
      1  365a		       0d		      .byte.b	13
      0  365b					      dw	ERR_CLOSINGBRACKET
      1  365b		       17 00		      .word.w	ERR_CLOSINGBRACKET
   1073  365d							;
   1074  365d							; End of return from gosub
   1075  365d							;=============================================================
   1076  365d							; Gosub can be both a Function and a Subroutine
   1077  365d				   GOSUBSTATEMENT
      0  365d					      TSTBRANCH	GOSUBCOMPILED	; if the two bytes after gosub are not zero then direct transfer
      0  365d					      db	106
      1  365d		       6a		      .byte.b	106
      0  365e					      db	(GOSUBCOMPILED-*)-1
      1  365e		       0a		      .byte.b	(GOSUBCOMPILED-*)-1
      0  365f					      CALL	EXPR	; GET DESTINATION
      0  365f					      db	28
      1  365f		       1c		      .byte.b	28
      0  3660					      dw	EXPR
      1  3660		       41 34		      .word.w	EXPR
      0  3662					      CALL	GOSUBCONT
      0  3662					      db	28
      1  3662		       1c		      .byte.b	28
      0  3663					      dw	GOSUBCONT
      1  3663		       70 36		      .word.w	GOSUBCONT
      0  3665					      lit	0	; mark as lookup on stack
      0  3665					      db	27
      1  3665		       1b		      .byte.b	27
      0  3666					      dw	0
      1  3666		       00 00		      .word.w	0
      0  3668					      RTN
      0  3668					      db	25
      1  3668		       19		      .byte.b	25
   1083  3669
   1084  3669				   GOSUBCOMPILED
      0  3669					      CALL	GOSUBCONT
      0  3669					      db	28
      1  3669		       1c		      .byte.b	28
      0  366a					      dw	GOSUBCONT
      1  366a		       70 36		      .word.w	GOSUBCONT
      0  366c					      lit	1	;mark as compiled on stack
      0  366c					      db	27
      1  366c		       1b		      .byte.b	27
      0  366d					      dw	1
      1  366d		       01 00		      .word.w	1
      0  366f					      RTN
      0  366f					      db	25
      1  366f		       19		      .byte.b	25
   1088  3670
   1089  3670				   GOSUBCONT
      0  3670					      TSTB	GOSUBDONE,oLeftBracket	;Check if any Parameters If not bracket get out
      0  3670					      db	101
      1  3670		       65		      .byte.b	101
      0  3671					      db	(GOSUBDONE-*)-1
      1  3671		       11		      .byte.b	(GOSUBDONE-*)-1
      0  3672					      db	oLeftBracket
      1  3672		       e0		      .byte.b	oLeftBracket
      0  3673					      STK2TMP		;Transfer stack top to temp, temp gets line to goto
      0  3673					      db	95
      1  3673		       5f		      .byte.b	95
      0  3674					      PUSHMATHSTACK		;Record stack frame for return
      0  3674					      db	84
      1  3674		       54		      .byte.b	84
   1093  3675				   GOSUBLOOP
      0  3675					      CALL	EXPR	; Allows what ever fits onto stack
      0  3675					      db	28
      1  3675		       1c		      .byte.b	28
      0  3676					      dw	EXPR
      1  3676		       41 34		      .word.w	EXPR
      0  3678					      INCPARMCOUNT
      0  3678					      db	88
      1  3678		       58		      .byte.b	88
      0  3679					      TSTB	GOSUBParmDONE,oComma
      0  3679					      db	101
      1  3679		       65		      .byte.b	101
      0  367a					      db	(GOSUBParmDONE-*)-1
      1  367a		       04		      .byte.b	(GOSUBParmDONE-*)-1
      0  367b					      db	oComma
      1  367b		       e2		      .byte.b	oComma
      0  367c					      IJMP	GOSUBLOOP
      0  367c					      db	29
      1  367c		       1d		      .byte.b	29
      0  367d					      dw	GOSUBLOOP
      1  367d		       75 36		      .word.w	GOSUBLOOP
   1098  367f				   GOSUBParmDONE
      0  367f					      TSTB	ReturnExpectBracket,oRightBracket
      0  367f					      db	101
      1  367f		       65		      .byte.b	101
      0  3680					      db	(ReturnExpectBracket-*)-1
      1  3680		       d8		      .byte.b	(ReturnExpectBracket-*)-1
      0  3681					      db	oRightBracket
      1  3681		       e1		      .byte.b	oRightBracket
      0  3682					      TMP2STK		; Restore line to goto
      0  3682					      db	96
      1  3682		       60		      .byte.b	96
   1101  3683				   GOSUBDONE
      0  3683					      RTN
      0  3683					      db	25
      1  3683		       19		      .byte.b	25
   1103  3684
   1104  3684		       36 84	   ILEND      equ	*
------- FILE mytb.asm
   2491  3684		       36 84	   PROGEND    equ	*
   2492  3684
   2493  3684
   2494  3684							;=====================================================
   2495  3684							; Define start of non page zero data
   2496 U36d7					      seg.u	TBData
   2497 U36d7
   2498 U36d7							;=====================================================
   2499 U36d7							; These are storage items not in page zero.
   2500 U36d7							;==================================================================================================
   2501 U36d7							; Task Management information
   2502 U36d7							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2503 U36d7							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2504 U36d7							; Task switchs happen at the beginning of the next Basic command line
   2505 U36d7							; It will not happen during an input or output operations
   2506 U36d7							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2507 U36d7							; Task Zero is always the root task, main line program
   2508 U36d7							;
   2509 U36d7							; Layout is repeated for each configured task
   2510 U36d7							; Task Table Byte   use masks follow
   2511 U36d7		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2512 U36d7		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2513 U36d7		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2514 U36d7		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2515 U36d7		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2516 U36d7
   2517 U36d7		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2518 U36d8		       00 00 00 00*taskTable  ds	[TASKCOUNT * CONTEXTLEN]	; Task Table Offset and pointer to Basic code, active flag
   2519 U36d8		       37 d2	   TASKTABLEEND equ	*	; End of task table
   2520 U36d8		       00 fa	   TASKTABLELEN equ	[TASKTABLEEND-taskTable]	; actual length of the task table
   2521 U37d2
   2522 U37d2							;Task Cycle Counter and reset count
   2523 U37d2		       00 00	   taskCurrentCycles ds	2
   2524 U37d4		       00 00	   taskResetValue ds	2
   2525 U37d6		       00	   taskCounter ds	1	; Count of active tasks
   2526 U37d7
   2527 U37d7							;
   2528 U37d7							; Math stack and IL call and Gosub/For-next return stack definitions
   2529 U37d7							;
   2530 U37d7		       37 d7	   STACKSTART equ	*
   2531 U37d7		       00 00 00 00*mathStack  ds	[MATHSTACKSIZE * 2 * TASKCOUNT]	; Stack used for math expressions
   2532 U3967		       00 00 00 00*ilStack    ds	[ILSTACKSIZE * 2 * TASKCOUNT]	; stack used by the IL for calls and returns
   2533 U3d4f		       00 00 00 00*gosubStack ds	[GOSUBSTACKSIZE * 4 * TASKCOUNT]	; stack size for gosub stacks
   2534 U3fcf		       00 00 00 00*variableStack ds	[VARIABLESSIZE * 2 * TASKCOUNT]	; Stack of variables, 26 A-Z-task exit code,taskio block
   2535 U42b3							;									  stdin,stdout,stdstat,iostatus
   2536 U42b3		       00 48	   TASKEXITCODE equ	[[VARIABLESSIZE * 2] - 2]	; Offset to exit code location
   2537 U42b3		       42 b3	   STACKEND   equ	*
   2538 U42b3		       0a dc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2539 U42b3							;
   2540 U42b3							;
   2541 U42b3		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2542 U4337		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2543 U4338		       00	   printtx    ds	1	;temp X for print funcs
   2544 U4339		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2545 U433a		       00	   promptChar ds	1	;the character to use for a prompt
   2546 U433b		       00	   diddigit   ds	1	;for leading zero suppression
   2547 U433c		       00	   putsy      ds	1
   2548 U433d		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2549 U433f		       00	   sign       ds	1	;0 = positive, else negative
   2550 U4340		       00 00	   rtemp1     ds	2	;Temp for x and y
   2551 U4342		       00 00	   random     ds	2
   2552 U4344		       00	   tempy      ds	1	;temp y storage
   2553 U4345
   2554 U4345
   2555 U4345							; Moved from page zero as one clock cycle diff gives more space on page zero
   2556 U4345		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
   2557 U4347		       00	   tempIlY    ds	1	;Temp IL Y register storage
   2558 U4348		       00	   offset     ds	1	;IL Offset to next inst when test fails
   2559 U4349		       00	   lineLength ds	1	;Length of current line
   2560 U434a
   2561 U434a		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
   2562 U434b		       00	   taskRDPending ds	1	; 1 = background read is pending
   2563 U434c		       00 00 00 00 timercounter ds	4	; if timer is running then this is continuously incremented
   2564 U4350
   2565 U4350				  -	      if	XKIM
   2566 U4350				  -buffer     ds	BUFFER_SIZE
   2567 U4350					      endif
   2568 U4350							;
   2569 U4350							; PROGRAMEND is the end of the user's BASIC program.
   2570 U4350							; More precisely, it is one byte past the end.  Or,
   2571 U4350							; it's where the next line added to the end will be
   2572 U4350							; placed.
   2573 U4350							;
   2574 U4350		       00 00	   ProgramStart ds	2	; Start Of usable memory
   2575 U4352		       00 00	   ProgramEnd ds	2	; End of users basic program, Next free byte after end
   2576 U4354		       00 00	   HighMem    ds	2	; highest location
   2577 U4356		       00 00	   UsedMem    ds	2	; size of user program
   2578 U4358		       00 00	   FreeMem    ds	2	; amount of free memory
   2579 U435a							;
   2580 U435a							;=====================================================
   2581 U435a							; This is the start of the user's BASIC program space.
   2582 U435a							;
   2583 U435a							; PERSONAL GOAL: This should be no larger than $0DFF. *JustLostInTim abandoned, just for fun
   2584 U435a							;		  0200-05FF = 1K
   2585 U435a							;		  0200-09FF = 2K
   2586 U435a							;		  0200-0DFF = 3K
   2587 U435a							;		  0200-11FF = 4K
   2588 U435a							;		  0200-13FF = 4.5K
   2589 U435a							;
   2590 U435a				  -	      if	FIXED
   2591 U435a				  -	      org	$2000
   2592 U435a					      endif
   2593 U435a
   2594 U435a		       43 5a	   FreeMemStart equ	*
   2595 U435a							;/*
   2596 U435a							;  if	  CTMON65 || XKIM
   2597 U435a							;	  SEG Code
   2598 U435a							;	  org	  AutoRun
   2599 U435a							;	  dw	  TBasicCold
   2600 U435a							;  endif
   2601 U435a							;*/
   2602 U435a					      end
