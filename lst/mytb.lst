------- FILE mytb.asm LEVEL 1 PASS 6
      1 U43f6				   input      processor	65c02
      2 U43f6 ????						;=====================================================
      3 U43f6 ????						; Concurrent Tiny Basic, no longer Tiny
      4 U43f6 ????						; Derived from Bob's Tiny Basic, and Lots of
      5 U43f6 ????						; Free Time. Now abiut 6K Full OS features.
      6 U43f6 ????						;
      7 U43f6 ????						; While working on the Corsham Technologies KIM Clone
      8 U43f6 ????						; project, I wanted to include a TINY BASIC since that
      9 U43f6 ????						; was a highly desirable feature of early computers.
     10 U43f6 ????						;
     11 U43f6 ????						; Rather than negotiating copyright issues for
     12 U43f6 ????						; existing BASICs, I decided to just write one from
     13 U43f6 ????						; scratch.
     14 U43f6 ????						;
     15 U43f6 ????						; 10/07/2017
     16 U43f6 ????						;
     17 U43f6 ????						; This implements a stripped down Tiny BASIC
     18 U43f6 ????						; interpreter using the Interpretive Language (IL)
     19 U43f6 ????						; method as described in the first few issues of
     20 U43f6 ????						; Dr Dobb's Journal.  The IL interpreter can be used
     21 U43f6 ????						; to write various languages simply by changing the
     22 U43f6 ????						; IL code rather than the interpreter itself.
     23 U43f6 ????						;
     24 U43f6 ????						; 10/15/2021 v0.4 - Bob Applegate
     25 U43f6 ????						;		* Fixed major bug in findLine that
     26 U43f6 ????						;		  caused corrupted lines, crashes, etc.
     27 U43f6 ????						;		* If no parameter given to RND, assume
     28 U43f6 ????						;		  32766.
     29 U43f6 ????						;		* No more error 5 when a program
     30 U43f6 ????						;		  reaches the end without an END.
     31 U43f6 ????						;
     32 U43f6 ????						; 02/15/2022 v0.5 JustLostInTime@gmail.com
     33 U43f6 ????						;		 * Unexpanded version to play with everything
     34 U43f6 ????						;		 * Add some usefull system level functions
     35 U43f6 ????						;		 * allow a larger number of tiny basic formats
     36 U43f6 ????						;		 * Add byte at start of line holding length
     37 U43f6 ????						;		   for faster execution of goto and gosub
     38 U43f6 ????						;		 * Re-added gosub
     39 U43f6 ????						;		 * allow ; or , at end if print stmt
     40 U43f6 ????						;		   without CRLF being added.
     41 U43f6 ????						;		 * Added extended function erase to
     42 U43f6 ????						;		   use the extended ctmon65 rm file
     43 U43f6 ????						;		 * Fix quoted text to not have to backtrack
     44 U43f6 ????						;		 * Add IRQ handler, Call Gosub and Iret at end
     45 U43f6 ????						;		 * Add concurrency features
     46 U43f6 ????						;		 * Add Compile at runtime for gosub and goto addresses
     47 U43f6 ????						;
     48 U43f6 ????						; 10/31/2023 v0.5 Justlostintime@gmail.com
     49 U43f6 ????						;		 * Inline in il some var load value instead of calling
     50 U43f6 ????						;
     51 U43f6 ????						; 11/20/2023 v1.1.3 Justlostintime@gmail.com
     52 U43f6 ????						;		 * Many improvment, bug fixes
     53 U43f6 ????						;
     54 U43f6 ????						; 07/11/2025 v1.1.4 Justlostintime@gmail.com
     55 U43f6 ????						;		  * Added While..wend speed improvement
     56 U43f6 ????						;		  * Updated all code to use 65c02 instructions
     57 U43f6 ????						;		  * Added macros for old 6502 version if needed
     58 U43f6 ????						;
     59 U43f6 ????						; www.corshamtech.com Now defunct
     60 U43f6 ????						; bob@corshamtech.com Bob sadly passed away
     61 U43f6 ????						; JustLostInTime@gmail.com Active development
     62 U43f6 ????						;
     63 U43f6 ????						;=====================================================
     64 U43f6 ????						;
     65 U43f6 ????						; Create TRUE and FALSE values for conditionals.
     66 U43f6 ????						;
     67 U43f6 ????
     68 U43f6 ????	       00 00	   FALSE      equ	0
     69 U43f6 ????	       ff ff ff ff TRUE       equ	~FALSE
     70 U43f6 ????						;
     71 U43f6 ????						;---------------------------------------------------------
     72 U43f6 ????						; One of these must be set to indicate which environment
     73 U43f6 ????						; Tiny BASIC will be running in.  Here are the current
     74 U43f6 ????						; environments:
     75 U43f6 ????						;
     76 U43f6 ????						; KIM - This is a bare KIM-1.	You'll need to add a few
     77 U43f6 ????						; more K of RAM.
     78 U43f6 ????						;
     79 U43f6 ????						; XKIM - The Corsham Technologies xKIM extended monitor,
     80 U43f6 ????						; which enhances, without replacing, the standard KIM
     81 U43f6 ????						; monitor.  It gives access to routines to save/load files
     82 U43f6 ????						; to a micro SD card.
     83 U43f6 ????						;
     84 U43f6 ????						; CTMON65 is a from-scratch monitor written for the
     85 U43f6 ????						; Corsham Tech SS-50 6502 CPU board, but the monitor can
     86 U43f6 ????						; easily be ported to other systems.  It has support for
     87 U43f6 ????						; using a micro SD card for file storage/retrieval.
     88 U43f6 ????						;
     89 U43f6 ????	       00 00	   KIM	      equ	FALSE	;Basic KIM-1, no extensions
     90 U43f6 ????	       00 00	   XKIM       equ	FALSE	;Corsham Tech xKIM monitor
     91 U43f6 ????	       ff ff ff ff CTMON65    equ	TRUE	;Corsham Tech CTMON65
     92 U43f6 ????	       ff ff ff ff IL_DEBUG_TEXT equ	TRUE	;Print out as text IL instructions
     93 U43f6 ????	       ff ff ff ff ILTRACEACTIVE equ	TRUE	;enable il debugging
     94 U43f6 ????						;
     95 U43f6 ????						;   Need to define some macros for the dasm assembler
     96 U43f6 ????						;
------- FILE TB_macros.inc LEVEL 2 PASS 6
      0 U43f6 ????				      include	"TB_macros.inc"
      1 U43f6 ????	       00 00	   USE6502    EQU	FALSE
      2 U43f6 ????			  -	      if	USE6502
      6 U43f6 ????			  -	      ENDM
      7 U43f6 ????			  -
     11 U43f6 ????			  -	      ENDM
     12 U43f6 ????			  -
     16 U43f6 ????			  -	      ENDM
     17 U43f6 ????			  -
     21 U43f6 ????			  -	      ENDM
     22 U43f6 ????			  -
     26 U43f6 ????			  -	      ENDM
     27 U43f6 ????			  -
     28 U43f6 ????				      endif
     29 U43f6 ????
     30 U43f6 ????				      MACRO	pushxy
     31 U43f6 ????				      phx
     32 U43f6 ????				      phy
     33 U43f6 ????				      ENDM
     34 U43f6 ????
     35 U43f6 ????				      MACRO	pullxy
     36 U43f6 ????				      ply
     37 U43f6 ????				      plx
     38 U43f6 ????				      ENDM
     39 U43f6 ????
     40 U43f6 ????				      MACRO	dw
     41 U43f6 ????				      .word	{0}
     42 U43f6 ????				      ENDM
     43 U43f6 ????
     44 U43f6 ????				      MACRO	db
     45 U43f6 ????				      .byte	{0}
     46 U43f6 ????				      ENDM
------- FILE mytb.asm
     98 U43f6 ????						;
     99 U43f6 ????						; If set, include disk functions.
    100 U43f6 ????						;
    101 U43f6 ????	       ff ff ff ff DISK_ACCESS equ	TRUE
    102 U43f6 ????						;
    103 U43f6 ????						; If ILTRACE is set then dump out the address of every
    104 U43f6 ????						; IL opcode before executing it.
    105 U43f6 ????						; 0 = off, 7=IL trace, 6 = Basic Prog Trace, 7+6 = both
    106 U43f6 ????						;
    107 U43f6 ????	       00 00	   ILTRACE    equ	%00000000	;%0100000 = Basic STMT Trace, %10000000 = il trace etc
    108 U43f6 ????
    109 U43f6 ????						;
    110 U43f6 ????						; If FIXED is set, put the IL code and the user
    111 U43f6 ????						; program space at fixed locations in memory.	This is
    112 U43f6 ????						; meant only for debugging.
    113 U43f6 ????						;
    114 U43f6 ????	       00 00	   FIXED      equ	FALSE
    115 U43f6 ????
    116 U43f6 ????	       00 0f	   terminalIOblockLen equ	[TerminalIOblockEnd - TerminalIOblock]
    117 U43f6 ????
    118 U43f6 ????						;
    119 U43f6 ????						; Sets the arithmetic stack depth.  This is *TINY*
    120 U43f6 ????						; BASIC, so keep this small!
    121 U43f6 ????						;
    122 U43f6 ????	       00 14	   MATHSTACKSIZE equ	20	;number of entries in math stack
    123 U43f6 ????	       00 32	   ILSTACKSIZE equ	50	;number of entries in ilstack
    124 U43f6 ????	       00 10	   GOSUBSTACKSIZE equ	16	;Depth of gosub/For-Next nesting max is 64 times TASKTABLE LENGTH must < 256
    125 U43f6 ????	       00 25	   VARIABLESSIZE equ	37	;26 variables + 1 for exit code + 10 entries (20bytes) for ioblock
    126 U43f6 ????	       00 0a	   TASKCOUNT  equ	10	;Task Table count, up to 10 tasks
    127 U43f6 ????	       00 ff	   TASKCYCLESDEFAULT equ	255	;Default Task Switch 0-255 uses a single byte
    128 U43f6 ????	       00 02	   TASKCYCLESHIGH equ	2	;hi order count
    129 U43f6 ????	       00 10	   MESSAGESMAX equ	GOSUBSTACKSIZE	;Not used msg q and gosub grow towards each other and over flow when they meet
    130 U43f6 ????
    131 U43f6 ????	       00 36	   taskSTDIN  equ	[[VARIABLESSIZE - 10]*2]	;io vector
    132 U43f6 ????	       00 38	   taskSTDOUT equ	[[[VARIABLESSIZE - 10]*2]+2]	;io vector
    133 U43f6 ????
    134 U43f6 ????	       00 3f	   taskIOinPort equ	[[[VARIABLESSIZE - 10]*2]+4+5]	;Offset into the ioblock
    135 U43f6 ????	       00 3b	   taskIOoutPort equ	[[[VARIABLESSIZE - 10]*2]+4+1]	;Offset into the ioblock
    136 U43f6 ????	       00 46	   taskIOstatusPort equ	[[[VARIABLESSIZE - 10]*2]+4+12]	;Offset into the ioblock
    137 U43f6 ????						;
    138 U43f6 ????						; Common ASCII constants
    139 U43f6 ????						;
    140 U43f6 ????	       00 07	   BEL	      equ	$07
    141 U43f6 ????	       00 08	   BS	      equ	$08
    142 U43f6 ????	       00 09	   TAB	      equ	$09
    143 U43f6 ????	       00 0a	   LF	      equ	$0A
    144 U43f6 ????	       00 0d	   CR	      equ	$0D
    145 U43f6 ????	       00 22	   quote      equ	$22
    146 U43f6 ????	       00 20	   SPACE      equ	$20
    147 U43f6 ????	       00 2c	   COMMA      equ	',
    148 U43f6 ????	       00 3b	   SEMICOLON  equ	';
    149 U43f6 ????	       00 3a	   COLON      equ	':
    150 U43f6 ????	       00 24	   DOLLAR     equ	'$
    151 U43f6 ????						;
    152 U43f6 ????						; These are error codes
    153 U43f6 ????						;
    154 U43f6 ????	       00 00	   ERR_NONE   equ	0	;No Errror
    155 U43f6 ????	       00 01	   ERR_EXPR   equ	1	;expression error
    156 U43f6 ????	       00 02	   ERR_UNDER  equ	2	;The Math stack underflow
    157 U43f6 ????	       00 03	   ERR_OVER   equ	3	;The Math stack overflow
    158 U43f6 ????	       00 04	   ERR_EXTRA_STUFF equ	4	;Stuff at end of line
    159 U43f6 ????	       00 05	   ERR_SYNTAX equ	5	;various syntax errors
    160 U43f6 ????	       00 06	   ERR_DIVIDE_ZERO equ	6	;divide by zero
    161 U43f6 ????	       00 07	   ERR_READ_FAIL equ	7	;error loading file
    162 U43f6 ????	       00 08	   ERR_WRITE_FAIL equ	8	;error saving file
    163 U43f6 ????	       00 09	   ERR_NO_FILENAME equ	9	;Forgot to include the file name
    164 U43f6 ????	       00 0a	   ERR_FILE_NOT_FOUND equ	10	;The file name provided not found
    165 U43f6 ????	       00 0b	   ERR_STACK_UNDER_FLOW equ	11	;the gosub stack underflow
    166 U43f6 ????	       00 0c	   ERR_STACK_OVER_FLOW equ	12	;the gosub Stack overflow
    167 U43f6 ????	       00 0d	   ERR_BAD_LINE_NUMBER equ	13	;Bad line number specified Not found
    168 U43f6 ????	       00 0e	   ERR_NO_EMPTY_TASK_SLOT equ	14	;Unable to create a new task no/slots
    169 U43f6 ????	       00 0f	   ERR_INDEX_OUT_OF_RANGE equ	15	;Subscript out of range
    170 U43f6 ????	       00 10	   ERR_INVALID_PID equ	16	;Invalid PID provided
    171 U43f6 ????	       00 11	   ERR_OUT_OF_MSG_SPACE equ	17	;Out of space for new messsages
    172 U43f6 ????	       00 12	   ERR_INVALID_STK_FRAME equ	18	;The stack frame was expected not found
    173 U43f6 ????	       00 13	   ERR_NO_RETURN_VALUE_PROVIDED equ	19	;No value returned by a gofn call
    174 U43f6 ????	       00 14	   ERR_LINE_NOT_FOUND equ	20	;Gosub/goto/gofn line number not found
    175 U43f6 ????	       00 15	   ERR_IL_STACK_OVER_FLOW equ	21	;The IL return stack has overflowed
    176 U43f6 ????	       00 16	   ERR_EXPECTVAR equ	22	;Expected a variable name or definition
    177 U43f6 ????	       00 17	   ERR_CLOSINGBRACKET equ	23	;Expected a closing bracket
    178 U43f6 ????	       00 18	   ERR_MISSINGEQUALSIGN equ	24	;Expected an equal sign for assignment
    179 U43f6 ????	       00 19	   ERR_FUNCTION_EXPECTED_PARAMETERS equ	25	;Function expected parameters
    180 U43f6 ????	       00 1a	   ERR_EXPECTED_OPENING_BRACKET equ	26	;Expected opening bracket [ or (
    181 U43f6 ????	       00 1b	   ERR_NO_MATCHING_BEGIN_BLOCK equ	27	;expected a while,for, if endif statement, was not found
    182 U43f6 ????	       00 1c	   ERR_NO_MATCHING_END_BLOCK equ	28	;expected a closing block value wend, next, endif
    183 U43f6 ????
    184 U43f6 ????						;
    185 U43f6 ????						;=====================================================
    186 U43f6 ????						; Zero page storage.
    187 U43f6 ????						;
    188 U00f6 ????				      SEG.U	ZEROPAGE
    189 U0040					      org	$0040
    190 U0040
    191 U0040		       00	   ILTrace    ds	1	;non-zero means tracing
    192 U0041
    193 U0041							; The context is used to locate a task switch
    194 U0041							; it copies from here till all task fields are saved/swapped
    195 U0041							; The max number of tasks is 256 / context length
    196 U0041							; All positions POS values are plus one task table incldues
    197 U0041							; a leading status byte .
    198 U0041							;
    199 U0041		       00 41	   CONTEXT    equ	*
    200 U0041							;StatusCode		 db	 1  this is here to remind why everything is plus 1 this and is only in the Task table
    201 U0041
    202 U0041		       00 00	   VARIABLES  ds	2	; 2 bytes pointer to, 26 A-Z
    203 U0041		       00 01	   VARIABLEPOS equ	VARIABLES - CONTEXT + 1
    204 U0043
    205 U0043		       00 00	   ILPC       ds	2	; IL program counter
    206 U0045		       00 00	   ILSTACK    ds	2	; IL call stack
    207 U0047		       00	   ILSTACKPTR ds	1
    208 U0048
    209 U0048		       00 00	   MATHSTACK  ds	2	; MATH Stack pointer
    210 U0048		       00 08	   MATHSTACKPOS equ	MATHSTACK - CONTEXT + 1
    211 U004a
    212 U004a		       00	   MATHSTACKPTR ds	1
    213 U004a		       00 0a	   MATHSTACKPTRPOS equ	MATHSTACKPTR - CONTEXT + 1
    214 U004b
    215 U004b		       00 00	   GOSUBSTACK ds	2	; pointer to gosub stack
    216 U004b		       00 0b	   GOSUBSTKPOS equ	GOSUBSTACK - CONTEXT + 1	; Get the offset to the gosub/msg stack
    217 U004d
    218 U004d		       00	   GOSUBSTACKPTR ds	1	; current offset in the stack, moved to task table
    219 U004d		       00 0d	   GOSUBPTRPOS equ	GOSUBSTACKPTR - CONTEXT+1	; Pointer to gosub stack pointer
    220 U004e
    221 U004e		       00	   MESSAGEPTR ds	1	; Pointer to active message, from bottom of gosub stack
    222 U004e		       00 0e	   MSGPTRPOS  equ	MESSAGEPTR - CONTEXT+1	; Pointer to the message counter
    223 U004f							;
    224 U004f							; CURPTR is a pointer to curent BASIC line being
    225 U004f							; executed.  Always points to start of line, CUROFF
    226 U004f							; is the offset to the current character.
    227 U004f							; The order of these fields is important
    228 U004f		       00 00	   CURPTR     ds	2	; Pointer to current Basic line
    229 U0051		       00	   CUROFF     ds	1	; Current offset in Basic Line
    230 U0052							;
    231 U0052							;The order of these fields in important
    232 U0052
    233 U0052							;
    234 U0052							; R0, R1 and MQ are used for arithmetic operations and
    235 U0052							; general use.
    236 U0052							;
    237 U0052		       00 52	   REGISTERS  equ	*	;IL MATH REGISTERS
    238 U0052		       00 00	   R0	      ds	2	;arithmetic register 0
    239 U0054		       00 00	   R1	      ds	2	;arithmetic register 1
    240 U0056		       00 00	   MQ	      ds	2	;used for some math
    241 U0058		       00	   R2	      ds	1	;General purpose work register(tasking)
    242 U0058		       00 59	   REGISTERSEND equ	*
    243 U0058		       00 07	   REGISTERSLEN equ	REGISTERSEND-REGISTERS
    244 U0059
    245 U0059		       00 59	   CONTEXTEND equ	*	; End of swap context
    246 U0059		       00 19	   CONTEXTLEN equ	CONTEXTEND - CONTEXT + 1	; length of the context plus the status byte
    247 U0059
    248 U0059		       00 00	   dpl	      ds	2	; Used as a pointer to call il instructions
    249 U005b							;
    250 U005b							; This is zero if in immediate mode, or non-zero
    251 U005b							; if currently running a program.  Any input from
    252 U005b							; the main loop clears this, and the XFER IL
    253 U005b							; statement will set it.
    254 U005b							;
    255 U005b		       00	   RunMode    ds	1	;Basic program is running or stop
    256 U005c							;
    257 U005c							; Used for line insertion/removal.
    258 U005c							;
    259 U005c		       00 00	   FROM       ds	2	;Used for basic prog insert/remove
    260 U005e
    261 U005e							; THE ADDRESS USED BY THE PRINTER FUNCTION
    262 U005e							; TO PRINT A GENERIC STRING X,Y ADDRESS, Ac = TERMINATOR
    263 U005e							;
    264 U005e		       00 00	   PrtFrom    ds	2	; FROM
    265 U0060
    266 U0060							;
    267 U0060							;=====================================================
    268 U0060							;
    269  3720 ????				      SEG	Code
    270  0200					      org	$0200
    271  0200							;
    272  0200							; Cold start is at $0200.  Warm start is at $0203.
    273  0200							;
    274  0200		       4c 06 02    TBasicCold jmp	cold2	;jump around vectors
    275  0203		       4c 6f 02    warm       jmp	warm2	;Entry point for worm restart
    276  0206							;
    277  0206							; These are the user-supplied vectors to I/O routines.
    278  0206							; If you want, you can just patch these in the binary
    279  0206							; file, but it would be better to change the source
    280  0206							; code.
    281  0206							;
    282  0206				  -	      if	KIM
    283  0206				  -OUTCH      jmp	$1ea0	;output char in A
    284  0206				  -GETCH      jmp	$1e5a	;get char in A (blocks)
    285  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    286  0206				  -OUTHEX     jmp	$1e3b	;print A as hex
    287  0206				  -MONITOR    jmp	$1c4f	;return to monitor
    288  0206					      endif
    289  0206				  -	      if	XKIM
    290  0206				  -	      include	"xkim.inc"
    291  0206				  -	      SEG	Code
    292  0206				  -OUTCH      jmp	$1ea0
    293  0206				  -GETCH      jmp	xkGETCH
    294  0206				  -CRLF       jmp	$1e2f	;print CR/LF
    295  0206				  -OUTHEX     jmp	xkPRTBYT
    296  0206				  -MONITOR    jmp	extKIM
    297  0206				  -puts       equ	putsil
    298  0206				  -BUFFER_SIZE equ	132
    299  0206					      endif
    300  0206
    301  0206					      if	CTMON65
------- FILE ctmon65.inc LEVEL 2 PASS 6
      0  0206					      include	"ctmon65.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: ctmon65.inc
      3  0206							;
      4  0206							; Applications wishing to run under CTMON65 should include
      5  0206							; this file, as it defines vectors and other pieces of
      6  0206							; necessary data.
      7  0206							;*********************************************************
      8  0206							;
------- FILE config.inc LEVEL 3 PASS 6
      0  0206					      include	"config.inc"
      1  0206							;*********************************************************
      2  0206							; FILE: config.inc
      3  0206							;
      4  0206							; General configuration file for the Corsham Technologies
      5  0206							; CTMON65 monitor.
      6  0206							;*********************************************************
      7  0206							;
      8  0206							; Current version and revision
      9  0206							;
     10  0206		       00 00	   VERSION    equ	0
     11  0206		       00 01	   REVISION   equ	1
     12  0206							;
     13  0206							;FALSE		equ	0
     14  0206							;TRUE		equ	!FALSE
     15  0206							;
     16  0206							; SS-50 bus constants
     17  0206							;
     18  0206		       e0 00	   IO_BASE    equ	$e000
     19  0206		       00 10	   IO_SIZE    equ	16
     20  0206							;
     21  0206							; Memory usage
     22  0206							;
     23  0206		       00 f0	   ZERO_PAGE_START equ	$00f0
     24  0206		       f0 00	   ROM_START  equ	$f000
     25  0206		       df 00	   RAM_START  equ	$df00
     26  0206							;
     27  0206							; If enabled, turn on buffered input code.
     28  0206							;
     29  0206		       00 00	   BUFFERED_INPUT equ	FALSE
     30  0206							;
     31  0206		       00 05	   MAX_ARGC   equ	5
     32  0206							;
     33  0206							; If enabled, the debugger will display the flag register
     34  0206							; in ASCII.  Nice, but takes more code.
     35  0206							;
     36  0206		       ff ff ff ff FULL_STATUS equ	TRUE
     37  0206							;
     38  0206							; Enable EXTENDED_CMDS to allow linking external commands
     39  0206							; to the command handler.
     40  0206							;
     41  0206		       00 00	   EXTENDED_CMDS equ	FALSE
     42  0206							;
     43  0206							; Define to enable SD related functions
     44  0206							;
     45  0206		       ff ff ff ff SD_ENABLED equ	TRUE
     46  0206							;
     47  0206							; Size of the keyboard buffer
     48  0206							;
     49  0206		       00 84	   BUFFER_SIZE equ	132
     50  0206
------- FILE ctmon65.inc
     10  0206							; Zero-page data
     11  0206							;
     12  0206							;		zpage
     13 U0060					      seg.U	ZEROPAGE
     14 U00f0					      org	ZERO_PAGE_START
     15 U00f0		       00 00	   sptr       ds	2
     16 U00f2		       00	   INL	      ds	1
     17 U00f3		       00	   INH	      ds	1
     18 U00f4		       00 00	   putsp      ds	2
     19 U00f6							;
     20 Uf048 ????				      SEG.U	rom
     21 Uf000					      org	ROM_START
     22 Uf000							;
     23 Uf000							;=========================================================
     24 Uf000							; Jump table to common functions.  The entries in this
     25 Uf000							; table are used by external programs, so nothing can be
     26 Uf000							; moved or removed from this table.  New entries always
     27 Uf000							; go at the end.  Many of these are internal functions
     28 Uf000							; and I figured they might be handy for others.
     29 Uf000							;
     30 Uf000		       00 00 00    RESET      ds	3
     31 Uf003		       00 00 00    WARM       ds	3
     32 Uf006							;
     33 Uf006							; These are the major and minor revision numbers so that
     34 Uf006							; code can check to see which CTMON65 version is running.
     35 Uf006							;
     36 Uf006		       00	   CTMON65ver ds	1
     37 Uf007		       00	   CTMON65rev ds	1
     38 Uf008		       00		      ds	1	;unused
     39 Uf009							;
     40 Uf009							; Console related functions
     41 Uf009							;
     42 Uf009		       00 00 00    cin	      ds	3
     43 Uf00c		       00 00 00    cout       ds	3
     44 Uf00f		       00 00 00    cstatus    ds	3
     45 Uf012		       00 00 00    putsil     ds	3
     46 Uf015		       00 00 00    getline    ds	3
     47 Uf018		       00 00 00    crlf       ds	3
     48 Uf01b		       00 00 00    HexA       ds	3
     49 Uf01e							;
     50 Uf01e							; Low-level functions to access the SD card system
     51 Uf01e							;
     52 Uf01e					      if	SD_ENABLED	;SD ENABLED
     53 Uf01e		       00 00 00    xParInit   ds	3
     54 Uf021		       00 00 00    xParSetWrite ds	3
     55 Uf024		       00 00 00    xParSetRead ds	3
     56 Uf027		       00 00 00    xParWriteByte ds	3
     57 Uf02a		       00 00 00    xParReadByte ds	3
     58 Uf02d							;
     59 Uf02d							; Higher level SD card functions
     60 Uf02d							;
     61 Uf02d		       00 00 00    DiskPing   ds	3
     62 Uf030		       00 00 00    DiskDir    ds	3
     63 Uf033		       00 00 00    DiskDirNext ds	3
     64 Uf036		       00 00 00    DiskOpenRead ds	3
     65 Uf039		       00 00 00    DiskOpenWrite ds	3
     66 Uf03c		       00 00 00    DiskRead   ds	3
     67 Uf03f		       00 00 00    DiskWrite  ds	3
     68 Uf042		       00 00 00    DiskClose  ds	3
     69 Uf045		       00 00 00    DiskRmFile ds	3
     70 Uf048					      endif		;SD_ENABLED
     71 Uf048
     72 Uf048							;
     73 Udf8e ????				      SEG.U	Data
     74 Udf00					      org	RAM_START
     75 Udf00							;
     76 Udf00							; The use of memory starting from here will remain
     77 Udf00							; constant through different versions of CTMON65.
     78 Udf00							;
     79 Udf00		       00 00	   IRQvec     ds	2
     80 Udf02		       00 00	   NMIvec     ds	2
     81 Udf04							;
     82 Udf04							; Before a L(oad) command, these are set to $FF.
     83 Udf04							; After loading, if they are different, jump to
     84 Udf04							; that address.
     85 Udf04							;
     86 Udf04		       00 00	   AutoRun    ds	2
     87 Udf06							;
     88 Udf06							; Pointer to the subroutine that gets the next input
     89 Udf06							; character.  Used for doing disk/console input.
     90 Udf06							;
     91 Udf06		       00 00	   inputVector ds	2
     92 Udf08							;
     93 Udf08							; Same thing for output.
     94 Udf08							;
     95 Udf08		       00 00	   outputVector ds	2
     96 Udf0a							;
     97 Udf0a							; Buffer for GETLINE
     98 Udf0a							;
     99 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
------- FILE mytb.asm
    303 Udf8e
    304  0206					      SEG	Code
    305  0206							;
    306  0206		       f0 0c	   OUTCH      equ	cout
    307  0206		       f0 09	   GETCH      equ	cin
    308  0206		       2e 14	   CRLF       equ	tbcrlf
    309  0206		       21 63	   OUTHEX     equ	HexToOut
    310  0206		       f0 03	   MONITOR    equ	WARM
    311  0206		       f0 0f	   ISCHAR     equ	cstatus
    312  0206		       21 80	   puts       equ	tbputs
    313  0206					      endif
    314  0206							;
    315  0206		       20 5a 2f    cold2      jsr	SetOutConsole
    316  0209		       20 67 2f 	      jsr	SetInConsole
    317  020c		       20 80 21 	      jsr	puts
      0  020f					      db	CR,LF
      1  020f		       0d 0a		      .byte.b	CR,LF
      0  0211					      db	"Concurrent Tiny BASIC v1.1.40"
      1  0211		       43 6f 6e 63*	      .byte.b	"Concurrent Tiny BASIC v1.1.40"
      0  022e					      db	CR,LF,0
      1  022e		       0d 0a 00 	      .byte.b	CR,LF,0
    321  0231							;
    322  0231		       20 6b 23 	      jsr	MemInit	;setup the free space available
    323  0234
    324  0234		       a9 01	   calcstack  lda	#1
    325  0236		       8d 72 38 	      sta	taskCounter	; Initialize number of tasks to 1
    326  0239		       a9 80		      lda	#TASKACTIVE	; bit 7 is set
    327  023b		       8d 74 37 	      sta	taskTable	; mark the main task as active
    328  023e		       20 98 26 	      jsr	taskSetStacks	; setup all the task stacks/Variables, Init task io block
    329  0241		       a9 9d		      lda	#IL&$ff
    330  0243		       85 43		      sta	ILPC
    331  0245		       a9 32		      lda	#IL>>8
    332  0247		       85 44		      sta	ILPC+1
    333  0249							;
    334  0249							;		  lda	  ProgramStart		     ; user prog
    335  0249							;		  sta	  ProgramEnd
    336  0249							;		  lda	  ProgramStart+1
    337  0249							;		  sta	  ProgramEnd+1
    338  0249							;
    339  0249
    340  0249							;  Init time slices defaults
    341  0249		       a9 02		      lda	#TASKCYCLESHIGH
    342  024b		       8d 71 38 	      sta	taskResetValue+1
    343  024e		       a9 ff		      lda	#TASKCYCLESDEFAULT
    344  0250		       8d 70 38 	      sta	taskResetValue
    345  0253							;
    346  0253							; Initialize the pseudo-random number sequence...
    347  0253							;
    348  0253		       a9 5a		      lda	#$5a
    349  0255		       8d dc 43 	      sta	rtemp1
    350  0258		       a9 9d		      lda	#%10011101
    351  025a		       8d de 43 	      sta	random
    352  025d		       a9 5b		      lda	#%01011011
    353  025f		       8d df 43 	      sta	random+1
    354  0262							;
    355  0262							;   Insert a Basic irq handler for the basic Language
    356  0262		       a9 ff		      lda	#ServiceIrq&$ff
    357  0264		       8d 00 df 	      sta	IRQvec
    358  0267		       a9 19		      lda	#ServiceIrq>>8
    359  0269		       8d 01 df 	      sta	IRQvec+1
    360  026c		       4c 82 02 	      jmp	coldtwo
    361  026f
    362  026f							;
    363  026f							;
    364  026f							; This is the warm start entry point
    365  026f							;
    366  026f		       20 5a 2f    warm2      jsr	SetOutConsole
    367  0272		       20 67 2f 	      jsr	SetInConsole
    368  0275		       20 14 2e 	      jsr	CRLF
    369  0278		       ad d9 43 	      lda	errGoto
    370  027b		       85 43		      sta	ILPC
    371  027d		       ad da 43 	      lda	errGoto+1
    372  0280		       85 44		      sta	ILPC+1
    373  0282							;
    374  0282							; And continue with both starts here
    375  0282							;
    376  0282				   coldtwo
    377  0282							;
    378  0282							; The ILTrace flag is now run-time settable.
    379  0282							;
    380  0282		       a9 00		      lda	#ILTRACE&$ff
    381  0284		       85 40		      sta	ILTrace
    382  0286							;
    383  0286
    384  0286		       a9 00		      lda	#0
    385  0288		       85 5b		      sta	RunMode
    386  028a		       8d 4f 43 	      sta	LINBUF
    387  028d
    388  028d							; Clear everything from the stacks
    389  028d
    390  028d		       8d e6 43 	      sta	taskIOPending	; No one waiting for io
    391  0290		       8d e7 43 	      sta	taskRDPending	; No one waiting for bg io
    392  0293
    393  0293		       20 10 27 	      jsr	taskReset
    394  0296							;
    395  0296		       a9 4f		      lda	#LINBUF&$ff
    396  0298		       85 4f		      sta	CURPTR
    397  029a		       a9 43		      lda	#LINBUF>>8
    398  029c		       85 50		      sta	CURPTR+1	;fall through...
    399  029e
    400  029e							;=====================================================
    401  029e							; This is the top of the IL interpreter.  This fetches
    402  029e							; and executes the instruction currently pointed to
    403  029e							; by ILPC and adjusts ILPC to point to the next
    404  029e							; instruction to execute.
    405  029e							;
    406  029e				   NextIL
    407  029e
    408  029e		       ba		      tsx		; Get the stack pointer value, only for debugging
    409  029f		       e0 ff		      cpx	#$FF	; Should be empty
    410  02a1		       d0 29		      bne	ILbad	; Halt and catch fire now!
    411  02a3
    412  02a3		       ce 6e 38 	      dec	taskCurrentCycles
    413  02a6		       d0 03		      bne	NextIlNow
    414  02a8		       20 37 27 	      jsr	iTaskSwitch	;check for a task switch
    415  02ab				   NextIlNow
    416  02ab
    417  02ab
    418  02ab		       a5 40		      lda	ILTrace	;Do we need to trace this
    419  02ad		       f0 03		      beq	NextIL2	;Skip if no bits set
    420  02af
    421  02af		       20 a4 2e 	      jsr	dbgLine	;Print the IL trace information
    422  02b2
    423  02b2
    424  02b2		       a4 51	   NextIL2    ldy	CUROFF
    425  02b4							;		  jsr	  SkipSpaces	       ; no longer needed as tokenizer takes care of this
    426  02b4							;		  sty	  CUROFF
    427  02b4
    428  02b4							;Task IO Management
    429  02b4		       ad e7 43 	      lda	taskRDPending	; if it is zero then Nothing pending
    430  02b7		       f0 08		      beq	NextILStr
    431  02b9		       20 33 2c 	      jsr	ReadLine	; else Pending and poll keyboard
    432  02bc		       90 03		      bcc	NextILStr	; if carry is clear then no end of line yet
    433  02be		       ce e7 43 	      dec	taskRDPending	; Carry is set if CR has been recieved
    434  02c1							;
    435  02c1		       20 b6 2a    NextILStr  jsr	getILByte
    436  02c4							;
    437  02c4							; When the handler is called, these are the conditions
    438  02c4							; of several important items:
    439  02c4							;
    440  02c4							;    (ILPC) will point to the byte AFTER the IL
    441  02c4							;    opcode being executed.
    442  02c4							;
    443  02c4							;    (CURPTR),CUROFF will point to the start of the
    444  02c4							;    next word in the input buffer.  Ie, the next word
    445  02c4							;    in the user program.
    446  02c4							;
    447  02c4		       18		      clc		; Clear carry before shift
    448  02c5		       0a		      asl		; valid for 0-127
    449  02c6		       b0 04		      bcs	ILbad	; Out of range
    450  02c8		       aa		      tax		; Move value to x
    451  02c9							;		 db	 $7c		      ; jmp (ILTBL,X) ; dasm does not support 65c02 inst
    452  02c9							;		 dw	 ILTBL		      ; Actual IL table address
    453  02c9		       7c ff 02 	      jmp	(ILTBL,x)
    454  02cc
    455  02cc							;		asl
    456  02cc							;		cmp	#ILTBLend-ILTBL+2
    457  02cc							;		bcc	ILgood
    458  02cc							;
    459  02cc							; This handles an illegal IL opcode.  This is serious
    460  02cc							; and there's no way to recover.
    461  02cc							;
    462  02cc				   iBadOP
    463  02cc		       20 80 21    ILbad      jsr	puts
      0  02cf					      db	CR,LF
      1  02cf		       0d 0a		      .byte.b	CR,LF
      0  02d1					      db	"Illegal IL "
      1  02d1		       49 6c 6c 65*	      .byte.b	"Illegal IL "
      0  02dc					      db	0
      1  02dc		       00		      .byte.b	0
    467  02dd							;
    468  02dd							; Well this is awkward, we need to back up the IL
    469  02dd							; by one since it no longer points to the current
    470  02dd							; opcode.
    471  02dd							;
    472  02dd		       20 c3 2a 	      jsr	decIL
    473  02e0							;
    474  02e0		       a0 00		      ldy	#0
    475  02e2		       b1 43		      lda	(ILPC),y
    476  02e4		       20 63 21 	      jsr	OUTHEX
    477  02e7		       20 80 21 	      jsr	puts
      0  02ea					      db	" at ",0
      1  02ea		       20 61 74 20*	      .byte.b	" at ",0
    479  02ef		       a5 44		      lda	ILPC+1
    480  02f1		       20 63 21 	      jsr	OUTHEX
    481  02f4		       a5 43		      lda	ILPC
    482  02f6		       20 63 21 	      jsr	OUTHEX
    483  02f9		       20 14 2e 	      jsr	CRLF
    484  02fc		       4c 03 f0 	      jmp	MONITOR
    485  02ff							;
    486  02ff							; Just jump to the address (ILPC),y.  Have to do
    487  02ff							; some goofy stuff.
    488  02ff							;
    489  02ff							;ILgood:	  tay			 ;move index into Y
    490  02ff							;		  lda	  ILTBL,y
    491  02ff							;		  sta	  dpl
    492  02ff							;		  lda	  ILTBL+1,y
    493  02ff							;		  sta	  dpl+1
    494  02ff							;		  jmp	  (dpl) 	 ;go to handler
    495  02ff							;
    496  02ff							;=====================================================
    497  02ff							; This is the IL jump table.  The IL opcode is
    498  02ff							; mulitplied by two, then looked-up in this table.
    499  02ff							; There is absolutely nothing special about the order
    500  02ff							; of entries here... they all decode at exactly the
    501  02ff							; same speed.	However the entry number must match the
    502  02ff							; values in IL.inc.
    503  02ff							;
    504  02ff				   ILTBL
------- FILE ilvectortable.asm LEVEL 2 PASS 6
      0  02ff					      include	"ilvectortable.asm"
      1  02ff					      seg	Code
      2  02ff				   ILTBL1
      0  02ff					      dw	iXINIT	;0  Initialize the IL
      1  02ff		       37 04		      .word.w	iXINIT
      0  0301					      dw	iDONE	;1  Verify nothing left on statement line, return error if is
      1  0301		       54 04		      .word.w	iDONE
      0  0303					      dw	iPRS	;2  Print string until closing quote
      1  0303		       6b 04		      .word.w	iPRS
      0  0305					      dw	iPRN	;3  Pop the top off the stack and print it as a signed decimal number.
      1  0305		       73 04		      .word.w	iPRN
      0  0307					      dw	iSPC	;4  Space to next zone. Otherwise print a tab
      1  0307		       7c 04		      .word.w	iSPC
      0  0309					      dw	iNLINE	;5  Print a newline
      1  0309		       26 09		      .word.w	iNLINE
      0  030b					      dw	iNXT	;6  CMD MODE: Jump inst following NXT inst., Else move to next line of user code
      1  030b		       84 04		      .word.w	iNXT
      0  030d					      dw	iXFER	;7  Get line number from top of stack, transfer to it or next higher if not found
      1  030d		       d0 04		      .word.w	iXFER
      0  030f					      dw	iSAV	;8  Save a pointer to the next basic code line to the CAll stack
      1  030f		       ee 04		      .word.w	iSAV
      0  0311					      dw	iRSTR	;9  Return from gosub or function, pops the line pointer from stack and sets pc
      1  0311		       1c 25		      .word.w	iRSTR
      0  0313					      dw	iCMPR	;10 Compares top two entries on stach an pushes true or false onto stack, stack enries expected = val1, cmp type, val2
      1  0313		       34 05		      .word.w	iCMPR
      0  0315					      dw	iINNUM	;11 Read line of text, convert to number and puch onto stack
      1  0315		       b3 05		      .word.w	iINNUM
      0  0317					      dw	iFIN	;12 Stop program, enter command mode
      1  0317		       eb 05		      .word.w	iFIN
      0  0319					      dw	iERR	;13 Print error code, stop program, enter command mode
      1  0319		       ff 05		      .word.w	iERR
      0  031b					      dw	iADD	;14 Add the two value at top of stack push answer to top of stack
      1  031b		       88 06		      .word.w	iADD
      0  031d					      dw	iSUB	;15
      1  031d		       9e 06		      .word.w	iSUB
      0  031f					      dw	iNEG	;16
      1  031f		       b4 06		      .word.w	iNEG
      0  0321					      dw	iMUL	;17
      1  0321		       cc 06		      .word.w	iMUL
      0  0323					      dw	iDIV	;18
      1  0323		       0c 07		      .word.w	iDIV
      0  0325					      dw	iSTORE	;19 Pops two entries off stack, first is value, second is address where to store it
      1  0325		       64 07		      .word.w	iSTORE
      0  0327					      dw	iIND	;20 Indirect fetch, byte or word, pop address from stack, use address to get value and push onto stack
      1  0327		       80 07		      .word.w	iIND
      0  0329					      dw	iLST	;21 List the current user program in memory
      1  0329		       1c 08		      .word.w	iLST
      0  032b					      dw	iINIT	;22 Initialize the IL virtual machine
      1  032b		       ff 03		      .word.w	iINIT
      0  032d					      dw	iGETLINE	;23 Read a line from the terminal, terminate with a null byte
      1  032d		       52 08		      .word.w	iGETLINE
      0  032f					      dw	iINSRT	;24 Insert a line of user code into a program at correct location
      1  032f		       6f 08		      .word.w	iINSRT
      0  0331					      dw	iRTN	;25 POP value from IL stack and place into ip program counter, then continue executing from there
      1  0331		       20 09		      .word.w	iRTN
      0  0333					      dw	MONITOR	;26 Exit basic and return to system monitor
      1  0333		       03 f0		      .word.w	MONITOR
      0  0335					      dw	iLIT	;27 Push a literal value onto the math stack
      1  0335		       4a 09		      .word.w	iLIT
      0  0337					      dw	iCALL	;28 Call and IL function, push nextil onto il stach and branch to provided address
      1  0337		       2c 09		      .word.w	iCALL
      0  0339					      dw	iJMP	;29 Immeadiate jump to provided address
      1  0339		       38 09		      .word.w	iJMP
      0  033b					      dw	iVINIT	;30 Initialize all variables for a single task.  Ie, set to zero. And internal stack pointers
      1  033b		       6d 09		      .word.w	iVINIT
      0  033d					      dw	iERRGOTO	;31 Sets the error HAndler Address
      1  033d		       76 09		      .word.w	iERRGOTO
      0  033f					      dw	iTST	;32 compare string, if match continue else jump to provided address
      1  033f		       82 09		      .word.w	iTST
      0  0341					      dw	iTSTV	;33 Test if next is a variable name, if it is then continue, else branch to provided address
      1  0341		       a7 0a		      .word.w	iTSTV
      0  0343					      dw	iTSTL	;34 Test for valid line number and leave it in r0, branch to provided address if not
      1  0343		       4d 0b		      .word.w	iTSTL
      0  0345					      dw	iTSTN	;35 Check for number, if it is then convert push onto math stack and continue, if not then branch to provided address
      1  0345		       68 0b		      .word.w	iTSTN
      0  0347					      dw	iFREE	;36 Push the number of free bytes available for user programs into the math stack
      1  0347		       21 0c		      .word.w	iFREE
      0  0349					      dw	iRANDOM	;37 push a random number onto the math stack
      1  0349		       27 0c		      .word.w	iRANDOM
      0  034b					      dw	iABS	;38 pop math stack, push asbsolute value onto stack
      1  034b		       f8 0c		      .word.w	iABS
     42  034d							;
     43  034d							; Disk functions.  There must be pointers
     44  034d							; to functions even if no disk is supported.
     45  034d							; Makes things easier in IL.inc.
     46  034d							; Life, universe, everything(hitch hiker)
     47  034d							; Did you remember your towel?
     48  034d					      if	DISK_ACCESS
      0  034d					      dw	iOPENREAD	;39  OPen a file for reading
      1  034d		       af 30		      .word.w	iOPENREAD
      0  034f					      dw	iOPENWRITE	;40  Open a file for writing
      1  034f		       10 31		      .word.w	iOPENWRITE
      0  0351					      dw	iDCLOSE	;41  Close an open file
      1  0351		       a4 31		      .word.w	iDCLOSE
      0  0353					      dw	iDGETLINE	;42  Read a line from an open file
      1  0353		       32 31		      .word.w	iDGETLINE
      0  0355					      dw	iDLIST	;43  List the content of the user program to an open disk file... basically save
      1  0355		       9e 31		      .word.w	iDLIST
      0  0357					      dw	iDDIR	;44  List the content of the directory on disk
      1  0357		       79 31		      .word.w	iDDIR
      0  0359					      dw	iRMFILE	;45  Delete as file from disk
      1  0359		       fe 30		      .word.w	iRMFILE
     56  035b				  -	      else
     57  035b				  -	      dw	NextIL	;39
     58  035b				  -	      dw	NextIL	;40
     59  035b				  -	      dw	NextIL	;41
     60  035b				  -	      dw	NextIL	;42
     61  035b				  -	      dw	NextIL	;43
     62  035b				  -	      dw	NextIL	;44
     63  035b				  -	      dw	NextIL	;45
     64  035b					      endif
     65  035b							;
      0  035b					      dw	iCLEARSCREEN	;46	   Clear the terminal of text
      1  035b		       74 2f		      .word.w	iCLEARSCREEN
      0  035d					      dw	iPOKEMEMORY	;47	   Put a byte value into memory location, pop value from stack, pop memory address from stack.
      1  035d		       85 0c		      .word.w	iPOKEMEMORY
      0  035f					      dw	iPEEKMEMORY	;48	   Get a byte from memory, pop memory address from stack
      1  035f		       9a 0c		      .word.w	iPEEKMEMORY
      0  0361					      dw	iTSTLET	;49	   Test if the let with no LET keyword
      1  0361		       c9 09		      .word.w	iTSTLET
      0  0363					      dw	iTSTDONE	;50	   Test if we are at the end of a line
      1  0363		       4e 0a		      .word.w	iTSTDONE
      0  0365					      dw	iGETCHAR	;51	   Get a character from the terminal
      1  0365		       c7 0c		      .word.w	iGETCHAR
      0  0367					      dw	iPUTCHAR	;52	   Put a char to the terminal
      1  0367		       db 0c		      .word.w	iPUTCHAR
      0  0369					      dw	iCallFunc	;53	   call a machine func rtn accumulator
      1  0369		       b0 0c		      .word.w	iCallFunc
      0  036b					      dw	iBranch	;54	   if value on stack is 0 then next line, else next instuction
      1  036b		       81 05		      .word.w	iBranch
      0  036d					      dw	iTSTStr	;55	   Test Specifically for the start of a quoted string
      1  036d		       ac 09		      .word.w	iTSTStr
      0  036f					      dw	iSetIrq	;56	   sets the irq handler
      1  036f		       9d 0d		      .word.w	iSetIrq
      0  0371					      dw	iTstIrq	;57	   test if irq is pending
      1  0371		       df 0b		      .word.w	iTstIrq
      0  0373					      dw	iRET	;58	   return from interupt
      1  0373		       22 05		      .word.w	iRET
      0  0375					      dw	iINSTR	;59	   read a string return first char on top of stack
      1  0375		       cc 05		      .word.w	iINSTR
      0  0377					      dw	iMOD	;60	   returns remainder of division
      1  0377		       15 07		      .word.w	iMOD
      0  0379					      dw	iTaskSet	;61	   sets a line number for the start of a task
      1  0379		       89 27		      .word.w	iTaskSet
      0  037b					      dw	iETask	;62	   Terminates a task
      1  037b		       bb 28		      .word.w	iETask
      0  037d					      dw	iNTask	;63	   goto next task
      1  037d		       6e 28		      .word.w	iNTask
     84  037f				   ILTBL2
      0  037f					      dw	iArray	;64	   Allow Variable to have a subscript
      1  037f		       9d 07		      .word.w	iArray
      0  0381					      dw	iTaskKill	;65	   kill a running task
      1  0381		       66 28		      .word.w	iTaskKill
      0  0383					      dw	iTaskStat	;66	   return the state of a task PID
      1  0383		       3a 28		      .word.w	iTaskStat
      0  0385					      dw	iHexOut	;67	   output the value on the stack as a hex string
      1  0385		       e6 0c		      .word.w	iHexOut
      0  0387					      dw	iReadComplete	;68	   Called after a background read completes
      1  0387		       9d 05		      .word.w	iReadComplete
      0  0389					      dw	iReadStart	;69	   Called to start a background read request
      1  0389		       93 05		      .word.w	iReadStart
      0  038b					      dw	iStartIO	;70	   Lock task until io complete
      1  038b		       9e 28		      .word.w	iStartIO
      0  038d					      dw	iEndIO	;71	   release task lock for io
      1  038d		       a4 28		      .word.w	iEndIO
      0  038f					      dw	iLogNot	;72	   Logical not
      1  038f		       51 0d		      .word.w	iLogNot
      0  0391					      dw	iLogOr	;73	   Logical Or
      1  0391		       27 0d		      .word.w	iLogOr
      0  0393					      dw	iLogAnd	;74	   Logical And
      1  0393		       12 0d		      .word.w	iLogAnd
      0  0395					      dw	iLogXor	;75	   Logical Xor
      1  0395		       3c 0d		      .word.w	iLogXor
      0  0397					      dw	iWTASK	;76	   Wait for a task or set of tasks to complete
      1  0397		       79 28		      .word.w	iWTASK
      0  0399					      dw	iTASKPID	;77	   Returns the TASK PID
      1  0399		       af 28		      .word.w	iTASKPID
      0  039b					      dw	iTRACEPROG	;78	   Turn on and off il trace, bit 6 = basic trace on,  bit 7 = il trace on
      1  039b		       db 0d		      .word.w	iTRACEPROG
      0  039d					      dw	idbgBasic	;79	   Interactive basic debugging
      1  039d		       21 2e		      .word.w	idbgBasic
      0  039f					      dw	iIPCS	;80	   Sending a msg to a task
      1  039f		       99 29		      .word.w	iIPCS
      0  03a1					      dw	iIPCR	;81	   Recieve a message from a task
      1  03a1		       ae 29		      .word.w	iIPCR
      0  03a3					      dw	iIPCC	;82	   Check if any message available for task
      1  03a3		       c0 29		      .word.w	iIPCC
      0  03a5					      dw	iIPCIO	;83	   Check if ips queue is empty, suspend task if empty
      1  03a5		       cb 29		      .word.w	iIPCIO
      0  03a7					      dw	iPushMathStack	;84	   Push the match stack frame pointer and create parameter count
      1  03a7		       8d 24		      .word.w	iPushMathStack
      0  03a9					      dw	iPopMathStack	;85	   Restore the Math Stack frame after parameters have been passed
      1  03a9		       b9 24		      .word.w	iPopMathStack
      0  03ab					      dw	iSaveMathStack	;86	   Save all math info
      1  03ab		       d4 24		      .word.w	iSaveMathStack
      0  03ad					      dw	iRestoreMathStack	;87	Restore the math stack info
      1  03ad		       f1 24		      .word.w	iRestoreMathStack
      0  03af					      dw	iIncParmCount	;88	   Increment the parameter counter
      1  03af		       a8 24		      .word.w	iIncParmCount
      0  03b1					      dw	iTaskGetMathStack	;89   get another tasks stack pointers
      1  03b1		       db 28		      .word.w	iTaskGetMathStack
      0  03b3					      dw	iTaskEnable	;90	   enable a suspended task
      1  03b3		       0c 28		      .word.w	iTaskEnable
      0  03b5					      dw	iTaskSuspend	;91	   Suspend a running task
      1  03b5		       24 28		      .word.w	iTaskSuspend
      0  03b7					      dw	iTaskPutMathPtr	;92	  updates the tasks stack pointer
      1  03b7		       f5 28		      .word.w	iTaskPutMathPtr
      0  03b9					      dw	iTSTVT	;93	   test for another tasks variable
      1  03b9		       9e 0a		      .word.w	iTSTVT
      0  03bb					      dw	iSetR2	;94	   Set the Working register R2 to a value
      1  03bb		       42 09		      .word.w	iSetR2
      0  03bd					      dw	iStk2Tmp	;95	   Move top of stack to temp
      1  03bd		       00 05		      .word.w	iStk2Tmp
      0  03bf					      dw	iTmp2Stk	;96	   Move Temp to stack
      1  03bf		       11 05		      .word.w	iTmp2Stk
      0  03c1					      dw	iTSTBYTE	;97	   Test byte and branch if true
      1  03c1		       ea 09		      .word.w	iTSTBYTE
      0  03c3					      dw	iINCVAR	;98	   Increment variable
      1  03c3		       70 0a		      .word.w	iINCVAR
      0  03c5					      dw	iDECVAR	;99	   Decrement variable
      1  03c5		       88 0a		      .word.w	iDECVAR
      0  03c7					      dw	iSLICE	;100	   set the time slice for tasks
      1  03c7		       2e 29		      .word.w	iSLICE
      0  03c9					      dw	iTSTB	;101	   Test if byte equals
      1  03c9		       09 0a		      .word.w	iTSTB
      0  03cb					      dw	iTSTW	;102	   Test If word equals
      1  03cb		       24 0a		      .word.w	iTSTW
      0  03cd					      dw	iOnGoto	;103	   Branch to table entry based upon buffer value
      1  03cd		       13 1f		      .word.w	iOnGoto
      0  03cf					      dw	iTSTRELOP	;104	   Test relop, push mask onto stack if true, branch otherwise
      1  03cf		       44 1f		      .word.w	iTSTRELOP
      0  03d1					      dw	iRepeatLine	;105	   Repeat the same line again, start execution from beginning of the same line
      1  03d1		       aa 04		      .word.w	iRepeatLine
      0  03d3					      dw	iTSTBRANCH	;106	   Test for compiled branch, take branch if is, skip two bytes and following integer value(line number) goto, gosub, gofn
      1  03d3		       6b 1f		      .word.w	iTSTBRANCH
      0  03d5					      dw	iFastXfer	;107	   move top of stack to curptr, it contains an address
      1  03d5		       bb 04		      .word.w	iFastXfer
      0  03d7					      dw	iSetTerminal	;108	   Set the Io Terminal to be used by print and input statements
      1  03d7		       f4 2f		      .word.w	iSetTerminal
      0  03d9					      dw	iINDB	;109	   fetch a single byte from memory indirect
      1  03d9		       8c 07		      .word.w	iINDB
      0  03db					      dw	iSetBlock	;110	   Set a block or words or byte to a value 16 bit length
      1  03db		       c0 23		      .word.w	iSetBlock
      0  03dd					      dw	iCopyBlock	;111	   Copy a block or memory from one location to another 16 bit length
      1  03dd		       12 24		      .word.w	iCopyBlock
      0  03df					      dw	iCmpBlock	;112	   Compare to parts of memory
      1  03df		       42 24		      .word.w	iCmpBlock
      0  03e1					      dw	iShift	;113	   Shift left 0 or right 1 as parameters
      1  03e1		       75 0d		      .word.w	iShift
      0  03e3					      dw	iTimer	;114	   Start/Stop/Set timer and enable disable system irq
      1  03e3		       37 19		      .word.w	iTimer
    136  03e5
      0  03e5					      dw	iJmpEnd	;115	   Point PC to end of Block if top of math stack is true(0)
      1  03e5		       1b 26		      .word.w	iJmpEnd
      0  03e7					      dw	iJmpStart	;116	   Point the PC to beginning of block in stack
      1  03e7		       41 26		      .word.w	iJmpStart
      0  03e9					      dw	iBeginBlock	;117	   Puts an entry onto the gosub stack for some type of block
      1  03e9		       a1 25		      .word.w	iBeginBlock
      0  03eb					      dw	iIfTrue	;118	   Pops the top off math stack and branches if true
      1  03eb		       71 26		      .word.w	iIfTrue
      0  03ed					      dw	iIfFalse	;119	   Pops the top off math stack and branches if false
      1  03ed		       83 26		      .word.w	iIfFalse
      0  03ef					      dw	iFasterXfer	;120	   MOves the pc directly from stack to curptr
      1  03ef		       b1 04		      .word.w	iFasterXfer
      0  03f1					      dw	iBadOP	;121	   Invalid IL op code
      1  03f1		       cc 02		      .word.w	iBadOP
      0  03f3					      dw	iBadOP	;122	   Invalid IL op code
      1  03f3		       cc 02		      .word.w	iBadOP
      0  03f5					      dw	iBadOP	;123	   Invalid IL op code
      1  03f5		       cc 02		      .word.w	iBadOP
      0  03f7					      dw	iBadOP	;124	   Invalid IL op code
      1  03f7		       cc 02		      .word.w	iBadOP
      0  03f9					      dw	iBadOP	;125	   Invalid IL op code
      1  03f9		       cc 02		      .word.w	iBadOP
      0  03fb					      dw	iBadOP	;126	   Invalid IL op code
      1  03fb		       cc 02		      .word.w	iBadOP
      0  03fd					      dw	iBadOP	;127	   Invalid IL op code
      1  03fd		       cc 02		      .word.w	iBadOP
------- FILE mytb.asm
    506  03fd		       03 ff	   ILTBLend   equ	*
    507  03ff
    508  03ff							;
    509  03ff							;=====================================================
    510  03ff							;=====================================================
    511  03ff							;=====================================================
    512  03ff							; This marks the start of the handlers for IL opcodes.
    513  03ff							;=====================================================
    514  03ff							;=====================================================
    515  03ff							;=====================================================
    516  03ff							;
    517  03ff							;
    518  03ff		       a9 00	   iINIT      lda	#0	; clear IL stack pointer,gosub stack
    519  0401		       85 47		      sta	ILSTACKPTR
    520  0403		       85 4a		      sta	MATHSTACKPTR
    521  0405		       85 4d		      sta	GOSUBSTACKPTR
    522  0407		       a9 38		      lda	#[[GOSUBSTACKSIZE - 2] * 4]	; Reserve two entries for gosubs
    523  0409		       85 4e		      sta	MESSAGEPTR	; message ptr is bottom stack space
    524  040b							;
    525  040b		       ad ec 43 	      lda	ProgramStart	; user prog
    526  040e		       85 4f		      sta	CURPTR
    527  0410		       8d 75 37 	      sta	taskTable+1
    528  0413		       8d ee 43 	      sta	ProgramEnd
    529  0416		       ad ed 43 	      lda	ProgramStart+1
    530  0419		       85 50		      sta	CURPTR+1
    531  041b		       8d 76 37 	      sta	taskTable+2
    532  041e		       8d ef 43 	      sta	ProgramEnd+1
    533  0421		       a9 80		      lda	#TASKACTIVE
    534  0423		       8d 74 37 	      sta	taskTable	;Mark the first slot as active
    535  0426		       a9 01		      lda	#1
    536  0428		       8d 72 38 	      sta	taskCounter	;there is always one task / Main task
    537  042b		       ad 70 38 	      lda	taskResetValue
    538  042e		       8d 6e 38 	      sta	taskCurrentCycles	; set up the task switch counts
    539  0431		       ad 71 38 	      lda	taskResetValue+1
    540  0434		       8d 6f 38 	      sta	taskCurrentCycles+1
    541  0437							;
    542  0437							; fall into XINIT...
    543  0437							;
    544  0437							;=====================================================
    545  0437							; This initializes for the start of the next line of
    546  0437							; BASIC text.
    547  0437							;
    548  0437		       78	   iXINIT     sei		; ensure interupts are off
    549  0438		       20 10 27 	      jsr	taskReset	; Clear the task table
    550  043b		       a9 00		      lda	#0	; Clear the irq flags
    551  043d		       8d 84 19 	      sta	IRQPending	; reset the irq pending
    552  0440		       8d 83 19 	      sta	IRQStatus	; Make sure irqs are off
    553  0443
    554  0443		       4c 9e 02    goodExit   jmp	NextIL
    555  0446							;
    556  0446							;=====================================================
    557  0446							; This check if the escape key has been entered
    558  0446							; then changes out of run mode. z Set if esc found
    559  0446				   BreakSet
    560  0446		       20 0f f0 	      jsr	ISCHAR
    561  0449		       f0 06		      beq	BreakNo
    562  044b		       20 22 1a 	      jsr	VGETCH
    563  044e		       c9 1b		      cmp	#$1B
    564  0450		       60		      rts
    565  0451				   BreakNo
    566  0451		       a9 01		      lda	#1
    567  0453		       60		      rts
    568  0454
    569  0454							;
    570  0454
    571  0454							;=====================================================
    572  0454							; Verify there is nothing else on this input line.
    573  0454							; If there is, generate an error.
    574  0454							;
    575  0454		       a4 51	   iDONE      ldy	CUROFF
    576  0456		       b1 4f		      lda	(CURPTR),y
    577  0458		       f0 0e		      beq	doneadv
    578  045a		       c9 e6		      cmp	#oColon	; is it a  ':' or eol
    579  045c		       d0 03		      bne	idoneErr
    580  045e							;		  sty	  CUROFF
    581  045e		       4c 9e 02 	      jmp	NextIL	; continue on this line
    582  0461
    583  0461				   idoneErr
    584  0461		       a2 04		      ldx	#ERR_EXTRA_STUFF
    585  0463		       a9 00		      lda	#0
    586  0465		       4c 66 06 	      jmp	iErr2
    587  0468							;
    588  0468							; Advance to the next line
    589  0468							;
    590  0468				   doneadv
    591  0468		       4c 9e 02 	      jmp	NextIL
    592  046b							;
    593  046b							;=====================================================
    594  046b							; Print the string until a closing quote
    595  046b							;
    596  046b				   iPRS
    597  046b		       20 a3 21 	      jsr	PrtQuoted
    598  046e		       84 51		      sty	CUROFF
    599  0470		       4c 9e 02 	      jmp	NextIL
    600  0473							;
    601  0473							;=====================================================
    602  0473							; Pop the top off the stack and print it as a signed
    603  0473							; decimal number.
    604  0473							;
    605  0473				   iPRN
    606  0473		       20 5b 2d 	      jsr	popR0
    607  0476		       20 b3 20 	      jsr	PrintDecimal
    608  0479		       4c 9e 02 	      jmp	NextIL
    609  047c							;
    610  047c							;=====================================================
    611  047c							; Space to next zone.	Currently the code does not
    612  047c							; keep track of which column the output is on, so
    613  047c							; just print a tab.
    614  047c							;
    615  047c				   iSPC
    616  047c		       a9 09		      lda	#TAB
    617  047e		       20 1f 1a 	      jsr	VOUTCH
    618  0481		       4c 9e 02 	      jmp	NextIL
    619  0484							;
    620  0484							;=====================================================
    621  0484							; If in immediate mode, jump to the address following
    622  0484							; the NXT instruction.  Else move to the next line of
    623  0484							; user code and continue.
    624  0484							;
    625  0484		       a5 5b	   iNXT       lda	RunMode
    626  0486		       d0 03		      bne	iNxtRun	;in run mode
    627  0488							;
    628  0488							; Get address and jump to it.
    629  0488							;
    630  0488		       4c 38 09 	      jmp	iJMP
    631  048b							;
    632  048b				   iNxtRun
    633  048b		       a4 51		      ldy	CUROFF
    634  048d		       b1 4f		      lda	(CURPTR),y
    635  048f		       c9 e6		      cmp	#oColon
    636  0491		       d0 06		      bne	iNxtRunGo
    637  0493		       c8		      iny
    638  0494		       84 51		      sty	CUROFF
    639  0496		       4c a4 04 	      jmp	iNxtRun2
    640  0499
    641  0499				   iNxtRunGo
    642  0499		       20 40 2b 	      jsr	FindNextLine
    643  049c		       20 54 2b 	      jsr	AtEnd
    644  049f		       d0 03		      bne	iNxtRun2	;not at end
    645  04a1							;
    646  04a1							; At the end of the program.  Pretend an END statement
    647  04a1							; was found.
    648  04a1							;
    649  04a1		       4c eb 05    iFINv      jmp	iFIN
    650  04a4							;
    651  04a4		       20 b2 2a    iNxtRun2   jsr	getILWord	;ignore next word
    652  04a7		       4c 9e 02 	      jmp	NextIL
    653  04aa							;=====================================================
    654  04aa							;Repeat the same line again
    655  04aa		       a0 03	   iRepeatLine ldy	#3
    656  04ac		       84 51		      sty	CUROFF
    657  04ae		       4c 9e 02 	      jmp	NextIL
    658  04b1							;
    659  04b1							;=====================================================
    660  04b1							; XFER takes the number on top of the stack and looks
    661  04b1							; for that line in the program, or the next line
    662  04b1							; higher.  Ie, if it's 1 but there is no line 1, then
    663  04b1							; find the next one after that.
    664  04b1							;
    665  04b1				   iFasterXfer
    666  04b1		       20 b6 2a 	      jsr	getILByte	; get the type of transfer
    667  04b4		       f0 1a		      beq	iXFER	; if it is zero then it must be a line number
    668  04b6		       20 f2 2c 	      jsr	popMath	; put the path stack top into curptr
    669  04b9		       80 20		      bra	iXFER3	; Thats it we are done
    670  04bb
    671  04bb							; This entry point is used by the gosub
    672  04bb				   iFastXfer
    673  04bb		       20 73 2d 	      jsr	popR1	; get type of transfer
    674  04be		       a5 54		      lda	R1
    675  04c0		       f0 0e		      beq	iXFER
    676  04c2		       20 5b 2d 	      jsr	popR0	; get where to transfer
    677  04c5
    678  04c5				   FastFastXfer
    679  04c5		       a5 52		      lda	R0
    680  04c7		       85 4f		      sta	CURPTR
    681  04c9		       a5 53		      lda	R0+1
    682  04cb		       85 50		      sta	CURPTR+1
    683  04cd		       4c d6 04 	      jmp	iXFER2
    684  04d0
    685  04d0				   iXFER
    686  04d0		       20 5b 2d 	      jsr	popR0
    687  04d3		       20 fb 2a 	      jsr	findLine
    688  04d6
    689  04d6				   iXFER2
    690  04d6		       20 54 2b 	      jsr	AtEnd	;at end of user program?
    691  04d9		       f0 c6		      beq	iFINv
    692  04db				   iXFER3		; we dont need to check for end in this case as it was a compiled goto
    693  04db		       a0 03		      ldy	#3	;Change: 2->3 to skip length byte, point to start of text
    694  04dd		       84 51		      sty	CUROFF
    695  04df
    696  04df							;		  lda	  #$ff
    697  04df							;		  sta	  RunMode
    698  04df							;
    699  04df							; Transfer IL to STMT.  I don't like having this
    700  04df							; hard-coded; fix it.
    701  04df							;
    702  04df							;		  lda	  #STMT&$ff
    703  04df							;		  sta	  ILPC
    704  04df							;		  lda	  #STMT>>8
    705  04df							;		  sta	  ILPC+1
    706  04df							;		  jmp	  NextIL
    707  04df							;
    708  04df							; Run
    709  04df							;
    710  04df				   iXferok
    711  04df		       a9 ff		      lda	#$ff
    712  04e1		       85 5b		      sta	RunMode	;we're running
    713  04e3							;
    714  04e3							; Need a more elegant way to do this
    715  04e3							;
    716  04e3		       a9 ab		      lda	#STMT&$ff
    717  04e5		       85 43		      sta	ILPC
    718  04e7		       a9 32		      lda	#STMT>>8
    719  04e9		       85 44		      sta	ILPC+1
    720  04eb		       4c 9e 02 	      jmp	NextIL
    721  04ee							;
    722  04ee							;=====================================================
    723  04ee							; Save the pointer to the next line to the call stack.
    724  04ee							;
    725  04ee		       20 b6 2a    iSAV       jsr	getILByte	; load type of gosub
    726  04f1		       20 c9 2c 	      jsr	pushLN	; Type passed in A
    727  04f4		       b0 03		      bcs	iSAVErr
    728  04f6		       4c 9e 02 	      jmp	NextIL
    729  04f9
    730  04f9		       a2 0c	   iSAVErr    ldx	#ERR_STACK_OVER_FLOW
    731  04fb		       a9 00	   iSAVErr2   lda	#0
    732  04fd		       4c 66 06 	      jmp	iErr2
    733  0500							;====================================================
    734  0500							; Move stack top to and from temp area
    735  0500				   iStk2Tmp
    736  0500		       20 5b 2d 	      jsr	popR0
    737  0503		       a5 52		      lda	R0
    738  0505		       a0 48		      ldy	#TASKEXITCODE	; can also be used as temp
    739  0507		       91 41		      sta	(VARIABLES),y
    740  0509		       c8		      iny
    741  050a		       a5 53		      lda	R0+1
    742  050c		       91 41		      sta	(VARIABLES),y
    743  050e		       4c 9e 02 	      jmp	NextIL
    744  0511
    745  0511		       a0 48	   iTmp2Stk   ldy	#TASKEXITCODE
    746  0513		       b1 41		      lda	(VARIABLES),y
    747  0515		       85 52		      sta	R0
    748  0517		       c8		      iny
    749  0518		       b1 41		      lda	(VARIABLES),y
    750  051a		       85 53		      sta	R0+1
    751  051c		       20 af 2c 	      jsr	pushR0
    752  051f		       4c 9e 02 	      jmp	NextIL
    753  0522							;
    754  0522							;=====================================================
    755  0522							; Pop the next line from the call stack. IRQ return
    756  0522							;
    757  0522		       20 0c 2d    iRET       jsr	popLN
    758  0525		       b0 d2		      bcs	iSAVErr
    759  0527		       a0 03		      ldy	#3
    760  0529		       84 51		      sty	CUROFF
    761  052b		       a9 00		      lda	#0
    762  052d		       8d 84 19 	      sta	IRQPending
    763  0530		       58		      cli
    764  0531		       4c 9e 02 	      jmp	NextIL
    765  0534							;
    766  0534							;=====================================================
    767  0534							; Compare items on stack.  Okay, so on input there are
    768  0534							; three things on the stack
    769  0534							;
    770  0534							;    EXPR2 <- Top of stack
    771  0534							;    OP    <- relational operator, next on stack
    772  0534							;    EXPR1 <- last item on stack
    773  0534							;
    774  0534							; Comparison is: EXPR1 <operator> EXPR2
    775  0534							;
    776  0534							; Operator is one of...
    777  0534							;
    778  0534							;    2 is =
    779  0534							;    1 is <
    780  0534							;    3 is <=
    781  0534							;    5 is <>
    782  0534							;    4 is >
    783  0534							;    6 is >=
    784  0534							;
    785  0534							; Those are bit-mapped:
    786  0534							;
    787  0534							;    xxxxxGEL
    788  0534							;
    789  0534							;    G = Greater than
    790  0534							;    E = Equal
    791  0534							;    L = Less than
    792  0534							;
    793  0534							; If the comparison is false, do a NXT, ie, move to the
    794  0534							; next line and continue.  If true, continue executing
    795  0534							; on this line.
    796  0534							;
    797  0534		       00 01	   REL_LT     equ	%001
    798  0534		       00 02	   REL_EQUAL  equ	%010
    799  0534		       00 04	   REL_GT     equ	%100
    800  0534							;
    801  0534		       20 73 2d    iCMPR      jsr	popR1
    802  0537		       20 8a 2d 	      jsr	popMQ	;operator in MQ
    803  053a		       20 5b 2d 	      jsr	popR0
    804  053d		       20 46 05 	      jsr	iCMPRsub
    805  0540		       20 af 2c 	      jsr	pushR0
    806  0543		       4c 9e 02 	      jmp	NextIL
    807  0546							;
    808  0546							; See if they are equal or not
    809  0546							;
    810  0546				   iCMPRsub		; Called by internal functions
    811  0546
    812  0546		       a5 52		      lda	R0
    813  0548		       c5 54		      cmp	R1
    814  054a		       d0 0a		      bne	iCMPRnoteq	;try not equal
    815  054c		       a5 53		      lda	R0+1
    816  054e		       c5 55		      cmp	R1+1
    817  0550		       d0 04		      bne	iCMPRnoteq
    818  0552							;
    819  0552							; Equal, set the flag in MQ+1
    820  0552							;
    821  0552		       a9 02		      lda	#REL_EQUAL	;They Are Equal
    822  0554		       d0 14		      bne	iCMPcom	;Exit it is equal
    823  0556							;
    824  0556							; See if EXPR1 (R0) < EXPR2 (R1)
    825  0556							; See www.6502.org/tutorials/compare_beyond.html
    826  0556							;
    827  0556				   iCMPRnoteq
    828  0556		       a5 52		      lda	R0
    829  0558		       c5 54		      cmp	R1	; Sets the carry flag
    830  055a		       a5 53		      lda	R0+1
    831  055c		       e5 55		      sbc	R1+1
    832  055e
    833  055e		       50 02		      bvc	iCMPR_2	; branch if N eor V
    834  0560		       49 80		      eor	#$80
    835  0562
    836  0562		       30 04	   iCMPR_2    bmi	iCMPlt
    837  0564		       a9 04		      lda	#REL_GT
    838  0566		       d0 02		      bne	iCMPcom
    839  0568
    840  0568		       a9 01	   iCMPlt     lda	#REL_LT	; R0 < R1
    841  056a
    842  056a				   iCMPcom		;ora	    MQ+1	     ; or with original mask MQ+1 is always zero
    843  056a							;
    844  056a							; Now compare the end result with what the caller
    845  056a							; was looking for.
    846  056a							;
    847  056a		       25 56		      and	MQ
    848  056c		       f0 0c		      beq	iCMPno	; no match
    849  056e		       a9 ff		      lda	#$FF	; true is $ffff
    850  0570		       85 52		      sta	R0
    851  0572		       85 53		      sta	R0+1
    852  0574		       d0 0a		      bne	iCMPDone
    853  0576							;
    854  0576							; R0 > R1
    855  0576							;
    856  0576		       a9 04	   iCMPgt     lda	#REL_GT
    857  0578		       d0 f0		      bne	iCMPcom
    858  057a				   iCMPno
    859  057a		       a9 00		      lda	#0
    860  057c		       85 52		      sta	R0
    861  057e		       85 53		      sta	R0+1
    862  0580
    863  0580				   iCMPDone
    864  0580		       60		      rts
    865  0581
    866  0581							;
    867  0581							; if Not a match, so jump to the next line of user program code.
    868  0581							; Branches based upon value on top of the stack
    869  0581				   iBranch
    870  0581		       20 5b 2d 	      jsr	popR0
    871  0584		       a5 52		      lda	R0
    872  0586		       05 53		      ora	R0+1
    873  0588		       f0 03		      beq	iBranchFalse	; not true
    874  058a		       4c 9e 02 	      jmp	NextIL	; It is true if any value not zero
    875  058d							;
    876  058d				   iBranchFalse
    877  058d		       20 40 2b 	      jsr	FindNextLine
    878  0590		       4c d6 04 	      jmp	iXFER2
    879  0593							;
    880  0593							;=====================================================
    881  0593							; Start a read of data in background
    882  0593				   iReadStart
    883  0593		       a9 3f		      lda	#'?	; Prompt with question mark
    884  0595		       a6 01		      ldx	1	; Indicate to start read in background
    885  0597		       20 cc 2b 	      jsr	GetLine	; Call the getline to start read
    886  059a		       4c 9e 02 	      jmp	NextIL	; next instruction
    887  059d							;
    888  059d							;=====================================================
    889  059d							; Complete the read and return the curptr, curoff pointing to data
    890  059d				   iReadComplete
    891  059d		       a9 01		      lda	#GOSUB_RTN
    892  059f		       20 c9 2c 	      jsr	pushLN
    893  05a2		       90 03		      bcc	iReadOk
    894  05a4		       4c 1a 0c    iReadErr   jmp	ErrStkOver	; Check if there was an error
    895  05a7				   iReadOk
    896  05a7		       20 ec 2b 	      jsr	ReadComplete
    897  05aa		       4c 9e 02 	      jmp	NextIL
    898  05ad		       20 0c 2d 	      jsr	popLN
    899  05b0		       4c 9e 02 	      jmp	NextIL
    900  05b3							;=====================================================
    901  05b3							; Get a line of text from the user, convert to a
    902  05b3							; number, leave on top of stack.
    903  05b3							;
    904  05b3				   iINNUM
    905  05b3		       a9 01		      lda	#GOSUB_RTN
    906  05b5		       20 c9 2c 	      jsr	pushLN
    907  05b8		       b0 ea		      bcs	iReadErr	; Stack over flow error
    908  05ba							;
    909  05ba		       a9 3f		      lda	#'?
    910  05bc		       a2 00		      ldx	#0	;Wait for complete
    911  05be		       20 cc 2b 	      jsr	GetLine
    912  05c1		       20 61 2b 	      jsr	getDecimal
    913  05c4		       20 af 2c 	      jsr	pushR0	;put onto stack
    914  05c7		       b0 db		      bcs	iReadErr	;StackOverflow error
    915  05c9							;
    916  05c9		       4c e5 05 	      jmp	ExitIn
    917  05cc							;
    918  05cc							;=====================================================
    919  05cc							; Get a line of text from the user, convert to a
    920  05cc							; character value , leave on top of stack. up to 2 characters
    921  05cc							;
    922  05cc				   iINSTR
    923  05cc		       a9 01		      lda	#GOSUB_RTN
    924  05ce		       20 c9 2c 	      jsr	pushLN
    925  05d1		       b0 d1		      bcs	iReadErr	; Stack overflow error
    926  05d3		       a9 3f		      lda	#'?
    927  05d5		       a2 00		      ldx	#0	;wait for read complete
    928  05d7		       20 cc 2b 	      jsr	GetLine
    929  05da		       b1 4f		      lda	(CURPTR),y
    930  05dc		       85 52		      sta	R0
    931  05de		       a9 00		      lda	#0
    932  05e0		       85 53		      sta	R0+1
    933  05e2		       20 af 2c 	      jsr	pushR0	;put onto stack
    934  05e5				   ExitIn
    935  05e5		       20 0c 2d 	      jsr	popLN
    936  05e8		       4c 9e 02 	      jmp	NextIL
    937  05eb							;
    938  05eb							;
    939  05eb							;=====================================================
    940  05eb							; Stop the currently running program.	Actually very
    941  05eb							; simple to do... clear the RunMode flag, then set the
    942  05eb							; ILPC to the standard handler and continue running.
    943  05eb							;
    944  05eb		       a9 00	   iFIN       lda	#0
    945  05ed		       85 5b		      sta	RunMode
    946  05ef		       20 10 27 	      jsr	taskReset
    947  05f2							;
    948  05f2		       ad d9 43 	      lda	errGoto
    949  05f5		       85 43		      sta	ILPC
    950  05f7		       ad da 43 	      lda	errGoto+1
    951  05fa		       85 44		      sta	ILPC+1
    952  05fc		       4c 9e 02 	      jmp	NextIL
    953  05ff							;
    954  05ff							;=====================================================
    955  05ff							; Handle the ERR opcode.  Following the instruction is
    956  05ff							; a 16 bit error number.  Print an error message, and
    957  05ff							; if we're in run mode, print the line number.  Stop
    958  05ff							; program execution and return to the initial state.
    959  05ff							;
    960  05ff		       ad e6 43    iERR       lda	taskIOPending
    961  0602		       f0 03		      beq	iErrNext
    962  0604		       ce e6 43 	      dec	taskIOPending
    963  0607
    964  0607		       20 b2 2a    iErrNext   jsr	getILWord	;get err code
    965  060a		       20 10 06 	      jsr	DisplayError
    966  060d		       4c 69 06 	      jmp	iErrComplete
    967  0610							;
    968  0610							; Enter here with the error code in X (LSB) and A (MSB).
    969  0610							;
    970  0610				   DisplayError
    971  0610		       86 52		      stx	R0
    972  0612		       85 53		      sta	R0+1
    973  0614							;
    974  0614		       20 80 21 	      jsr	puts
      0  0617					      db	CR,LF,"Error ",0
      1  0617		       0d 0a 45 72*	      .byte.b	CR,LF,"Error ",0
    976  0620		       20 b3 20 	      jsr	PrintDecimal
    977  0623							;
    978  0623		       a5 5b		      lda	RunMode	;running?
    979  0625		       f0 3b		      beq	iERR3	;nope
    980  0627		       20 80 21 	      jsr	puts
      0  062a					      db	" at line ",0
      1  062a		       20 61 74 20*	      .byte.b	" at line ",0
    982  0634		       a0 01		      ldy	#1	;Changed: Skip the leading length byte
    983  0636				   iErr2a
    984  0636		       b1 4f		      lda	(CURPTR),y
    985  0638		       85 52		      sta	R0
    986  063a		       c8		      iny
    987  063b		       b1 4f		      lda	(CURPTR),y
    988  063d		       85 53		      sta	R0+1
    989  063f		       20 b3 20 	      jsr	PrintDecimal
    990  0642		       20 80 21 	      jsr	puts
      0  0645					      db	":",0
      1  0645		       3a 00		      .byte.b	":",0
    992  0647		       a9 00		      lda	#0
    993  0649		       85 53		      sta	R0+1
    994  064b		       a5 51		      lda	CUROFF
    995  064d		       18		      clc
    996  064e		       e9 03		      sbc	#3
    997  0650		       85 52		      sta	R0
    998  0652		       20 b3 20 	      jsr	PrintDecimal
    999  0655		       20 80 21 	      jsr	puts
      0  0658					      db	":",0
      1  0658		       3a 00		      .byte.b	":",0
   1001  065a		       ad 73 37 	      lda	taskPtr
   1002  065d		       85 52		      sta	R0
   1003  065f		       20 63 21 	      jsr	HexToOut
   1004  0662							;
   1005  0662				   iERR3
   1006  0662		       20 14 2e 	      jsr	CRLF
   1007  0665		       60		      rts
   1008  0666
   1009  0666				   iErr2
   1010  0666		       20 10 06 	      jsr	DisplayError
   1011  0669
   1012  0669				   iErrComplete
   1013  0669		       20 08 27 	      jsr	taskResetStacks	; some error may cause the main task to point to wrong math stack
   1014  066c		       a9 00		      lda	#0
   1015  066e		       85 5b		      sta	RunMode	; fall through...
   1016  0670							;
   1017  0670							;=====================================================
   1018  0670							; Reset the IL to be back at the idle loop.  Does not
   1019  0670							; clear variables so the user can see what state
   1020  0670							; the program is in.
   1021  0670							;
   1022  0670		       a9 00	   ResetIL    lda	#0
   1023  0672		       85 4f		      sta	CURPTR
   1024  0674		       85 51		      sta	CUROFF
   1025  0676		       85 47		      sta	ILSTACKPTR
   1026  0678		       ad d9 43 	      lda	errGoto
   1027  067b		       85 43		      sta	ILPC
   1028  067d		       ad da 43 	      lda	errGoto+1
   1029  0680		       85 44		      sta	ILPC+1
   1030  0682		       a2 ff		      ldx	#$FF	; make sure the stack pointer is reset
   1031  0684		       9a		      txs
   1032  0685		       4c 9e 02 	      jmp	NextIL
   1033  0688
   1034  0688							;
   1035  0688							;=====================================================
   1036  0688							; Pop two items off stack, add them, then place the
   1037  0688							; result back onto the stack.
   1038  0688							;
   1039  0688		       20 5b 2d    iADD       jsr	popR0
   1040  068b		       20 73 2d 	      jsr	popR1
   1041  068e				   iADDfast
   1042  068e		       18		      clc
   1043  068f		       a5 52		      lda	R0
   1044  0691		       65 54		      adc	R1
   1045  0693		       85 52		      sta	R0
   1046  0695		       a5 53		      lda	R0+1
   1047  0697		       65 55		      adc	R1+1
   1048  0699		       85 53		      sta	R0+1
   1049  069b		       4c 06 07 	      jmp	pushR0nextIl
   1050  069e							;
   1051  069e							;=====================================================
   1052  069e							; Pop two items off the stack.  Subtract the top of
   1053  069e							; stack from the lower entry.
   1054  069e							;
   1055  069e		       20 73 2d    iSUB       jsr	popR1
   1056  06a1		       20 5b 2d 	      jsr	popR0
   1057  06a4		       38		      sec
   1058  06a5		       a5 52		      lda	R0
   1059  06a7		       e5 54		      sbc	R1
   1060  06a9		       85 52		      sta	R0
   1061  06ab		       a5 53		      lda	R0+1
   1062  06ad		       e5 55		      sbc	R1+1
   1063  06af		       85 53		      sta	R0+1
   1064  06b1		       4c 06 07 	      jmp	pushR0nextIl
   1065  06b4							;
   1066  06b4							;=====================================================
   1067  06b4							; Negate the top of stack.
   1068  06b4							;
   1069  06b4		       20 5b 2d    iNEG       jsr	popR0
   1070  06b7		       a5 52		      lda	R0
   1071  06b9		       49 ff		      eor	#$ff
   1072  06bb		       85 52		      sta	R0
   1073  06bd		       a5 53		      lda	R0+1
   1074  06bf		       49 ff		      eor	#$ff
   1075  06c1		       85 53		      sta	R0+1
   1076  06c3		       e6 52		      inc	R0
   1077  06c5		       d0 02		      bne	iNEG2
   1078  06c7		       e6 53		      inc	R0+1
   1079  06c9		       4c 06 07    iNEG2      jmp	pushR0nextIl
   1080  06cc							;
   1081  06cc							;=====================================================
   1082  06cc							; Multiply top two items on the stack, put the results
   1083  06cc							; on top.  This uses the algorithm documented on page
   1084  06cc							; 115 of "Microprocessor Programming for Computer
   1085  06cc							; Hobbyists" by Neill Graham.
   1086  06cc							;
   1087  06cc		       20 d2 06    iMUL       jsr	iMultiply
   1088  06cf		       4c 9e 02 	      jmp	NextIL
   1089  06d2
   1090  06d2				   iMultiply
   1091  06d2		       20 5b 2d 	      jsr	popR0	;AC
   1092  06d5		       20 73 2d 	      jsr	popR1	;OP
   1093  06d8							;
   1094  06d8		       a5 52		      lda	R0
   1095  06da		       85 56		      sta	MQ
   1096  06dc		       a5 53		      lda	R0+1
   1097  06de		       85 57		      sta	MQ+1
   1098  06e0		       a9 00		      lda	#0	;clear result
   1099  06e2		       85 52		      sta	R0
   1100  06e4		       85 53		      sta	R0+1
   1101  06e6							;
   1102  06e6		       a2 10		      ldx	#16	;number of bits in value
   1103  06e8		       06 52	   multloop   asl	R0
   1104  06ea		       26 53		      rol	R0+1
   1105  06ec		       06 56		      asl	MQ
   1106  06ee		       26 57		      rol	MQ+1
   1107  06f0		       90 0d		      bcc	multno	;skip add if no carry
   1108  06f2							;
   1109  06f2							; Add R1 back into R0
   1110  06f2							;
   1111  06f2		       18		      clc
   1112  06f3		       a5 52		      lda	R0
   1113  06f5		       65 54		      adc	R1
   1114  06f7		       85 52		      sta	R0
   1115  06f9		       a5 53		      lda	R0+1
   1116  06fb		       65 55		      adc	R1+1
   1117  06fd		       85 53		      sta	R0+1
   1118  06ff							;
   1119  06ff		       ca	   multno     dex		;did all bits yet?
   1120  0700		       d0 e6		      bne	multloop
   1121  0702		       20 af 2c 	      jsr	pushR0	;OP
   1122  0705		       60		      rts
   1123  0706							;
   1124  0706				   pushR0nextIl
   1125  0706		       20 af 2c 	      jsr	pushR0	;OP
   1126  0709		       4c 9e 02 	      jmp	NextIL
   1127  070c							;
   1128  070c							;=====================================================
   1129  070c							; Divide the top of stack into the next to top item.
   1130  070c							; Leave results on stack.  Taken from:
   1131  070c							; http://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
   1132  070c							;
   1133  070c							; R0 = R0 / R1
   1134  070c							; Remainder is in MQ
   1135  070c							;
   1136  070c		       20 26 07    iDIV       jsr	iDoDiv
   1137  070f		       20 dc 2d 	      jsr	RestoreSigns
   1138  0712		       4c 06 07 	      jmp	pushR0nextIl
   1139  0715
   1140  0715		       20 26 07    iMOD       jsr	iDoDiv
   1141  0718		       20 dc 2d 	      jsr	RestoreSigns
   1142  071b		       a5 56		      lda	MQ
   1143  071d		       85 52		      sta	R0
   1144  071f		       a5 57		      lda	MQ+1
   1145  0721		       85 53		      sta	R0+1
   1146  0723		       4c 06 07 	      jmp	pushR0nextIl
   1147  0726
   1148  0726				   iDoDiv
   1149  0726		       20 73 2d 	      jsr	popR1
   1150  0729		       20 5b 2d 	      jsr	popR0
   1151  072c							;
   1152  072c							; Check for divide by zero
   1153  072c							;
   1154  072c
   1155  072c				   iDivNoPop
   1156  072c		       a5 54		      lda	R1
   1157  072e		       05 55		      ora	R1+1
   1158  0730		       f0 29		      beq	divby0
   1159  0732							;
   1160  0732		       20 a1 2d 	      jsr	SaveSigns
   1161  0735		       a9 00		      lda	#0	;preset remainder to 0
   1162  0737		       85 56		      sta	MQ
   1163  0739		       85 57		      sta	MQ+1
   1164  073b		       a2 10		      ldx	#16	;repeat for each bit: ...
   1165  073d				   divloop
   1166  073d		       06 52		      asl	R0	;dividend lb & hb*2, msb -> Carry
   1167  073f		       26 53		      rol	R0+1
   1168  0741		       26 56		      rol	MQ	;remainder lb & hb * 2 + msb from carry
   1169  0743		       26 57		      rol	MQ+1
   1170  0745		       a5 56		      lda	MQ
   1171  0747		       38		      sec
   1172  0748		       e5 54		      sbc	R1	;substract divisor to see if it fits in
   1173  074a		       a8		      tay		;lb result -> Y, for we may need it later
   1174  074b		       a5 57		      lda	MQ+1
   1175  074d		       e5 55		      sbc	R1+1
   1176  074f		       90 06		      bcc	skip	;if carry=0 then divisor didn't fit in yet
   1177  0751
   1178  0751		       85 57		      sta	MQ+1	;else save substraction result as new remainder,
   1179  0753		       84 56		      sty	MQ
   1180  0755		       e6 52		      inc	R0	;and INCrement result cause divisor fit in 1 times
   1181  0757
   1182  0757		       ca	   skip       dex
   1183  0758		       d0 e3		      bne	divloop
   1184  075a		       60		      rts
   1185  075b							;
   1186  075b							; Indicate divide-by-zero error
   1187  075b							;
   1188  075b		       68	   divby0     pla		; remove the reyurn from the stack
   1189  075c		       68		      pla
   1190  075d		       a2 06		      ldx	#ERR_DIVIDE_ZERO	; do the error
   1191  075f		       a9 00		      lda	#0
   1192  0761		       4c 66 06 	      jmp	iErr2
   1193  0764							;
   1194  0764							;=====================================================
   1195  0764							; This pops the top two items off the stack.  The top
   1196  0764							; item is a data value and the other is an ABSOLUTE address.
   1197  0764							; Save the value into that address.
   1198  0764							;
   1199  0764		       5a	   iSTORE     phy
   1200  0765		       20 5b 2d 	      jsr	popR0	;data
   1201  0768		       20 73 2d 	      jsr	popR1	;Storage location
   1202  076b		       a0 01		      ldy	#1
   1203  076d		       a5 58		      lda	R2
   1204  076f		       c9 a2		      cmp	#tByte
   1205  0771		       f0 04		      beq	iStoreB
   1206  0773				   iStoreW
   1207  0773		       a5 53		      lda	R0+1
   1208  0775		       91 54		      sta	(R1),y
   1209  0777				   iStoreB
   1210  0777		       a5 52		      lda	R0
   1211  0779		       88		      dey
   1212  077a		       91 54		      sta	(R1),y
   1213  077c		       7a		      ply
   1214  077d		       4c 9e 02 	      jmp	NextIL
   1215  0780							;
   1216  0780							;=====================================================
   1217  0780							; Replaces the top of stack with the Value
   1218  0780							; of the variable  whose absolute address it represents.
   1219  0780							;
   1220  0780
   1221  0780		       5a	   iIND       phy
   1222  0781		       20 73 2d 	      jsr	popR1
   1223  0784		       a0 01		      ldy	#1
   1224  0786		       a5 58		      lda	R2
   1225  0788		       c9 a4		      cmp	#tInteger
   1226  078a		       f0 04		      beq	iINDW
   1227  078c				   iINDB
   1228  078c		       a9 00		      lda	#0
   1229  078e		       f0 02		      BEQ	iINDC
   1230  0790				   iINDW
   1231  0790		       b1 54		      lda	(R1),y
   1232  0792				   iINDC
   1233  0792		       85 53		      sta	R0+1
   1234  0794		       88		      dey
   1235  0795		       b1 54		      lda	(R1),y
   1236  0797		       85 52		      sta	R0
   1237  0799		       7a		      ply
   1238  079a		       4c 06 07 	      jmp	pushR0nextIl
   1239  079d
   1240  079d							;
   1241  079d							;=====================================================
   1242  079d							; Check which type of index to use byte or word and jmp to correct
   1243  079d							; function
   1244  079d		       5a	   iArray     phy
   1245  079e
   1246  079e		       20 5b 2d 	      jsr	popR0	; Get the array index
   1247  07a1		       20 73 2d 	      jsr	popR1	; Get the Variable address
   1248  07a4
   1249  07a4		       20 b6 2a 	      jsr	getILByte	; Get type of number to process
   1250  07a7		       c9 81		      cmp	#GOSUB_RTN_VALUE	; Are we testing a valid parameter
   1251  07a9		       f0 50		      beq	iArrayFNparm	; process a fn pramater index
   1252  07ab
   1253  07ab		       29 fe		      and	#$FE	; Turn off the unsigned bit
   1254  07ad		       c9 a2		      cmp	#tByte	; Test for a byte index
   1255  07af		       f0 10		      beq	iArrayB	; yes so branch to process a byte
   1256  07b1							;=====================================================
   1257  07b1							; Process 32 bit index into memory
   1258  07b1		       c9 a6	   iArrayL    cmp	#tLong	; Are we working with 32 bit integers
   1259  07b3		       d0 06		      bne	iArrayW	; Process with sigle shift
   1260  07b5		       06 52		      asl	R0	; Do the multiply by 2
   1261  07b7		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1262  07b9		       b0 38		      bcs	iArrayError	; if the carry is set we have an error
   1263  07bb							;=====================================================
   1264  07bb							; Get the array index from top of stack get Current variable
   1265  07bb							; address from next on stack, add the offset
   1266  07bb							; push the result back onto the stack
   1267  07bb				   iArrayW		; pointers, arrays etc all use 16 bit unsigned integers
   1268  07bb		       06 52		      asl	R0	; Do the multiply by 2
   1269  07bd		       26 53		      rol	R0+1	; Indexes can by up to max memory
   1270  07bf		       b0 32		      bcs	iArrayError	; if the carry is set we have an error
   1271  07c1
   1272  07c1							;=====================================================
   1273  07c1							; Get from Byte array not Integer array
   1274  07c1				   iArrayB
   1275  07c1		       18		      clc
   1276  07c2		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1277  07c4		       65 52		      adc	R0
   1278  07c6		       85 52		      sta	R0
   1279  07c8		       a5 55		      lda	R1+1
   1280  07ca		       65 53		      adc	R0+1
   1281  07cc		       85 53		      sta	R0+1	; The new Variable Address is stored in R0
   1282  07ce		       a5 55		      lda	R1+1
   1283  07d0		       cd ef 43 	      cmp	ProgramEnd+1	; lets check if we are processing an @ buffer pointer to free memory
   1284  07d3		       d0 07		      bne	iArrayCheckVar
   1285  07d5				   iArrayExit
   1286  07d5		       20 af 2c 	      jsr	pushR0	; Push R0 assume it is correct
   1287  07d8
   1288  07d8		       7a		      ply
   1289  07d9		       4c 9e 02 	      jmp	NextIL
   1290  07dc							; Check for valis variable and valid index to use
   1291  07dc		       a5 41	   iArrayCheckVar lda	VARIABLES
   1292  07de		       18		      clc
   1293  07df		       69 33		      adc	#[25*2]+1	; the number of actual variable valid bytes
   1294  07e1		       85 56		      sta	MQ	; mq contains the last valid byte we can use
   1295  07e3		       a9 00		      lda	#0
   1296  07e5		       65 42		      adc	VARIABLES+1	; Memory past last word R0+1 > A then invalid
   1297  07e7		       c5 53		      cmp	R0+1
   1298  07e9		       90 08		      bcc	iArrayError
   1299  07eb		       a5 52		      lda	R0	; a > m invalid past last byte of variable area
   1300  07ed		       c5 56		      cmp	MQ
   1301  07ef		       f0 e4		      beq	iArrayExit	; If it is equal then it is valid
   1302  07f1		       90 e2		      bcc	iArrayExit	; if it is less it is valid
   1303  07f3
   1304  07f3							; Get here if array index is out of range
   1305  07f3		       7a	   iArrayError ply
   1306  07f4		       a9 00		      lda	#0
   1307  07f6		       a2 0f		      ldx	#ERR_INDEX_OUT_OF_RANGE
   1308  07f8		       4c 66 06 	      jmp	iErr2
   1309  07fb							;=====================================================
   1310  07fb							; Verify function paramater index is valid
   1311  07fb		       20 6b 25    iArrayFNparm jsr	GosubFindParms	; Get a pointer to the current functions parameter list info
   1312  07fe		       90 f3		      bcc	iArrayError	; There are no paramters for this call, should never be true
   1313  0800		       88		      dey
   1314  0801		       88		      dey		; Points to parameter count
   1315  0802		       a5 52		      lda	R0	; get parm to be accessed
   1316  0804		       d1 4b		      cmp	(GOSUBSTACK),y	; compare to max number allowed
   1317  0806		       b0 eb		      bcs	iArrayError	; the parameter index should be less than the count
   1318  0808		       06 52		      asl	R0	; Do the multiply by 2
   1319  080a		       26 53		      rol	R0+1
   1320  080c
   1321  080c		       18		      clc
   1322  080d		       a5 54		      lda	R1	; Add the index onto the variable pointer
   1323  080f		       65 52		      adc	R0
   1324  0811		       85 52		      sta	R0
   1325  0813		       a5 55		      lda	R1+1
   1326  0815		       65 53		      adc	R0+1
   1327  0817		       85 53		      sta	R0+1	; The new Variable Address is stored in R0
   1328  0819		       4c d5 07 	      jmp	iArrayExit	; Get ot we are done
   1329  081c							;
   1330  081c							;=====================================================
   1331  081c							; List the current BASIC program in memory.  Uses R0,
   1332  081c							; tempIly, and dpl.
   1333  081c							;
   1334  081c		       20 5a 2f    iLST       jsr	SetOutConsole
   1335  081f		       ad ec 43    iLST2      lda	ProgramStart
   1336  0822		       85 59		      sta	dpl
   1337  0824		       ad ed 43 	      lda	ProgramStart+1
   1338  0827		       85 5a		      sta	dpl+1
   1339  0829							;
   1340  0829							; dpl/dph point to the current line.  See if we're at
   1341  0829							; the end of the program.
   1342  0829							;
   1343  0829		       a5 59	   iLSTloop   lda	dpl
   1344  082b		       cd ee 43 	      cmp	ProgramEnd
   1345  082e		       d0 07		      bne	iLstNotEnd
   1346  0830		       a5 5a		      lda	dpl+1
   1347  0832		       cd ef 43 	      cmp	ProgramEnd+1
   1348  0835		       f0 15		      beq	iLstdone
   1349  0837							;
   1350  0837		       20 13 22    iLstNotEnd jsr	PrintProgramLine
   1351  083a							;		  ldy	  #1		  ;Change:  Skip first byte length
   1352  083a							;		  lda	  (dpl),y	  ;line number LSB
   1353  083a							;		  sta	  R0
   1354  083a							;		  iny
   1355  083a							;		  lda	  (dpl),y		 ;line number MSB
   1356  083a							;		  sta	  R0+1
   1357  083a							;		  iny
   1358  083a							;		  sty	  tempIlY
   1359  083a							;		  jsr	  PrintDecimal
   1360  083a							;		  lda	  #SPACE
   1361  083a							;		  jsr	  VOUTCH
   1362  083a							;		  ldy	  tempIlY
   1363  083a							;iLSTl2	  lda	  (dpl),y
   1364  083a							;		  beq	  iLST3 	  ;end of this line 0 value
   1365  083a							;		  sty	  tempIlY
   1366  083a							;		  jsr	  VOUTCH
   1367  083a							;		  ldy	  tempIlY
   1368  083a							;		  iny
   1369  083a							;		  bne	  iLSTl2	  ;do next char
   1370  083a							;
   1371  083a							; End of this line.  Print CR/LF, then move to the
   1372  083a							; next line.
   1373  083a							;
   1374  083a		       a0 00	   iLST3      ldy	#0	;Move to next line
   1375  083c		       b1 59		      lda	(dpl),y	;Current line length
   1376  083e		       18		      clc		;Clear the carry flag
   1377  083f							;		  tya
   1378  083f		       65 59		      adc	dpl	;Add the offset to the pointer
   1379  0841		       85 59		      sta	dpl	;Save the new value
   1380  0843		       a5 5a		      lda	dpl+1	;Next byte
   1381  0845		       69 00		      adc	#0	;ad in the carry if any
   1382  0847		       85 5a		      sta	dpl+1	;Save it
   1383  0849							;
   1384  0849							; Have to manually do CR/LF so it uses the vectored
   1385  0849							; output function.
   1386  0849							;
   1387  0849							;		  lda	  #CR
   1388  0849							;		  jsr	  VOUTCH
   1389  0849							;		  lda	  #LF
   1390  0849							;		  jsr	  VOUTCH
   1391  0849		       4c 29 08 	      jmp	iLSTloop	;do next line
   1392  084c							;
   1393  084c		       20 5a 2f    iLstdone   jsr	SetOutConsole
   1394  084f		       4c 9e 02 	      jmp	NextIL
   1395  0852							;
   1396  0852							;=====================================================
   1397  0852							; Get a line of text into LINBUF.  Terminate with a
   1398  0852							; null byte.
   1399  0852							;
   1400  0852				   iGETLINE
   1401  0852		       a9 3e		      lda	#'>	;prompt character
   1402  0854		       a6 00		      ldx	0	;Wait for read to complete
   1403  0856		       20 cc 2b 	      jsr	GetLine
   1404  0859							;
   1405  0859		       a9 00		      lda	#0
   1406  085b		       85 5b		      sta	RunMode
   1407  085d				   iGetParseLine
   1408  085d							; lda	   CUROFF
   1409  085d							; pha
   1410  085d		       20 23 1d 	      jsr	ParseInputLine
   1411  0860							; pla
   1412  0860							;  sta     CUROFF
   1413  0860		       a9 20		      lda	#TOKENBUFFER&$FF
   1414  0862		       85 4f		      sta	CURPTR
   1415  0864		       a9 1c		      lda	#TOKENBUFFER>>8
   1416  0866		       85 50		      sta	CURPTR+1
   1417  0868		       a9 01		      lda	#1
   1418  086a		       85 51		      sta	CUROFF
   1419  086c		       4c 9e 02 	      jmp	NextIL
   1420  086f							;
   1421  086f							;=====================================================
   1422  086f							; This is called when the input buffer contains a line
   1423  086f							; typed in by the user that starts with a line number.
   1424  086f							; Insert the line into the program or delete the line
   1425  086f							; if there is nothing after the line number,
   1426  086f							;
   1427  086f				   iINSRT		; On entry here the TOKEBUFFER contains the Parsed input line completely
   1428  086f		       ad 21 1c 	      lda	TOKENBUFFER+1	; Get the first byte of the line number
   1429  0872		       85 52		      sta	R0	; place the number into R0
   1430  0874		       ad 22 1c 	      lda	TOKENBUFFER+2	; Get hi byte of line number
   1431  0877		       85 53		      STA	R0+1	; Place it into
   1432  0879							;
   1433  0879							; Now find the line OR the next higher line OR the
   1434  0879							; end of the program.
   1435  0879							;
   1436  0879		       20 fb 2a 	      jsr	findLine	; Look for the line number in the current program
   1437  087c							; Returns Z and curptr point to the line if found
   1438  087c							; Returns C and curptr at next higher line if not found and there is a higher line
   1439  087c							; Returns ZC clear and curptr to end of program if higher than all other lines
   1440  087c							;
   1441  087c							; If the line exists, it needs to be removed.
   1442  087c							;
   1443  087c		       d0 44		      bne	insert2	;jump if no line found higer or a higher line number found, at end of program curptr points to program end
   1444  087e							;
   1445  087e							; Get length of line to be removed, we fall thru to here if we find a matching line
   1446  087e							;
   1447  087e							;		 jsr	 getCURPTRLength ;results in Y , curptr is pointing to point we need to insert the line
   1448  087e		       a0 00		      ldy	#0
   1449  0880		       b1 4f		      lda	(CURPTR),y	;Change the length is now at beginning of the line
   1450  0882		       a8		      tay
   1451  0883							;If it is equal we delete the line and replace it, get length
   1452  0883							;then adjust all program line after up or down depending on len of line
   1453  0883							;If next higher then just move everythimg down by length bytes
   1454  0883							;This call will return how many bytes in the line we found
   1455  0883		       8c e5 43 	      sty	lineLength	;Save the length of the line we found
   1456  0886							;
   1457  0886							; Compute the new end of the program first.
   1458  0886							;
   1459  0886		       38		      sec		;Set the carry bit
   1460  0887		       ad ee 43 	      lda	ProgramEnd	;Get low byte of program end
   1461  088a		       ed e5 43 	      sbc	lineLength	;Subtract the length of the current line
   1462  088d		       8d ee 43 	      sta	ProgramEnd	;save it
   1463  0890		       ad ef 43 	      lda	ProgramEnd+1
   1464  0893		       e9 00		      sbc	#0	;Process the carry
   1465  0895		       8d ef 43 	      sta	ProgramEnd+1	;We now have the new end of program with the line removed
   1466  0898							;
   1467  0898							; Copy CURPTR into R1 for working
   1468  0898							;
   1469  0898		       a5 4f		      lda	CURPTR	;Save the current position to r1 copy destination
   1470  089a		       85 54		      sta	R1
   1471  089c		       a5 50		      lda	CURPTR+1
   1472  089e		       85 55		      sta	R1+1
   1473  08a0							;
   1474  08a0							; See if we're at the end.
   1475  08a0							;
   1476  08a0		       a5 54	   InsDelChk  lda	R1	;Compare the copy dest to end of memory to check if we are finished copy
   1477  08a2		       cd ee 43 	      cmp	ProgramEnd
   1478  08a5		       d0 07		      bne	InsDelLoop
   1479  08a7		       a5 55		      lda	R1+1
   1480  08a9		       cd ef 43 	      cmp	ProgramEnd+1
   1481  08ac		       f0 14		      beq	insert2	;Now the existing line was removed lets go insert the new line
   1482  08ae							;
   1483  08ae							; Move one byte, move to next location.
   1484  08ae							;
   1485  08ae		       ac e5 43    InsDelLoop ldy	lineLength	;Move a byte up to remove the space
   1486  08b1		       f0 0f		      beq	insert2	;if this is zero it is a big oops
   1487  08b3		       b1 54		      lda	(R1),y
   1488  08b5		       a0 00		      ldy	#0
   1489  08b7		       91 54		      sta	(R1),y
   1490  08b9		       e6 54		      inc	R1
   1491  08bb		       d0 e3		      bne	InsDelChk
   1492  08bd		       e6 55		      inc	R1+1
   1493  08bf		       4c a0 08 	      jmp	InsDelChk	; Check if we have moved the last byte
   1494  08c2							;
   1495  08c2							; Deletion is done.
   1496  08c2							; If the new line is empty we're done.  Now we have to open a space for the line we are inserting
   1497  08c2							;
   1498  08c2				   insert2		; ldy	   offset		; get back ptr	Get the current offset
   1499  08c2		       ad 20 1c 	      lda	TOKENBUFFER	; Get the length
   1500  08c5		       c9 04		      cmp	#4	; empty lines only have 4 bytes { len(1), linenum(2) ,null(1) }
   1501  08c7							;		 lda	 LINBUF,y	      ;next byte     Get the next byte to be stored
   1502  08c7		       f0 54		      beq	mvUpFini	;empty line	if there is a null then we were deleting a line, no content
   1503  08c9							;
   1504  08c9							; CURPTR points to where the line will be inserted.
   1505  08c9							;
   1506  08c9							;		 jsr	 getLineLength	 ;get bytes needed Reload the number of bytes required for the new line
   1507  08c9		       ae 20 1c 	      ldx	TOKENBUFFER
   1508  08cc		       8e e5 43 	      stx	lineLength	; So update, the TOKENBUFFER already has the line length
   1509  08cf							;
   1510  08cf		       ad ee 43 	      lda	ProgramEnd	;Load the start address for the copy
   1511  08d2							;At this point curptr still contains the location we will insert data
   1512  08d2		       85 5c		      sta	FROM
   1513  08d4		       ad ef 43 	      lda	ProgramEnd+1
   1514  08d7		       85 5d		      sta	FROM+1
   1515  08d9							;
   1516  08d9		       a0 00	   mvup1      ldy	#0	;always zero from From copy position to use indirect addressing
   1517  08db		       b1 5c		      lda	(FROM),y
   1518  08dd		       ac e5 43 	      ldy	lineLength	;Now load y with new offset downward to store the byte
   1519  08e0		       91 5c		      sta	(FROM),y	;Save the new byte
   1520  08e2							;
   1521  08e2		       a5 5c		      lda	FROM	;Check if we have copied the last byte
   1522  08e4		       c5 4f		      cmp	CURPTR
   1523  08e6		       d0 06		      bne	mvUpMore
   1524  08e8		       a5 5d		      lda	FROM+1
   1525  08ea		       c5 50		      cmp	CURPTR+1
   1526  08ec		       f0 0b		      beq	mvUpDone	; yes from now equals curptr where we insert the new line
   1527  08ee							;
   1528  08ee							; Not done yet
   1529  08ee							;
   1530  08ee		       a5 5c	   mvUpMore   lda	FROM	;decrement FROM to copy the next byte
   1531  08f0		       d0 02		      bne	mvUpMore2
   1532  08f2		       c6 5d		      dec	FROM+1
   1533  08f4		       c6 5c	   mvUpMore2  dec	FROM
   1534  08f6		       4c d9 08 	      jmp	mvup1	;Loop until everything is moved
   1535  08f9							;
   1536  08f9							; All done with copy.
   1537  08f9							;
   1538  08f9				   mvUpDone
   1539  08f9		       18		      clc		;Ok, We are now ready to copy the new line to the program
   1540  08fa		       ad e5 43 	      lda	lineLength	;Number of bytes to copy from line buff
   1541  08fd		       6d ee 43 	      adc	ProgramEnd	;Now pdate the end of program address for space we just opened
   1542  0900		       8d ee 43 	      sta	ProgramEnd
   1543  0903		       ad ef 43 	      lda	ProgramEnd+1
   1544  0906		       69 00		      adc	#0
   1545  0908		       8d ef 43 	      sta	ProgramEnd+1	;Program end now points to the correct enpty space
   1546  090b							;
   1547  090b							;===================jlit use length before line newline
   1548  090b
   1549  090b		       a0 00		      ldy	#0	;Set offset of copy
   1550  090d							;		  lda	  lineLength	  ;We will insert the actual length of the line first
   1551  090d							;		  sta	  (CURPTR),y	  ;Store the length
   1552  090d							;		  iny
   1553  090d							;		  lda	  R0		  ;Store the line number next
   1554  090d							;		  sta	  (CURPTR),y
   1555  090d							;		  iny
   1556  090d							;		  lda	  R0+1
   1557  090d							;		  sta	  (CURPTR),y
   1558  090d							;		  iny
   1559  090d							;
   1560  090d							;		  ldx	  offset	 ; Load the offset into line buffer in page zero
   1561  090d		       a2 00		      ldx	#0	; the token buffer is ready to copy
   1562  090f				   mvUpLoop2
   1563  090f							;		  lda	  LINBUF,x	 ;get a byte
   1564  090f		       bd 20 1c 	      lda	TOKENBUFFER,x	;get a byte
   1565  0912		       91 4f		      sta	(CURPTR),y	;Store into Space opened, copies the closing null as well
   1566  0914
   1567  0914		       e8		      inx
   1568  0915		       ec 20 1c 	      cpx	TOKENBUFFER	; Check if we have copied all that we need to
   1569  0918		       b0 03		      bcs	mvUpFini	;hit the null at end of line then we are done
   1570  091a		       c8		      iny
   1571  091b		       d0 f2		      bne	mvUpLoop2	;in case y wraps past 256 bytes stop
   1572  091d							;
   1573  091d		       4c 9e 02    mvUpFini   jmp	NextIL
   1574  0920							;
   1575  0920							;=====================================================
   1576  0920							; Pops the top value of the ILPC stack and stores it
   1577  0920							; in ILPC.  Ie, return from an IL subroutine.
   1578  0920							;
   1579  0920		       20 e9 2a    iRTN       jsr	popILPC
   1580  0923		       4c 9e 02 	      jmp	NextIL
   1581  0926							;
   1582  0926							;=====================================================
   1583  0926							; NLINE print a newline
   1584  0926							;
   1585  0926		       20 14 2e    iNLINE     jsr	CRLF	;user supplied sub
   1586  0929		       4c 9e 02 	      jmp	NextIL
   1587  092c							;
   1588  092c							;=====================================================
   1589  092c							; This saves the current ILPC value on the stack, then
   1590  092c							; jumps to the address specified by the next two bytes.
   1591  092c							;
   1592  092c		       20 cc 2a    iCALL      jsr	pushILPC	;save ILPC
   1593  092f		       90 07		      bcc	iJMP
   1594  0931
   1595  0931							;If the push failed not enough stack space
   1596  0931		       a2 15	   ErrILStkOver ldx	#ERR_IL_STACK_OVER_FLOW	; Flag any error in line number
   1597  0933		       a9 00		      lda	#0	; stop the execution
   1598  0935		       4c 66 06 	      jmp	iErr2
   1599  0938							;
   1600  0938							; Jmp to a specific location in the IL code.  The new
   1601  0938							; address immediately follows the opcode.
   1602  0938							;
   1603  0938		       20 b2 2a    iJMP       jsr	getILWord
   1604  093b		       86 43		      stx	ILPC
   1605  093d		       85 44		      sta	ILPC+1
   1606  093f		       4c 9e 02 	      jmp	NextIL
   1607  0942
   1608  0942							;
   1609  0942							;=====================================================
   1610  0942							; Push the next two bytes onto the arithmetic stack.
   1611  0942							;
   1612  0942		       20 b6 2a    iSetR2     jsr	getILByte
   1613  0945		       85 58		      sta	R2
   1614  0947		       4c 9e 02 	      jmp	NextIL
   1615  094a							;
   1616  094a							;=====================================================
   1617  094a							; Push the next two bytes onto the arithmetic stack.
   1618  094a							;
   1619  094a		       20 b2 2a    iLIT       jsr	getILWord
   1620  094d		       86 52		      stx	R0
   1621  094f		       85 53		      sta	R0+1
   1622  0951		       20 af 2c 	      jsr	pushR0
   1623  0954		       4c 9e 02 	      jmp	NextIL
   1624  0957							;
   1625  0957							;=====================================================
   1626  0957							; Initialize all variables for a single task.	Ie, set to zero.
   1627  0957							; And internal stack pointers
   1628  0957							;
   1629  0957		       5a	   subVINIT   phy
   1630  0958
   1631  0958		       a9 00		      lda	#0
   1632  095a		       a0 00		      ldy	#0
   1633  095c		       91 41	   Vinit2     sta	(VARIABLES),y
   1634  095e		       c8		      iny
   1635  095f		       c0 48		      cpy	#[[VARIABLESSIZE * 2] - 2]	; skip the old exit code
   1636  0961		       90 f9		      bcc	Vinit2
   1637  0963		       85 4a		      sta	MATHSTACKPTR	; Clear the math stack
   1638  0965		       85 4d		      sta	GOSUBSTACKPTR	; Clear the gosub stack
   1639  0967		       a9 38		      lda	#[[GOSUBSTACKSIZE - 2] * 4]	; Reset the message queue
   1640  0969		       85 4e		      STA	MESSAGEPTR
   1641  096b
   1642  096b		       7a		      ply
   1643  096c		       60		      rts
   1644  096d
   1645  096d				   iVINIT
   1646  096d		       20 57 09 	      jsr	subVINIT
   1647  0970		       20 c1 1f 	      jsr	Compile	; compile line numbers to memory pointers
   1648  0973		       4c 9e 02 	      jmp	NextIL
   1649  0976							;
   1650  0976							;=====================================================
   1651  0976							; Set the address of the error handler.  After any
   1652  0976							; error, set to the ILPC to the specified location.
   1653  0976							;
   1654  0976		       20 b2 2a    iERRGOTO   jsr	getILWord
   1655  0979		       8e d9 43 	      stx	errGoto
   1656  097c		       8d da 43 	      sta	errGoto+1
   1657  097f		       4c 9e 02 	      jmp	NextIL
   1658  0982							;
   1659  0982							;=====================================================
   1660  0982							; TST is followed by an 8 bit signed offset, then a
   1661  0982							; null terminated string.  Compare the string against
   1662  0982							; the string starting at (CURPTR),CUROFF.  If the
   1663  0982							; strings match, continue executing the next IL
   1664  0982							; opcode.  Else, add the offset to ILPC.
   1665  0982							;
   1666  0982		       20 b6 2a    iTST       jsr	getILByte	;Get the relative jump address
   1667  0985		       8d e4 43 	      sta	offset	;save it to use if test faile
   1668  0988		       20 99 2c 	      jsr	saveIL	;in case of failure, to restore before jump calculation
   1669  098b
   1670  098b		       a4 51		      ldy	CUROFF
   1671  098d		       84 59		      sty	dpl	;save for later
   1672  098f							;
   1673  098f		       20 b6 2a    iTSTloop   jsr	getILByte	;get next char
   1674  0992		       f0 11		      beq	iTSTm	;match!
   1675  0994		       a4 59		      ldy	dpl
   1676  0996		       d1 4f		      cmp	(CURPTR),y
   1677  0998		       f0 06		      beq	iTSTUpper	; JLIT added 02/08/2022
   1678  099a		       09 20		      ora	#$20	; lets allow lowercase as well
   1679  099c		       d1 4f		      cmp	(CURPTR),y
   1680  099e		       d0 23		      bne	iTSTfail	;mismatch
   1681  09a0		       c8	   iTSTUpper  iny
   1682  09a1		       84 59		      sty	dpl
   1683  09a3		       d0 ea		      bne	iTSTloop
   1684  09a5							;
   1685  09a5							; It's a match!  Clean up a bit.
   1686  09a5							;
   1687  09a5		       a4 59	   iTSTm      ldy	dpl
   1688  09a7		       84 51		      sty	CUROFF
   1689  09a9		       4c 9e 02 	      jmp	NextIL
   1690  09ac
   1691  09ac							; Test for a single quote string
   1692  09ac		       20 b6 2a    iTSTStr    jsr	getILByte
   1693  09af		       8d e4 43 	      sta	offset
   1694  09b2		       20 99 2c 	      jsr	saveIL
   1695  09b5		       a4 51		      ldy	CUROFF
   1696  09b7		       a9 22		      lda	#'"
   1697  09b9		       d1 4f		      cmp	(CURPTR),y
   1698  09bb		       d0 06		      bne	iTSTfail
   1699  09bd		       c8		      iny
   1700  09be		       84 51		      sty	CUROFF
   1701  09c0		       4c c1 02 	      jmp	NextILStr
   1702  09c3							;
   1703  09c3							; Not a match, reset ILPC and then move to the
   1704  09c3							; offset.
   1705  09c3							;
   1706  09c3		       20 a4 2c    iTSTfail   jsr	restoreIL
   1707  09c6		       4c c0 0b 	      jmp	tstBranch
   1708  09c9							;
   1709  09c9							;=================================================JLIT=
   1710  09c9							; Test if we have a let statement without the let keyword
   1711  09c9		       20 b6 2a    iTSTLET    jsr	getILByte	; Get the relative offset byte
   1712  09cc		       8d e4 43 	      sta	offset	; Save the jump offset for fails
   1713  09cf		       20 99 2c 	      jsr	saveIL	; save to restore when done if fail
   1714  09d2
   1715  09d2		       a4 51		      ldy	CUROFF	; Get the current offset into the buffer
   1716  09d4		       b1 4f		      lda	(CURPTR),y	; Get the byte
   1717  09d6		       c9 01		      cmp	#kLet	; Is it a let keyword
   1718  09d8		       f0 0a		      beq	iTSTLETGOOD	; We have a good let statement
   1719  09da		       c9 80		      cmp	#tVa	; lets check for a variable
   1720  09dc		       90 e5		      bcc	iTSTfail	; Less than variable range
   1721  09de		       c9 9e		      cmp	#tVat+1	; Test if it is greater that the last variable
   1722  09e0		       90 05		      bcc	iTSTGOODVAR	; No it failed get out Fast
   1723  09e2		       b0 df		      bcs	iTSTfail	; return it failed
   1724  09e4
   1725  09e4				   iTSTLETGOOD
   1726  09e4		       c8		      iny
   1727  09e5		       84 51		      sty	CUROFF	; If it was a let then inc past the let word
   1728  09e7				   iTSTGOODVAR
   1729  09e7		       4c 9e 02 	      jmp	NextIL	; Then next instruction
   1730  09ea
   1731  09ea							;=================================================JLIT=
   1732  09ea							; Test a byte at an indirect address
   1733  09ea							; fails if byte is not equal to the value at the address
   1734  09ea							; The tests an indirect byte and branches if true
   1735  09ea		       20 b6 2a    iTSTBYTE   jsr	getILByte	; Get the relative offset byte
   1736  09ed		       8d e4 43 	      sta	offset	; Save the jump offset for fails
   1737  09f0		       20 99 2c 	      jsr	saveIL	; save to restore when done if fail
   1738  09f3		       20 b2 2a 	      jsr	getILWord	; Get a word into RO
   1739  09f6		       86 52		      stx	R0
   1740  09f8		       85 53		      sta	R0+1
   1741  09fa		       20 b6 2a 	      jsr	getILByte	; Get byte into A
   1742  09fd		       a0 00		      ldy	#0
   1743  09ff		       d1 52		      cmp	(R0),y
   1744  0a01		       d0 03		      bne	iTSTByteNotEqual
   1745  0a03		       4c c3 09 	      jmp	iTSTfail
   1746  0a06
   1747  0a06				   iTSTByteNotEqual
   1748  0a06		       4c 9e 02 	      jmp	NextIL	; Then next instruction
   1749  0a09
   1750  0a09							;=================================================JLIT=
   1751  0a09							; Test a byte	branch if it fails
   1752  0a09		       20 b6 2a    iTSTB      jsr	getILByte	; Get the relative offset byte
   1753  0a0c		       8d e4 43 	      sta	offset	; Save the jump offset for fails
   1754  0a0f		       20 99 2c 	      jsr	saveIL	; save to restore when done if fail
   1755  0a12		       20 b6 2a 	      jsr	getILByte	; Get a byte into Acc
   1756  0a15		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1757  0a17		       d1 4f		      cmp	(CURPTR),y
   1758  0a19		       f0 03		      beq	iTSTBMatch	; Yes it matched move on
   1759  0a1b		       4c c3 09 	      jmp	iTSTfail	; REcover and move on to next test
   1760  0a1e
   1761  0a1e				   iTSTBMatch
   1762  0a1e		       c8		      iny
   1763  0a1f		       84 51		      sty	CUROFF	; Point to the next byte
   1764  0a21		       4c 9e 02 	      jmp	NextIL	; Then next instruction
   1765  0a24
   1766  0a24							;=================================================JLIT=
   1767  0a24							; Test a byte	branch if it fails
   1768  0a24		       20 b6 2a    iTSTW      jsr	getILByte	; Get the relative offset byte
   1769  0a27		       8d e4 43 	      sta	offset	; Save the jump offset for fails
   1770  0a2a		       20 99 2c 	      jsr	saveIL	; save to restore when done if fail
   1771  0a2d		       20 b2 2a 	      jsr	getILWord	; Get a word into RO
   1772  0a30		       86 52		      stx	R0
   1773  0a32		       85 53		      sta	R0+1
   1774  0a34		       a4 51		      ldy	CUROFF	; Get offset in the stream
   1775  0a36		       8a		      txa
   1776  0a37		       d1 4f		      cmp	(CURPTR),y	; Test if low order byte matches
   1777  0a39		       f0 e3		      beq	iTSTBMatch	; Yes it matched move on
   1778  0a3b		       4c c3 09 	      jmp	iTSTfail	; REcover and move on to next test
   1779  0a3e		       c8	   iTSTWM1    iny
   1780  0a3f		       a5 53		      lda	R0+1
   1781  0a41		       d1 4f		      cmp	(CURPTR),y	; Check high order byte
   1782  0a43		       f0 03		      beq	iTSTWMatch
   1783  0a45		       4c c3 09 	      jmp	iTSTfail
   1784  0a48
   1785  0a48				   iTSTWMatch
   1786  0a48		       c8		      iny
   1787  0a49		       84 51		      sty	CUROFF
   1788  0a4b		       4c 9e 02 	      jmp	NextIL	; Then next instruction
   1789  0a4e
   1790  0a4e							;================================================jLIT=
   1791  0a4e							;Test for end of line
   1792  0a4e							;
   1793  0a4e				   iTSTDONE
   1794  0a4e		       20 b6 2a 	      jsr	getILByte
   1795  0a51		       8d e4 43 	      sta	offset
   1796  0a54		       20 99 2c 	      jsr	saveIL
   1797  0a57		       a4 51		      ldy	CUROFF
   1798  0a59		       84 59		      sty	dpl
   1799  0a5b		       b1 4f		      lda	(CURPTR),y
   1800  0a5d		       f0 0b		      beq	iTSTDONEtrue
   1801  0a5f		       c9 e6		      cmp	#oColon
   1802  0a61		       f0 07		      beq	iTSTDONEtrue
   1803  0a63		       a4 59		      ldy	dpl
   1804  0a65		       84 51		      sty	CUROFF
   1805  0a67		       4c c3 09 	      jmp	iTSTfail
   1806  0a6a							;
   1807  0a6a							; Advance to the next line
   1808  0a6a							;
   1809  0a6a				   iTSTDONEtrue
   1810  0a6a		       4c 9e 02 	      jmp	NextIL
   1811  0a6d
   1812  0a6d		       4c c0 0b    tstBranchLink jmp	tstBranch
   1813  0a70							;
   1814  0a70							;=====================================================
   1815  0a70							; Inc and dec a variable , faster than a = a + 1
   1816  0a70				   iINCVAR
   1817  0a70		       20 5b 2d 	      jsr	popR0
   1818  0a73		       a0 00		      ldy	#0
   1819  0a75		       18		      clc
   1820  0a76		       a9 01		      lda	#1
   1821  0a78		       71 52		      adc	(R0),y
   1822  0a7a		       91 52		      sta	(R0),y
   1823  0a7c		       90 07		      bcc	iINCDONE
   1824  0a7e		       c8		      iny
   1825  0a7f		       a9 00		      lda	#0
   1826  0a81		       71 52		      adc	(R0),y
   1827  0a83		       91 52		      sta	(R0),y
   1828  0a85				   iINCDONE
   1829  0a85		       4c 9e 02 	      jmp	NextIL
   1830  0a88
   1831  0a88				   iDECVAR
   1832  0a88		       20 5b 2d 	      jsr	popR0
   1833  0a8b		       a0 00		      ldy	#0
   1834  0a8d		       38		      sec
   1835  0a8e		       b1 52		      lda	(R0),y
   1836  0a90		       e9 01		      sbc	#1
   1837  0a92		       91 52		      sta	(R0),y
   1838  0a94		       c8		      iny
   1839  0a95		       b1 52		      lda	(R0),y
   1840  0a97		       e9 00		      sbc	#0
   1841  0a99		       91 52		      sta	(R0),y
   1842  0a9b		       4c 9e 02 	      jmp	NextIL
   1843  0a9e
   1844  0a9e							;
   1845  0a9e							;=====================================================
   1846  0a9e							; TSTV is followed by an 8 bit signed offset.	If the
   1847  0a9e							; value at (CURPTR),CUROFF appears to be a variable
   1848  0a9e							; name, move to the next IL statement.  Else, add the
   1849  0a9e							; offset to ILPC. Converted to use actual absolute memory addresses
   1850  0a9e							; TSTVT Looks for the task context
   1851  0a9e							;
   1852  0a9e		       20 73 2d    iTSTVT     jsr	popR1	; The task top has the context id(PID)
   1853  0aa1		       a9 00		      lda	#0
   1854  0aa3		       85 58		      sta	R2
   1855  0aa5		       f0 04		      beq	iTSTVV
   1856  0aa7
   1857  0aa7							; Test for simple variable
   1858  0aa7		       a9 01	   iTSTV      lda	#1	; set a process Flag
   1859  0aa9		       85 58		      sta	R2
   1860  0aab
   1861  0aab		       20 b6 2a    iTSTVV     jsr	getILByte	;offset
   1862  0aae		       8d e4 43 	      sta	offset
   1863  0ab1							;
   1864  0ab1		       a4 51		      ldy	CUROFF	; Get the pointer into the program
   1865  0ab3		       b1 4f		      lda	(CURPTR),y	; Get the next byte to process
   1866  0ab5		       d0 03		      bne	iTSTVnext	; if is not null then process it
   1867  0ab7		       4c 6d 0a 	      jmp	tstBranchLink	; if we are at the end of line just get out with error
   1868  0aba							;
   1869  0aba				   iTSTVnext
   1870  0aba		       c9 9d		      cmp	#tVat	; allow access to all unused memory as an array or integers
   1871  0abc		       f0 4f		      beq	iTSTVat	; Setup to do a pointer to unused memory
   1872  0abe
   1873  0abe		       c9 9c		      cmp	#tVhash	; parameters passed to this task
   1874  0ac0		       f0 5b		      beq	iTSTVParm
   1875  0ac2
   1876  0ac2		       c9 9b		      cmp	#tVhat	; task exit code
   1877  0ac4		       d0 04		      bne	iTSTV_A2Z
   1878  0ac6		       a9 48		      lda	#TASKEXITCODE
   1879  0ac8		       d0 0b		      bne	iTSTVContinue
   1880  0aca
   1881  0aca				   iTSTV_A2Z
   1882  0aca
   1883  0aca		       c9 80		      cmp	#tVa
   1884  0acc		       90 9f		      bcc	tstBranchLink
   1885  0ace		       c9 9a		      cmp	#tVz+1
   1886  0ad0		       b0 9b		      bcs	tstBranchLink
   1887  0ad2
   1888  0ad2							;
   1889  0ad2							; The condition is true, so convert to an index, push
   1890  0ad2							; it onto the stack and continue running.
   1891  0ad2							;
   1892  0ad2		       29 7f		      and	#%01111111	; Mask off the high bit
   1893  0ad4		       0a		      asl		; multiply by two
   1894  0ad5
   1895  0ad5				   iTSTVContinue
   1896  0ad5		       c8		      iny
   1897  0ad6		       84 51		      sty	CUROFF	; it is a valid variable
   1898  0ad8		       48		      pha		; save the last variable pointer value
   1899  0ad9		       a5 58		      lda	R2
   1900  0adb		       d0 1e		      bne	iTSTVLocalValue	; Value local to this task
   1901  0add
   1902  0add		       20 8d 2a 	      jsr	ipc_ValidateContext	; Lets make sure R1 has a valid context value
   1903  0ae0		       90 08		      bcc	iTSTVGOODPID	; Invalid PID provided
   1904  0ae2
   1905  0ae2		       68		      pla		; We have an invalid pid for getting variable value
   1906  0ae3		       a2 10		      ldx	#ERR_INVALID_PID
   1907  0ae5		       a9 00		      lda	#0
   1908  0ae7		       4c 66 06 	      jmp	iErr2
   1909  0aea
   1910  0aea				   iTSTVGOODPID
   1911  0aea		       20 75 2a 	      jsr	ipc_getcontext	; Get the other tasks variables
   1912  0aed		       a0 01		      ldy	#VARIABLEPOS
   1913  0aef		       b1 56		      lda	(MQ),y
   1914  0af1		       85 52		      sta	R0
   1915  0af3		       c8		      iny
   1916  0af4		       b1 56		      lda	(MQ),y
   1917  0af6		       85 53		      sta	R0+1
   1918  0af8		       4c 03 0b 	      jmp	iTSTVAddOffset
   1919  0afb
   1920  0afb				   iTSTVLocalValue
   1921  0afb		       a5 41		      lda	VARIABLES	; Get the local tasks variables
   1922  0afd		       85 52		      sta	R0
   1923  0aff		       a5 42		      lda	VARIABLES+1
   1924  0b01		       85 53		      sta	R0+1
   1925  0b03
   1926  0b03				   iTSTVAddOffset
   1927  0b03		       68		      pla
   1928  0b04		       85 54		      sta	R1
   1929  0b06		       a9 00		      lda	#0
   1930  0b08		       85 55		      sta	R1+1
   1931  0b0a
   1932  0b0a				   iTSTVcontinue
   1933  0b0a
   1934  0b0a		       4c 8e 06 	      jmp	iADDfast	; Fast add for value/place on stack
   1935  0b0d
   1936  0b0d							; When we get here then we are using the root address of the Lowest addresses free bytes as
   1937  0b0d							; an array of integer values or byte.
   1938  0b0d				   iTSTVat
   1939  0b0d		       c8		      iny
   1940  0b0e		       84 51		      sty	CUROFF	;it is a valid variable
   1941  0b10		       ad ee 43 	      lda	ProgramEnd	;set flag to let evaluator to use PROGRAMEND as the root
   1942  0b13		       85 52		      sta	R0
   1943  0b15		       ad ef 43 	      lda	ProgramEnd+1
   1944  0b18		       85 53		      sta	R0+1
   1945  0b1a		       4c 06 07 	      jmp	pushR0nextIl	;place this onto the stack
   1946  0b1d
   1947  0b1d							; When we get parameters passed we can access them using the # variable with[]
   1948  0b1d							; example #[0] #[1] etc, we dont check yet if there is too many
   1949  0b1d		       c8	   iTSTVParm  iny
   1950  0b1e		       84 51		      sty	CUROFF	;it is a valid variable
   1951  0b20
   1952  0b20							; upon return the y register  point to the gosub Parms entry value entry
   1953  0b20		       20 6b 25 	      jsr	GosubFindParms
   1954  0b23		       90 21		      bcc	iTSTMissingParms
   1955  0b25
   1956  0b25		       88		      dey
   1957  0b26		       88		      dey
   1958  0b27		       88		      dey		;Point to the actual index of first parameter in math stack
   1959  0b28
   1960  0b28		       a5 48		      lda	MATHSTACK
   1961  0b2a		       85 52		      sta	R0
   1962  0b2c		       a5 49		      lda	MATHSTACK+1
   1963  0b2e		       85 53		      sta	R0+1
   1964  0b30		       b1 4b		      lda	(GOSUBSTACK),y	; Get the correct Offset to start of parameters
   1965  0b32		       f0 0b		      beq	iTSTVindex0	; no math if no offset
   1966  0b34		       18		      clc
   1967  0b35		       65 52		      adc	R0	; Point to the actual address that the variables start, not just top of stack
   1968  0b37		       85 52		      sta	R0
   1969  0b39		       a9 00		      lda	#0
   1970  0b3b		       65 53		      adc	R0+1
   1971  0b3d		       85 53		      sta	R0+1
   1972  0b3f				   iTSTVindex0
   1973  0b3f		       a9 81		      lda	#GOSUB_RTN_VALUE
   1974  0b41		       85 58		      sta	R2	; Set the data type as a parameter to a function
   1975  0b43		       4c 06 07 	      jmp	pushR0nextIl
   1976  0b46
   1977  0b46				   iTSTMissingParms
   1978  0b46		       a9 00		      lda	#0
   1979  0b48		       a2 19		      ldx	#ERR_FUNCTION_EXPECTED_PARAMETERS
   1980  0b4a		       4c 66 06 	      jmp	iErr2
   1981  0b4d
   1982  0b4d							;
   1983  0b4d							;=====================================================
   1984  0b4d							; TSTL seems basically the same as TSTN, but leave the
   1985  0b4d							; value in R0 instead of pushing onto stack.
   1986  0b4d							; This tests for a valid line number
   1987  0b4d							;
   1988  0b4d		       20 b6 2a    iTSTL      jsr	getILByte
   1989  0b50		       8d e4 43 	      sta	offset
   1990  0b53							;
   1991  0b53		       a4 51		      ldy	CUROFF
   1992  0b55		       b1 4f		      lda	(CURPTR),y
   1993  0b57		       c8		      iny
   1994  0b58		       11 4f		      ora	(CURPTR),y
   1995  0b5a		       f0 06		      beq	iTSTLNotLineNo
   1996  0b5c
   1997  0b5c							; In Both cases we need to point to the first usefull byte to process.
   1998  0b5c		       c8		      iny
   1999  0b5d		       84 51		      sty	CUROFF
   2000  0b5f		       4c 9e 02 	      jmp	NextIL
   2001  0b62				   iTSTLNotLineNo
   2002  0b62		       c8		      iny
   2003  0b63		       84 51		      sty	CUROFF
   2004  0b65		       4c c0 0b 	      jmp	tstBranch
   2005  0b68
   2006  0b68							;
   2007  0b68							;=====================================================
   2008  0b68							; TSTN checks for a number.  This is very simplistic;
   2009  0b68							; if the character is a digit, assume it's a number.
   2010  0b68							; Convert to a number and push it onto the stack.
   2011  0b68							;
   2012  0b68		       20 b6 2a    iTSTN      jsr	getILByte
   2013  0b6b		       8d e4 43 	      sta	offset
   2014  0b6e							;
   2015  0b6e		       a9 00		      lda	#0
   2016  0b70		       85 59		      sta	dpl
   2017  0b72		       a4 51		      ldy	CUROFF
   2018  0b74				   chkType
   2019  0b74		       b1 4f		      lda	(CURPTR),y
   2020  0b76		       c9 a2		      cmp	#tByte
   2021  0b78		       f0 0e		      beq	chkByte
   2022  0b7a		       c9 a4		      cmp	#tInteger
   2023  0b7c		       f0 16		      beq	chkInteger
   2024  0b7e		       c9 eb		      cmp	#oMinus
   2025  0b80		       d0 3e		      bne	tstBranch
   2026  0b82		       e6 59		      inc	dpl
   2027  0b84		       c8		      iny
   2028  0b85		       4c 74 0b 	      jmp	chkType
   2029  0b88
   2030  0b88				   chkByte
   2031  0b88		       a9 00		      lda	#0
   2032  0b8a		       85 53		      sta	R0+1
   2033  0b8c		       c8		      iny
   2034  0b8d		       b1 4f		      lda	(CURPTR),y
   2035  0b8f		       85 52		      sta	R0
   2036  0b91		       c8		      iny
   2037  0b92		       d0 0b		      bne	iTSTN_1
   2038  0b94
   2039  0b94				   chkInteger
   2040  0b94		       c8		      iny
   2041  0b95		       b1 4f		      lda	(CURPTR),y
   2042  0b97		       85 52		      sta	R0
   2043  0b99		       c8		      iny
   2044  0b9a		       b1 4f		      lda	(CURPTR),y
   2045  0b9c		       85 53		      sta	R0+1
   2046  0b9e		       c8		      iny
   2047  0b9f							;
   2048  0b9f							; Check if it is negative and make it so
   2049  0b9f							;
   2050  0b9f				   iTSTN_1
   2051  0b9f		       84 51		      sty	CUROFF
   2052  0ba1
   2053  0ba1		       a5 59		      lda	dpl
   2054  0ba3		       f0 18		      beq	iTSTN_2	;positive
   2055  0ba5							;
   2056  0ba5		       a5 52		      lda	R0
   2057  0ba7		       05 53		      ora	R0+1
   2058  0ba9		       f0 12		      beq	iTSTN_2	;zero
   2059  0bab
   2060  0bab							; Invert all the bits, then add one.
   2061  0bab							;
   2062  0bab		       a5 52		      lda	R0
   2063  0bad		       49 ff		      eor	#$ff
   2064  0baf		       85 52		      sta	R0
   2065  0bb1		       a5 53		      lda	R0+1
   2066  0bb3		       49 ff		      eor	#$ff
   2067  0bb5		       85 53		      sta	R0+1
   2068  0bb7							;
   2069  0bb7		       e6 52		      inc	R0
   2070  0bb9		       d0 02		      bne	iTSTN_2
   2071  0bbb		       e6 53		      inc	R0+1
   2072  0bbd				   iTSTN_2
   2073  0bbd		       4c 06 07 	      jmp	pushR0nextIl	;save onto stack
   2074  0bc0
   2075  0bc0							;
   2076  0bc0							; Common jump point for all TSTx instructions that
   2077  0bc0							; fail to meet the requirements.  This takes the
   2078  0bc0							; offset and adds/subtracts to/from ILPC.
   2079  0bc0							;
   2080  0bc0		       ad e4 43    tstBranch  lda	offset	;get signed offset
   2081  0bc3		       10 0e		      bpl	tstPositive
   2082  0bc5							;
   2083  0bc5							; Do negative branch.	Do sign extension.
   2084  0bc5							;
   2085  0bc5		       18	   tstNegative clc
   2086  0bc6		       65 43		      adc	ILPC
   2087  0bc8		       85 43		      sta	ILPC
   2088  0bca							;		  bcc	  tstBothDone
   2089  0bca							;		  dec	  ILPC+1
   2090  0bca							;		  jmp	  NextIL
   2091  0bca
   2092  0bca		       a5 44		      lda	ILPC+1
   2093  0bcc		       69 ff		      adc	#$ff
   2094  0bce		       85 44		      sta	ILPC+1
   2095  0bd0		       4c 9e 02 	      jmp	NextIL	;keep going
   2096  0bd3							;
   2097  0bd3		       18	   tstPositive clc
   2098  0bd4		       65 43		      adc	ILPC
   2099  0bd6		       85 43		      sta	ILPC
   2100  0bd8		       90 02		      bcc	tstBothDone
   2101  0bda		       e6 44		      inc	ILPC+1
   2102  0bdc				   tstBothDone
   2103  0bdc		       4c 9e 02 	      jmp	NextIL
   2104  0bdf
   2105  0bdf							;
   2106  0bdf							;====================================================
   2107  0bdf							; Test for IRQ pending, and test if a break key pressed
   2108  0bdf							; Yes I know but this handles all sorts of irq/break issues
   2109  0bdf							;
   2110  0bdf		       20 b6 2a    iTstIrq    jsr	getILByte	; get the offset to next instruction when not in irq
   2111  0be2		       8d e4 43 	      sta	offset	; Store the not true jump address offset
   2112  0be5		       ad 84 19    irqNo      lda	IRQPending	; Check if the pending value is set
   2113  0be8		       f0 20		      beq	tstBreak	; if no irq then check for an escape key pressed
   2114  0bea		       c9 01		      cmp	#1	; only do this if set to first time
   2115  0bec		       d0 1c		      bne	tstBreak	; We are in a irq service already
   2116  0bee				   iTSTProcessIRQ
   2117  0bee		       78		      sei		; disable the interupt until ireturn resets it
   2118  0bef		       ee 84 19 	      inc	IRQPending	; Set the pending to 2, so this ignores it, iret sets it to 0
   2119  0bf2		       a9 01		      lda	#GOSUB_RTN	; Save as gosub
   2120  0bf4		       20 c9 2c 	      jsr	pushLN	; Push the next line to be executed
   2121  0bf7		       b0 21		      bcs	ErrStkOver	; Check if there was an error
   2122  0bf9		       ad 85 19 	      lda	IRQEntry	; Get the line number to branch to
   2123  0bfc		       85 4f		      sta	CURPTR	; put line number into r0
   2124  0bfe		       ad 86 19 	      lda	IRQEntry+1
   2125  0c01		       85 50		      sta	CURPTR+1
   2126  0c03		       a9 03		      lda	#3	; Point to first byte of program text
   2127  0c05		       85 51		      sta	CUROFF
   2128  0c07		       4c 9e 02 	      jmp	NextIL	; Execute the next instruction should jmp statement
   2129  0c0a
   2130  0c0a				   tstBreak
   2131  0c0a		       20 46 04 	      jsr	BreakSet	; Check if the escape key was pressed
   2132  0c0d		       d0 b1		      bne	tstBranch	; z not set of no break found
   2133  0c0f		       ad e6 43 	      lda	taskIOPending
   2134  0c12		       f0 03		      beq	tstBrkComplete
   2135  0c14		       ce e6 43 	      dec	taskIOPending
   2136  0c17		       4c eb 05    tstBrkComplete jmp	iFIN	; Exit out of run mode
   2137  0c1a
   2138  0c1a		       a2 0c	   ErrStkOver ldx	#ERR_STACK_OVER_FLOW	; Flag any error in line number
   2139  0c1c		       a9 00		      lda	#0	; stop the execution
   2140  0c1e		       4c 66 06 	      jmp	iErr2
   2141  0c21							;
   2142  0c21
   2143  0c21							;=====================================================
   2144  0c21							; This places the number of free bytes on top of the
   2145  0c21							; stack.
   2146  0c21							;
   2147  0c21		       20 90 23    iFREE      jsr	MemFree
   2148  0c24		       4c 06 07 	      jmp	pushR0nextIl
   2149  0c27							;
   2150  0c27							;=====================================================
   2151  0c27							; Generate a random number from 0-FFFF and then MOD
   2152  0c27							; it with the value on top of stack.  Leaves number on
   2153  0c27							; stack
   2154  0c27							;
   2155  0c27		       20 73 2d    iRANDOM    jsr	popR1	;mod value
   2156  0c2a							;
   2157  0c2a							; If the value is zero, just return a one.
   2158  0c2a							;
   2159  0c2a		       a5 54		      lda	R1
   2160  0c2c		       05 55		      ora	R1+1
   2161  0c2e		       f0 4a		      beq	irandom1
   2162  0c30							;
   2163  0c30		       ad df 43 	      lda	random+1
   2164  0c33		       8d dc 43 	      sta	rtemp1
   2165  0c36		       ad de 43 	      lda	random
   2166  0c39		       0a		      asl
   2167  0c3a		       2e dc 43 	      rol	rtemp1
   2168  0c3d		       0a		      asl
   2169  0c3e		       2e dc 43 	      rol	rtemp1
   2170  0c41		       18		      clc
   2171  0c42		       6d de 43 	      adc	random
   2172  0c45
   2173  0c45		       48		      pha
   2174  0c46
   2175  0c46		       ad dc 43 	      lda	rtemp1
   2176  0c49		       6d df 43 	      adc	random+1
   2177  0c4c		       8d df 43 	      sta	random+1
   2178  0c4f
   2179  0c4f		       68		      pla
   2180  0c50
   2181  0c50		       69 11		      adc	#$11
   2182  0c52		       8d de 43 	      sta	random
   2183  0c55		       ad df 43 	      lda	random+1
   2184  0c58		       69 36		      adc	#$36
   2185  0c5a		       8d df 43 	      sta	random+1
   2186  0c5d
   2187  0c5d		       ad de 43 	      lda	random
   2188  0c60		       85 52		      sta	R0
   2189  0c62		       ad df 43 	      lda	random+1
   2190  0c65		       29 7f		      and	#$7f	;make positive
   2191  0c67		       85 53		      sta	R0+1
   2192  0c69							;
   2193  0c69							; R0 contains the number and R1 contains the max value.
   2194  0c69							;
   2195  0c69		       20 2c 07 	      jsr	iDivNoPop
   2196  0c6c		       20 dc 2d 	      jsr	RestoreSigns
   2197  0c6f		       a5 56		      lda	MQ
   2198  0c71		       85 52		      sta	R0
   2199  0c73		       a5 57		      lda	MQ+1
   2200  0c75		       85 53		      sta	R0+1
   2201  0c77		       4c 06 07 	      jmp	pushR0nextIl
   2202  0c7a				   irandom1
   2203  0c7a		       a9 00		      lda	#0
   2204  0c7c		       85 53		      sta	R0+1
   2205  0c7e		       a9 01		      lda	#1
   2206  0c80		       85 52		      sta	R0
   2207  0c82		       4c 06 07 	      jmp	pushR0nextIl
   2208  0c85
   2209  0c85							; The following replaced by call to division/modulo
   2210  0c85							;iRANDOM_2	lda	R0
   2211  0c85							;		cmp	R1
   2212  0c85							;		bne	iRANDOM_1
   2213  0c85							;		lda	R0+1
   2214  0c85							;		cmp	R1+1
   2215  0c85							;		bne	iRANDOM_1	;need to subtract
   2216  0c85							;
   2217  0c85							; Subtract R1 from R0
   2218  0c85							;
   2219  0c85							;iRANDOM_sub	sec
   2220  0c85							;		lda	R0
   2221  0c85							;		sbc	R1
   2222  0c85							;		sta	R0
   2223  0c85							;		lda	R0+1
   2224  0c85							;		sbc	R1+1
   2225  0c85							;		sta	R0+1
   2226  0c85							;		jmp	iRANDOM_2
   2227  0c85							;
   2228  0c85							; See if R1 > R0.  If so, branch to subtract.
   2229  0c85							;
   2230  0c85							;iRANDOM_1	lda	R0
   2231  0c85							;		cmp	R1
   2232  0c85							;		lda	R0+1
   2233  0c85							;		sbc	R1+1
   2234  0c85							;		bvc	iRANDOM_4
   2235  0c85							;		eor	#$80
   2236  0c85							;iRANDOM_4	bpl	iRANDOM_sub
   2237  0c85							;
   2238  0c85							; All done.  Almost.  Add one, then push the result.
   2239  0c85							;
   2240  0c85							;irandom1	inc	R0
   2241  0c85							;		bne	iRANDOM_3
   2242  0c85							;		inc	R0+1
   2243  0c85							;iRANDOM_3
   2244  0c85							;		  jsr	pushR0	;return value
   2245  0c85							;		jmp	NextIL
   2246  0c85							;
   2247  0c85							; Poke a value into a memory location
   2248  0c85		       8c e0 43    iPOKEMEMORY sty	tempy
   2249  0c88		       20 5b 2d 	      jsr	popR0
   2250  0c8b		       20 73 2d 	      jsr	popR1
   2251  0c8e		       a0 00		      ldy	#0
   2252  0c90		       a5 52		      lda	R0
   2253  0c92		       91 54		      sta	(R1),y
   2254  0c94		       ac e0 43 	      ldy	tempy
   2255  0c97		       4c 9e 02 	      jmp	NextIL
   2256  0c9a							;
   2257  0c9a							; Get a value from a memory location
   2258  0c9a							;
   2259  0c9a		       8c e0 43    iPEEKMEMORY sty	tempy
   2260  0c9d		       20 5b 2d 	      jsr	popR0
   2261  0ca0		       a0 00		      ldy	#0
   2262  0ca2		       b1 52		      lda	(R0),y
   2263  0ca4		       ac e0 43 	      ldy	tempy
   2264  0ca7		       85 52		      sta	R0
   2265  0ca9		       a9 00		      lda	#0
   2266  0cab		       85 53		      sta	R0+1
   2267  0cad		       4c 06 07 	      jmp	pushR0nextIl
   2268  0cb0							;
   2269  0cb0							; Call to address return what ever is in a to the stack
   2270  0cb0							; func2 will load a value into a before the call
   2271  0cb0		       20 73 2d    iCallFunc  jsr	popR1
   2272  0cb3		       a5 54		      lda	R1
   2273  0cb5		       20 c1 0c 	      jsr	iCallRtn
   2274  0cb8		       85 52		      sta	R0
   2275  0cba		       a9 00		      lda	#0
   2276  0cbc		       85 53		      sta	R0+1
   2277  0cbe		       20 06 07 	      jsr	pushR0nextIl
   2278  0cc1				   iCallRtn
   2279  0cc1		       20 5b 2d 	      jsr	popR0
   2280  0cc4		       6c 52 00 	      jmp	(R0)
   2281  0cc7
   2282  0cc7							;===========================================jlit======
   2283  0cc7							;Get a character from the terminal convert to value
   2284  0cc7							;leave the number on top of the stack
   2285  0cc7							;
   2286  0cc7				   iGETCHAR
   2287  0cc7		       20 22 1a 	      jsr	VGETCH
   2288  0cca					      if	CTMON65
   2289  0cca		       48		      pha
   2290  0ccb		       20 1f 1a 	      jsr	VOUTCH	;echo echo echo
   2291  0cce		       68		      pla
   2292  0ccf					      endif
   2293  0ccf		       85 52		      sta	R0
   2294  0cd1		       a9 00		      lda	#0
   2295  0cd3		       85 53		      sta	R0+1
   2296  0cd5		       20 af 2c 	      jsr	pushR0
   2297  0cd8							;
   2298  0cd8		       4c 9e 02 	      jmp	NextIL
   2299  0cdb							;===========================================jusilostintim======
   2300  0cdb							;Put a character to the terminal convert to
   2301  0cdb							;
   2302  0cdb		       20 5b 2d    iPUTCHAR   jsr	popR0
   2303  0cde		       a5 52		      lda	R0
   2304  0ce0		       20 1f 1a 	      jsr	VOUTCH
   2305  0ce3		       4c 9e 02 	      jmp	NextIL
   2306  0ce6							;=====================================================
   2307  0ce6							; Put the number on the stack out as hex, suppress leading 0
   2308  0ce6				   iHexOut
   2309  0ce6		       20 5b 2d 	      jsr	popR0
   2310  0ce9		       a5 53		      lda	R0+1
   2311  0ceb		       f0 03		      beq	iHexSecondByte
   2312  0ced		       20 63 21 	      jsr	OUTHEX
   2313  0cf0				   iHexSecondByte
   2314  0cf0		       a5 52		      lda	R0
   2315  0cf2		       20 63 21 	      jsr	OUTHEX
   2316  0cf5		       4c 9e 02 	      jmp	NextIL
   2317  0cf8							;
   2318  0cf8							;=====================================================
   2319  0cf8							; Replace TOS with its absolute value.
   2320  0cf8							;
   2321  0cf8		       20 5b 2d    iABS       jsr	popR0
   2322  0cfb		       a5 53		      lda	R0+1
   2323  0cfd		       10 10		      bpl	iABS_1	;already positive
   2324  0cff		       49 ff		      eor	#$ff
   2325  0d01		       85 53		      sta	R0+1
   2326  0d03		       a5 52		      lda	R0
   2327  0d05		       49 ff		      eor	#$ff
   2328  0d07		       85 52		      sta	R0
   2329  0d09		       e6 52		      inc	R0
   2330  0d0b		       d0 02		      bne	iABS_1
   2331  0d0d		       e6 53		      inc	R0+1
   2332  0d0f		       4c 06 07    iABS_1     jmp	pushR0nextIl
   2333  0d12
   2334  0d12							;
   2335  0d12							;================================================================
   2336  0d12							; The set of logical operators
   2337  0d12				   iLogAnd
   2338  0d12		       20 5b 2d 	      jsr	popR0
   2339  0d15		       20 73 2d 	      jsr	popR1
   2340  0d18		       a5 52		      lda	R0
   2341  0d1a		       25 54		      and	R1
   2342  0d1c		       85 52		      sta	R0
   2343  0d1e		       a5 53		      lda	R0+1
   2344  0d20		       25 55		      and	R1+1
   2345  0d22		       85 53		      sta	R0+1
   2346  0d24		       4c 06 07 	      jmp	pushR0nextIl
   2347  0d27
   2348  0d27				   iLogOr
   2349  0d27		       20 5b 2d 	      jsr	popR0
   2350  0d2a		       20 73 2d 	      jsr	popR1
   2351  0d2d		       a5 52		      lda	R0
   2352  0d2f		       05 54		      ora	R1
   2353  0d31		       85 52		      sta	R0
   2354  0d33		       a5 53		      lda	R0+1
   2355  0d35		       05 55		      ora	R1+1
   2356  0d37		       85 53		      sta	R0+1
   2357  0d39		       4c 06 07 	      jmp	pushR0nextIl
   2358  0d3c				   iLogXor
   2359  0d3c		       20 5b 2d 	      jsr	popR0
   2360  0d3f		       20 73 2d 	      jsr	popR1
   2361  0d42		       a5 52		      lda	R0
   2362  0d44		       45 54		      eor	R1
   2363  0d46		       85 52		      sta	R0
   2364  0d48		       a5 53		      lda	R0+1
   2365  0d4a		       45 55		      eor	R1+1
   2366  0d4c		       85 53		      sta	R0+1
   2367  0d4e		       4c 06 07 	      jmp	pushR0nextIl
   2368  0d51				   iLogNot
   2369  0d51		       20 5b 2d 	      jsr	popR0
   2370  0d54		       a5 52		      lda	R0
   2371  0d56		       49 ff		      eor	#$FF
   2372  0d58		       85 52		      sta	R0
   2373  0d5a		       a5 53		      lda	R0+1
   2374  0d5c		       49 ff		      eor	#$FF
   2375  0d5e		       85 53		      sta	R0+1
   2376  0d60		       4c 06 07 	      jmp	pushR0nextIl
   2377  0d63
   2378  0d63				   iTruth
   2379  0d63		       a9 ff		      lda	#$FF
   2380  0d65		       85 52		      sta	R0
   2381  0d67		       85 53		      sta	R0+1
   2382  0d69		       4c 06 07 	      jmp	pushR0nextIl
   2383  0d6c				   iFalse
   2384  0d6c		       a9 00		      lda	#$00
   2385  0d6e		       85 52		      sta	R0
   2386  0d70		       85 53		      sta	R0+1
   2387  0d72		       4c 06 07 	      jmp	pushR0nextIl
   2388  0d75							;===============================================================
   2389  0d75							;Shift instruction a is set to right = 1, left = 0
   2390  0d75							;
   2391  0d75		       da	   iShift     phx
   2392  0d76		       20 5b 2d 	      jsr	popR0	; number of places to shift 0 to 16 really
   2393  0d79		       20 73 2d 	      jsr	popR1	; value to shift
   2394  0d7c		       a6 52		      ldx	R0	; get number of times to shift
   2395  0d7e		       20 b6 2a 	      jsr	getILByte	; get direction to shift
   2396  0d81		       c9 01		      cmp	#1	; Should we be doing left
   2397  0d83		       f0 0a		      beq	iShiftRight
   2398  0d85							;
   2399  0d85							; Shift r1 left n bits
   2400  0d85				   iShiftLeft
   2401  0d85		       18	   iShiftLloop clc
   2402  0d86		       26 54		      rol	R1
   2403  0d88		       26 55		      rol	R1+1
   2404  0d8a		       ca		      dex
   2405  0d8b		       d0 f8		      bne	iShiftLloop
   2406  0d8d		       f0 07		      beq	iShiftExit
   2407  0d8f							;
   2408  0d8f							; Shift R1 right n bits
   2409  0d8f							;
   2410  0d8f				   iShiftRight
   2411  0d8f		       46 55	   iShiftRloop lsr	R1+1
   2412  0d91		       46 54		      lsr	R1
   2413  0d93		       ca		      dex
   2414  0d94		       d0 f9		      bne	iShiftRloop
   2415  0d96				   iShiftExit
   2416  0d96		       fa		      plx
   2417  0d97		       20 41 2d 	      jsr	pushR1
   2418  0d9a		       4c 9e 02 	      jmp	NextIL
   2419  0d9d
   2420  0d9d							;================================================================
   2421  0d9d							;Set the IRQ service rtn line number
   2422  0d9d							;
   2423  0d9d		       78	   iSetIrq    sei		; disable the interupts
   2424  0d9e		       a9 00		      lda	#0	; Zero the Status flag
   2425  0da0		       8d 83 19 	      sta	IRQStatus
   2426  0da3		       20 5b 2d 	      jsr	popR0	; get the line number
   2427  0da6		       a5 52		      lda	R0
   2428  0da8		       05 53		      ora	R0+1
   2429  0daa		       f0 22		      beq	iSetExt	; if it is zero disable all
   2430  0dac		       a9 01		      lda	#GOSUB_RTN	; default push type
   2431  0dae		       20 c9 2c 	      jsr	pushLN	; Save the current line pointer
   2432  0db1		       90 03		      bcc	iSetIrqOk	; Check if there was an error
   2433  0db3		       4c 1a 0c 	      jmp	ErrStkOver	; Check if there was an error
   2434  0db6				   iSetIrqOk
   2435  0db6		       20 fb 2a 	      jsr	findLine	; Find the IRQ func Line Pointer
   2436  0db9		       d0 16		      bne	iSetIrqErr	; Error if exact line not found
   2437  0dbb		       a5 50		      lda	CURPTR+1	; Copy it to the Entry pointer
   2438  0dbd		       8d 86 19 	      sta	IRQEntry+1
   2439  0dc0		       a5 4f		      lda	CURPTR
   2440  0dc2		       8d 85 19 	      sta	IRQEntry
   2441  0dc5		       a9 01		      lda	#1	; Indicate there is an irq gosub
   2442  0dc7		       8d 83 19 	      sta	IRQStatus
   2443  0dca		       20 0c 2d 	      jsr	popLN	; Restore the old line number
   2444  0dcd		       58		      cli		; Enable the interupts
   2445  0dce		       4c 9e 02    iSetExt    jmp	NextIL
   2446  0dd1
   2447  0dd1		       20 0c 2d    iSetIrqErr jsr	popLN
   2448  0dd4		       a2 0d		      ldx	#ERR_BAD_LINE_NUMBER
   2449  0dd6		       a9 00		      lda	#0
   2450  0dd8		       4c 66 06 	      jmp	iErr2
   2451  0ddb							;
   2452  0ddb		       20 5b 2d    iTRACEPROG jsr	popR0
   2453  0dde		       a5 52		      lda	R0
   2454  0de0		       85 40		      sta	ILTrace
   2455  0de2		       4c 9e 02 	      jmp	NextIL
   2456  0de5
   2457  0de5							;=====================================================
   2458  0de5							; Define start of non page zero data
   2459 U43f6 ????				      seg.u	TBData
   2460 U3720					      org	PROGEND
   2461 U3720							;=================================================================
   2462 U3720							;
   2463 U3720					      if	IL_DEBUG_TEXT
------- FILE ILKeyText.inc LEVEL 2 PASS 6
      0 U3720					      include	"ILKeyText.inc"
      1  0de5					      seg	Code
      2  0de5					      if	IL_DEBUG_TEXT
      3  0de5				   ILTEXTTABLE
      0  0de5					      db	0,23,"iXINIT		   ",0
      1  0de5		       00 17 69 58*	      .byte.b	0,23,"iXINIT		   ",0
      0  0dfc					      db	1,23,"iDONE		   ",0
      1  0dfc		       01 17 69 44*	      .byte.b	1,23,"iDONE		   ",0
      0  0e13					      db	2,23,"iPRS		   ",0
      1  0e13		       02 17 69 50*	      .byte.b	2,23,"iPRS		   ",0
      0  0e2a					      db	3,23,"iPRN		   ",0
      1  0e2a		       03 17 69 50*	      .byte.b	3,23,"iPRN		   ",0
      0  0e41					      db	4,23,"iSPC		   ",0
      1  0e41		       04 17 69 53*	      .byte.b	4,23,"iSPC		   ",0
      0  0e58					      db	5,23,"iNLINE		   ",0
      1  0e58		       05 17 69 4e*	      .byte.b	5,23,"iNLINE		   ",0
      0  0e6f					      db	6,23,"iNXT		   ",0
      1  0e6f		       06 17 69 4e*	      .byte.b	6,23,"iNXT		   ",0
      0  0e86					      db	7,23,"iXFER		   ",0
      1  0e86		       07 17 69 58*	      .byte.b	7,23,"iXFER		   ",0
      0  0e9d					      db	8,23,"iSAV		   ",0
      1  0e9d		       08 17 69 53*	      .byte.b	8,23,"iSAV		   ",0
      0  0eb4					      db	9,23,"iRSTR		   ",0
      1  0eb4		       09 17 69 52*	      .byte.b	9,23,"iRSTR		   ",0
      0  0ecb					      db	10,23,"iCMPR		    ",0
      1  0ecb		       0a 17 69 43*	      .byte.b	10,23,"iCMPR		    ",0
      0  0ee2					      db	11,23,"iINNUM		    ",0
      1  0ee2		       0b 17 69 49*	      .byte.b	11,23,"iINNUM		    ",0
      0  0ef9					      db	12,23,"iFIN		    ",0
      1  0ef9		       0c 17 69 46*	      .byte.b	12,23,"iFIN		    ",0
      0  0f10					      db	13,23,"iERR		    ",0
      1  0f10		       0d 17 69 45*	      .byte.b	13,23,"iERR		    ",0
      0  0f27					      db	14,23,"iADD		    ",0
      1  0f27		       0e 17 69 41*	      .byte.b	14,23,"iADD		    ",0
      0  0f3e					      db	15,23,"iSUB		    ",0
      1  0f3e		       0f 17 69 53*	      .byte.b	15,23,"iSUB		    ",0
      0  0f55					      db	16,23,"iNEG		    ",0
      1  0f55		       10 17 69 4e*	      .byte.b	16,23,"iNEG		    ",0
      0  0f6c					      db	17,23,"iMUL		    ",0
      1  0f6c		       11 17 69 4d*	      .byte.b	17,23,"iMUL		    ",0
      0  0f83					      db	18,23,"iDIV		    ",0
      1  0f83		       12 17 69 44*	      .byte.b	18,23,"iDIV		    ",0
      0  0f9a					      db	19,23,"iSTORE		    ",0
      1  0f9a		       13 17 69 53*	      .byte.b	19,23,"iSTORE		    ",0
      0  0fb1					      db	20,23,"iIND		    ",0
      1  0fb1		       14 17 69 49*	      .byte.b	20,23,"iIND		    ",0
      0  0fc8					      db	21,23,"iLST		    ",0
      1  0fc8		       15 17 69 4c*	      .byte.b	21,23,"iLST		    ",0
      0  0fdf					      db	22,23,"iINIT		    ",0
      1  0fdf		       16 17 69 49*	      .byte.b	22,23,"iINIT		    ",0
      0  0ff6					      db	23,23,"iGETLINE	    ",0
      1  0ff6		       17 17 69 47*	      .byte.b	23,23,"iGETLINE	    ",0
      0  100d					      db	24,23,"iINSRT		    ",0
      1  100d		       18 17 69 49*	      .byte.b	24,23,"iINSRT		    ",0
      0  1024					      db	25,23,"iRTN		    ",0
      1  1024		       19 17 69 52*	      .byte.b	25,23,"iRTN		    ",0
      0  103b					      db	26,23,"MONITOR 	    ",0
      1  103b		       1a 17 4d 4f*	      .byte.b	26,23,"MONITOR 	    ",0
      0  1052					      db	27,23,"iLIT		    ",0
      1  1052		       1b 17 69 4c*	      .byte.b	27,23,"iLIT		    ",0
      0  1069					      db	28,23,"iCALL		    ",0
      1  1069		       1c 17 69 43*	      .byte.b	28,23,"iCALL		    ",0
      0  1080					      db	29,23,"iJMP		    ",0
      1  1080		       1d 17 69 4a*	      .byte.b	29,23,"iJMP		    ",0
      0  1097					      db	30,23,"iVINIT		    ",0
      1  1097		       1e 17 69 56*	      .byte.b	30,23,"iVINIT		    ",0
      0  10ae					      db	31,23,"iERRGOTO	    ",0
      1  10ae		       1f 17 69 45*	      .byte.b	31,23,"iERRGOTO	    ",0
      0  10c5					      db	32,23,"iTST		    ",0
      1  10c5		       20 17 69 54*	      .byte.b	32,23,"iTST		    ",0
      0  10dc					      db	33,23,"iTSTV		    ",0
      1  10dc		       21 17 69 54*	      .byte.b	33,23,"iTSTV		    ",0
      0  10f3					      db	34,23,"iTSTL		    ",0
      1  10f3		       22 17 69 54*	      .byte.b	34,23,"iTSTL		    ",0
      0  110a					      db	35,23,"iTSTN		    ",0
      1  110a		       23 17 69 54*	      .byte.b	35,23,"iTSTN		    ",0
      0  1121					      db	36,23,"iFREE		    ",0
      1  1121		       24 17 69 46*	      .byte.b	36,23,"iFREE		    ",0
      0  1138					      db	37,23,"iRANDOM 	    ",0
      1  1138		       25 17 69 52*	      .byte.b	37,23,"iRANDOM 	    ",0
      0  114f					      db	38,23,"iABS		    ",0
      1  114f		       26 17 69 41*	      .byte.b	38,23,"iABS		    ",0
     43  1166							;
     44  1166					      if	DISK_ACCESS
      0  1166					      db	39,23,"iOPENREAD	    ",0
      1  1166		       27 17 69 4f*	      .byte.b	39,23,"iOPENREAD	    ",0
      0  117d					      db	40,23,"iOPENWRITE	    ",0
      1  117d		       28 17 69 4f*	      .byte.b	40,23,"iOPENWRITE	    ",0
      0  1194					      db	41,23,"iDCLOSE 	    ",0
      1  1194		       29 17 69 44*	      .byte.b	41,23,"iDCLOSE 	    ",0
      0  11ab					      db	42,23,"iDGETLINE	    ",0
      1  11ab		       2a 17 69 44*	      .byte.b	42,23,"iDGETLINE	    ",0
      0  11c2					      db	43,23,"iDLIST		    ",0
      1  11c2		       2b 17 69 44*	      .byte.b	43,23,"iDLIST		    ",0
      0  11d9					      db	44,23,"iDDIR		    ",0
      1  11d9		       2c 17 69 44*	      .byte.b	44,23,"iDDIR		    ",0
      0  11f0					      db	45,23,"iRMFILE 	    ",0
      1  11f0		       2d 17 69 52*	      .byte.b	45,23,"iRMFILE 	    ",0
     52  1207				  -	      else
     53  1207				  -	      db	39,23,"NextIL		    ",0
     54  1207				  -	      db	40,23,"NextIL		    ",0
     55  1207				  -	      db	41,23,"NextIL		    ",0
     56  1207				  -	      db	42,23,"NextIL		    ",0
     57  1207				  -	      db	43,23,"NextIL		    ",0
     58  1207				  -	      db	44,23,"NextIL		    ",0
     59  1207				  -	      db	45,23,"NextIL		    ",0
     60  1207					      endif
     61  1207							;
      0  1207					      db	46,23,"iCLEARSCREEN	    ",0
      1  1207		       2e 17 69 43*	      .byte.b	46,23,"iCLEARSCREEN	    ",0
      0  121e					      db	47,23,"iPOKEMEMORY	    ",0
      1  121e		       2f 17 69 50*	      .byte.b	47,23,"iPOKEMEMORY	    ",0
      0  1235					      db	48,23,"iPEEKMEMORY	    ",0
      1  1235		       30 17 69 50*	      .byte.b	48,23,"iPEEKMEMORY	    ",0
      0  124c					      db	49,23,"iTSTLET 	    ",0
      1  124c		       31 17 69 54*	      .byte.b	49,23,"iTSTLET 	    ",0
      0  1263					      db	50,23,"iTSTDONE	    ",0
      1  1263		       32 17 69 54*	      .byte.b	50,23,"iTSTDONE	    ",0
      0  127a					      db	51,23,"iGETCHAR	    ",0
      1  127a		       33 17 69 47*	      .byte.b	51,23,"iGETCHAR	    ",0
      0  1291					      db	52,23,"iPUTCHAR	    ",0
      1  1291		       34 17 69 50*	      .byte.b	52,23,"iPUTCHAR	    ",0
      0  12a8					      db	53,23,"iCallFunc	    ",0
      1  12a8		       35 17 69 43*	      .byte.b	53,23,"iCallFunc	    ",0
      0  12bf					      db	54,23,"iBranch 	    ",0
      1  12bf		       36 17 69 42*	      .byte.b	54,23,"iBranch 	    ",0
      0  12d6					      db	55,23,"iTSTStr 	    ",0
      1  12d6		       37 17 69 54*	      .byte.b	55,23,"iTSTStr 	    ",0
      0  12ed					      db	56,23,"iSetIrq 	    ",0
      1  12ed		       38 17 69 53*	      .byte.b	56,23,"iSetIrq 	    ",0
      0  1304					      db	57,23,"iTstIrq 	    ",0
      1  1304		       39 17 69 54*	      .byte.b	57,23,"iTstIrq 	    ",0
      0  131b					      db	58,23,"iRET		    ",0
      1  131b		       3a 17 69 52*	      .byte.b	58,23,"iRET		    ",0
      0  1332					      db	59,23,"iINSTR		    ",0
      1  1332		       3b 17 69 49*	      .byte.b	59,23,"iINSTR		    ",0
      0  1349					      db	60,23,"iMOD		    ",0
      1  1349		       3c 17 69 4d*	      .byte.b	60,23,"iMOD		    ",0
      0  1360					      db	61,23,"iTaskSet	    ",0
      1  1360		       3d 17 69 54*	      .byte.b	61,23,"iTaskSet	    ",0
      0  1377					      db	62,23,"iETask		    ",0
      1  1377		       3e 17 69 45*	      .byte.b	62,23,"iETask		    ",0
      0  138e					      db	63,23,"iNTask		    ",0
      1  138e		       3f 17 69 4e*	      .byte.b	63,23,"iNTask		    ",0
      0  13a5					      db	64,23,"iArray		    ",0
      1  13a5		       40 17 69 41*	      .byte.b	64,23,"iArray		    ",0
      0  13bc					      db	65,23,"iTaskKill	    ",0
      1  13bc		       41 17 69 54*	      .byte.b	65,23,"iTaskKill	    ",0
      0  13d3					      db	66,23,"iTaskStat	    ",0
      1  13d3		       42 17 69 54*	      .byte.b	66,23,"iTaskStat	    ",0
      0  13ea					      db	67,23,"iHexOut 	    ",0
      1  13ea		       43 17 69 48*	      .byte.b	67,23,"iHexOut 	    ",0
      0  1401					      db	68,23,"iReadComplete	    ",0
      1  1401		       44 17 69 52*	      .byte.b	68,23,"iReadComplete	    ",0
      0  1418					      db	69,23,"iReadStart	    ",0
      1  1418		       45 17 69 52*	      .byte.b	69,23,"iReadStart	    ",0
      0  142f					      db	70,23,"iStartIO	    ",0
      1  142f		       46 17 69 53*	      .byte.b	70,23,"iStartIO	    ",0
      0  1446					      db	71,23,"iEndIO		    ",0
      1  1446		       47 17 69 45*	      .byte.b	71,23,"iEndIO		    ",0
      0  145d					      db	72,23,"iLogNot 	    ",0
      1  145d		       48 17 69 4c*	      .byte.b	72,23,"iLogNot 	    ",0
      0  1474					      db	73,23,"iLogOr		    ",0
      1  1474		       49 17 69 4c*	      .byte.b	73,23,"iLogOr		    ",0
      0  148b					      db	74,23,"iLogAnd 	    ",0
      1  148b		       4a 17 69 4c*	      .byte.b	74,23,"iLogAnd 	    ",0
      0  14a2					      db	75,23,"iLogXor 	    ",0
      1  14a2		       4b 17 69 4c*	      .byte.b	75,23,"iLogXor 	    ",0
      0  14b9					      db	76,23,"iWTASK		    ",0
      1  14b9		       4c 17 69 57*	      .byte.b	76,23,"iWTASK		    ",0
      0  14d0					      db	77,23,"iTASKPID	    ",0
      1  14d0		       4d 17 69 54*	      .byte.b	77,23,"iTASKPID	    ",0
      0  14e7					      db	78,23,"iTRACEPROG	    ",0
      1  14e7		       4e 17 69 54*	      .byte.b	78,23,"iTRACEPROG	    ",0
      0  14fe					      db	79,23,"idbgBasic	    ",0
      1  14fe		       4f 17 69 64*	      .byte.b	79,23,"idbgBasic	    ",0
      0  1515					      db	80,23,"iIPCS		    ",0
      1  1515		       50 17 69 49*	      .byte.b	80,23,"iIPCS		    ",0
      0  152c					      db	81,23,"iIPCR		    ",0
      1  152c		       51 17 69 49*	      .byte.b	81,23,"iIPCR		    ",0
      0  1543					      db	82,23,"iIPCC		    ",0
      1  1543		       52 17 69 49*	      .byte.b	82,23,"iIPCC		    ",0
      0  155a					      db	83,23,"iIPCIO		    ",0
      1  155a		       53 17 69 49*	      .byte.b	83,23,"iIPCIO		    ",0
      0  1571					      db	84,23,"iPushMathStack	    ",0
      1  1571		       54 17 69 50*	      .byte.b	84,23,"iPushMathStack	    ",0
      0  1588					      db	85,23,"iPopMathStack	    ",0
      1  1588		       55 17 69 50*	      .byte.b	85,23,"iPopMathStack	    ",0
      0  159f					      db	86,23,"iSaveMathStack	    ",0
      1  159f		       56 17 69 53*	      .byte.b	86,23,"iSaveMathStack	    ",0
      0  15b6					      db	87,23,"iRestoreMathStack   ",0
      1  15b6		       57 17 69 52*	      .byte.b	87,23,"iRestoreMathStack   ",0
      0  15cd					      db	88,23,"iIncParmCount	    ",0
      1  15cd		       58 17 69 49*	      .byte.b	88,23,"iIncParmCount	    ",0
      0  15e4					      db	89,23,"iTaskGetMathStack   ",0
      1  15e4		       59 17 69 54*	      .byte.b	89,23,"iTaskGetMathStack   ",0
      0  15fb					      db	90,23,"iTaskEnable	    ",0
      1  15fb		       5a 17 69 54*	      .byte.b	90,23,"iTaskEnable	    ",0
      0  1612					      db	91,23,"iTaskSuspend	    ",0
      1  1612		       5b 17 69 54*	      .byte.b	91,23,"iTaskSuspend	    ",0
      0  1629					      db	92,23,"iTaskPutMathPtr     ",0
      1  1629		       5c 17 69 54*	      .byte.b	92,23,"iTaskPutMathPtr     ",0
      0  1640					      db	93,23,"iTSTVT		    ",0
      1  1640		       5d 17 69 54*	      .byte.b	93,23,"iTSTVT		    ",0
      0  1657					      db	94,23,"iSetR2		    ",0
      1  1657		       5e 17 69 53*	      .byte.b	94,23,"iSetR2		    ",0
      0  166e					      db	95,23,"iStk2Tmp	    ",0
      1  166e		       5f 17 69 53*	      .byte.b	95,23,"iStk2Tmp	    ",0
      0  1685					      db	96,23,"iTmp2Stk	    ",0
      1  1685		       60 17 69 54*	      .byte.b	96,23,"iTmp2Stk	    ",0
      0  169c					      db	97,23,"iTSTBYTE	    ",0
      1  169c		       61 17 69 54*	      .byte.b	97,23,"iTSTBYTE	    ",0
      0  16b3					      db	98,23,"iINCVAR 	    ",0
      1  16b3		       62 17 69 49*	      .byte.b	98,23,"iINCVAR 	    ",0
      0  16ca					      db	99,23,"iDECVAR 	    ",0
      1  16ca		       63 17 69 44*	      .byte.b	99,23,"iDECVAR 	    ",0
      0  16e1					      db	100,23,"iSLICE 	     ",0
      1  16e1		       64 17 69 53*	      .byte.b	100,23,"iSLICE 	     ",0
      0  16f8					      db	101,23,"iTSTB		     ",0
      1  16f8		       65 17 69 54*	      .byte.b	101,23,"iTSTB		     ",0
      0  170f					      db	102,23,"iTSTW		     ",0
      1  170f		       66 17 69 54*	      .byte.b	102,23,"iTSTW		     ",0
      0  1726					      db	103,23,"iOnGoto	     ",0
      1  1726		       67 17 69 4f*	      .byte.b	103,23,"iOnGoto	     ",0
      0  173d					      db	104,23,"iTSTRELOP	     ",0
      1  173d		       68 17 69 54*	      .byte.b	104,23,"iTSTRELOP	     ",0
      0  1754					      db	105,23,"iRepeatLine	     ",0
      1  1754		       69 17 69 52*	      .byte.b	105,23,"iRepeatLine	     ",0
      0  176b					      db	106,23,"iTSTBRANCH	     ",0
      1  176b		       6a 17 69 54*	      .byte.b	106,23,"iTSTBRANCH	     ",0
      0  1782					      db	107,23,"iFastXfer	     ",0
      1  1782		       6b 17 69 46*	      .byte.b	107,23,"iFastXfer	     ",0
      0  1799					      db	108,23,"iSetTerminal	     ",0
      1  1799		       6c 17 69 53*	      .byte.b	108,23,"iSetTerminal	     ",0
      0  17b0					      db	109,23,"iINDB		     ",0
      1  17b0		       6d 17 69 49*	      .byte.b	109,23,"iINDB		     ",0
      0  17c7					      db	110,23,"iSetBlock	     ",0
      1  17c7		       6e 17 69 53*	      .byte.b	110,23,"iSetBlock	     ",0
      0  17de					      db	111,23,"iCopyBlock	     ",0
      1  17de		       6f 17 69 43*	      .byte.b	111,23,"iCopyBlock	     ",0
      0  17f5					      db	112,23,"iCmpBlock	     ",0
      1  17f5		       70 17 69 43*	      .byte.b	112,23,"iCmpBlock	     ",0
      0  180c					      db	113,23,"iShift 	     ",0
      1  180c		       71 17 69 53*	      .byte.b	113,23,"iShift 	     ",0
      0  1823					      db	114,23,"iTimer 	     ",0
      1  1823		       72 17 69 54*	      .byte.b	114,23,"iTimer 	     ",0
      0  183a					      db	115,23,"iJmpEnd	     ",0
      1  183a		       73 17 69 4a*	      .byte.b	115,23,"iJmpEnd	     ",0
      0  1851					      db	116,23,"iJmpStart	     ",0
      1  1851		       74 17 69 4a*	      .byte.b	116,23,"iJmpStart	     ",0
      0  1868					      db	117,23,"iBeginBlock	     ",0
      1  1868		       75 17 69 42*	      .byte.b	117,23,"iBeginBlock	     ",0
      0  187f					      db	118,23,"iIfTrue	     ",0
      1  187f		       76 17 69 49*	      .byte.b	118,23,"iIfTrue	     ",0
      0  1896					      db	119,23,"iIfFalse	     ",0
      1  1896		       77 17 69 49*	      .byte.b	119,23,"iIfFalse	     ",0
      0  18ad					      db	120,23,"iFasterXfer	     ",0
      1  18ad		       78 17 69 46*	      .byte.b	120,23,"iFasterXfer	     ",0
      0  18c4					      db	$FF,23,"0		     ",0
      1  18c4		       ff 17 30 20*	      .byte.b	$FF,23,"0		     ",0
    138  18db
    139  18db							; Search for the il instruction and print the correct text for it
    140  18db							; on entry a contains the ip instruction to print
    141  18db
    142 U3720					      seg.u	TBData
    143 U3720		       00 00	   R0TempIL   ds	2
    144 U3722		       00	   ILSTA      ds	1
    145 U3723
    146  18db					      Seg	Code
    147  18db
    148  18db		       8d 22 37    PrintILText sta	ILSTA
    149  18de		       5a		      phy
    150  18df		       da		      phx
    151  18e0		       a5 52		      lda	R0
    152  18e2		       8d 20 37 	      sta	R0TempIL
    153  18e5		       a5 53		      lda	R0+1
    154  18e7		       8d 20 37 	      sta	R0TempIL
    155  18ea		       a9 e5		      lda	#ILTEXTTABLE&$FF
    156  18ec		       85 52		      sta	R0
    157  18ee		       a9 0d		      LDA	#ILTEXTTABLE>>8
    158  18f0		       85 53		      sta	R0+1
    159  18f2							;Loop Here for each entry
    160  18f2		       a0 00	   PrintILLoop ldy	#0
    161  18f4		       b1 52		      lda	(R0),y
    162  18f6		       c9 ff		      cmp	#$FF
    163  18f8		       f0 2a		      beq	PrintILNotFound
    164  18fa		       cd 22 37 	      cmp	ILSTA
    165  18fd		       f0 11		      beq	PrintILFound
    166  18ff		       c8		      iny
    167  1900		       b1 52		      lda	(R0),y
    168  1902		       18		      clc
    169  1903		       65 52		      adc	R0
    170  1905		       85 52		      sta	R0
    171  1907		       a9 00		      lda	#0
    172  1909		       65 53		      adc	R0+1
    173  190b		       85 53		      sta	R0+1
    174  190d		       4c f2 18 	      jmp	PrintILLoop
    175  1910							; The text was discovered
    176  1910		       c8	   PrintILFound iny		; point to length of instruction
    177  1911		       c8		      iny		; Point to start of text
    178  1912		       98		      tya
    179  1913		       18		      clc
    180  1914		       65 52		      adc	R0
    181  1916		       a8		      tay		; Low order byte of address
    182  1917		       a9 00		      lda	#0
    183  1919		       65 53		      adc	R0+1
    184  191b		       aa		      tax		; High order byte of address
    185  191c		       a9 00		      lda	#0	; Termination byte of string
    186  191e		       20 be 21 	      jsr	PrtStr	; print the string
    187  1921		       4c 2a 19 	      jmp	PrintILDone
    188  1924
    189  1924		       ad 22 37    PrintILNotFound lda	ILSTA
    190  1927		       20 63 21 	      jsr	HexToOut
    191  192a
    192  192a		       ad 20 37    PrintILDone lda	R0TempIL
    193  192d		       85 52		      sta	R0
    194  192f		       ad 21 37 	      lda	R0TempIL+1
    195  1932		       85 52		      sta	R0
    196  1934		       fa		      plx
    197  1935		       7a		      ply
    198  1936		       60		      rts
    199  1937					      endif
------- FILE mytb.asm
   2465  1937					      endif
------- FILE time.asm LEVEL 2 PASS 6
      0  1937					      include	"time.asm"
      1  1937							;This is the timer management functions
      2  1937							; a = 0 turn off irq, stop timer
      3  1937							; a = 1 turn on irq, set parm contained in x
      4  1937							; a = 4 get low value
      5  1937							; a = 2 get high value
      6  1937
      7  1937		       e0 10	   timerinterface equ	$E010
      8  1937		       00 1e	   cTimerControl equ	$1E
      9  1937		       00 00	   cTimerStop equ	0
     10  1937		       00 01	   cTimerStart equ	1
     11  1937		       00 02	   cTimerLow  equ	2
     12  1937		       00 04	   cTimerHigh equ	4
     13  1937
     14  1937							; returns	$82 ack    dec(130)
     15  1937							;		$83 Failed dec(131)
     16  1937
     17  1937							; il interface to the timer
     18  1937
     19  1937				   iTimer
     20  1937		       20 5b 2d 	      jsr	popR0
     21  193a		       a6 52		      ldx	R0	; Set time parameter
     22  193c		       20 5b 2d 	      jsr	popR0
     23  193f		       a5 52		      lda	R0	; control parameter 0-4
     24  1941		       20 4b 19 	      jsr	iTimerif
     25  1944		       85 52		      sta	R0
     26  1946		       86 53		      stx	R0+1
     27  1948		       4c 06 07 	      jmp	pushR0nextIl
     28  194b
     29  194b							; Actual system interface to the timer
     30  194b							; x is value 9 = 1 second, 1-5 = value * 10ms 6 = 100ms, 7=250ms, 8=500ms, 0 = stop timer
     31  194b							; a is 0,1,2,4
     32  194b				   iTimerif
     33  194b
     34  194b		       c9 02		      cmp	#cTimerLow	; Do they want the low byte
     35  194d		       b0 25		      bcs	iTimerValue	; Just get the value we need
     36  194f		       78		      sei		; Disable the interupts
     37  1950		       48		      pha		; save the command
     38  1951		       a9 1e		      lda	#cTimerControl	; Load the timer control command
     39  1953		       8d 10 e0 	      sta	timerinterface	; Write it to the timer port
     40  1956		       8a		      txa		; get value to write, if cmd = 0 stop then x is init to zero
     41  1957		       8d 10 e0 	      sta	timerinterface	; write it to the port the timeout value
     42  195a		       68		      pla		; Get the actual command back
     43  195b		       c9 00		      cmp	#cTimerStop	; if the command was stop timer just get out
     44  195d		       f0 0f		      beq	iTimerAck	; if not then get ack/nak and continue
     45  195f
     46  195f		       a9 00		      lda	#0	; Clear the counter
     47  1961		       8d e8 43 	      sta	timercounter
     48  1964		       8d e9 43 	      sta	timercounter+1
     49  1967		       8d ea 43 	      sta	timercounter+2
     50  196a		       8d eb 43 	      sta	timercounter+3
     51  196d		       58		      cli		; enable the interupts, this is start/restart timer
     52  196e
     53  196e				   iTimerAck
     54  196e		       ad 10 e0 	      lda	timerinterface	; get the ack nak
     55  1971		       a2 00		      ldx	#0	; the ack value is single byte so pad with x
     56  1973		       60		      rts		; Get out of here
     57  1974
     58  1974				   iTimerValue		; get the value from the offsets provided
     59  1974		       08		      php		; Save the flags so we can restore irq setting later
     60  1975		       78		      sei		; turn off the interupts
     61  1976		       aa		      tax		; the control is also the value
     62  1977		       bd e6 43 	      lda	[timercounter-2],x	; get the high byte of value
     63  197a		       48		      pha		; Save the value for x set
     64  197b		       bd e7 43 	      lda	[timercounter-1],x	; get the low part of value
     65  197e		       aa		      tax
     66  197f		       68		      pla
     67  1980		       28		      plp		; restore the interupt flag if it was enabled
     68  1981		       60		      rts
     69  1982
     70  1982
     71  1982
------- FILE mytb.asm
------- FILE io.asm LEVEL 2 PASS 6
      0  1982					      include	"io.asm"
      1  1982							; This is the io blocks and function for reading and writing
      2  1982							; to devices attached to this computer.
      3  1982							; This supports devices mapped at e000 thru efff in slot sizes of 16 byte
      4  1982							;
      5  1982							;=====================================================================
      6  1982							; Device configuration equates
      7  1982		       00 00	   ConsoleID  equ	0
      8  1982		       00 08	   SerialID   equ	[1<<3]
      9  1982		       00 10	   ClockID    equ	[2<<3]
     10  1982		       00 18	   TimerID    equ	[3<<3]
     11  1982		       00 20	   DiskID     equ	[4<<3]
     12  1982
     13  1982		       00 0a	   IO_MAX_DEVICES equ	10
     14  1982		       00 06	   IO_VECT_LEN equ	6
     15  1982
     16  1982		       00 01	   IO_DEVICE_CLOSED equ	1	; The device is not open
     17  1982		       00 02	   IO_DEVICE_INVALID equ	2	; The Device number provided is invalid
     18  1982
     19  1982							;========================================================================================
     20  1982							; Uninitialized data segment
     21 U3723					      seg.u	TBData
     22 U3723
     23 U3723		       00 00	   BInVec     ds	2	; This is used by fuction to vector to current input rtn
     24 U3725		       00 00	   BOutVec    ds	2	; This is used by functions to vector to the current output rtn
     25 U3727		       00 00	   BStatVec   ds	2	; This is used by inteface to read write status/config information
      0 U3729				   BActiveDevice db	1	; the index of the current device block
      1 U3729		       01		      .byte.b	1
      0 U372a				   BActiveDriver db	1	; Index of the device driver block
      1 U372a		       01		      .byte.b	1
     28 U372b
     29 U372b							;============================================================================================
     30  1982					      Seg	Code
     31  1982							; IRQ BASIC Code Service RTN Support
      0  1982				   SaveIrqReg db	0	; Store current setting
      1  1982		       00		      .byte.b	0
      0  1983				   IRQStatus  db	0	; 1 = enabled, 0 = dissabled
      1  1983		       00		      .byte.b	0
      0  1984				   IRQPending db	0	; Irq recieved, Called at next Basic Line
      1  1984		       00		      .byte.b	0
      0  1985				   IRQEntry   db	0,0	; Basic code offset of IRQ Handler
      1  1985		       00 00		      .byte.b	0,0
     36  1987
     37  1987							;============================================================================================
     38  1987							; Define the device interface blocks
     39  1987				   DeviceDriverBlocks
     40  1987				   ConsoleDevice		; Block 0
      0  1987					      dw	ConsoleID	; device idenifier Console
      1  1987		       00 00		      .word.w	ConsoleID
      0  1989					      dw	cin	; read function vector
      1  1989		       09 f0		      .word.w	cin
      0  198b					      dw	cout	; write function vector
      1  198b		       0c f0		      .word.w	cout
      0  198d					      dw	cstatus	; Get current Status info/Write config
      1  198d		       0f f0		      .word.w	cstatus
     45  198f
     46  198f				   SerialDevice 		; Block 1
      0  198f					      dw	SerialID	; device idenifier Serial
      1  198f		       08 00		      .word.w	SerialID
      0  1991					      dw	SerialIn	; read function vector
      1  1991		       79 1a		      .word.w	SerialIn
      0  1993					      dw	SerialOut	; write function vector
      1  1993		       79 1a		      .word.w	SerialOut
      0  1995					      dw	SerialStatus	; Get current Status info/Write config
      1  1995		       79 1a		      .word.w	SerialStatus
     51  1997
     52  1997				   ClockDevice		; Block 2
      0  1997					      dw	ClockID	; Day/date Clock
      1  1997		       10 00		      .word.w	ClockID
      0  1999					      dw	ClockRead	; Read the date from clock
      1  1999		       7a 1a		      .word.w	ClockRead
      0  199b					      dw	ClockWrite	; Set the date/time of clock
      1  199b		       7a 1a		      .word.w	ClockWrite
      0  199d					      dw	#0	; No Status/Config Function
      1  199d		       00 00		      .word.w	#0
     57  199f
     58  199f				   TimerDevice		; Block 3
      0  199f					      dw	TimerID	; Timer/interrupt interface
      1  199f		       18 00		      .word.w	TimerID
      0  19a1					      dw	TimerStart	; Start the timer
      1  19a1		       7b 1a		      .word.w	TimerStart
      0  19a3					      dw	TimerStop	; Stop the timer
      1  19a3		       7b 1a		      .word.w	TimerStop
      0  19a5					      dw	TimerStatus	; Config/read status
      1  19a5		       7b 1a		      .word.w	TimerStatus
     63  19a7
      0  19a7				   DiskDevice dw	DiskID	; Block 4
      1  19a7		       20 00		      .word.w	DiskID
      0  19a9					      dw	DIN	; Disk Input / read function
      1  19a9		       fd 31		      .word.w	DIN
      0  19ab					      dw	DOUT	; Disk Output / write function
      1  19ab		       e4 31		      .word.w	DOUT
      0  19ad					      dw	DSTAT	; Disk Status/open/close etc information
      1  19ad		       16 32		      .word.w	DSTAT
     68  19af							;
     69  19af							;======================================================================
     70  19af							; Define the Device/Slot,driver control blocks
     71  19af							; entry format: ControlWord,DeviceDriver,PortAddress,StatusWord
     72  19af							; Fixed at 10 devices memory usage is getting pretty big!!!!!!
     73  19af							; Control word : bit 0 = active 1, Free 0
     74  19af
     75  19af				   DeviceIoBlocks
      0  19af					      dw	1, ConsoleID, $E000, 0	; Console device is 0 file
      1  19af		       01 00 00 00*	      .word.w	1, ConsoleID, $E000, 0
      0  19b7					      dw	1, ClockID, $E010, 0	; Port for the day/time clock
      1  19b7		       01 00 10 00*	      .word.w	1, ClockID, $E010, 0
      0  19bf					      dw	1, TimerID, $E010, 0	; Timer interface
      1  19bf		       01 00 18 00*	      .word.w	1, TimerID, $E010, 0
      0  19c7					      dw	1, DiskID, $E010, 0	; Disk Driver interface
      1  19c7		       01 00 20 00*	      .word.w	1, DiskID, $E010, 0
      0  19cf					      dw	1, SerialID, $E020, 0	; Second terminal(default Basic debug)
      1  19cf		       01 00 08 00*	      .word.w	1, SerialID, $E020, 0
      0  19d7					      dw	0, SerialID, $E030, 0	; Unused slot
      1  19d7		       00 00 08 00*	      .word.w	0, SerialID, $E030, 0
      0  19df					      dw	0, SerialID, $E040, 0	; Unused slot
      1  19df		       00 00 08 00*	      .word.w	0, SerialID, $E040, 0
      0  19e7					      dw	0, SerialID, $E050, 0	; Unused slot
      1  19e7		       00 00 08 00*	      .word.w	0, SerialID, $E050, 0
      0  19ef					      dw	0, SerialID, $E060, 0	; Unused slot
      1  19ef		       00 00 08 00*	      .word.w	0, SerialID, $E060, 0
      0  19f7					      dw	0, SerialID, $E070, 0	; Unused slot
      1  19f7		       00 00 08 00*	      .word.w	0, SerialID, $E070, 0
     86  19ff							;
     87  19ff							;======================================================================
     88  19ff							;
     89  19ff					      Seg	Code
     90  19ff							;======================================================================
     91  19ff							; This is the Basic IRQ handler, works with task manager, assumes timer interupt
     92  19ff							;
     93  19ff		       48	   ServiceIrq pha
     94  1a00		       da		      phx
     95  1a01		       a2 00		      ldx	#0
     96  1a03				   ServiceLoop
     97  1a03		       fe e8 43 	      inc	timercounter,x
     98  1a06		       d0 05		      bne	ServiceCont
     99  1a08		       e8		      inx
    100  1a09		       e0 04		      cpx	#4
    101  1a0b		       d0 f6		      bne	ServiceLoop
    102  1a0d				   ServiceCont
    103  1a0d		       ad 83 19 	      lda	IRQStatus
    104  1a10		       f0 0a		      beq	RetIrq
    105  1a12		       ad 84 19 	      lda	IRQPending
    106  1a15		       d0 05		      bne	RetIrq
    107  1a17		       a9 01		      lda	#1
    108  1a19		       8d 84 19 	      sta	IRQPending
    109  1a1c				   RetIrq
    110  1a1c		       fa		      plx
    111  1a1d		       68		      pla
    112  1a1e		       40		      rti
    113  1a1f							;======================================================================
    114  1a1f							; Jump to the output/input function in BOutVec/BInVec
    115  1a1f							;
    116  1a1f		       6c 25 37    VOUTCH     jmp	(BOutVec)	; Primary block io vectors
    117  1a22		       6c 23 37    VGETCH     jmp	(BInVec)
    118  1a25		       6c 27 37    VSTAT      jmp	(BStatVec)
    119  1a28							;
    120  1a28							;======================================================================
    121  1a28							; IO Service functions
    122  1a28							; Validate the device index and set x to offest in table
    123  1a28							; does not return to ioInterface if invalid, returns to original caller
    124  1a28							; should be called immediatly after entering the ioInterface call
    125  1a28				   ioValidateDevice
    126  1a28		       e0 0a		      cpx	#IO_MAX_DEVICES
    127  1a2a		       90 04		      bcc	ioValidIndex
    128  1a2c		       a2 02		      ldx	#IO_DEVICE_INVALID
    129  1a2e		       b0 13		      bcs	ioInvalidDevice
    130  1a30				   ioValidIndex
    131  1a30		       8a		      txa
    132  1a31		       0a		      asl		; Multiply by 8
    133  1a32		       0a		      asl
    134  1a33		       0a		      asl
    135  1a34		       aa		      tax		; Point to actual offset in the table
    136  1a35		       ec 29 37 	      cpx	BActiveDevice	; is it already active ?
    137  1a38		       f0 0d		      beq	ioValidDevice	; Shortcut if this is the active device already
    138  1a3a		       a9 01		      lda	#1	; Active flag
    139  1a3c		       3d af 19 	      and	DeviceIoBlocks,x	; Check if the device is active
    140  1a3f		       d0 06		      bne	ioValidDevice	; The device is active and valid index
    141  1a41		       a2 01		      ldx	#IO_DEVICE_CLOSED
    142  1a43
    143  1a43				   ioInvalidDevice
    144  1a43		       68		      pla		; Remove return address of IO interface
    145  1a44		       68		      pla
    146  1a45		       38		      sec		; ensure that carry is set
    147  1a46		       60		      rts
    148  1a47
    149  1a47				   ioValidDevice
    150  1a47		       18		      clc
    151  1a48		       60		      rts
    152  1a49							;
    153  1a49							;===================================================================================
    154  1a49							; Set the io device jmp vectors
    155  1a49							; input x contains the vector to the active Device IO Block
    156  1a49							; output a, x undefined y unchanged
    157  1a49				   ioSetDeviceVectors
    158  1a49		       ec 29 37 	      cpx	BActiveDevice	; Check if already set
    159  1a4c		       f0 19		      beq	ioSetDevExit	; if already set then do nothing
    160  1a4e
    161  1a4e		       8e 29 37 	      stx	BActiveDevice	; set the active device vector
    162  1a51		       5a		      phy
    163  1a52
    164  1a52		       bc b1 19 	      ldy	DeviceIoBlocks+2,x	; Get the device driver index
    165  1a55		       8c 2a 37 	      sty	BActiveDriver	; Pointer to active Device driver
    166  1a58		       a2 00		      ldx	#0	; Transfer the 6 pointers to the Vectors
    167  1a5a				   ioSetDevLoop
    168  1a5a		       b9 89 19 	      lda	DeviceDriverBlocks+2,y
    169  1a5d		       9d 23 37 	      sta	BInVec,x
    170  1a60		       e8		      inx
    171  1a61		       c8		      iny
    172  1a62		       e0 06		      cpx	#IO_VECT_LEN	; Transfer the vector length to copy
    173  1a64		       d0 f4		      bne	ioSetDevLoop
    174  1a66
    175  1a66		       7a		      ply
    176  1a67				   ioSetDevExit
    177  1a67		       60		      rts
    178  1a68							;
    179  1a68							;======================================================================
    180  1a68							; Generic call interface for devices
    181  1a68							; input x = DeviceIoBlockIndex
    182  1a68							; Carry set if error, x contains the error code
    183  1a68							; all other parameters are dependant upon the actual device interface
    184  1a68							;
    185  1a68							; ioPutCH  a contains the character to send
    186  1a68		       20 28 1a    ioPutCH    jsr	ioValidateDevice
    187  1a6b		       48		      pha
    188  1a6c		       20 49 1a 	      jsr	ioSetDeviceVectors
    189  1a6f		       68		      pla
    190  1a70		       20 1f 1a 	      jsr	VOUTCH
    191  1a73		       18		      clc
    192  1a74		       60		      rts
    193  1a75
    194  1a75							; io Getch returns the character read from device
    195  1a75		       20 28 1a    ioGetCH    jsr	ioValidateDevice
    196  1a78
    197  1a78		       60		      rts
    198  1a79							;
    199  1a79							;======================================================================
    200  1a79							;TTY interface functions,
    201  1a79							;	a contains the character to send
    202  1a79							;	x contains the Device ID (equals index into io blocks)	of the io block to used
    203  1a79							;
    204  1a79				   SerialIn
    205  1a79
    206  1a79				   SerialOut
    207  1a79
    208  1a79				   SerialStatus
    209  1a79		       60		      rts
    210  1a7a							;
    211  1a7a							;======================================================================
    212  1a7a							; Date/Time clock interface
    213  1a7a				   ClockRead
    214  1a7a
    215  1a7a				   ClockWrite
    216  1a7a		       60		      rts
    217  1a7b							;
    218  1a7b							;======================================================================
    219  1a7b							;
    220  1a7b				   TimerStart
    221  1a7b
    222  1a7b				   TimerStop
    223  1a7b
    224  1a7b				   TimerStatus
    225  1a7b		       60		      rts
    226  1a7c
------- FILE mytb.asm
------- FILE tokenizer.asm LEVEL 2 PASS 6
      0  1a7c					      include	"tokenizer.asm"
      1  1a7c					      seg	Code
      2  1a7c		       00 00	   DEBUGPARSER equ	FALSE	; Print debugging information
      3  1a7c
      4  1a7c							; Define the types of tokens found, and identifiers
      5  1a7c		       00 7f	   KeywordsMax equ	$7F	; Allow to be range  1 to 127	key words, high order bit must be 0 for it to be a key word
      6  1a7c		       00 80	   tVa	      equ	$80	; Variable A = 1, .... Z = 26	 ^ = 27
      7  1a7c		       00 81	   tVb	      equ	$81	; Variables 128 - 157	$80-$9D
      8  1a7c		       00 99	   tVz	      equ	tVa+25	; Value of the last variable
      9  1a7c
     10  1a7c		       00 9b	   tVhat      equ	$9B	; Variable ^
     11  1a7c		       00 9c	   tVhash     equ	$9C	; Variable #
     12  1a7c		       00 9d	   tVat       equ	$9D	; Variable @ = 0
     13  1a7c
     14  1a7c							; Base variable type supported by This basic
     15  1a7c							; Unsigned types always have the 0 bit set to 1
     16  1a7c		       00 a0	   tString    equ	$A0	; Strings all start with this byte and end with  byte value 0 strings can be accessed with array slicing
     17  1a7c		       00 a2	   tByte      equ	$A2	; Signed Byte value
     18  1a7c		       00 a4	   tInteger   equ	$A4	; all tokenized integers start with 251 as first byte 16 bit signed number
     19  1a7c		       00 a6	   tLong      equ	$A6	; Signed 32 bit integer
     20  1a7c
     21  1a7c		       00 a1	   tArray     equ	$A1	; Identifies Array Type, the byte following defines the length of each element
     22  1a7c							; Arrays of string are arrays of pointers 2 bytes each
     23  1a7c		       00 a3	   tPointer   equ	$A3	; Pointer  unsigned 16 bit
     24  1a7c		       00 a5	   tIndirect  equ	$A5	; Points to an address that points to the data 16 bits
     25  1a7c		       00 a7	   tuByte     equ	$A7	; Unsigned byte value 8 bit unsigned value
     26  1a7c		       00 a9	   tUint      equ	$A9	; unsigned integer type 16 bit
     27  1a7c		       00 ab	   tUlong     equ	$AB	; Unsigned 32 bit integer
     28  1a7c
     29  1a7c		       3c 3e	   Operators  BYTE.b	"<>"
     30  1a7e		       3c 3d		      BYTE.b	"<="
     31  1a80		       3e 3d		      BYTE.b	">="
     32  1a82		       3c 3c		      Byte.b	"<<"
     33  1a84		       3e 3e		      Byte.b	">>"
     34  1a86		       3c 00		      BYTE.b	"<",0
     35  1a88		       3d 00		      BYTE.b	"=",0
     36  1a8a		       3e 00		      BYTE.b	">",0
     37  1a8c		       2b 2b		      Byte.b	"++"
     38  1a8e		       2b 00		      BYTE.b	"+",0
     39  1a90		       2d 2d		      Byte.b	"--"
     40  1a92		       2d 00		      BYTE.b	"-",0
     41  1a94		       2f 00		      BYTE.b	"/",0
     42  1a96		       25 00		      BYTE.b	"%",0
     43  1a98		       2a 00		      BYTE.b	"*",0
     44  1a9a		       28 00		      BYTE.b	"(",0
     45  1a9c		       29 00		      BYTE.b	")",0
     46  1a9e		       2c 00		      BYTE.b	",",0
     47  1aa0		       3b 00		      BYTE.b	";",0
     48  1aa2		       5b 00		      BYTE.b	"[",0
     49  1aa4		       5d 00		      BYTE.b	"]",0
     50  1aa6		       3a 00		      BYTE.b	":",0
     51  1aa8		       24 00		      BYTE.b	"$",0
     52  1aaa		       21 00		      BYTE.b	"!",0
     53  1aac		       3f 00		      BYTE.b	"?",0
     54  1aae		       2e 00		      BYTE.b	".",0
     55  1ab0		       26 00		      BYTE.b	"&",0
     56  1ab2		       27 00		      Byte.b	"'",0
     57  1ab4		       7c 00		      Byte.b	"|",0
     58  1ab6		       7e 00		      Byte.b	"~",0
     59  1ab8		       00 00		      BYTE.b	0,0
     60  1aba
     61  1aba		       f5 f3 f6 2e*OperValues BYTE.b	oNotEqual,oLessEqual,oGreaterEqual,oSHL,oSHR,oLess,oEqual,oGreater
     62  1ac2		       02 ea 03 eb*	      BYTE.b	oINC, oPlus, oDEC, oMinus, oDivide, oModulo, oMultiply
     63  1ac9		       e0 e1 e2 e3*	      BYTE.b	oLeftBracket, oRightBracket, oComma, oSemiColon, oLeftSQBracket, oRightSQBracket
     64  1acf		       e6 e7 e8 0b*	      BYTE.b	oColon, oDollar, oBang, oQuestion, oPeriod, oAmphistan, oQuote, oBar,oTilde
     65  1ad8
     66  1ad8		       00 0b	   oQuestion  equ	kPrint
     67  1ad8							;    2 is =
     68  1ad8							;    1 is <
     69  1ad8							;    3 is <=
     70  1ad8							;    5 is <>
     71  1ad8							;    4 is >
     72  1ad8							;    6 is >=
     73  1ad8		       00 f1	   oLess      equ	$F1
     74  1ad8		       00 f2	   oEqual     equ	$F2
     75  1ad8		       00 f3	   oLessEqual equ	$F3
     76  1ad8		       00 f4	   oGreater   equ	$F4
     77  1ad8		       00 f5	   oNotEqual  equ	$F5
     78  1ad8		       00 f6	   oGreaterEqual equ	$F6
     79  1ad8
     80  1ad8		       00 e0	   oLeftBracket equ	$E0
     81  1ad8		       00 e1	   oRightBracket equ	$E1
     82  1ad8		       00 e2	   oComma     equ	$E2
     83  1ad8		       00 e3	   oSemiColon equ	$E3
     84  1ad8		       00 e4	   oLeftSQBracket equ	$E4
     85  1ad8		       00 e5	   oRightSQBracket equ	$E5
     86  1ad8		       00 e6	   oColon     equ	$E6
     87  1ad8		       00 e7	   oDollar    equ	$E7
     88  1ad8		       00 e8	   oBang      equ	$E8
     89  1ad8		       00 e9	   oPeriod    equ	$E9
     90  1ad8
     91  1ad8		       00 ea	   oPlus      equ	$EA
     92  1ad8		       00 eb	   oMinus     equ	$EB
     93  1ad8		       00 ec	   oDivide    equ	$EC
     94  1ad8		       00 ed	   oModulo    equ	$ED
     95  1ad8		       00 ee	   oMultiply  equ	$EE
     96  1ad8
     97  1ad8		       00 ed	   oPercent   equ	oModulo
     98  1ad8		       00 2c	   oAmphistan equ	kAnd
     99  1ad8		       00 2a	   oBar       equ	kOr
    100  1ad8		       00 0a	   oQuote     equ	kRem
    101  1ad8		       00 2b	   oTilde     equ	kXor
    102  1ad8		       00 2d	   oSHR       equ	kShr
    103  1ad8		       00 2e	   oSHL       equ	kShl
    104  1ad8		       00 02	   oINC       equ	kInc
    105  1ad8		       00 03	   oDEC       equ	kDec
    106  1ad8
    107  1ad8		       00 f0	   tOperatorX equ	$F0	;+ operator Value  ; stores the value used to do the relational operator compare
    108  1ad8
    109  1ad8		       00 ff	   tError     equ	$FF	; Error should never happen
    110  1ad8							;============================================================================================
    111  1ad8							; Keyword and seperator values
    112  1ad8				   '
    113  1ad8		       00 01	   kBeginKey  equ	kLet
    114  1ad8							;
    115  1ad8		       00 01	   kLet       equ	1
    116  1ad8		       00 02	   kInc       equ	kLet+1
    117  1ad8		       00 03	   kDec       equ	kInc+1
    118  1ad8		       00 04	   kIreturn   equ	kDec+1
    119  1ad8		       00 05	   kIf	      equ	kIreturn+1
    120  1ad8		       00 06	   kThen      equ	kIf+1
    121  1ad8		       00 07	   kGoto      equ	kThen+1
    122  1ad8		       00 08	   kGosub     equ	kGoto+1
    123  1ad8		       00 09	   kReturn    equ	kGosub+1
    124  1ad8		       00 0a	   kRem       equ	kReturn+1
    125  1ad8		       00 0b	   kPrint     equ	kRem+1
    126  1ad8		       00 0c	   kTaske     equ	kPrint+1
    127  1ad8		       00 0d	   kTaskn     equ	kTaske+1
    128  1ad8		       00 0e	   kTaskw     equ	kTaskn+1
    129  1ad8		       00 0f	   kPoke      equ	kTaskw+1
    130  1ad8		       00 10	   kPutch     equ	kPoke+1
    131  1ad8		       00 11	   kCls       equ	kPutch+1
    132  1ad8		       00 12	   kInput     equ	kCls+1
    133  1ad8		       00 13	   kEnd       equ	kInput+1
    134  1ad8		       00 14	   kIrq       equ	kEnd+1
    135  1ad8		       00 15	   kKill      equ	kIrq+1
    136  1ad8		       00 16	   kList      equ	kKill+1
    137  1ad8		       00 17	   kRun       equ	kList+1
    138  1ad8		       00 18	   kNew       equ	kRun+1
    139  1ad8		       00 19	   kSlice     equ	kNew+1
    140  1ad8		       00 1a	   kTrace     equ	kSlice+1
    141  1ad8		       00 1b	   kExit      equ	kTrace+1
    142  1ad8		       00 1c	   kSave      equ	kExit+1
    143  1ad8		       00 1d	   kLoad      equ	kSave+1
    144  1ad8		       00 1e	   kErase     equ	kLoad+1
    145  1ad8		       00 1f	   kDir       equ	kErase+1
    146  1ad8		       00 20	   kSetTerm   equ	kDir+1
    147  1ad8		       00 21	   kSetMemB   equ	kSetTerm+1
    148  1ad8		       00 22	   kSetMemW   equ	kSetMemB+1
    149  1ad8		       00 23	   kCopyMem   equ	kSetMemW+1
    150  1ad8		       00 24	   kWhile     equ	kCopyMem+1
    151  1ad8		       00 25	   kWend      equ	kWhile+1
    152  1ad8		       00 26	   kFor       equ	kWend+1
    153  1ad8		       00 27	   kNext      equ	kFor+1
    154  1ad8		       00 28	   kStep      equ	kNext+1
    155  1ad8							;
    156  1ad8							; End of actual key words
    157  1ad8							;
    158  1ad8		       00 27	   kKeyCount  equ	kStep-kBeginKey
    159  1ad8							;
    160  1ad8							; Logical operators
    161  1ad8							;
    162  1ad8		       00 29	   kNot       equ	kStep+1
    163  1ad8		       00 2a	   kOr	      equ	kNot+1
    164  1ad8		       00 2b	   kXor       equ	kOr+1
    165  1ad8		       00 2c	   kAnd       equ	kXor+1
    166  1ad8							;
    167  1ad8							; Shift operators
    168  1ad8							;
    169  1ad8		       00 2d	   kShr       equ	kAnd+1
    170  1ad8		       00 2e	   kShl       equ	kShr+1
    171  1ad8
    172  1ad8							; numeric functions
    173  1ad8							;
    174  1ad8		       00 2f	   kBeginFunc equ	kTrue
    175  1ad8							;
    176  1ad8							; Truth operators
    177  1ad8							;
    178  1ad8		       00 2f	   kTrue      equ	kShl+1
    179  1ad8		       00 30	   kFalse     equ	kTrue+1
    180  1ad8							; Functions
    181  1ad8		       00 31	   kFree      equ	kFalse+1
    182  1ad8		       00 32	   kGetch     equ	kFree+1
    183  1ad8		       00 33	   kPeek      equ	kGetch+1
    184  1ad8		       00 34	   kTask      equ	kPeek+1
    185  1ad8		       00 35	   kIpcc      equ	kTask+1
    186  1ad8		       00 36	   kIpcs      equ	kIpcc+1
    187  1ad8		       00 37	   kIpcr      equ	kIpcs+1
    188  1ad8		       00 38	   kRnd       equ	kIpcr+1
    189  1ad8		       00 39	   kStat      equ	kRnd+1
    190  1ad8		       00 3a	   kAbs       equ	kStat+1
    191  1ad8		       00 3b	   kCall      equ	kAbs+1
    192  1ad8		       00 3c	   kGofn      equ	kCall+1
    193  1ad8		       00 3d	   kPid       equ	kGofn+1
    194  1ad8		       00 3e	   kAddr      equ	kPid+1
    195  1ad8		       00 3f	   kCmpMem    equ	kAddr+1
    196  1ad8		       00 40	   kTimer     equ	kCmpMem+1
    197  1ad8							;
    198  1ad8		       00 12	   kFuncCount equ	((kTimer - kBeginFunc) + 1)
    199  1ad8
    200  1ad8							;
    201  1ad8							; Keyword table contains 54 keywords
    202  1ad8				   KeyWordTable
      0  1ad8					      db	kLet,"leT"	; 1, we only have 0 at end of program or line
      1  1ad8		       01 6c 65 54	      .byte.b	kLet,"leT"
      0  1adc					      db	kInc,"inC"
      1  1adc		       02 69 6e 43	      .byte.b	kInc,"inC"
      0  1ae0					      db	kDec,"deC"
      1  1ae0		       03 64 65 43	      .byte.b	kDec,"deC"
      0  1ae4					      db	kIreturn,"ireturN"
      1  1ae4		       04 69 72 65*	      .byte.b	kIreturn,"ireturN"
      0  1aec					      db	kIf,"iF"
      1  1aec		       05 69 46 	      .byte.b	kIf,"iF"
      0  1aef					      db	kThen,"theN"
      1  1aef		       06 74 68 65*	      .byte.b	kThen,"theN"
      0  1af4					      db	kGoto,"gotO"
      1  1af4		       07 67 6f 74*	      .byte.b	kGoto,"gotO"
      0  1af9					      db	kGosub,"gosuB"
      1  1af9		       08 67 6f 73*	      .byte.b	kGosub,"gosuB"
      0  1aff					      db	kReturn,"returN"
      1  1aff		       09 72 65 74*	      .byte.b	kReturn,"returN"
      0  1b06					      db	kRem,"reM"
      1  1b06		       0a 72 65 4d	      .byte.b	kRem,"reM"
      0  1b0a					      db	kPrint,"prinT"
      1  1b0a		       0b 70 72 69*	      .byte.b	kPrint,"prinT"
      0  1b10					      db	kTaske,"taskE"
      1  1b10		       0c 74 61 73*	      .byte.b	kTaske,"taskE"
      0  1b16					      db	kTaskn,"taskN"
      1  1b16		       0d 74 61 73*	      .byte.b	kTaskn,"taskN"
      0  1b1c					      db	kTaskw,"taskW"
      1  1b1c		       0e 74 61 73*	      .byte.b	kTaskw,"taskW"
      0  1b22					      db	kPoke,"pokE"
      1  1b22		       0f 70 6f 6b*	      .byte.b	kPoke,"pokE"
      0  1b27					      db	kPutch,"putcH"
      1  1b27		       10 70 75 74*	      .byte.b	kPutch,"putcH"
      0  1b2d					      db	kCls,"clS"
      1  1b2d		       11 63 6c 53	      .byte.b	kCls,"clS"
      0  1b31					      db	kInput,"inpuT"
      1  1b31		       12 69 6e 70*	      .byte.b	kInput,"inpuT"
      0  1b37					      db	kEnd,"enD"
      1  1b37		       13 65 6e 44	      .byte.b	kEnd,"enD"
      0  1b3b					      db	kIrq,"irQ"
      1  1b3b		       14 69 72 51	      .byte.b	kIrq,"irQ"
      0  1b3f					      db	kKill,"kilL"
      1  1b3f		       15 6b 69 6c*	      .byte.b	kKill,"kilL"
      0  1b44					      db	kList,"lisT"
      1  1b44		       16 6c 69 73*	      .byte.b	kList,"lisT"
      0  1b49					      db	kRun,"ruN"
      1  1b49		       17 72 75 4e	      .byte.b	kRun,"ruN"
      0  1b4d					      db	kNew,"neW"
      1  1b4d		       18 6e 65 57	      .byte.b	kNew,"neW"
      0  1b51					      db	kSlice,"slicE"
      1  1b51		       19 73 6c 69*	      .byte.b	kSlice,"slicE"
      0  1b57					      db	kTrace,"tracE"
      1  1b57		       1a 74 72 61*	      .byte.b	kTrace,"tracE"
      0  1b5d					      db	kExit,"exiT"
      1  1b5d		       1b 65 78 69*	      .byte.b	kExit,"exiT"
      0  1b62					      db	kSave,"savE"
      1  1b62		       1c 73 61 76*	      .byte.b	kSave,"savE"
      0  1b67					      db	kLoad,"loaD"
      1  1b67		       1d 6c 6f 61*	      .byte.b	kLoad,"loaD"
      0  1b6c					      db	kErase,"erasE"
      1  1b6c		       1e 65 72 61*	      .byte.b	kErase,"erasE"
      0  1b72					      db	kDir,"diR"
      1  1b72		       1f 64 69 52	      .byte.b	kDir,"diR"
    234  1b76							;Short form for statements:
      0  1b76					      db	kIreturn,"ireT"
      1  1b76		       04 69 72 65*	      .byte.b	kIreturn,"ireT"
      0  1b7b					      db	kReturn,"reT"
      1  1b7b		       09 72 65 54	      .byte.b	kReturn,"reT"
      0  1b7f					      db	kPrint,"pR"	; some dialects of tiny basic use this for print
      1  1b7f		       0b 70 52 	      .byte.b	kPrint,"pR"
      0  1b82					      db	kSetTerm, "setterM"
      1  1b82		       20 73 65 74*	      .byte.b	kSetTerm, "setterM"
      0  1b8a					      db	kSetMemB, "setmemB"
      1  1b8a		       21 73 65 74*	      .byte.b	kSetMemB, "setmemB"
      0  1b92					      db	kSetMemW, "setmemW"
      1  1b92		       22 73 65 74*	      .byte.b	kSetMemW, "setmemW"
      0  1b9a					      db	kCopyMem, "copymeM"
      1  1b9a		       23 63 6f 70*	      .byte.b	kCopyMem, "copymeM"
      0  1ba2					      db	kWhile, "whilE"
      1  1ba2		       24 77 68 69*	      .byte.b	kWhile, "whilE"
      0  1ba8					      db	kWend, "wenD"
      1  1ba8		       25 77 65 6e*	      .byte.b	kWend, "wenD"
    244  1bad
    245  1bad							; Shift operators
      0  1bad					      db	kShr,"shR"
      1  1bad		       2d 73 68 52	      .byte.b	kShr,"shR"
      0  1bb1					      db	kShl,"shL"
      1  1bb1		       2e 73 68 4c	      .byte.b	kShl,"shL"
    248  1bb5
    249  1bb5							;Logical and truth operators
      0  1bb5					      db	kNot,"noT"
      1  1bb5		       29 6e 6f 54	      .byte.b	kNot,"noT"
      0  1bb9					      db	kOr,"oR"
      1  1bb9		       2a 6f 52 	      .byte.b	kOr,"oR"
      0  1bbc					      db	kXor,"xoR"
      1  1bbc		       2b 78 6f 52	      .byte.b	kXor,"xoR"
      0  1bc0					      db	kAnd,"anD"
      1  1bc0		       2c 61 6e 44	      .byte.b	kAnd,"anD"
    254  1bc4
    255  1bc4							; Truth values
      0  1bc4					      db	kTrue,"truE"
      1  1bc4		       2f 74 72 75*	      .byte.b	kTrue,"truE"
      0  1bc9					      db	kFalse,"falsE"
      1  1bc9		       30 66 61 6c*	      .byte.b	kFalse,"falsE"
    258  1bcf
    259  1bcf							;functions returning values
    260  1bcf
      0  1bcf					      db	kFree,"freE"
      1  1bcf		       31 66 72 65*	      .byte.b	kFree,"freE"
      0  1bd4					      db	kGetch,"getcH"
      1  1bd4		       32 67 65 74*	      .byte.b	kGetch,"getcH"
      0  1bda					      db	kPeek,"peeK"
      1  1bda		       33 70 65 65*	      .byte.b	kPeek,"peeK"
      0  1bdf					      db	kTask,"tasK"
      1  1bdf		       34 74 61 73*	      .byte.b	kTask,"tasK"
      0  1be4					      db	kIpcc,"ipcC"
      1  1be4		       35 69 70 63*	      .byte.b	kIpcc,"ipcC"
      0  1be9					      db	kIpcs,"ipcS"
      1  1be9		       36 69 70 63*	      .byte.b	kIpcs,"ipcS"
      0  1bee					      db	kIpcr,"ipcR"
      1  1bee		       37 69 70 63*	      .byte.b	kIpcr,"ipcR"
      0  1bf3					      db	kRnd,"rnD"
      1  1bf3		       38 72 6e 44	      .byte.b	kRnd,"rnD"
      0  1bf7					      db	kStat,"staT"
      1  1bf7		       39 73 74 61*	      .byte.b	kStat,"staT"
      0  1bfc					      db	kAbs,"abS"
      1  1bfc		       3a 61 62 53	      .byte.b	kAbs,"abS"
      0  1c00					      db	kCall,"calL"
      1  1c00		       3b 63 61 6c*	      .byte.b	kCall,"calL"
      0  1c05					      db	kGofn,"fN"
      1  1c05		       3c 66 4e 	      .byte.b	kGofn,"fN"
      0  1c08					      db	kPid,"piD"
      1  1c08		       3d 70 69 44	      .byte.b	kPid,"piD"
      0  1c0c					      db	kAddr,"addR"
      1  1c0c		       3e 61 64 64*	      .byte.b	kAddr,"addR"
      0  1c11					      db	kCmpMem, "cmpmeM"
      1  1c11		       3f 63 6d 70*	      .byte.b	kCmpMem, "cmpmeM"
      0  1c18					      db	kTimer,"timeR"
      1  1c18		       40 74 69 6d*	      .byte.b	kTimer,"timeR"
      0  1c1e					      db	0,0
      1  1c1e		       00 00		      .byte.b	0,0
    278  1c20
    279  1c20		       1c 20	   KeyWordTableEnd equ	*
    280  1c20		       01 48	   KeyWordTableLength equ	* - KeyWordTable
    281  1c20		       00 00 00 00*TOKENBUFFER ds	256	; placed here as temp for testing the Code
    282  1d20		       00 00 00    printStorage ds	3
    283  1d23							;==================================================================================================================
    284  1d23							; Read accross the inputline and output to TOKENBUFFER
    285  1d23							; Format   byte      Description
    286  1d23							;	     0	      length of line 1-255
    287  1d23							;	    0-1       Line Number
    288  1d23							;	    Tokens and litteral values encoded into the line
    289  1d23							;
    290  1d23							;  First test for numbers    for numbers insert type byte plus value 1 or 2 byte, byte, integer, string(pointers)
    291  1d23							;  if fails then test for keywords
    292  1d23							;  if fails then test for variables and arrays
    293  1d23							;  if fails check for operators/seperators  + - < > = % / * () [] , ; : >> <<
    294  1d23
    295  1d23				   ParseInputLine
    296  1d23				  -	      if	DEBUGPARSER
    297  1d23				  -	      jsr	SetOutDebug
    298  1d23				  -	      jsr	DebugClearBuffer
    299  1d23					      endif
    300  1d23		       a5 51		      lda	CUROFF
    301  1d25		       48		      pha
      0  1d26					      pushxy
      1  1d26		       da		      phx
      2  1d27		       5a		      phy
    303  1d28		       a2 01		      ldx	#1	; point to beginning of Token buffer + 1 reserve space for length byte
    304  1d2a		       20 61 2b 	      jsr	getDecimal	; Check for a line number, none is ok too
    305  1d2d		       84 51		      sty	CUROFF
    306  1d2f		       20 e9 1e 	      jsr	R02TOKEN	; Move R0 to token buffer
    307  1d32
    308  1d32				   ParseInputLoop
    309  1d32		       a4 51		      ldy	CUROFF
    310  1d34		       20 0b 2e 	      jsr	SkipSpaces	; Skip any spaces
    311  1d37		       84 51		      sty	CUROFF	; Even if it fails at least remove the spaces
    312  1d39		       b9 4f 43 	      lda	LINBUF,y	; Check for end of line
    313  1d3c		       f0 25		      beq	ParseComplete	; Finish token buffer and return
    314  1d3e
    315  1d3e				   ParseForNumber
    316  1d3e		       20 3d 1e 	      jsr	ParseNumeric	; Check for a numeric value
    317  1d41		       90 ef		      bcc	ParseInputLoop	; Go Back for next element
    318  1d43
    319  1d43				   ParseForString
    320  1d43		       20 13 1e 	      jsr	ParseString	; Check for a string
    321  1d46		       90 ea		      bcc	ParseInputLoop	; It was a string
    322  1d48
    323  1d48				   ParseForOp
    324  1d48		       20 7b 1e 	      jsr	ParseForOperator	; Check for operator or punctuation
    325  1d4b		       90 e5		      bcc	ParseInputLoop	; it was an operator/punctuation
    326  1d4d
    327  1d4d				   ParseForKey
    328  1d4d		       20 70 1d 	      jsr	ParseLookupKey	; Check for a keyword value
    329  1d50		       90 e0		      bcc	ParseInputLoop	; Go back for next token, we are not syntax checking
    330  1d52
    331  1d52				   ParseForVar
    332  1d52		       20 b2 1e 	      jsr	ParseForVariable	; Check for variable and convert to Index, as task centric
    333  1d55		       90 db		      bcc	ParseInputLoop
    334  1d57
    335  1d57				   ParseKeepChar		; if it does not parse just keep it safe
    336  1d57		       b9 4f 43 	      lda	LINBUF,y
    337  1d5a		       9d 20 1c 	      sta	TOKENBUFFER,x
    338  1d5d		       e8		      inx
    339  1d5e		       c8		      iny
    340  1d5f		       84 51		      sty	CUROFF
    341  1d61		       d0 cf		      bne	ParseInputLoop
    342  1d63
    343  1d63				   ParseComplete
    344  1d63							;lda	  #0
    345  1d63							;sta	  TOKENBUFFER,x      ; null terminate the line of tokens
    346  1d63		       9e 20 1c 	      stz	TOKENBUFFER,x	; null terminate the line of tokens
    347  1d66		       e8		      inx
    348  1d67		       8e 20 1c 	      stx	TOKENBUFFER	; Place size including null into buffer start
    349  1d6a
      0  1d6a					      pullxy
      1  1d6a		       7a		      ply
      2  1d6b		       fa		      plx
    351  1d6c		       68		      pla
    352  1d6d		       85 51		      sta	CUROFF
    353  1d6f
    354  1d6f				  -	      if	DEBUGPARSER
    355  1d6f				  -
    356  1d6f				  -	      jsr	printTokenBuffer
    357  1d6f				  -			;jsr	  DebugPrintProgramLine
    358  1d6f				  -	      jsr	SetOutDebugEnd
    359  1d6f				  -
    360  1d6f					      endif
    361  1d6f		       60		      rts
    362  1d70
    363  1d70							;==================================================================================================================
    364  1d70							; Look at curptr, curpos and check for a valid KeyWord
    365  1d70							; A contains the index value. c is clear
    366  1d70							;		     not found c set  A undefined
    367  1d70							; X is prerserved
    368  1d70							;
    369  1d70				   ParseLookupKey
    370  1d70		       86 58		      stx	R2
    371  1d72		       a0 00		      ldy	#0
    372  1d74		       a9 d8		      lda	#KeyWordTable&$FF	; Key Table longer than 256 bytes
    373  1d76		       85 54		      sta	R1
    374  1d78		       a9 1a		      lda	#KeyWordTable>>8
    375  1d7a		       85 55		      sta	R1+1	; R1 points to first entry in keyword table
    376  1d7c		       b1 54		      lda	(R1),y	; Get the Key Token value for first keyword
    377  1d7e		       85 52		      sta	R0	; Save until next keyword
    378  1d80		       c8		      iny		; Point to first character of keyword
    379  1d81		       a6 51		      ldx	CUROFF	; X points to the character in the input buffer
    380  1d83
    381  1d83				  -	      if	DEBUGPARSER
    382  1d83				  -			;    jsr DebugKeyword
    383  1d83					      endif
    384  1d83
    385  1d83				   ParseLookupLoop
    386  1d83		       b1 54		      lda	(R1),y	; Get the first character of the keyword
    387  1d85		       29 df		      and	#%11011111	; Force Keyword to upper case
    388  1d87		       dd 4f 43 	      cmp	LINBUF,x	; Check the input buffer
    389  1d8a		       f0 07		      beq	ParseNextLetter	; If it equals then do next letter
    390  1d8c		       09 20		      ora	#%00100000	; Force Keyword to lowercase
    391  1d8e		       dd 4f 43 	      cmp	LINBUF,x	; Compare value to upercase
    392  1d91		       d0 34		      bne	ParseNextEntry	; Not equal then move to next entry in the keyword table
    393  1d93
    394  1d93				   ParseNextLetter
    395  1d93		       b1 54		      lda	(R1),y	; Check if we just processed the last letter is upper
    396  1d95		       29 20		      and	#%00100000	; if this bit not set then end of keyword, Last char is always uppercase
    397  1d97		       f0 0b		      beq	ParseKeyFound	; If we are at end of keyword and all match then we found the key
    398  1d99		       e8		      inx		; Point to next char in the input buffer
    399  1d9a		       c8		      iny		; Point to the next character in the Keyword table
    400  1d9b		       a9 00		      lda	#0	; Check if we are at the end of the input buffer
    401  1d9d		       dd 4f 43 	      cmp	LINBUF,x	; Check if we are at the end of the input buffer
    402  1da0		       f0 25		      beq	ParseNextEntry	; End of buffer but no keyword, ext keyword entry
    403  1da2		       d0 df		      bne	ParseLookupLoop	; Go back and check the next characters
    404  1da4
    405  1da4				   ParseKeyFound
    406  1da4		       a5 52		      lda	R0	; get the keyword index
    407  1da6
    408  1da6				   ParseKeyDone
    409  1da6		       e8		      inx		; point past the last character
    410  1da7		       86 51		      stx	CUROFF	; update to point to next character in the input buffer
    411  1da9		       a6 58		      ldx	R2	; Restore the original x pointer
    412  1dab		       9d 20 1c 	      sta	TOKENBUFFER,x	; store the Token into the compiled buffer
    413  1dae		       e8		      inx		; Point to next position in the output buffer
    414  1daf		       86 58		      stx	R2	; Save next position in buffer
    415  1db1		       c9 0a		      cmp	#kRem	; remark statement
    416  1db3		       f0 3a		      beq	ParseMoveLine	; Move everything until the end of line to the token buffer
    417  1db5		       c9 07		      cmp	#kGoto
    418  1db7		       f0 4a		      beq	ParseHandleBranches	; Jump allow space for memory address in token buffer
    419  1db9		       c9 08		      cmp	#kGosub
    420  1dbb		       f0 46		      beq	ParseHandleBranches	; Handle the gosub branch address
    421  1dbd		       c9 3c		      cmp	#kGofn
    422  1dbf		       f0 42		      beq	ParseHandleBranches	; Handle the gosub branch address
    423  1dc1		       c9 34		      cmp	#kTask
    424  1dc3		       f0 3e		      beq	ParseHandleBranches	; We may have the ability to also compile task vectors Bracket between the space and the value
    425  1dc5
    426  1dc5		       18		      clc		; C flag clear, we found it
    427  1dc6		       60		      rts
    428  1dc7
    429  1dc7							; Move forward to the next entry in table
    430  1dc7				   ParseNextEntry
    431  1dc7		       b1 54		      lda	(R1),y	; Get the next character in the token
    432  1dc9		       29 20		      and	#%00100000	; Is it the last character
    433  1dcb		       f0 03		      beq	ParseEndOfEntry	; Yes then end of this entry found
    434  1dcd		       c8		      iny		; Point to next char in the entry
    435  1dce		       d0 f7		      bne	ParseNextEntry	; loop until we find the end character
    436  1dd0
    437  1dd0				   ParseEndOfEntry
    438  1dd0		       c8		      iny		; Point to the byte after the last character
    439  1dd1		       98		      tya		; Move into a as we must add this to the pointer in R1, more that 256 keyword characters in table
    440  1dd2		       18		      clc		; table May be longer than 256 so increment r1 to next entry
    441  1dd3		       65 54		      adc	R1
    442  1dd5		       85 54		      sta	R1
    443  1dd7		       a5 55		      lda	R1+1
    444  1dd9		       69 00		      adc	#0
    445  1ddb		       85 55		      sta	R1+1	; Now pointing to start of next entry in the table
    446  1ddd		       a0 00		      ldy	#0	; Reset the index back to zero
    447  1ddf		       b1 54		      lda	(R1),y	; get keyword value
    448  1de1		       f0 08		      beq	ParseNoneFound	; Check for end of the table -> 0
    449  1de3		       85 52		      sta	R0	; save the next token value
    450  1de5		       c8		      iny		; Inc past token value
    451  1de6
    452  1de6				  -	      if	DEBUGPARSER
    453  1de6				  -			;    jsr DebugKeyword
    454  1de6					      endif
    455  1de6		       a6 51		      ldx	CUROFF	; Restore x to last position in the input buffer
    456  1de8		       4c 83 1d 	      jmp	ParseLookupLoop	; branch back for next key word
    457  1deb
    458  1deb				   ParseNoneFound
    459  1deb		       a6 58		      ldx	R2	; it did not find one, restore x to position in output buffer
    460  1ded		       38		      sec		; c clear, not found
    461  1dee		       60		      rts
    462  1def
    463  1def							;===============================================================================
    464  1def							; Move everything from current position until the end of line into the token buffer
    465  1def							;
    466  1def		       a4 51	   ParseMoveLine ldy	CUROFF	; next byte to parse
    467  1df1		       a6 58		      ldx	R2	; where to place in the buffer
    468  1df3				   ParseMoveLoop
    469  1df3		       b9 4f 43 	      lda	LINBUF,y	; get the next byte
    470  1df6		       f0 07		      beq	ParseMoveDone	; if we load a zero then done
    471  1df8		       9d 20 1c 	      sta	TOKENBUFFER,x	; save the byte
    472  1dfb		       c8		      iny
    473  1dfc		       e8		      inx
    474  1dfd		       d0 f4		      bne	ParseMoveLoop
    475  1dff				   ParseMoveDone
    476  1dff		       84 51		      sty	CUROFF
    477  1e01		       18		      clc
    478  1e02		       60		      rts
    479  1e03							;================================================================================================
    480  1e03							; Add two bytes after the gosub and goto to allow the "compiler" to place mem address, to directly
    481  1e03							; transfer to a memory address
    482  1e03				   ParseHandleBranches
    483  1e03		       a6 58		      ldx	R2
    484  1e05		       a9 00		      lda	#0
    485  1e07		       9d 20 1c 	      sta	TOKENBUFFER,x
    486  1e0a		       e8		      inx
    487  1e0b		       9d 20 1c 	      sta	TOKENBUFFER,x
    488  1e0e		       e8		      inx
    489  1e0f		       86 58		      stx	R2
    490  1e11		       18		      clc
    491  1e12		       60		      rts
    492  1e13
    493  1e13							;=========================================================================================================
    494  1e13							;ParseString Parse a quotes string
    495  1e13							; on input X = outbuf position
    496  1e13							; y = inbuf position
    497  1e13							; Copies string to output buffer, updates x and y
    498  1e13				   ParseString
    499  1e13		       a4 51		      ldy	CUROFF
    500  1e15		       a9 a0		      lda	#tString
    501  1e17		       9d 20 1c 	      sta	TOKENBUFFER,X
    502  1e1a		       b9 4f 43 	      lda	LINBUF,y
    503  1e1d		       c9 22		      cmp	#'"
    504  1e1f		       d0 1a		      bne	ParseStringInvalid
    505  1e21		       e8		      inx
    506  1e22		       9d 20 1c 	      sta	TOKENBUFFER,x
    507  1e25		       e8		      inx
    508  1e26		       c8		      iny
    509  1e27
    510  1e27				   ParseStringLoop
    511  1e27		       b9 4f 43 	      lda	LINBUF,y
    512  1e2a		       9d 20 1c 	      sta	TOKENBUFFER,x
    513  1e2d		       c9 22		      cmp	#'"
    514  1e2f		       f0 04		      beq	ParseStringDone
    515  1e31		       c8		      iny
    516  1e32		       e8		      inx
    517  1e33		       d0 f2		      bne	ParseStringLoop
    518  1e35
    519  1e35				   ParseStringDone
    520  1e35		       e8		      inx
    521  1e36		       c8		      iny
    522  1e37		       84 51		      sty	CUROFF
    523  1e39		       18		      clc
    524  1e3a		       60		      rts
    525  1e3b
    526  1e3b				   ParseStringInvalid
    527  1e3b		       38		      sec
    528  1e3c		       60		      rts
    529  1e3d
    530  1e3d							;=========================================================================================================
    531  1e3d							; Get numeric values and return value in RO and type in a
    532  1e3d							;
    533  1e3d				   ParseNumeric
    534  1e3d		       a4 51		      ldy	CUROFF
    535  1e3f		       b9 4f 43 	      lda	LINBUF,y
    536  1e42		       c9 30		      cmp	#'0
    537  1e44		       90 33		      bcc	ParseNumInvalid
    538  1e46		       c9 3a		      cmp	#'9+1
    539  1e48		       b0 2f		      bcs	ParseNumInvalid
    540  1e4a		       86 58		      stx	R2
    541  1e4c		       20 61 2b 	      jsr	getDecimal
    542  1e4f		       a6 58		      ldx	R2
    543  1e51		       84 51		      sty	CUROFF
    544  1e53		       a5 53		      lda	R0+1
    545  1e55		       f0 14		      beq	ParseByteValue
    546  1e57
    547  1e57				   ParseIntegerValue
    548  1e57		       a9 a4		      lda	#tInteger
    549  1e59		       9d 20 1c 	      sta	TOKENBUFFER,x
    550  1e5c		       e8		      inx
    551  1e5d		       a5 52		      lda	R0
    552  1e5f		       9d 20 1c 	      sta	TOKENBUFFER,x
    553  1e62		       e8		      inx
    554  1e63		       a5 53		      lda	R0+1
    555  1e65		       9d 20 1c 	      sta	TOKENBUFFER,X
    556  1e68		       e8		      inx
    557  1e69		       18		      clc
    558  1e6a		       60		      rts
    559  1e6b
    560  1e6b				   ParseByteValue
    561  1e6b		       a9 a2		      lda	#tByte
    562  1e6d		       9d 20 1c 	      sta	TOKENBUFFER,x
    563  1e70		       e8		      inx
    564  1e71		       a5 52		      lda	R0
    565  1e73		       9d 20 1c 	      sta	TOKENBUFFER,x
    566  1e76		       e8		      inx
    567  1e77		       18		      clc
    568  1e78		       60		      rts
    569  1e79
    570  1e79				   ParseNumInvalid		;Not a valid Numeric
    571  1e79		       38		      sec
    572  1e7a		       60		      rts
    573  1e7b
    574  1e7b							;=========================================================================================================
    575  1e7b							;Parse for operators and seperators
    576  1e7b							; on exit the A has the oper code, c is clear
    577  1e7b							;		 not found then c is set
    578  1e7b							;	x is preserved
    579  1e7b							;
    580  1e7b				   ParseForOperator
    581  1e7b		       86 58		      stx	R2
    582  1e7d		       a4 51		      ldy	CUROFF
    583  1e7f		       a2 00		      ldx	#0
    584  1e81				  -	      if	DEBUGPARSER
    585  1e81				  -			;	jsr    DebugPrintOP
    586  1e81					      endif
    587  1e81
    588  1e81				   ParseOpLoop
    589  1e81		       bd 7c 1a 	      lda	Operators,x	; First byte of operator
    590  1e84		       f0 28		      beq	ParseOpNotFound	; Last entry os 0,0
    591  1e86
    592  1e86		       d9 4f 43 	      cmp	LINBUF,y	; Check the first byte
    593  1e89		       d0 1c		      bne	ParseOpNext
    594  1e8b
    595  1e8b		       c8		      iny
    596  1e8c
    597  1e8c		       bd 7d 1a 	      lda	Operators+1,x
    598  1e8f		       f0 06		      beq	ParseOpFoundSingle	; Single Character op
    599  1e91
    600  1e91		       d9 4f 43 	      cmp	LINBUF,y
    601  1e94		       d0 11		      bne	ParseOpNext
    602  1e96
    603  1e96				   ParseOpFound
    604  1e96		       c8		      iny
    605  1e97
    606  1e97				   ParseOpFoundSingle
    607  1e97		       84 51		      sty	CUROFF
    608  1e99
    609  1e99		       8a		      txa
    610  1e9a		       4a		      lsr
    611  1e9b		       aa		      tax
    612  1e9c		       bd ba 1a 	      lda	OperValues,x
    613  1e9f		       a6 58		      ldx	R2
    614  1ea1		       9d 20 1c 	      sta	TOKENBUFFER,x
    615  1ea4		       e8		      inx
    616  1ea5		       18		      clc
    617  1ea6		       60		      rts
    618  1ea7
    619  1ea7				   ParseOpNext
    620  1ea7		       e8		      inx
    621  1ea8		       e8		      inx
    622  1ea9
    623  1ea9				  -	      if	DEBUGPARSER
    624  1ea9				  -			;	 jsr	DebugPrintOP
    625  1ea9					      endif
    626  1ea9		       a4 51		      ldy	CUROFF	; reset the y pointer to beginning
    627  1eab		       4c 81 1e 	      jmp	ParseOpLoop
    628  1eae
    629  1eae				   ParseOpNotFound
    630  1eae		       a6 58		      ldx	R2
    631  1eb0		       38		      sec
    632  1eb1		       60		      rts
    633  1eb2							;=========================================================================================================
    634  1eb2				  -	      if	DEBUGPARSER
    635  1eb2				  -			;Print the text of a keyword
    636  1eb2				  -			;Input R1    = offset into table
    637  1eb2				  -DebugKeyword
    638  1eb2				  -	      phy
    639  1eb2				  -	      ldy	#1
    640  1eb2				  -DebugKeyLoop
    641  1eb2				  -	      lda	(R1),y
    642  1eb2				  -	      jsr	VOUTCH
    643  1eb2				  -	      and	#%00100000
    644  1eb2				  -	      beq	DebugKeyDone
    645  1eb2				  -	      iny
    646  1eb2				  -	      bne	DebugKeyLoop
    647  1eb2				  -
    648  1eb2				  -DebugKeyDone
    649  1eb2				  -	      jsr	CRLF
    650  1eb2				  -	      ply
    651  1eb2				  -	      rts
    652  1eb2				  -			;========================================
    653  1eb2				  -DebugPrintOP
    654  1eb2				  -	      pha
    655  1eb2				  -	      lda	Operators,x
    656  1eb2				  -	      jsr	VOUTCH
    657  1eb2				  -	      lda	Operators+1,x
    658  1eb2				  -	      beq	DbgPrtOpDone
    659  1eb2				  -	      jsr	VOUTCH
    660  1eb2				  -
    661  1eb2				  -DbgPrtOpDone
    662  1eb2				  -	      jsr	CRLF
    663  1eb2				  -	      pla
    664  1eb2				  -	      rts
    665  1eb2				  -			;=======================================
    666  1eb2				  -DebugClearBuffer
    667  1eb2				  -	      phx
    668  1eb2				  -	      ldx	#$FF
    669  1eb2				  -	      lda	#0
    670  1eb2				  -DebugClrLoop
    671  1eb2				  -	      sta	TOKENBUFFER,x
    672  1eb2				  -	      dex
    673  1eb2				  -	      bne	DebugClrLoop
    674  1eb2				  -	      sta	TOKENBUFFER,x
    675  1eb2				  -	      plx
    676  1eb2				  -	      rts
    677  1eb2				  -
    678  1eb2				  -			;=====================================================
    679  1eb2				  -			; Print the parser buffer as hex values
    680  1eb2				  -printTokenBuffer
    681  1eb2				  -	      stx	printStorage
    682  1eb2				  -	      sty	printStorage+1
    683  1eb2				  -	      sta	printStorage+2
    684  1eb2				  -
    685  1eb2				  -	      ldx	TOKENBUFFER	; get the length of the buffer
    686  1eb2				  -	      inx		; we want to show the last zero byte
    687  1eb2				  -	      ldy	#0
    688  1eb2				  -
    689  1eb2				  -printHexLoop
    690  1eb2				  -	      lda	TOKENBUFFER,y	; get the character
    691  1eb2				  -	      jsr	HexToOut	; print it
    692  1eb2				  -	      lda	#$20
    693  1eb2				  -	      jsr	VOUTCH
    694  1eb2				  -	      iny
    695  1eb2				  -	      dex
    696  1eb2				  -	      cpx	#0
    697  1eb2				  -	      bne	printHexLoop
    698  1eb2				  -	      jsr	CRLF
    699  1eb2				  -
    700  1eb2				  -	      ldy	printStorage+1
    701  1eb2				  -	      ldx	printStorage
    702  1eb2				  -	      lda	printStorage+2
    703  1eb2				  -printHexDone
    704  1eb2				  -	      clc
    705  1eb2				  -	      rts
    706  1eb2					      endif
    707  1eb2
    708  1eb2							;=========================================================================================================
    709  1eb2							; Parse for variables A-Z @, ^  x!x x[op]
    710  1eb2				   ParseForVariable
    711  1eb2		       a4 51		      ldy	CUROFF
    712  1eb4		       b9 4f 43 	      lda	LINBUF,y
    713  1eb7		       c9 5e		      cmp	#'^	; is it an exit code
    714  1eb9		       d0 04		      bne	ParseVarMem
    715  1ebb		       a9 9b		      lda	#tVhat	; Mark the index as 27th slot
    716  1ebd		       d0 1f		      bne	ParseVarSpecial
    717  1ebf
    718  1ebf				   ParseVarMem
    719  1ebf		       c9 40		      cmp	#'@	; are we indirect through program end eg. @[0] ..
    720  1ec1		       d0 04		      bne	ParseVarStack
    721  1ec3		       a9 9d		      lda	#tVat
    722  1ec5		       d0 17		      bne	ParseVarSpecial
    723  1ec7
    724  1ec7				   ParseVarStack
    725  1ec7		       c9 23		      cmp	#'#	; Indirect var through top of stack eg. #[0]
    726  1ec9		       d0 04		      bne	ParseVarLetters
    727  1ecb		       a9 9c		      lda	#tVhash
    728  1ecd		       d0 0f		      bne	ParseVarSpecial
    729  1ecf
    730  1ecf				   ParseVarLetters
    731  1ecf		       29 df		      and	#%11011111	; Force upper case
    732  1ed1		       c9 41		      cmp	#'A
    733  1ed3		       90 12		      bcc	ParseVarInvalid
    734  1ed5		       c9 5b		      cmp	#'Z+1
    735  1ed7		       b0 0e		      bcs	ParseVarInvalid
    736  1ed9							;
    737  1ed9							; The condition is true, so convert to an index, push
    738  1ed9							; it onto the stack and continue running.
    739  1ed9							;
    740  1ed9		       38		      sec
    741  1eda		       e9 41		      sbc	#'A	;index is zero based
    742  1edc		       09 80		      ora	#$80
    743  1ede
    744  1ede				   ParseVarSpecial
    745  1ede		       9d 20 1c 	      sta	TOKENBUFFER,x
    746  1ee1		       e8		      inx
    747  1ee2		       c8		      iny
    748  1ee3		       84 51		      sty	CUROFF
    749  1ee5		       18		      clc
    750  1ee6		       60		      rts
    751  1ee7
    752  1ee7				   ParseVarInvalid
    753  1ee7		       38		      sec
    754  1ee8		       60		      rts
    755  1ee9
    756  1ee9							;=========================================================================================================
    757  1ee9							; Transfer R0 to the TOKENBUFFER
    758  1ee9							;
    759  1ee9				   R02TOKEN
    760  1ee9		       a5 52		      lda	R0
    761  1eeb		       9d 20 1c 	      sta	TOKENBUFFER,x
    762  1eee		       e8		      inx
    763  1eef		       a5 53		      lda	R0+1
    764  1ef1		       9d 20 1c 	      sta	TOKENBUFFER,x
    765  1ef4		       e8		      inx
    766  1ef5		       18		      clc
    767  1ef6		       60		      rts
    768  1ef7							;=========================================================================
    769  1ef7							; Transfer word in Token Buffer to R0
    770  1ef7				   TOKEN2R0
    771  1ef7		       b9 20 1c 	      lda	TOKENBUFFER,y
    772  1efa		       85 52		      sta	R0
    773  1efc		       c8		      iny
    774  1efd		       ca		      dex
    775  1efe		       b9 20 1c 	      lda	TOKENBUFFER,y
    776  1f01		       c8		      iny
    777  1f02		       ca		      dex
    778  1f03		       85 53		      sta	R0+1
    779  1f05		       60		      rts
    780  1f06							;==========================================================================
    781  1f06							; Transfer	Display Buffer position to R0
    782  1f06							;
    783  1f06				   DPL2R0
    784  1f06		       b1 59		      lda	(dpl),y
    785  1f08		       85 52		      sta	R0
    786  1f0a		       c8		      iny
    787  1f0b		       ca		      dex
    788  1f0c		       b1 59		      lda	(dpl),y
    789  1f0e		       c8		      iny
    790  1f0f		       ca		      dex
    791  1f10		       85 53		      sta	R0+1
    792  1f12		       60		      rts
    793  1f13
    794  1f13							;=========================================================================
    795  1f13							; Read an IL byte lookit up in the table, of words
    796  1f13							; set the next ilpc to point to that address
    797  1f13							; if not found then do ussual filter stuff
    798  1f13							; ongoto ilvectortable, not found address
    799  1f13		       20 b2 2a    iOnGoto    jsr	getILWord	; places the word into r0, pointer to table
    800  1f16		       86 52		      stx	R0
    801  1f18		       85 53		      sta	R0+1
    802  1f1a
    803  1f1a		       a4 51		      ldy	CUROFF
    804  1f1c		       b1 4f		      lda	(CURPTR),y	; get the operation byte
    805  1f1e		       a0 00		      ldy	#0
    806  1f20		       38		      sec
    807  1f21		       f1 52		      sbc	(R0),y	; Subract the base value
    808  1f23		       c8		      iny
    809  1f24		       d1 52		      cmp	(R0),y	; Check if we are in range
    810  1f26		       b0 12		      bcs	iOnGotoInvalid
    811  1f28		       e6 51		      inc	CUROFF	; Save the offset
    812  1f2a
    813  1f2a		       0a		      asl
    814  1f2b		       a8		      tay		; Turn into vector
    815  1f2c		       c8		      iny		; Inc must include the table base and entry count
    816  1f2d		       c8		      iny
    817  1f2e
    818  1f2e		       b1 52		      lda	(R0),y
    819  1f30		       85 43		      sta	ILPC
    820  1f32		       c8		      iny
    821  1f33		       b1 52		      lda	(R0),y
    822  1f35		       85 44		      sta	ILPC+1
    823  1f37		       4c 9e 02 	      jmp	NextIL
    824  1f3a
    825  1f3a				   iOnGotoInvalid
    826  1f3a		       20 b2 2a 	      jsr	getILWord
    827  1f3d		       86 43		      stx	ILPC
    828  1f3f		       85 44		      sta	ILPC+1
    829  1f41		       4c 9e 02 	      jmp	NextIL
    830  1f44							;
    831  1f44							;==========================================================================================
    832  1f44							; Test the token for relop and push the value onto the stack if true
    833  1f44							;
    834  1f44				   iTSTRELOP
    835  1f44		       20 b6 2a 	      jsr	getILByte
    836  1f47		       8d e4 43 	      sta	offset
    837  1f4a
    838  1f4a		       a4 51		      ldy	CUROFF
    839  1f4c		       b1 4f		      lda	(CURPTR),y
    840  1f4e		       48		      pha
    841  1f4f		       29 f0		      and	#$F0
    842  1f51		       c9 f0		      cmp	#$F0
    843  1f53		       d0 12		      bne	iTSTRELOPNOT
    844  1f55		       68		      pla
    845  1f56		       29 0f		      and	#$0F	; get the actual value
    846  1f58		       85 52		      sta	R0	; save it for later
    847  1f5a		       a9 00		      lda	#0
    848  1f5c		       85 53		      sta	R0+1
    849  1f5e		       20 af 2c 	      jsr	pushR0
    850  1f61		       c8		      iny
    851  1f62		       84 51		      sty	CUROFF	; save the y pointer
    852  1f64		       4c 9e 02 	      jmp	NextIL
    853  1f67
    854  1f67				   iTSTRELOPNOT
    855  1f67		       68		      pla
    856  1f68		       4c c0 0b 	      jmp	tstBranch
    857  1f6b
    858  1f6b							;
    859  1f6b							;===================================================================================================
    860  1f6b							; Test the token and following info for precompiled address information
    861  1f6b							; skip it if zero, transfer and skip next integer value if not zero
    862  1f6b							; used by both gosub, goto and gofN
    863  1f6b							;
    864  1f6b				   iTSTBRANCH		; il format TSTBRANCH whereToGoIfFailed
    865  1f6b		       20 b6 2a 	      jsr	getILByte	; Get jump address if vector is valid
    866  1f6e		       8d e4 43 	      sta	offset	; Mark offset for later if vector found
    867  1f71		       a4 51		      ldy	CUROFF	; get offset of first byte of compiled value
    868  1f73		       88		      dey		; point back to the type of branch
    869  1f74		       b1 4f		      lda	(CURPTR),y	; get the actual instructions
    870  1f76		       48		      pha		; Save till needed
    871  1f77		       c8		      iny		; back to memory vectors
    872  1f78				   ITSTBRANCHCont
    873  1f78		       b1 4f		      lda	(CURPTR),y	; Get first byte of compiled value
    874  1f7a		       85 52		      sta	R0	; R0 will contain mem pointer of present
    875  1f7c		       c8		      iny		; Point to next byte of mem vector
    876  1f7d		       b1 4f		      lda	(CURPTR),y	; It was compiled so get the hi byte value
    877  1f7f		       85 53		      sta	R0+1	; Move it into R0, R0 now contains vector address
    878  1f81		       c8		      iny		; Point to the byte past memory vector
    879  1f82		       84 51		      sty	CUROFF	; At least point past the memory vector built in
    880  1f84
    881  1f84		       05 52		      ora	R0	; Get the second byte of the mem
    882  1f86		       f0 28		      BEQ	iTSTBRANCHNoCompile	; If both are zero then not compiled
    883  1f88		       68		      pla
    884  1f89		       c9 07		      cmp	#kGoto	; Short cut lots if a goto stuff
    885  1f8b		       d0 03		      bne	NotGoto
    886  1f8d		       4c c5 04 	      jmp	FastFastXfer
    887  1f90				   NotGoto
    888  1f90		       c9 34		      cmp	#kTask	; Task defined with Task() so bypass the first bracket
    889  1f92		       d0 07		      bne	iTSTBRANCHCont
    890  1f94		       b1 4f		      lda	(CURPTR),y
    891  1f96		       c9 e0		      cmp	#oLeftBracket
    892  1f98		       d0 24		      bne	iTSTBRANCHErr	; Well in that case something is very wrong
    893  1f9a		       c8		      iny		; Increment past the bracket
    894  1f9b				   iTSTBRANCHCont
    895  1f9b		       b1 4f		      lda	(CURPTR),y	; We should get a datatype, if not memvector is invalid
    896  1f9d		       c9 a2		      cmp	#tByte	; A byte value is valid
    897  1f9f		       f0 05		      beq	ITSTBRANCHBYTE	; Skip the byte
    898  1fa1		       c9 a4		      cmp	#tInteger	; An integer value is valid
    899  1fa3		       d0 19		      bne	iTSTBRANCHErr	; If not then we can not use the memory vector
    900  1fa5		       c8		      iny		; skip type indicator for
    901  1fa6				   ITSTBRANCHBYTE
    902  1fa6		       c8		      iny		; skip first byte of value line number
    903  1fa7		       c8		      iny		; Skip second byte of line number
    904  1fa8
    905  1fa8				   iTSTBRANCHVALID
    906  1fa8		       84 51		      sty	CUROFF
    907  1faa		       20 af 2c 	      jsr	pushR0	; place transfer address on top of stack
    908  1fad		       4c c0 0b 	      jmp	tstBranch
    909  1fb0
    910  1fb0				   iTSTBRANCHNoCompile
    911  1fb0		       68		      pla
    912  1fb1		       c9 07		      cmp	#kGoto	; check here if the destination is . then just do it
    913  1fb3		       d0 09		      bne	iTSTBRANCHErr
    914  1fb5		       b1 4f		      lda	(CURPTR),y
    915  1fb7		       c9 e9		      cmp	#oPeriod	; check if the goto is back to this line, then just do it
    916  1fb9		       d0 03		      bne	iTSTBRANCHErr
    917  1fbb		       4c db 04 	      jmp	iXFER3
    918  1fbe				   iTSTBRANCHErr
    919  1fbe		       4c 9e 02 	      jmp	NextIL
------- FILE mytb.asm
------- FILE compile.asm LEVEL 2 PASS 6
      0  1fc1					      include	"compile.asm"
      1  1fc1					      Seg	Code
      2  1fc1							;
      3  1fc1							;=====================================================================
      4  1fc1							; Scan the loaded program just before running and insert memory locations of each
      5  1fc1							; line number branched to. goto 100, gosub 100, fn10(), task(100)
      6  1fc1							; These have the format  in memory  example 81{key word token} 0000{pointer to memory location} A1{number type} 92 00{byte or integer value line number value}
      7  1fc1							; goto 100   : 07 0000 A2 64			 the tokenizer optimizes the literal values to byte or int depending on value
      8  1fc1							; gosub 1000 : 08 0000 A4 E803
      9  1fc1							; fn 100()   ; 37 0000 A2 64 40 41
     10  1fc1							; task(1000) : 2F 0000 40 A4 E803 41
     11  1fc1				   Compile
     12  1fc1		       a9 00		      lda	#0
     13  1fc3		       85 52		      sta	R0	; keep track of how many errors we find
     14  1fc5		       a5 5b		      lda	RunMode
     15  1fc7		       48		      pha
     16  1fc8		       e6 5b		      inc	RunMode	; force run mode for error reporting
     17  1fca		       a5 4f		      lda	CURPTR
     18  1fcc		       48		      pha
     19  1fcd		       a5 50		      lda	CURPTR+1
     20  1fcf		       48		      pha
     21  1fd0		       a5 51		      lda	CUROFF
     22  1fd2		       48		      pha
     23  1fd3		       ad ec 43 	      lda	ProgramStart
     24  1fd6		       85 59		      sta	dpl
     25  1fd8		       ad ed 43 	      lda	ProgramStart+1
     26  1fdb		       85 5a		      sta	dpl+1
     27  1fdd
     28  1fdd				   CompileLineStart
     29  1fdd		       a5 59		      lda	dpl
     30  1fdf		       cd ee 43 	      cmp	ProgramEnd
     31  1fe2		       d0 07		      bne	CompileContinue
     32  1fe4		       a5 5a		      lda	dpl+1
     33  1fe6		       cd ef 43 	      cmp	ProgramEnd+1
     34  1fe9		       f0 3f		      beq	CompileComplete
     35  1feb
     36  1feb				   CompileContinue
     37  1feb		       a0 03		      ldy	#3	; first real character in the line
     38  1fed
     39  1fed				   CompileLoop
     40  1fed		       b1 59		      lda	(dpl),y	; get the byte
     41  1fef		       f0 27		      beq	CompileEndOfLine	; End of line, so goto next line for scan
     42  1ff1		       c8		      iny		; Pass this byte
     43  1ff2		       c9 07		      cmp	#kGoto
     44  1ff4		       f0 58		      beq	CompileField	; Will update the memory address and move pointer to next value
     45  1ff6		       c9 08		      cmp	#kGosub
     46  1ff8		       f0 54		      beq	CompileField	; Will update the memory address and move pointer to next value
     47  1ffa		       c9 3c		      cmp	#kGofn
     48  1ffc		       f0 50		      beq	CompileField	; Will update the memory address and move pointer to next value
     49  1ffe		       c9 34		      cmp	#kTask
     50  2000		       f0 4c		      beq	CompileField
     51  2002		       c9 0a		      cmp	#kRem
     52  2004		       f0 12		      beq	CompileRem	; Skip until end of line
     53  2006		       c9 a0		      cmp	#tString
     54  2008		       f0 2f		      beq	CompileString
     55  200a		       c9 a4		      cmp	#tInteger
     56  200c		       f0 06		      beq	CompileInteger
     57  200e		       c9 a2		      cmp	#tByte
     58  2010		       f0 03		      beq	CompileByte
     59  2012		       d0 d9		      bne	CompileLoop	; Next character
     60  2014
     61  2014				   CompileInteger
     62  2014		       c8		      iny
     63  2015				   CompileByte
     64  2015		       c8		      iny
     65  2016		       d0 d5		      bne	CompileLoop
     66  2018				   CompileRem
     67  2018				   CompileEndOfLine
     68  2018		       a0 00		      ldy	#0
     69  201a		       b1 59		      lda	(dpl),y
     70  201c		       18		      clc
     71  201d		       65 59		      adc	dpl
     72  201f		       85 59		      sta	dpl
     73  2021		       a9 00		      lda	#0
     74  2023		       65 5a		      adc	dpl+1
     75  2025		       85 5a		      sta	dpl+1
     76  2027
     77  2027		       4c dd 1f 	      jmp	CompileLineStart
     78  202a
     79  202a				   CompileComplete
     80  202a		       68		      pla
     81  202b		       85 51		      sta	CUROFF
     82  202d		       68		      pla
     83  202e		       85 50		      sta	CURPTR+1
     84  2030		       68		      pla
     85  2031		       85 4f		      sta	CURPTR
     86  2033		       68		      pla
     87  2034		       85 5b		      sta	RunMode
     88  2036		       a5 52		      lda	R0	; returning the number of errors
     89  2038		       60		      rts
     90  2039
     91  2039
     92  2039				   CompileString
     93  2039		       c8		      iny		; point past first "
     94  203a				   CompileStringLoop
     95  203a		       b1 59		      lda	(dpl),y
     96  203c		       f0 0d		      beq	CompileStrDone2	; end of line
     97  203e		       c9 22		      cmp	#'"	; end of string
     98  2040		       f0 08		      beq	CompileStrDone
     99  2042		       c9 5c		      cmp	#'\	; escape character
    100  2044		       d0 01		      bne	CompileStrNext
    101  2046		       c8		      iny		; skip the escape character
    102  2047				   CompileStrNext
    103  2047		       c8		      iny		; Next character
    104  2048		       d0 f0		      bne	CompileStringLoop	; test for end
    105  204a				   CompileStrDone
    106  204a		       c8		      iny
    107  204b				   CompileStrDone2
    108  204b		       4c ed 1f 	      Jmp	CompileLoop
    109  204e							;
    110  204e							;===============================================================
    111  204e							; on entry y points to storage location y+2 points to line number
    112  204e							; on exit y points to line number type
    113  204e
    114  204e		       85 52	   CompileField sta	R0
    115  2050		       5a		      phy		; save the y pointer to store the memory value
    116  2051		       c8		      iny		; Skip over the memory vector
    117  2052		       c8		      iny
    118  2053		       a5 52		      lda	R0
    119  2055		       c9 34		      cmp	#kTask	; for a task it is the next byte after a bracket
    120  2057		       d0 07		      bne	CompNoBracket
    121  2059
    122  2059		       b1 59		      lda	(dpl),y	; Lets make sure it is a (
    123  205b		       c9 e0		      cmp	#oLeftBracket
    124  205d		       d0 01		      bne	CompNoBracket	; in case of error
    125  205f		       c8		      iny		; skip the bracket
    126  2060
    127  2060				   CompNoBracket
    128  2060		       a9 00		      lda	#0	; In case the value is a byte
    129  2062		       85 53		      sta	R0+1
    130  2064
    131  2064		       b1 59		      lda	(dpl),Y	; get the type of the next byte txxx something or other
    132  2066		       c9 a2		      cmp	#tByte
    133  2068		       f0 15		      beq	CompByteLoad
    134  206a		       c9 a4		      cmp	#tInteger
    135  206c		       f0 04		      beq	CompIntLoad	; If it is not a number then get out of here
    136  206e		       68		      pla
    137  206f		       4c ed 1f 	      jmp	CompileLoop	; Ignore the saved stack
    138  2072				   CompIntLoad
    139  2072		       c8		      iny
    140  2073		       b1 59		      lda	(dpl),y
    141  2075		       85 52		      sta	R0
    142  2077		       c8		      iny
    143  2078		       b1 59		      lda	(dpl),y
    144  207a		       85 53		      sta	R0+1
    145  207c		       4c 84 20 	      jmp	CompFindLine
    146  207f				   CompByteLoad
    147  207f		       c8		      iny
    148  2080		       b1 59		      lda	(dpl),y
    149  2082		       85 52		      sta	R0
    150  2084				   CompFindLine
    151  2084		       20 fb 2a 	      jsr	findLine
    152  2087		       f0 1c		      beq	CompFoundLine
    153  2089		       e6 52		      inc	R0	; number of errors
    154  208b
    155  208b		       a5 59		      lda	dpl
    156  208d		       85 4f		      sta	CURPTR
    157  208f		       a5 5a		      lda	dpl+1
    158  2091		       85 50		      sta	CURPTR+1
    159  2093		       84 51		      sty	CUROFF
    160  2095
    161  2095		       a2 14		      ldx	#ERR_LINE_NOT_FOUND
    162  2097		       a9 00		      lda	#0
    163  2099
    164  2099		       20 10 06 	      jsr	DisplayError
    165  209c		       20 13 22 	      jsr	PrintProgramLine
    166  209f
    167  209f		       7a		      ply
    168  20a0		       c8		      iny
    169  20a1		       c8		      iny
    170  20a2		       4c ed 1f 	      jmp	CompileLoop
    171  20a5
    172  20a5				   CompFoundLine
    173  20a5		       7a		      ply
    174  20a6		       a5 4f		      lda	CURPTR
    175  20a8		       91 59		      sta	(dpl),y
    176  20aa		       c8		      iny
    177  20ab		       a5 50		      lda	CURPTR+1
    178  20ad		       91 59		      sta	(dpl),y
    179  20af		       c8		      iny
    180  20b0		       4c ed 1f 	      jmp	CompileLoop
    181  20b3
    182  20b3
    183  20b3
    184  20b3
    185  20b3
    186  20b3
    187  20b3
    188  20b3
    189  20b3
    190  20b3
    191  20b3
    192  20b3
    193  20b3
    194  20b3
    195  20b3
    196  20b3
    197  20b3
    198  20b3
    199  20b3
    200  20b3
    201  20b3
    202  20b3
    203  20b3
    204  20b3
    205  20b3
    206  20b3
    207  20b3
    208  20b3
    209  20b3
    210  20b3
    211  20b3
    212  20b3
    213  20b3
    214  20b3
    215  20b3
    216  20b3
    217  20b3
    218  20b3
    219  20b3
    220  20b3
    221  20b3
------- FILE mytb.asm
------- FILE print.asm LEVEL 2 PASS 6
      0  20b3					      include	"print.asm"
      1  20b3					      Seg	Code
      2  20b3							;---------------------------
      3  20b3							; Print 24-bit decimal number or  16bit unsigned
      4  20b3							; ---------------------------
      5  20b3							; On entry, R0=number to print
      6  20b3							;	     Defaults to pad=0 , y=21 default
      7  20b3							;	     R2 = 1 unsigned 16 bit
      8  20b3							;	     R2 = 0 Signed   16 bit
      9  20b3
     10  20b3							; On entry at PrintDecPadded:
     11  20b3							;	     X = padding, Y=(number of digits)*3-3, eg 21 for 8 digits
     12  20b3
     13  20b3							; On exit,  A,X,Y,num,pad corrupted
     14  20b3							; Size      129 bytes, Table 24 bytes	--- total 153
     15  20b3							; -----------------------------------------------------------------
     16  20b3
     17  20b3				   PrintDecimal
      0  20b3					      pushxy
      1  20b3		       da		      phx
      2  20b4		       5a		      phy
     19  20b5		       a9 00		      lda	#0
     20  20b7		       8d 4a 21 	      sta	pad
     21  20ba		       a0 15		      LDY	#21	; Offset to powers of ten
     22  20bc		       4c c2 20 	      JMP	PrintDo
     23  20bf
     24  20bf				   PrintDecPadded
     25  20bf		       8e 4a 21 	      stx	pad
     26  20c2
     27  20c2				   PrintDo
     28  20c2		       a9 00		      lda	#0
     29  20c4		       85 54		      sta	R1
     30  20c6
     31  20c6		       a5 58		      lda	R2
     32  20c8		       c9 a9		      cmp	#tUint
     33  20ca		       f0 29		      beq	PrintPos
     34  20cc
     35  20cc		       a5 53		      lda	R0+1	;MSB has sign
     36  20ce		       10 25		      bpl	PrintPos	;it's a positive number;
     37  20d0
     38  20d0							; Negative numbers need more work.  Invert all the bits,
     39  20d0							; then add one.
     40  20d0
     41  20d0		       a9 2d		      lda	#'-
     42  20d2		       20 1f 1a 	      jsr	VOUTCH	;print the negative sign
     43  20d5
     44  20d5		       a9 ff		      lda	#$FF
     45  20d7		       85 54		      sta	R1
     46  20d9		       a5 52		      lda	R0	;invert bits
     47  20db		       49 ff		      eor	#$ff
     48  20dd		       85 52		      sta	R0
     49  20df		       a5 53		      lda	R0+1
     50  20e1		       49 ff		      eor	#$ff
     51  20e3		       85 53		      sta	R0+1
     52  20e5		       a5 54		      lda	R1
     53  20e7		       49 ff		      eor	#$ff
     54  20e9		       85 54		      sta	R1
     55  20eb		       e6 52		      inc	R0	;add one
     56  20ed		       d0 06		      bne	PrintPos
     57  20ef		       e6 53		      inc	R0+1
     58  20f1		       d0 02		      bne	PrintPos
     59  20f3		       e6 54		      inc	R1
     60  20f5				   PrintPos
     61  20f5
     62  20f5				   PrDec24Lp1
     63  20f5		       a2 ff		      LDX	#$FF
     64  20f7		       38		      SEC		; Start with digit=-1
     65  20f8				   PrDec24Lp2
     66  20f8		       a5 52		      LDA	R0+0
     67  20fa		       f9 4b 21 	      SBC	PrDec24Tens+0,Y
     68  20fd		       85 52		      STA	R0+0	; Subtract current tens
     69  20ff		       a5 53		      LDA	R0+1
     70  2101		       f9 4c 21 	      SBC	PrDec24Tens+1,Y
     71  2104		       85 53		      STA	R0+1
     72  2106		       a5 54		      LDA	R0+2
     73  2108		       f9 4d 21 	      SBC	PrDec24Tens+2,Y
     74  210b		       85 54		      STA	R0+2
     75  210d		       e8		      INX
     76  210e		       b0 e8		      BCS	PrDec24Lp2	; Loop until <0
     77  2110		       a5 52		      LDA	R0+0
     78  2112		       79 4b 21 	      ADC	PrDec24Tens+0,Y
     79  2115		       85 52		      STA	R0+0	; Add current tens back in
     80  2117		       a5 53		      LDA	R0+1
     81  2119		       79 4c 21 	      ADC	PrDec24Tens+1,Y
     82  211c		       85 53		      STA	R0+1
     83  211e		       a5 54		      LDA	R0+2
     84  2120		       79 4d 21 	      ADC	PrDec24Tens+2,Y
     85  2123		       85 54		      STA	R0+2
     86  2125		       8a		      TXA
     87  2126		       d0 07		      BNE	PrDec24Digit	; Not zero, print it
     88  2128		       ad 4a 21 	      LDA	pad
     89  212b		       d0 09		      BNE	PrDec24Print
     90  212d		       f0 0a		      BEQ	PrDec24Next	; pad<>0, use it
     91  212f				   PrDec24Digit
     92  212f		       a2 30		      LDX	#'0
     93  2131		       8e 4a 21 	      STX	pad	; No more zero padding
     94  2134		       09 30		      ORA	#'0	; Print this digit
     95  2136				   PrDec24Print
     96  2136		       20 1f 1a 	      JSR	VOUTCH
     97  2139				   PrDec24Next
     98  2139		       88		      DEY
     99  213a		       88		      DEY
    100  213b		       88		      DEY
    101  213c		       f0 05		      beq	PrDec24LastDigit
    102  213e		       10 b5		      BPL	PrDec24Lp1	; Loop for next digit
      0  2140					      pullxy
      1  2140		       7a		      ply
      2  2141		       fa		      plx
    104  2142		       60		      RTS
    105  2143				   PrDec24LastDigit
    106  2143		       a2 30		      LDX	#'0
    107  2145		       8e 4a 21 	      STX	pad	; No more zero padding
    108  2148		       d0 ab		      BNE	PrDec24Lp1	; Loop for last digit
    109  214a
      0  214a				   pad	      db	0
      1  214a		       00		      .byte.b	0
    111  214b
    112  214b				   PrDec24Tens
      0  214b					      dw	1
      1  214b		       01 00		      .word.w	1
      0  214d					      db	(1 / 65536)
      1  214d		       00		      .byte.b	(1 / 65536)
      0  214e					      dw	10
      1  214e		       0a 00		      .word.w	10
      0  2150					      db	(10 / 65536)
      1  2150		       00		      .byte.b	(10 / 65536)
      0  2151					      dw	100
      1  2151		       64 00		      .word.w	100
      0  2153					      db	(100 / 65536)
      1  2153		       00		      .byte.b	(100 / 65536)
      0  2154					      dw	1000
      1  2154		       e8 03		      .word.w	1000
      0  2156					      db	(1000 / 65536)
      1  2156		       00		      .byte.b	(1000 / 65536)
      0  2157					      dw	10000
      1  2157		       10 27		      .word.w	10000
      0  2159					      db	(10000 / 65536)
      1  2159		       00		      .byte.b	(10000 / 65536)
      0  215a					      dw	100000
      1  215a		       a0 86		      .word.w	100000
      0  215c					      db	(100000 / 65536)
      1  215c		       01		      .byte.b	(100000 / 65536)
      0  215d					      dw	1000000
      1  215d		       40 42		      .word.w	1000000
      0  215f					      db	(1000000 / 65536)
      1  215f		       0f		      .byte.b	(1000000 / 65536)
      0  2160					      dw	10000000
      1  2160		       80 96		      .word.w	10000000
      0  2162					      db	(10000000 / 65536)
      1  2162		       98		      .byte.b	(10000000 / 65536)
    129  2163							;=====================================================
    130  2163							; Print character in A as two hex digits to the Console
    131  2163
    132  2163		       48	   HexToOut   pha		;save return value
    133  2164		       48		      pha
    134  2165		       4a		      lsr		;a  ;move top nibble to bottom
    135  2166		       4a		      lsr		;a
    136  2167		       4a		      lsr		;a
    137  2168		       4a		      lsr		;a
    138  2169		       20 72 21 	      jsr	hexta	;output nibble
    139  216c		       68		      pla
    140  216d		       20 72 21 	      jsr	hexta
    141  2170		       68		      pla		;restore
    142  2171		       60		      rts
    143  2172							;
    144  2172		       29 0f	   hexta      and	#%0001111
    145  2174		       c9 0a		      cmp	#$0a
    146  2176		       18		      clc
    147  2177		       30 02		      bmi	hexta1
    148  2179		       69 07		      adc	#7
    149  217b		       69 30	   hexta1     adc	#'0	;then fall into...
    150  217d		       4c 1f 1a 	      jmp	VOUTCH
    151  2180							;
    152  2180							;=====================================================
    153  2180							; Print the string that immediately follows the JSR to
    154  2180							; this function.  Stops when a null byte is found,
    155  2180							; then returns to the instruction immediately
    156  2180							; following the null.
    157  2180							;
    158  2180							; Thanks to Ross Archer for this code.
    159  2180							; http://www.6502.org/source/io/primm.htm
    160  2180							;
    161  2180
    162  2180		       68	   tbputs     pla		;Get the low part of "return" address
    163  2181							;(data start address)
    164  2181		       85 5e		      sta	PrtFrom
    165  2183		       68		      pla
    166  2184		       85 5f		      sta	PrtFrom+1	;Get the high part of "return" address
    167  2186							;(data start address)
    168  2186							;Note: actually we're pointing one short
    169  2186		       a0 01	   PSINB      ldy	#1
    170  2188		       b1 5e		      lda	(PrtFrom),y	;Get the next string character
    171  218a		       e6 5e		      inc	PrtFrom	;update the pointer
    172  218c		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
    173  218e		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    174  2190		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
    175  2192							;   Accumulator
    176  2192		       f0 06		      beq	PSIX1	;don't print the final NULL
    177  2194		       20 1f 1a 	      jsr	VOUTCH	;write it out
    178  2197		       4c 86 21 	      jmp	PSINB	;back around
    179  219a		       e6 5e	   PSIX1      inc	PrtFrom
    180  219c		       d0 02		      bne	PSIX2
    181  219e		       e6 5f		      inc	PrtFrom+1	;account for page crossing
    182  21a0		       6c 5e 00    PSIX2      jmp	(PrtFrom)	;return to byte following final NULL
    183  21a3
    184  21a3							;+
    185  21a3							;====================================================
    186  21a3		       43 e0	   PrtTerm    equ	tempy
    187  21a3
    188  21a3							; on exit Print Y has the offset to use
    189  21a3							; input y =	 addr low
    190  21a3							;	 x =	 addr high
    191  21a3							;	 a =	 termination string
    192  21a3
    193  21a3				   PrtQuoted		; Print a quoted string from the current program space
    194  21a3		       a9 22		      lda	#'"
    195  21a5		       a4 51		      ldy	CUROFF
    196  21a7		       d1 4f		      cmp	(CURPTR),y	; the opening quote, can to " or ' so long as they match
    197  21a9		       d0 03		      bne	PrtNoInc
    198  21ab		       c8		      iny
    199  21ac		       84 51		      sty	CUROFF
    200  21ae				   PrtNoInc
    201  21ae		       8d e0 43 	      sta	PrtTerm
    202  21b1
    203  21b1				   PrtPrgString 		; Print a terminated string from the static program space
    204  21b1		       a4 51		      ldy	CUROFF
    205  21b3		       a5 4f		      lda	CURPTR
    206  21b5		       85 5e		      sta	PrtFrom
    207  21b7		       a5 50		      lda	CURPTR+1
    208  21b9		       85 5f		      sta	PrtFrom+1
    209  21bb		       4c c7 21 	      jmp	PrtLoop
    210  21be
    211  21be							; Print a string pointed to by x= h, y=l terminated by value in  accumulator
    212  21be							; Return y as the length
    213  21be
    214  21be		       86 5f	   PrtStr     stx	PrtFrom+1
    215  21c0		       84 5e		      sty	PrtFrom
    216  21c2		       8d e0 43 	      sta	PrtTerm
    217  21c5		       a0 00		      ldy	#0
    218  21c7							;
    219  21c7							; On entry here ptrfrom and prtterm point to area to print
    220  21c7							;
    221  21c7		       b1 5e	   PrtLoop    lda	(PrtFrom),y
    222  21c9		       cd e0 43 	      cmp	PrtTerm
    223  21cc		       f0 0b		      beq	PrtEnd
    224  21ce		       c9 00		      cmp	#0	; always end if 0 is found
    225  21d0		       f0 07		      beq	PrtEnd
    226  21d2		       20 1f 1a 	      jsr	VOUTCH
    227  21d5		       c8		      iny
    228  21d6		       4c c7 21 	      jmp	PrtLoop
    229  21d9		       c8	   PrtEnd     iny		;return byte after the write
    230  21da		       60		      rts
    231  21db
    232  21db							;
    233  21db							;=======================================================
    234  21db							; Print all Variables
    235  21db				   PrintAllVars
    236  21db		       a0 00		      ldy	#0
    237  21dd		       84 58		      sty	R2
    238  21df				   PrintAllVarsLoop
    239  21df		       b1 41		      lda	(VARIABLES),y	; get the value into R0
    240  21e1		       85 52		      sta	R0
    241  21e3		       c8		      iny
    242  21e4		       b1 41		      lda	(VARIABLES),y
    243  21e6		       85 53		      sta	R0+1
    244  21e8		       98		      tya		; get the count
    245  21e9		       48		      pha
    246  21ea		       4a		      lsr
    247  21eb		       18		      clc
    248  21ec		       69 41		      adc	#'A
    249  21ee		       20 1f 1a 	      jsr	VOUTCH
    250  21f1		       20 80 21 	      jsr	puts
      0  21f4					      db	"=",0
      1  21f4		       3d 00		      .byte.b	"=",0
    252  21f6
    253  21f6		       20 b3 20 	      jsr	PrintDecimal
    254  21f9		       20 80 21 	      jsr	puts
      0  21fc					      db	" ",0
      1  21fc		       20 00		      .byte.b	" ",0
    256  21fe		       68		      pla
    257  21ff		       a8		      tay
    258  2200		       c8		      iny
    259  2201		       c0 34		      cpy	#52	; A-Z 2 bytes each
    260  2203		       d0 da		      bne	PrintAllVarsLoop
    261  2205		       20 14 2e 	      jsr	CRLF
    262  2208
    263  2208		       60		      rts
    264  2209							;==========================================================================================================
    265  2209							;Debug   Print a Program Line from compile buffer
    266  2209							;
    267  2209				   DebugPrintProgramLine
    268  2209		       48		      pha
    269  220a		       a9 20		      lda	#TOKENBUFFER&$FF
    270  220c		       85 59		      sta	dpl
    271  220e		       a9 1c		      lda	#TOKENBUFFER>>8
    272  2210		       85 5a		      sta	dpl+1
    273  2212		       68		      pla
    274  2213
    275  2213							; Decode and print a line of program text
    276  2213							; on entry	 dpl points to line of code to print
    277  2213							; on exit	 no change in reg or dpl
    278  2213							;
    279  2213				   PrintProgramLine
    280  2213
    281  2213		       8e 20 1d 	      stx	printStorage
    282  2216		       8c 21 1d 	      sty	printStorage+1
    283  2219		       48		      pha
    284  221a
    285  221a		       a0 01		      ldy	#1	; index into the token buffer
    286  221c		       84 58		      sty	R2	; print unsigned decimal
    287  221e		       a0 00		      ldy	#0
    288  2220		       b1 59		      lda	(dpl),y	; get number of bytes
    289  2222		       aa		      tax		; place pointer into x
    290  2223		       c8		      iny
    291  2224		       ca		      dex		; Deduct the length byte
    292  2225		       20 06 1f 	      jsr	DPL2R0	; Print the line number
    293  2228		       20 b3 20 	      jsr	PrintDecimal
    294  222b		       a9 20		      lda	#$20
    295  222d		       20 1f 1a 	      jsr	VOUTCH
    296  2230
    297  2230				   PrintProgLoop
    298  2230		       b1 59		      lda	(dpl),y	; Get a character
    299  2232		       f0 4a		      beq	PrintProgramComplete	; If zero then at end of line
    300  2234		       29 80		      and	#%10000000	; check for Keyword or Variable/operator
    301  2236		       f0 76		      beq	PrintKeyword	; It uses the index in a to find a keyword
    302  2238
    303  2238				   PrintProgVars
    304  2238		       b1 59		      lda	(dpl),y
    305  223a		       29 e0		      and	#$E0	; Check for operators and punctuation
    306  223c		       c9 e0		      cmp	#$E0
    307  223e		       f0 6b		      beq	PrintProgOperatorVect
    308  2240
    309  2240		       b1 59		      lda	(dpl),y	; Get char back again and check for var
    310  2242		       c9 9e		      cmp	#$9D+1
    311  2244		       90 62		      bcc	PrintProgVariableVec
    312  2246		       29 a0		      and	#$A0	; Check for a valid datatype
    313  2248		       c9 a0		      cmp	#$A0
    314  224a		       f0 06		      beq	PrintDataType	; if not just print the character
    315  224c		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    316  224e		       ca		      dex		; Ok we are processing it
    317  224f		       c8		      iny
    318  2250		       d0 25		      bne	PrintContinue	; Print and do the next character
    319  2252
    320  2252				   PrintDataType
    321  2252		       b1 59		      lda	(dpl),y	; Get char back again and check for data type
    322  2254		       c9 a0		      cmp	#tString
    323  2256		       f0 31		      beq	PrintStringVariable
    324  2258
    325  2258				   PrintProgNumber
    326  2258		       c8		      iny		; we have a numerical integer value
    327  2259		       ca		      dex
    328  225a		       48		      pha
    329  225b		       a9 00		      lda	#0
    330  225d		       85 53		      sta	R0+1
    331  225f		       85 58		      sta	R2	; Set to print signed number
    332  2261		       b1 59		      lda	(dpl),y
    333  2263		       85 52		      sta	R0
    334  2265		       68		      pla
    335  2266		       c9 a4		      cmp	#tInteger
    336  2268		       d0 06		      bne	PrintProgNumDone
    337  226a		       c8		      iny
    338  226b		       ca		      dex
    339  226c		       b1 59		      lda	(dpl),y
    340  226e		       85 53		      sta	R0+1
    341  2270
    342  2270				   PrintProgNumDone
    343  2270		       c8		      iny
    344  2271		       ca		      dex
    345  2272		       20 b3 20 	      jsr	PrintDecimal
    346  2275
    347  2275				   PrintProgNext
    348  2275		       a9 20		      lda	#$20
    349  2277				   PrintContinue
    350  2277		       20 1f 1a 	      jsr	VOUTCH
    351  227a				   PrintProgSkipSpace
    352  227a		       e0 00		      cpx	#0
    353  227c		       d0 b2		      bne	PrintProgLoop
    354  227e				   PrintProgramComplete
    355  227e		       20 14 2e 	      jsr	CRLF
    356  2281
    357  2281		       ae 20 1d 	      ldx	printStorage
    358  2284		       ac 21 1d 	      ldy	printStorage+1
    359  2287		       68		      pla
    360  2288
    361  2288		       60		      rts
    362  2289							;=================================================================================================================
    363  2289							; Print a string variable including the quotes
    364  2289							; On Input	 y is offset into buffer
    365  2289							; On Exit	 y is updated to new offset
    366  2289
    367  2289				   PrintStringVariable
    368  2289		       c8		      iny
    369  228a		       a9 22		      lda	#'"
    370  228c		       20 1f 1a 	      jsr	VOUTCH
    371  228f		       c8		      iny
    372  2290		       a5 59		      lda	dpl
    373  2292		       85 5e		      sta	PrtFrom
    374  2294		       a5 5a		      lda	dpl+1
    375  2296		       85 5f		      sta	PrtFrom+1
    376  2298		       a9 22		      lda	#'"
    377  229a		       8d e0 43 	      sta	PrtTerm
    378  229d		       20 c7 21 	      jsr	PrtLoop
    379  22a0		       a9 22		      lda	#'"
    380  22a2		       20 1f 1a 	      jsr	VOUTCH
    381  22a5		       4c 75 22 	      jmp	PrintProgNext
    382  22a8
    383  22a8				   PrintProgVariableVec
    384  22a8		       4c 44 23 	      jmp	PrintProgVariable
    385  22ab
    386  22ab				   PrintProgOperatorVect
    387  22ab		       4c 1b 23 	      jmp	PrintProgOperator
    388  22ae							;===============================================================================================================
    389  22ae							; On entry dpl points to the buffer we are printing from
    390  22ae							;	    y	current offset into the dpl buffer
    391  22ae							; all registers preserved
    392  22ae							;
    393  22ae				   PrintKeyword
    394  22ae
    395  22ae		       b1 59		      lda	(dpl),y	; Get the Keyword token to lookup
    396  22b0		       85 52		      sta	R0	; The value we are looking for
    397  22b2		       c9 07		      cmp	#kGoto	; Test if we must skip an extra two bytes for branch type instructions
    398  22b4		       f0 0c		      beq	PrintKeyBranch
    399  22b6		       c9 08		      cmp	#kGosub
    400  22b8		       f0 08		      beq	PrintKeyBranch
    401  22ba		       c9 34		      cmp	#kTask
    402  22bc		       f0 04		      beq	PrintKeyBranch
    403  22be		       c9 3c		      cmp	#kGofn
    404  22c0		       d0 04		      bne	PrintKeySkipped
    405  22c2				   PrintKeyBranch
    406  22c2		       c8		      iny		; Skip the compiled memory address
    407  22c3		       c8		      iny
    408  22c4		       ca		      dex		; Change number of bytes to print
    409  22c5		       ca		      dex		; Remove the bytes to print
    410  22c6
    411  22c6				   PrintKeySkipped
    412  22c6		       c8		      iny		; Inc y to point to the next char to be printed
    413  22c7		       ca		      dex		; Reduce number of bytes to print
      0  22c8					      pushxy
      1  22c8		       da		      phx
      2  22c9		       5a		      phy
    415  22ca
    416  22ca		       a9 d8		      lda	#KeyWordTable&$FF	; R1 to point to the entry in the keyword table
    417  22cc		       85 54		      sta	R1
    418  22ce		       a9 1a		      lda	#KeyWordTable>>8
    419  22d0		       85 55		      sta	R1+1
    420  22d2
    421  22d2				   PrintKeyLoop
    422  22d2		       a0 00		      ldy	#0	; Index into the keyword entry
    423  22d4		       b1 54		      lda	(R1),y	; Get token value for this entry
    424  22d6		       c8		      iny		; Point to first byte of key
    425  22d7		       c5 52		      cmp	R0	; Compare to the token we are looking for
    426  22d9		       f0 16		      Beq	PrintKeyFound	; We have the correct Token, now print it
    427  22db
    428  22db				   PrintKeyNext
    429  22db		       b1 54		      lda	(R1),y	; Get key letter
    430  22dd		       c8		      iny		; Point to next byte always
    431  22de		       29 20		      and	#%00100000	; Check for last character in key work
    432  22e0		       d0 f9		      bne	PrintKeyNext	; If it is not set then get next character
    433  22e2
    434  22e2		       98		      tya		; Trabsfer y to a for the addition
    435  22e3		       18		      clc		; Table > 256 bytes
    436  22e4		       65 54		      adc	R1
    437  22e6		       85 54		      sta	R1
    438  22e8		       a9 00		      lda	#0
    439  22ea		       65 55		      adc	R1+1
    440  22ec		       85 55		      sta	R1+1
    441  22ee		       4c d2 22 	      jmp	PrintKeyLoop
    442  22f1
    443  22f1				   PrintKeyFound
    444  22f1		       b1 54		      lda	(R1),y	; letter from key table
    445  22f3		       48		      pha		; Save it for later check
    446  22f4		       09 20		      ora	#%00100000	; Force it to lower case
    447  22f6		       20 1f 1a 	      jsr	VOUTCH	; Print it out
    448  22f9		       c8		      iny		; Point to next character
    449  22fa		       68		      pla		; Restore the value
    450  22fb		       29 20		      and	#%00100000	; Check if it was last char in keyword
    451  22fd		       d0 f2		      bne	PrintKeyFound	; Yes, then goto all done printing
    452  22ff
      0  22ff					      pullxy
      1  22ff		       7a		      ply
      2  2300		       fa		      plx
    454  2301
    455  2301				   PrintChkRem
    456  2301		       a9 0a		      lda	#kRem
    457  2303		       c5 52		      cmp	R0
    458  2305		       d0 11		      bne	PrintKeyDone
    459  2307				   PrintKeyRem
    460  2307		       a5 59		      lda	dpl	; if it is a rem then we must print the entire line
    461  2309		       85 5e		      sta	PrtFrom
    462  230b		       a5 5a		      lda	dpl+1
    463  230d		       85 5f		      sta	PrtFrom+1
    464  230f		       a9 00		      lda	#0
    465  2311		       8d e0 43 	      sta	PrtTerm
    466  2314		       20 c7 21 	      jsr	PrtLoop
    467  2317		       88		      dey		; point back to the terminating null value
    468  2318				   PrintKeyDone
    469  2318		       4c 75 22 	      jmp	PrintProgNext
    470  231b							;==================================================================================================================
    471  231b							;Print Variable, number or operator
    472  231b				   PrintProgOperator
    473  231b		       b1 59		      lda	(dpl),y
    474  231d		       c8		      iny
    475  231e		       ca		      dex
    476  231f		       8e 22 1d 	      stx	printStorage+2
    477  2322		       a2 00		      ldx	#0
    478  2324				   PrintOprLoop
    479  2324		       dd ba 1a 	      cmp	OperValues,x
    480  2327		       f0 03		      beq	PrintOprFound
    481  2329		       e8		      inx
    482  232a		       d0 f8		      bne	PrintOprLoop
    483  232c				   PrintOprFound
    484  232c		       8a		      txa
    485  232d		       0a		      asl
    486  232e		       aa		      tax
    487  232f		       bd 7c 1a 	      lda	Operators,x
    488  2332		       20 1f 1a 	      jsr	VOUTCH
    489  2335		       e8		      inx
    490  2336		       bd 7c 1a 	      lda	Operators,x
    491  2339		       f0 03		      beq	PrintOprDone
    492  233b		       20 1f 1a 	      jsr	VOUTCH
    493  233e				   PrintOprDone
    494  233e		       ae 22 1d 	      ldx	printStorage+2
    495  2341		       4c 75 22 	      jmp	PrintProgNext
    496  2344
    497  2344							;=================================================================================================================
    498  2344							;KeywordsMax	    equ     128 		   ; Allow to be range	1 to 127  key words, high order bit must be 0 for it to be a key word
    499  2344							;tVa		    equ     128 		   ; Variable A = 1, .... Z = 26   ^ = 27
    500  2344							;tVb		    equ     130 		   ; Variables 128 - 157  $80-$9D
    501  2344							;tVhat 	    equ     155 		   ; Variable ^
    502  2344							;tVhash	    equ     156 		   ; Variable #
    503  2344							;tVat		    equ     157 		   ; Variable @ = 0
    504  2344				   PrintProgVariable
    505  2344		       b1 59		      lda	(dpl),y
    506  2346		       c8		      iny
    507  2347		       ca		      dex
    508  2348		       c9 9b		      cmp	#tVhat
    509  234a		       d0 04		      bne	PrintProgChkHash
    510  234c		       a9 5e		      lda	#'^
    511  234e		       d0 15		      bne	PrintTheVar
    512  2350				   PrintProgChkHash
    513  2350		       c9 9c		      cmp	#tVhash
    514  2352		       d0 04		      bne	PrintProgChkAt
    515  2354		       a9 23		      lda	#'#
    516  2356		       d0 0d		      bne	PrintTheVar
    517  2358				   PrintProgChkAt
    518  2358		       c9 9d		      cmp	#tVat
    519  235a		       d0 04		      bne	PrintProgVarLetter
    520  235c		       a9 40		      lda	#'@
    521  235e		       d0 05		      bne	PrintTheVar
    522  2360				   PrintProgVarLetter
    523  2360		       29 7f		      and	#%01111111
    524  2362		       18		      clc
    525  2363		       69 41		      adc	#'A
    526  2365				   PrintTheVar
    527  2365		       20 1f 1a 	      jsr	VOUTCH
    528  2368		       4c 75 22 	      jmp	PrintProgNext
    529  236b
    530  236b							;==================================================================================================
    531  236b							; Size of print functions
    532  236b		       02 b8	   PrintFunctionsSize equ	* - PrintDecimal	; should use label of first fuction in file
------- FILE mytb.asm
------- FILE mem.asm LEVEL 2 PASS 6
      0  236b					      include	"mem.asm"
      1  236b							;===================================================================
      2  236b							;This file contains the memory allocation and free functions
      3  236b							; This is the management of free memory in the system
      4  236b							; the interface to these functions
      5  236b							; a,x returns or provides the low hi bytes of the managed addresses
      6  236b							; This uses the programend, to memory end as the area to manage
      7  236b							;===================================================================
      8 U372b					      Seg.u	TBData
      9 U372b							;
     10 U372b							;=====================================================
     11 U372b							;Pointers for memory Management
     12 U372b							;Allocated block are not chained but can be followed for all memory by the associated length
     13 U372b							; Mem block format is
     14 U372b							;	 0-1   pointer to next block for free blocks
     15 U372b							;	 0-1   for allocated blocks
     16 U372b							;	   0   type of block, blob | array bytes, ints ,string | single type byte or integer
     17 U372b							;	   1   refrence counter ... lol only up to 256 but it is something
     18 U372b							;	 2-3   length constant for exevy type of memory block
     19 U372b							; Memory is recombined as it is released
     20 U372b							; The memory manager is not interupted durring allocation
     21 U372b							; or freeing of memory
     22 U372b							;====================================================
     23 U372b		       00 00	   MemFreeList ds	2	; list of free blocks of memory
     24 U372d		       00 00	   MemR0      ds	2	; source for copy/move/Init
     25 U372f		       00 00	   MemR1      ds	2	; Destination for copy/move
     26 U3731							;=====================================================
     27  236b					      Seg	Code
     28  236b							;=====================================================
     29  236b				   MemInit
     30  236b		       a9 f6		      lda	#FreeMemStart&$FF
     31  236d		       8d ec 43 	      sta	ProgramStart
     32  2370		       8d ee 43 	      sta	ProgramEnd
     33  2373		       a9 43		      lda	#FreeMemStart>>8
     34  2375		       8d ed 43 	      sta	ProgramStart+1
     35  2378		       8d ef 43 	      sta	ProgramEnd+1
     36  237b
     37  237b		       20 85 23 	      jsr	GetSizes
     38  237e		       20 90 23 	      jsr	MemFree
     39  2381		       20 a8 23 	      jsr	MemUsed
     40  2384				   MemInitEnd
     41  2384		       60		      rts
     42  2385
     43  2385
     44  2385							;
     45  2385							;=====================================================
     46  2385							; This function might go away eventually, but was
     47  2385							; added to provide data for other pieces of code.
     48  2385							; It has some ties to the operating environment that
     49  2385							; will need to be customized for the target system.
     50  2385							;
     51  2385				   GetSizes
     52  2385							;
     53  2385							; Here is machine specific code to get the highest
     54  2385							; memory location that can be used by BASIC.
     55  2385							;
     56  2385				  -	      if	ProgramStart < $2000
     57  2385				  -	      lda	#$ff
     58  2385				  -	      sta	HighMem	;$13ff for KIM-1
     59  2385				  -	      sta	MemFreeList
     60  2385				  -	      lda	#$DE	;#$13
     61  2385				  -	      sta	HighMem+1
     62  2385				  -	      sta	MemFreeList+1
     63  2385					      else
     64  2385		       a9 ff		      lda	#$ff
     65  2387		       8d f0 43 	      sta	HighMem	;$CFFF otherwise
     66  238a		       a9 cf		      lda	#$cf
     67  238c		       8d f1 43 	      sta	HighMem+1
     68  238f					      endif
     69  238f		       60		      rts
     70  2390							;
     71  2390							; This computes the available memory remaining.
     72  2390							;
     73  2390				   MemFree
     74  2390		       38		      sec
     75  2391		       ad f0 43 	      lda	HighMem
     76  2394		       ed ee 43 	      sbc	ProgramEnd
     77  2397		       8d f4 43 	      sta	FreeMem
     78  239a		       85 52		      sta	R0
     79  239c		       ad f1 43 	      lda	HighMem+1
     80  239f		       ed ef 43 	      sbc	ProgramEnd+1
     81  23a2		       8d f5 43 	      sta	FreeMem+1
     82  23a5		       85 53		      sta	R0+1
     83  23a7		       60		      rts
     84  23a8							;
     85  23a8							; This computes the size of the current user program.
     86  23a8							;
     87  23a8				   MemUsed
     88  23a8		       38		      sec
     89  23a9		       ad ee 43 	      lda	ProgramEnd
     90  23ac		       ed ec 43 	      sbc	ProgramStart
     91  23af		       8d f2 43 	      sta	UsedMem
     92  23b2		       85 52		      sta	R0
     93  23b4		       ad ef 43 	      lda	ProgramEnd+1
     94  23b7		       ed ed 43 	      sbc	ProgramStart+1
     95  23ba		       8d f3 43 	      sta	UsedMem+1
     96  23bd		       85 53		      sta	R0+1
     97  23bf							;
     98  23bf		       60		      rts
     99  23c0							;
    100  23c0							;=====================================================
    101  23c0							; Set a block of memory to a value
      0  23c0				   iSetBlock  pushxy
      1  23c0		       da		      phx
      2  23c1		       5a		      phy
    103  23c2		       20 5b 2d 	      jsr	popR0	; the address to write to
    104  23c5		       a5 52		      lda	R0
    105  23c7		       85 59		      sta	dpl
    106  23c9		       a5 53		      lda	R0+1
    107  23cb		       85 5a		      sta	dpl+1
    108  23cd		       20 73 2d 	      jsr	popR1	; Number of bytes to write
    109  23d0		       20 5b 2d 	      jsr	popR0	; Get the value to store into memory
    110  23d3		       20 b6 2a 	      jsr	getILByte
    111  23d6		       85 58		      sta	R2	; store the data type into R2
    112  23d8		       c9 a4		      cmp	#tInteger
    113  23da		       f0 08		      beq	memset	; skip this if we have an integer
    114  23dc		       a5 52		      lda	R0	; Revers the order so they can be copied in correct order
    115  23de		       a6 53		      ldx	R0+1
    116  23e0		       86 52		      stx	R0
    117  23e2		       85 53		      sta	R0+1
    118  23e4
    119  23e4				   memset
    120  23e4		       a0 00		      ldy	#0	; Set for length of block to copy
    121  23e6		       a2 00		      ldx	#0	; set for number of block of 256 to copy
    122  23e8
    123  23e8		       a5 58	   iSetBlockLoop lda	R2	; Get Datatype
    124  23ea		       c9 a2		      cmp	#tByte
    125  23ec		       f0 09		      beq	iSetBlockB
    126  23ee
    127  23ee		       a5 52	   iSetBlockW lda	R0
    128  23f0		       91 59		      sta	(dpl),y
    129  23f2		       20 05 24 	      jsr	iSetBlockEnd
    130  23f5		       f0 09		      beq	iSetBlockComplete
    131  23f7
    132  23f7		       a5 53	   iSetBlockB lda	R0+1
    133  23f9		       91 59		      sta	(dpl),y
    134  23fb		       20 05 24 	      jsr	iSetBlockEnd
    135  23fe		       d0 e8		      bne	iSetBlockLoop
    136  2400
    137  2400				   iSetBlockComplete
      0  2400					      pullxy
      1  2400		       7a		      ply
      2  2401		       fa		      plx
    139  2402		       4c 9e 02 	      jmp	NextIL
    140  2405							;
    141  2405							; Check if we have reached the end of the initialization/Copy
    142  2405							;
    143  2405		       c8	   iSetBlockEnd iny
    144  2406		       d0 03		      bne	iSetBlockEndChk
    145  2408		       e8		      inx
    146  2409		       e6 5a		      inc	dpl+1
    147  240b				   iSetBlockEndChk
    148  240b		       c4 54		      cpy	R1
    149  240d		       d0 02		      bne	iSetBlockEndExit
    150  240f		       e4 55		      cpx	R1+1
    151  2411				   iSetBlockEndExit
    152  2411		       60		      rts
    153  2412							;
    154  2412							;================================================================
    155  2412							; Copy a block of memory from one location to another
    156  2412							;
      0  2412				   iCopyBlock pushxy
      1  2412		       da		      phx
      2  2413		       5a		      phy
    158  2414		       20 5b 2d 	      jsr	popR0	; get the source address
    159  2417		       20 73 2d 	      jsr	popR1	; Destination address
    160  241a		       a5 54		      lda	R1
    161  241c		       85 59		      sta	dpl
    162  241e		       a5 55		      lda	R1+1
    163  2420		       85 5a		      sta	dpl+1
    164  2422		       20 73 2d 	      jsr	popR1	; Number of bytes to copy
    165  2425				   memcpy
    166  2425		       a2 00		      ldx	#0
    167  2427		       a0 00		      ldy	#0
    168  2429				   iCopyBlockLoop
    169  2429		       b1 52		      lda	(R0),y	;  Get the byte to copy
    170  242b		       91 59		      sta	(dpl),y	;  Store the byte
    171  242d		       c8		      iny
    172  242e		       d0 05		      bne	iCopyChkEnd
    173  2430		       e8		      inx
    174  2431		       e6 53		      inc	R0+1
    175  2433		       e6 5a		      inc	dpl+1
    176  2435		       c4 54	   iCopyChkEnd cpy	R1
    177  2437		       d0 f0		      bne	iCopyBlockLoop
    178  2439		       e4 55		      cpx	R1+1
    179  243b		       d0 ec		      bne	iCopyBlockLoop
    180  243d				   iCopyBlockDone
      0  243d					      pullxy
      1  243d		       7a		      ply
      2  243e		       fa		      plx
    182  243f		       4c 9e 02 	      jmp	NextIL
    183  2442							;
    184  2442							;=============================================================================
    185  2442							; Compare memory block location
    186  2442							; returns on the stack
    187  2442							; 0 - equals
    188  2442							; -1 - s1  <  s2
    189  2442							; 1   s1  >  s2
      0  2442				   iCmpBlock  pushxy
      1  2442		       da		      phx
      2  2443		       5a		      phy
    191  2444		       20 73 2d 	      jsr	popR1	; Get the Source 2 pointer
    192  2447		       a5 54		      lda	R1
    193  2449		       85 59		      sta	dpl	; store the secon source in dpl
    194  244b		       a5 55		      lda	R1+1
    195  244d		       85 5a		      sta	dpl+1
    196  244f		       20 5b 2d 	      jsr	popR0	; Get the Source 1 pointer
    197  2452		       20 73 2d 	      jsr	popR1	; Get the length of the compare to do
    198  2455		       a0 00		      ldy	#0
    199  2457		       a2 00		      ldx	#0
    200  2459		       4c 66 24 	      jmp	iCmpCheckEnd
    201  245c
    202  245c		       b1 59	   iCmpLoop   lda	(dpl),y
    203  245e		       d1 52		      cmp	(R0),y
    204  2460		       d0 17		      bne	iCmpDone
    205  2462		       c8		      iny
    206  2463		       d0 01		      bne	iCmpCheckEnd
    207  2465		       e8		      inx
    208  2466				   iCmpCheckEnd
    209  2466		       c4 54		      cpy	R1
    210  2468		       d0 f2		      bne	iCmpLoop
    211  246a		       e4 55		      cpx	R1+1
    212  246c		       d0 ee		      bne	iCmpLoop
    213  246e		       a5 00		      lda	0
    214  2470		       85 53		      sta	R0+1
    215  2472		       85 52		      sta	R0
    216  2474				   iCmpReturn
      0  2474					      pullxy
      1  2474		       7a		      ply
      2  2475		       fa		      plx
    218  2476		       4c 06 07 	      jmp	pushR0nextIl
    219  2479
    220  2479				   iCmpDone
    221  2479		       90 0a		      bcc	iCmpGreater
    222  247b				   iCmpLess
    223  247b		       a9 00		      lda	#0
    224  247d		       85 53		      sta	R0+1
    225  247f		       a9 01		      lda	#1
    226  2481		       85 52		      sta	R0
    227  2483		       d0 ef		      bne	iCmpReturn
    228  2485				   iCmpGreater
    229  2485		       a9 ff		      lda	#-1
    230  2487		       85 52		      sta	R0
    231  2489		       85 53		      sta	R0+1
    232  248b		       d0 e7		      bne	iCmpReturn
    233  248d
------- FILE mytb.asm
------- FILE gosub_def.inc LEVEL 2 PASS 6
      0  248d					      include	"gosub_def.inc"
      1  248d							; Gosub stack definitions and structure information
      2  248d							; The gosub stack is used by, while, for, gosub, function parameters
      3  248d							; Task parameter passing as well, math stack frame info
      4  248d							;
      5  248d							;==================================================================
      6  248d							; gosub stack entry formats, always contains a typw identifier
      7  248d							; gosub: no return value, no parameters
      8  248d							; byte 0   : Math Stack pointer
      9  248d							; byte 1   : The number of parameters being passed on the math stack always 0
     10  248d							; byte 2   : Not used always 0
     11  248d							; byte 3   : type of entry #GOSUB_STACK_FRAME
     12  248d							;
     13  248d							; gosub with parameters, no return value
     14  248d							; byte 0   : Math Stack pointer
     15  248d							; byte 1   : The number of parameters being passed on the math stack 1-255
     16  248d							; byte 2   : Not used always 0
     17  248d							; byte 3   : type of entry #GOSUB_STACK_FRAME
     18  248d
     19  248d							; gosub with parameters, return value
     20  248d							; byte 0   : Math Stack pointer
     21  248d							; byte 1   : The number of parameters being passed on the math stack 1-255
     22  248d							; byte 2   : Not used always 0
     23  248d							; byte 3   : type of entry #GOSUB_STACK_FRAME
     24  248d							; Value is return in R0
     25  248d							;
     26  248d							; Task with parameters, return value always in variable array
     27  248d							;  For tasks just like gosub calls, the parameters are stored onto the match stack
     28  248d							;  and the parameter stack frame is stored onto the gosub stack
     29  248d
     30  248d							; For next step, continue, break
     31  248d							; byte: 0,1  pc counter to return to test
     32  248d							; byte: 2,3  pc counter to exit to
     33  248d							; byte: 4    type of entry #GOSUB_FOR
     34  248d
     35  248d							; while..wend, continue, break
     36  248d							; byte: 0,1  pc counter to return to test
     37  248d							; byte: 2.3  pc counter to exit to
     38  248d							; byte: 4    type of entry #GOSUB_WHILE
     39  248d
     40  248d							;
     41  248d							; Gosub entry types
     42  248d
     43  248d		       00 01	   GOSUB_RTN  equ	$01	; This is a simple gosub return
     44  248d		       00 81	   GOSUB_RTN_VALUE equ	$81	; subroutine will return a value
     45  248d		       00 02	   GOSUB_FOR  equ	2	; Return point for FOR..Next
     46  248d		       00 03	   GOSUB_While equ	3	; Return point for the While.. wend
     47  248d		       00 04	   GOSUB_MSG  equ	4	; this identifies the entry as an IPC message
     48  248d		       00 05	   GOSUB_STACK_FRAME equ	5	; used to contain the gosubs stackframe info when passing parameters
     49  248d							; 0 byte is the original stack offset, byte 1 is the parameter count
     50  248d							; 2 byte  is unused, 3 byte  is the type GOSUB_STACK_FRAME
     51  248d		       00 06	   GOSUB_STACK_SAVE equ	6	; SAVES THE FULL MATH STACK INFORMATION
     52  248d		       00 07	   GOSUB_SCRATCH_PAD equ	7	; Used when a work space is needed in il code
     53  248d
------- FILE mytb.asm
------- FILE gosub.asm LEVEL 2 PASS 6
      0  248d					      include	"gosub.asm"
      1  248d					      seg	Code
      2  248d
      3  248d							; Gosub and return related functions, While ..  Wend
      4  248d							;==========================================================
      5  248d							; Push the current math stack frame onto the gosub stack
      6  248d							;   the frame is really just the information about the area on the
      7  248d							;   math stack that contains the passed values as parameters
      8  248d				   iPushMathStack
      9  248d		       5a		      phy
     10  248e		       a4 4d		      ldy	GOSUBSTACKPTR
     11  2490		       a5 4a		      lda	MATHSTACKPTR
     12  2492		       91 4b		      sta	(GOSUBSTACK),y	; place the current Math stack ptr onto the stack
     13  2494		       a9 00		      lda	#0
     14  2496		       c8		      iny
     15  2497		       91 4b		      sta	(GOSUBSTACK),y	; place a zero for the number of current parameters
     16  2499		       c8		      iny
     17  249a		       91 4b		      sta	(GOSUBSTACK),y	; Place a zero for the next byte
     18  249c		       c8		      iny
     19  249d		       a9 05		      lda	#GOSUB_STACK_FRAME
     20  249f		       91 4b		      sta	(GOSUBSTACK),y	; store the type of entry on the stack as the last byte
     21  24a1		       c8		      iny
     22  24a2		       84 4d		      sty	GOSUBSTACKPTR	; save the pointer into the gosub stack
     23  24a4		       7a		      ply
     24  24a5		       4c 9e 02 	      jmp	NextIL
     25  24a8							;
     26  24a8							;==========================================================
     27  24a8							; Increment parameter count. Assume Stack frame is top of stack
     28  24a8				   iIncParmCount
     29  24a8		       5a		      phy
     30  24a9
     31  24a9		       a4 4d		      ldy	GOSUBSTACKPTR	; get the pointer to update the stack entry
     32  24ab		       88		      dey		; point to the type of entry #GOSUB_STACK_FRAME
     33  24ac		       88		      dey		; point to the previous byte
     34  24ad		       88		      dey		; point to the count of parameters up to 255
     35  24ae		       b1 4b		      lda	(GOSUBSTACK),y	; get the count
     36  24b0		       18		      clc
     37  24b1		       69 01		      adc	#1	; increment the count
     38  24b3		       91 4b		      sta	(GOSUBSTACK),y	; save the updated count
     39  24b5
     40  24b5		       7a		      ply
     41  24b6		       4c 9e 02 	      jmp	NextIL
     42  24b9							;
     43  24b9							;==========================================================
     44  24b9							;Restore the math stack frame, removing parameters from stop
     45  24b9							;of the math stack
     46  24b9							;
     47  24b9		       20 bf 24    iPopMathStack jsr	PopMathStackNow
     48  24bc		       4c 9e 02 	      jmp	NextIL
     49  24bf
     50  24bf				   PopMathStackNow
     51  24bf		       5a		      phy
     52  24c0
     53  24c0		       a4 4d		      ldy	GOSUBSTACKPTR
     54  24c2		       88		      dey
     55  24c3		       b1 4b		      lda	(GOSUBSTACK),y
     56  24c5		       c9 05		      cmp	#GOSUB_STACK_FRAME
     57  24c7		       d0 09		      bne	iPopMathStackNoFrame
     58  24c9		       88		      dey
     59  24ca		       88		      dey
     60  24cb		       88		      dey
     61  24cc		       b1 4b		      lda	(GOSUBSTACK),y
     62  24ce		       85 4a		      sta	MATHSTACKPTR
     63  24d0		       84 4d		      sty	GOSUBSTACKPTR
     64  24d2
     65  24d2				   iPopMathStackNoFrame
     66  24d2
     67  24d2		       7a		      ply
     68  24d3		       60		      rts
     69  24d4
     70  24d4							;==========================================================
     71  24d4							; Push the current math stack information onto the gosub stack
     72  24d4				   iSaveMathStack
     73  24d4		       5a		      phy
     74  24d5
     75  24d5		       a4 4d		      ldy	GOSUBSTACKPTR
     76  24d7		       a5 4a		      lda	MATHSTACKPTR
     77  24d9		       91 4b		      sta	(GOSUBSTACK),y
     78  24db		       a5 48		      lda	MATHSTACK
     79  24dd		       c8		      iny
     80  24de
     81  24de		       91 4b		      sta	(GOSUBSTACK),y
     82  24e0		       c8		      iny
     83  24e1
     84  24e1		       a5 49		      lda	MATHSTACK+1
     85  24e3		       91 4b		      sta	(GOSUBSTACK),y
     86  24e5		       c8		      iny
     87  24e6
     88  24e6		       a9 06		      lda	#GOSUB_STACK_SAVE
     89  24e8		       91 4b		      sta	(GOSUBSTACK),y
     90  24ea		       c8		      iny
     91  24eb
     92  24eb		       84 4d		      sty	GOSUBSTACKPTR
     93  24ed
     94  24ed		       7a		      ply
     95  24ee		       4c 9e 02 	      jmp	NextIL
     96  24f1							;
     97  24f1							;==========================================================
     98  24f1							;Restore the math stack information from the gosub stack
     99  24f1				   iRestoreMathStack
    100  24f1		       5a		      phy
    101  24f2
    102  24f2		       a5 4a		      lda	MATHSTACKPTR
    103  24f4		       85 58		      sta	R2	; save the current offset for whatever task to R2
    104  24f6
    105  24f6		       a4 4d		      ldy	GOSUBSTACKPTR
    106  24f8		       88		      dey
    107  24f9		       b1 4b		      lda	(GOSUBSTACK),y
    108  24fb		       c9 06		      cmp	#GOSUB_STACK_SAVE
    109  24fd		       d0 15		      bne	iPopMathStack_Err
    110  24ff		       88		      dey
    111  2500		       b1 4b		      lda	(GOSUBSTACK),y
    112  2502		       85 49		      sta	MATHSTACK+1
    113  2504		       88		      dey
    114  2505		       b1 4b		      lda	(GOSUBSTACK),y
    115  2507		       85 48		      sta	MATHSTACK
    116  2509		       88		      dey
    117  250a		       b1 4b		      lda	(GOSUBSTACK),y
    118  250c		       85 4a		      sta	MATHSTACKPTR
    119  250e		       84 4d		      sty	GOSUBSTACKPTR
    120  2510
    121  2510		       7a		      ply
    122  2511		       4c 9e 02 	      jmp	NextIL
    123  2514
    124  2514				   iPopMathStack_Err
    125  2514		       7a		      ply
    126  2515		       a9 00		      lda	#0
    127  2517		       a2 12		      ldx	#ERR_INVALID_STK_FRAME
    128  2519		       4c 66 06 	      jmp	iErr2
    129  251c							;===========================================================
    130  251c							; For functions and tasks the variable address of # means
    131  251c							; a passed parameter so #[0] is the first parameter etc
    132  251c							; will try for a better way later
    133  251c							;============================================================
    134  251c							; On entry il, branch to if function
    135  251c							;	    il+1, value to be returned or not true or false
    136  251c							;
    137  251c							; Return from GOSUB  or function function
    138  251c							; format   RSTR 0   --- return form gosub
    139  251c							;	    RSTR 1   --- return from Function
    140  251c							;
    141  251c		       20 b6 2a    iRSTR      jsr	getILByte	; get where to go if 0 = gosub/1=function call
    142  251f		       8d e4 43 	      sta	offset
    143  2522		       20 99 2c 	      jsr	saveIL	; for later jump if needed add extra entry to	the return stack
    144  2525
    145  2525		       20 0c 2d 	      jsr	popLN	; get the next item from the stack into curptr and curroff, returns call type func or stmt
    146  2528		       85 54		      sta	R1	; keep the type of call returning from
    147  252a		       b0 2b		      bcs	iRSTRErr	; stack underflow error possible
    148  252c
    149  252c		       20 b6 2a 	      jsr	getILByte	; get if a value is being returned
    150  252f
    151  252f		       48		      pha		; save if a value was passed to be returned
    152  2530
    153  2530		       c9 00		      cmp	#0	; yes attemping to return a value
    154  2532		       f0 03		      beq	iRSTRPOP	; no value to return
    155  2534		       20 5b 2d 	      jsr	popR0	; Get the value from the stack save if needed
    156  2537
    157  2537				   iRSTRPOP
    158  2537		       20 bf 24 	      jsr	PopMathStackNow	; adjust the stack frame from the call
    159  253a		       a5 54		      lda	R1	; called as a statement ?
    160  253c		       c9 01		      cmp	#GOSUB_RTN	; Called as a statement
    161  253e		       f0 13		      beq	iRSTRExit
    162  2540
    163  2540		       68		      pla		; get back if value returned or not
    164  2541		       c9 01		      cmp	#1	; we have a value to return
    165  2543		       f0 05		      beq	iRSTRVALUE
    166  2545
    167  2545		       a2 13		      ldx	#ERR_NO_RETURN_VALUE_PROVIDED	; well no value provided and we need one
    168  2547		       4c fb 04 	      jmp	iSAVErr2	; jump to general error reporting function
    169  254a
    170  254a				   iRSTRVALUE
    171  254a		       20 af 2c 	      jsr	pushR0	; return value back to top of stack
    172  254d		       20 a4 2c 	      jsr	restoreIL	; get the correct il
    173  2550		       4c c0 0b 	      jmp	tstBranch	; And called as a function
    174  2553
    175  2553				   iRSTRExit
    176  2553		       68		      pla		; throw away gosub/func flag
    177  2554		       4c 9e 02 	      jmp	NextIL
    178  2557
    179  2557				   iRSTRNORETURNVALUE
    180  2557
    181  2557		       ad 73 37    iRSTRErr   lda	taskPtr	; Check if this is task zero
    182  255a		       f0 0a		      beq	taskZeroEnd	; this is task zero just stop with error
    183  255c		       a5 56		      lda	MQ
    184  255e		       d0 03		      bne	taskRet
    185  2560		       20 95 2f 	      jsr	pushFalse	; the result code by default is 0
    186  2563				   taskRet
    187  2563		       4c bb 28 	      jmp	iETask	; not task zero then do a task end instead
    188  2566				   taskZeroEnd
    189  2566		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    190  2568		       4c fb 04 	      jmp	iSAVErr2
    191  256b							;
    192  256b							;==========================================================================================
    193  256b							; Find the next gosub function parameter info	position on the stack
    194  256b							; Returns y = index and c set if found clear c otherwise
    195  256b		       a4 4d	   GosubFindParms ldy	GOSUBSTACKPTR	;Get the Pointer to the top of stack
    196  256d		       88		      dey		;Point to stack entry type
    197  256e
    198  256e							;Veryify the stack size and position for the call
    199  256e							;Loops here until it finds a GOSUB with value entry or gosub-rtn entry
    200  256e
    201  256e		       c0 00	   GosubFindLoop cpy	#0	;If we reach the top of the stack then no parametrs
    202  2570		       f0 2d		      beq	GosubNotFunc
    203  2572		       c0 10		      cpy	#GOSUBSTACKSIZE	;Tst if we are outside the stack size
    204  2574		       b0 29		      bcs	GosubNotFunc	;Not valid
    205  2576
    206  2576							;Look for the	 GOSUB_RTN_VALUE stack position
    207  2576		       b1 4b		      lda	(GOSUBSTACK),y	;Get the type of call - if it is not a fn call error
    208  2578		       c9 01		      cmp	#GOSUB_RTN	;if we find this then this function had no parameters
    209  257a		       f0 0f		      beq	GosubParmFnd	;We can pass parameters to a function that returns nothing
    210  257c
    211  257c		       c9 81		      cmp	#GOSUB_RTN_VALUE	;Parameters with the gosub call
    212  257e		       f0 0b		      beq	GosubParmFnd	;Skip any non Gosub related entries
    213  2580
    214  2580		       c9 05		      cmp	#GOSUB_STACK_FRAME	;Stack frame pointer So should contain the start position of Variables
    215  2582		       f0 13		      beq	GosubParmSkip	;We have a stackframe good
    216  2584
    217  2584		       88		      dey
    218  2585		       88		      dey
    219  2586		       88		      dey
    220  2587		       88		      dey
    221  2588		       4c 6e 25 	      jmp	GosubFindLoop
    222  258b
    223  258b		       c0 03	   GosubParmFnd cpy	#3	; Check if we are outside the stack
    224  258d		       90 10		      bcc	GosubNotFunc	; if y < 3 then error not found
    225  258f		       c0 10		      cpy	#GOSUBSTACKSIZE	; Largest value
    226  2591		       b0 0c		      bcs	GosubNotFunc	; no parameters passed
    227  2593
    228  2593		       88		      dey		; Point to hopefully Math Stack frame information
    229  2594		       88		      dey
    230  2595		       88		      dey
    231  2596		       88		      dey
    232  2597				   GosubParmSkip
    233  2597		       b1 4b		      lda	(GOSUBSTACK),y	;This should be a stack frame pointer
    234  2599		       c9 05		      cmp	#GOSUB_STACK_FRAME	;Stack frame pointer So should contain the start position of Variables
    235  259b		       d0 02		      bne	GosubNotFunc	;No parameters passed but expected
    236  259d		       38		      sec
    237  259e		       60		      rts
    238  259f
    239  259f		       18	   GosubNotFunc clc
    240  25a0		       60		      rts
    241  25a1
    242  25a1							;==========================================================================
    243  25a1							; This section support while..wend, for x = <expr> to <expr> [ step <expr> ] ... next
    244  25a1							;
    245  25a1							;===========================================================================
    246  25a1							; Begin a block of code, while, if endif, for next etc
    247  25a1							; on entry x contains the type of block being created
    248  25a1							; format WendPtr.wendptr,curptr,curptr+1,curoff,type
    249  25a1				   iBeginBlock
    250  25a1		       5a		      phy
    251  25a2		       20 b6 2a 	      jsr	getILByte	; get the type of block we are starting
    252  25a5		       85 54		      sta	R1
    253  25a7		       20 b6 2a 	      jsr	getILByte	; get the closing block marker
    254  25aa		       85 55		      sta	R1+1
    255  25ac		       20 cb 25 	      jsr	FindEndBlock	; push the endblock onto the stack
    256  25af
    257  25af		       a4 4d		      ldy	GOSUBSTACKPTR	; get the top of stack
    258  25b1		       a5 4f		      lda	CURPTR	; get the first byte of the program line
    259  25b3		       91 4b		      sta	(GOSUBSTACK),y	; place the current Math stack ptr onto the stack
    260  25b5		       c8		      iny		; Next byte to save
    261  25b6		       a5 50		      lda	CURPTR+1	; get the second byte of the program line
    262  25b8		       91 4b		      sta	(GOSUBSTACK),y	; place the current Math stack ptr onto the stack
    263  25ba		       c8		      iny
    264  25bb		       a5 51		      lda	CUROFF	; get the offset on the line
    265  25bd		       91 4b		      sta	(GOSUBSTACK),y	; place a zero for the number of current parameters
    266  25bf		       c8		      iny
    267  25c0		       a5 54		      lda	R1	; get the type of block to save
    268  25c2		       91 4b		      sta	(GOSUBSTACK),y	; store the type of entry on the stack as the last byte
    269  25c4		       c8		      iny
    270  25c5		       84 4d		      sty	GOSUBSTACKPTR	; save the pointer into the gosub stack
    271  25c7		       7a		      ply
    272  25c8		       4c 9e 02 	      jmp	NextIL
    273  25cb							;=================================================================================
    274  25cb							;find the end block, account for nested begin types
    275  25cb							;stores the address of the memory location to the next two byte on the gosub stack
    276  25cb							;return cleared carry if good, sets the carry if failed
    277  25cb							;R1 = begin block value, R1+1 = end block value, r2 is the balanced counter
    278  25cb							;
    279  25cb		       a5 4f	   FindEndBlock lda	CURPTR	; preserve the current line number
    280  25cd		       48		      pha
    281  25ce		       a5 50		      lda	CURPTR+1
    282  25d0		       48		      pha
    283  25d1		       a5 51		      lda	CUROFF
    284  25d3		       48		      pha
    285  25d4		       a9 00		      lda	#0
    286  25d6		       85 58		      sta	R2
    287  25d8				   FindEndBlkLoop
    288  25d8		       20 40 2b 	      jsr	FindNextLine	; CURPTR now points to the next line, CUROFF is location of first char
    289  25db		       20 54 2b 	      jsr	AtEnd	; At end of program
    290  25de		       f0 36		      beq	FindEof	; Branch out if at end of program
    291  25e0		       a4 51		      ldy	CUROFF	; this is where the kwhend or kwhile will be stored for example
    292  25e2		       a5 54		      lda	R1	; get the start block value
    293  25e4		       d1 4f		      cmp	(CURPTR),y	; test for a match
    294  25e6		       f0 11		      beq	Findincr2	; inc it and continue
    295  25e8		       a5 55		      lda	R1+1	; get the end of block value
    296  25ea		       d1 4f		      cmp	(CURPTR),y	; is it end block
    297  25ec		       d0 ea		      bne	FindEndBlkLoop	; check the next line
    298  25ee		       a5 58		      lda	R2	; check if we are at level 0
    299  25f0		       c9 00		      cmp	#0
    300  25f2		       f0 0a		      beq	FindFound
    301  25f4		       c6 58		      dec	R2	; reduce it by one
    302  25f6		       4c d8 25 	      jmp	FindEndBlkLoop	; do the next one
    303  25f9				   Findincr2
    304  25f9		       e6 58		      inc	R2
    305  25fb		       4c d8 25 	      jmp	FindEndBlkLoop
    306  25fe				   FindFound
    307  25fe		       a4 4d		      ldy	GOSUBSTACKPTR	; place the location of end block onto the gosub stack
    308  2600		       a5 4f		      lda	CURPTR
    309  2602		       91 4b		      sta	(GOSUBSTACK),y
    310  2604		       c8		      iny
    311  2605		       a5 50		      lda	CURPTR+1
    312  2607		       91 4b		      sta	(GOSUBSTACK),y
    313  2609		       c8		      iny
    314  260a		       84 4d		      sty	GOSUBSTACKPTR
    315  260c
    316  260c		       68		      pla
    317  260d		       85 51		      sta	CUROFF
    318  260f		       68		      pla		; restore the original line pointer
    319  2610		       85 50		      sta	CURPTR+1
    320  2612		       68		      pla
    321  2613		       85 4f		      sta	CURPTR
    322  2615
    323  2615		       60		      rts
    324  2616				   FindEof		; the matching closing block id not found
    325  2616		       a2 1c		      ldx	#ERR_NO_MATCHING_END_BLOCK
    326  2618		       4c fb 04 	      jmp	iSAVErr2
    327  261b							;
    328  261b							;==================================================================================
    329  261b							;Find end of block and set the user pc to it
    330  261b							;
    331  261b		       20 b6 2a    iJmpEnd    jsr	getILByte	; get the type of loop
    332  261e		       48		      pha
    333  261f		       a4 4d		      ldy	GOSUBSTACKPTR	; get the top of stack
    334  2621		       c0 00		      cpy	#0	; empty stack?
    335  2623		       f0 45		      beq	iJmpErrNoEntry
    336  2625		       88		      dey
    337  2626		       68		      pla
    338  2627		       d1 4b		      cmp	(GOSUBSTACK),y	; check if it is the correct type of entry
    339  2629		       d0 3a		      bne	iJmpErrInvalid	; Wrong type of entry
    340  262b		       88		      dey		; remove the entry from the stack
    341  262c		       88		      dey
    342  262d		       88		      dey
    343  262e		       88		      dey
    344  262f		       b1 4b		      lda	(GOSUBSTACK),y	; get the byte of curptr
    345  2631		       85 50		      sta	CURPTR+1
    346  2633		       88		      dey
    347  2634		       b1 4b		      lda	(GOSUBSTACK),y	; get the byte of curptr
    348  2636		       85 4f		      sta	CURPTR
    349  2638		       84 4d		      sty	GOSUBSTACKPTR
    350  263a		       a9 03		      lda	#3
    351  263c		       85 51		      sta	CUROFF
    352  263e
    353  263e		       4c 9e 02 	      jmp	NextIL	; if true then
    354  2641
    355  2641							;===========================================================================
    356  2641							; Jump back to the start of a block, look onto gosub stack for the while entry
    357  2641							; get the next il byte to determin which kind of block to process, while,for,if endif
    358  2641		       5a	   iJmpStart  phy
    359  2642		       20 b6 2a 	      jsr	getILByte	; get the type of block we are looking for
    360  2645		       48		      pha
    361  2646		       a4 4d		      ldy	GOSUBSTACKPTR	; the single byte offset to be used
    362  2648		       c0 00		      cpy	#0	; if it is zero bad juju
    363  264a		       f0 1e		      beq	iJmpErrNoEntry	; if it is zero then stack is empty get out
    364  264c		       88		      dey		; point to entry type on the stack
    365  264d		       68		      pla		; get type we are looking for
    366  264e		       d1 4b		      cmp	(GOSUBSTACK),y	; Check if it is the correct type of entry
    367  2650		       d0 13		      BNE	iJmpErrInvalid	; not the expected block type
    368  2652		       88		      dey
    369  2653		       b1 4b		      lda	(GOSUBSTACK),y	; get the correct offset of user program
    370  2655		       85 51		      sta	CUROFF	; offset on text line
    371  2657		       88		      dey
    372  2658		       b1 4b		      lda	(GOSUBSTACK),y	; get line start
    373  265a		       85 50		      sta	CURPTR+1
    374  265c		       88		      dey
    375  265d		       b1 4b		      lda	(GOSUBSTACK),y	; part of line start
    376  265f		       85 4f		      sta	CURPTR
    377  2661		       7a		      ply
    378  2662		       4c 9e 02 	      jmp	NextIL	; ignore for now
    379  2665
    380  2665		       a2 1b	   iJmpErrInvalid ldx	#ERR_NO_MATCHING_BEGIN_BLOCK
    381  2667		       4c fb 04 	      jmp	iSAVErr2
    382  266a
    383  266a		       68	   iJmpErrNoEntry pla
    384  266b		       7a		      ply
    385  266c		       a2 0b		      ldx	#ERR_STACK_UNDER_FLOW
    386  266e		       4c fb 04 	      jmp	iSAVErr2
    387  2671							;
    388  2671							;=======================================================================================
    389  2671							;Branch types
    390  2671				   iIfTrue
    391  2671		       20 b6 2a 	      jsr	getILByte
    392  2674		       8d e4 43 	      sta	offset
    393  2677		       20 5b 2d 	      jsr	popR0
    394  267a		       a5 52		      lda	R0
    395  267c		       05 53		      ora	R0+1
    396  267e		       f0 15		      beq	iftestfailed
    397  2680		       4c c0 0b 	      jmp	tstBranch
    398  2683				   iIfFalse
    399  2683		       20 b6 2a 	      jsr	getILByte
    400  2686		       8d e4 43 	      sta	offset
    401  2689		       20 5b 2d 	      jsr	popR0
    402  268c		       a5 52		      lda	R0
    403  268e		       05 53		      ora	R0+1
    404  2690		       d0 03		      bne	iftestfailed
    405  2692		       4c c0 0b 	      jmp	tstBranch
    406  2695				   iftestfailed
    407  2695		       4c 9e 02 	      jmp	NextIL
------- FILE mytb.asm
------- FILE tasks.asm LEVEL 2 PASS 6
      0  2698					      include	"tasks.asm"
      1  2698							;=====================================================
      2  2698							; Tiny Basic IL task management
      3  2698							; Data required by task management
      4  2698							; currently each context is about 30 bytes and is swapped
      5  2698							; into and out of page zero on each task switch....
      6  2698							; LOL yes it is slow, but works for this iteration.
      7  2698							;
      8  2698
      9  2698					      Seg	Code
     10  2698							;=====================================================
     11  2698							; Sets the pointers to the math,IL and gosub stacks
     12  2698							; Creates the initial Context for each task slot
     13  2698				   taskSetStacks
     14  2698		       a9 73		      lda	#mathStack&$FF
     15  269a		       85 48		      sta	MATHSTACK
     16  269c		       a9 38		      lda	#mathStack>>8
     17  269e		       85 49		      sta	MATHSTACK+1
     18  26a0
     19  26a0		       a9 03		      lda	#ilStack&$ff
     20  26a2		       85 45		      sta	ILSTACK
     21  26a4		       a9 3a		      lda	#ilStack>>8
     22  26a6		       85 46		      sta	ILSTACK+1
     23  26a8
     24  26a8		       a9 eb		      lda	#gosubStack&$FF
     25  26aa		       85 4b		      sta	GOSUBSTACK
     26  26ac		       a9 3d		      lda	#gosubStack>>8
     27  26ae		       85 4c		      sta	GOSUBSTACK+1
     28  26b0
     29  26b0		       a9 6b		      lda	#variableStack&$FF
     30  26b2		       85 41		      sta	VARIABLES
     31  26b4		       a9 40		      lda	#variableStack>>8
     32  26b6		       85 42		      sta	VARIABLES+1
     33  26b8		       a2 0a		      ldx	#TASKCOUNT
     34  26ba		       a0 00		      ldy	#0
     35  26bc		       20 77 29 	      jsr	ContextSave	; Save the Task 0 context
     36  26bf
     37  26bf		       c0 fa	   taskSetLoop cpy	#TASKTABLELEN
     38  26c1		       b0 3a		      bcs	taskSetDone
     39  26c3
     40  26c3		       a5 4b		      lda	GOSUBSTACK
     41  26c5		       18		      clc
     42  26c6		       69 40		      adc	#GOSUBSTACKSIZE*4	; must be less than 256
     43  26c8		       85 4b		      sta	GOSUBSTACK
     44  26ca		       a5 4c		      lda	GOSUBSTACK+1
     45  26cc		       69 00		      adc	#0
     46  26ce		       85 4c		      sta	GOSUBSTACK+1
     47  26d0
     48  26d0		       a5 45		      lda	ILSTACK	; must be less than 256
     49  26d2		       18		      clc
     50  26d3		       69 64		      adc	#ILSTACKSIZE*2
     51  26d5		       85 45		      sta	ILSTACK
     52  26d7		       a5 46		      lda	ILSTACK+1
     53  26d9		       69 00		      adc	#0
     54  26db		       85 46		      sta	ILSTACK+1
     55  26dd
     56  26dd		       a5 48		      lda	MATHSTACK	; must be less than 256
     57  26df		       18		      clc
     58  26e0		       69 28		      adc	#MATHSTACKSIZE*2
     59  26e2		       85 48		      sta	MATHSTACK
     60  26e4		       a5 49		      lda	MATHSTACK+1
     61  26e6		       69 00		      adc	#0
     62  26e8		       85 49		      sta	MATHSTACK+1
     63  26ea
     64  26ea		       a5 41		      lda	VARIABLES	; must be less than 256
     65  26ec		       18		      clc
     66  26ed		       69 4a		      adc	#VARIABLESSIZE*2
     67  26ef		       85 41		      sta	VARIABLES
     68  26f1		       a5 42		      lda	VARIABLES+1
     69  26f3		       69 00		      adc	#0
     70  26f5		       85 42		      sta	VARIABLES+1
     71  26f7		       20 77 29 	      jsr	ContextSave
     72  26fa		       4c bf 26 	      jmp	taskSetLoop
     73  26fd
     74  26fd				   taskSetDone
     75  26fd		       a0 00		      ldy	#0	; reload the main loop context
     76  26ff		       20 86 29 	      jsr	ContextLoad
     77  2702		       60		      rts
     78  2703							;
     79  2703							;============================================================
     80  2703							; Saves the io block to the context
     81  2703
     82  2703
      0  2703				   SaveIOblock pushxy
      1  2703		       da		      phx
      2  2704		       5a		      phy
     84  2705
     85  2705							; what the heck.... did i forget something
     86  2705
      0  2705					      pullxy
      1  2705		       7a		      ply
      2  2706		       fa		      plx
     88  2707		       60		      rts
     89  2708
     90  2708							;
     91  2708							;=====================================================
     92  2708							; In some error cases the math stacks may be left pointing to the wrong stack
     93  2708							; This function will reset those stack addresses but not the actual pointer
     94  2708				   taskResetStacks
     95  2708		       a0 00		      ldy	#0
     96  270a		       20 86 29 	      jsr	ContextLoad
     97  270d		       4c 98 26 	      jmp	taskSetStacks
     98  2710							;
     99  2710							;=====================================================
    100  2710							; Clear all task entries and task stacks
    101  2710		       5a	   taskReset  phy
    102  2711		       a9 01		      lda	#1
    103  2713		       8d 72 38 	      sta	taskCounter	; Set number of active tasks to 1
    104  2716		       ac 73 37 	      ldy	taskPtr	; Set the active task to 0 MAIN
    105  2719		       c0 00		      cpy	#0	; check if we are the main context
    106  271b		       f0 08		      beq	taskResetCont	; if we are just continue
    107  271d
    108  271d		       a0 00		      ldy	#0	; else we need to switch to the main context
    109  271f		       8c 73 37 	      sty	taskPtr
    110  2722		       20 86 29 	      jsr	ContextLoad	; load the System Task context
    111  2725				   taskResetCont
    112  2725		       a0 19		      ldy	#CONTEXTLEN	; Start at the second task +1 account for task control byte
    113  2727
    114  2727				   taskResetLoop
    115  2727		       a9 00		      lda	#TASKINACTIVE
    116  2729		       99 74 37 	      sta	taskTable,y	; Ensure that the task is made inactive
    117  272c		       18		      clc
    118  272d		       98		      tya
    119  272e		       69 19		      adc	#CONTEXTLEN
    120  2730		       a8		      tay
    121  2731		       c0 fa		      cpy	#TASKTABLELEN	; Are we at the end yet
    122  2733		       90 f2		      bcc	taskResetLoop	; Go for more
    123  2735
    124  2735				   taskResetComplete
    125  2735
    126  2735		       7a		      ply
    127  2736		       60		      rts
    128  2737
    129  2737							;
    130  2737							;======================================================
    131  2737							; iTaskSwitch	 switch to new task if not interrupt and
    132  2737							;		 count is exceded for task time slice gets here
    133  2737							;		 when time slice has reached zero
    134  2737							;
    135  2737		       5a	   iTaskSwitch phy
    136  2738
    137  2738		       ad 70 38 	      lda	taskResetValue	; Always reset the counter value
    138  273b		       8d 6e 38 	      sta	taskCurrentCycles	; Update the counter with the new value
    139  273e		       ce 6f 38 	      dec	taskCurrentCycles+1	; dec high order byte
    140  2741		       d0 44		      bne	iTaskSwitchDone	; Exit if not zero
    141  2743
    142  2743		       ad 71 38 	      lda	taskResetValue+1
    143  2746		       8d 6f 38 	      sta	taskCurrentCycles+1
    144  2749
    145  2749		       ad 84 19 	      lda	IRQPending	; Skip this if we are processing an irq
    146  274c		       0d e6 43 	      ora	taskIOPending	; If set then don't switch
    147  274f		       d0 36		      bne	iTaskSwitchDone	; DO irq Higher priority than the Tasks
    148  2751
    149  2751		       ad 72 38    iTaskMain  lda	taskCounter	; Number of tasks
    150  2754		       c9 01		      cmp	#1	; if there is only one task must be main
    151  2756		       d0 07		      bne	itasknext	; if it some other number continue to next
    152  2758
    153  2758		       ac 73 37 	      ldy	taskPtr	; check if we have not just ended some other task
    154  275b		       d0 02		      bne	itasknext	; 0 = main task if so then do a next anyway
    155  275d		       f0 28		      beq	iTaskSwitchDone	; Skip this if main is only task
    156  275f							;
    157  275f							; Save the current context this is moved from BASIC STMT LEVEL TO IL INSTRUCTION LEVEL
    158  275f							;
    159  275f				   itasknext
    160  275f		       ac 73 37 	      ldy	taskPtr
    161  2762		       20 77 29 	      jsr	ContextSave	; Save the current context, y points to next context
    162  2765				   itaskLoop
    163  2765		       c0 fa		      cpy	#TASKTABLELEN	; Are we at end of task table
    164  2767		       90 04		      bcc	iTaskNextChk
    165  2769
    166  2769		       a0 00	   iTaskResetTop ldy	#0	; reset to top of taskTable
    167  276b		       f0 0d		      beq	iTaskLoadEntry	; Go Ahead and just start this As we Can back and it is always active
    168  276d
    169  276d				   iTaskNextChk
    170  276d		       b9 74 37 	      lda	taskTable,y	; there is always at least one entry in table
    171  2770		       d0 08		      bne	iTaskLoadEntry	; get next slot if this one empty
    172  2772		       18	   iTaskNext  clc
    173  2773		       98		      tya
    174  2774		       69 19		      adc	#CONTEXTLEN	; Next Table entry
    175  2776		       a8		      tay
    176  2777		       4c 65 27 	      jmp	itaskLoop	; Check for busy entry
    177  277a
    178  277a		       a9 80	   iTaskLoadEntry lda	#TASKACTIVE
    179  277c		       59 74 37 	      eor	taskTable,y	; Check for anything waiting io
    180  277f		       d0 f1		      bne	iTaskNext
    181  2781		       20 86 29 	      jsr	ContextLoad	; load the next context
    182  2784		       8c 73 37 	      sty	taskPtr	; update the task pointer
    183  2787
    184  2787				   iTaskSwitchDone
    185  2787		       7a		      ply
    186  2788		       60		      rts
    187  2789							;
    188  2789							;================================================================
    189  2789							; Task Set task number to line number to start
    190  2789							; on entry stack contains, type of line description and  memvector or linenumber
    191  2789							; Task Table structure:
    192  2789							;    byte 0	-   Active inactive
    193  2789							;    byte 1-2	-   Basic code line pointer
    194  2789							;    byte 3	-   Offset on current line
    195  2789		       5a	   iTaskSet   phy		; push a
    196  278a		       20 73 2d 	      jsr	popR1	; Get if compiled or line number expression
    197  278d		       20 5b 2d 	      jsr	popR0	; Get the line number to be saved
    198  2790
    199  2790
    200  2790
    201  2790		       ac 73 37 	      ldy	taskPtr	; find out where we are
    202  2793		       20 77 29 	      jsr	ContextSave	; Save the current context
    203  2796
    204  2796							;Find the pointer to the line we need to start at
    205  2796		       a5 54		      lda	R1
    206  2798		       f0 0b		      beq	iTaskLineNum
    207  279a		       a5 52		      lda	R0
    208  279c		       85 4f		      sta	CURPTR
    209  279e		       a5 53		      lda	R0+1
    210  27a0		       85 50		      sta	CURPTR+1
    211  27a2		       4c b4 27 	      jmp	iTaskCont
    212  27a5
    213  27a5				   iTaskLineNum
    214  27a5		       20 fb 2a 	      jsr	findLine	; Get the offset of the line to start task at
    215  27a8		       f0 0a		      beq	iTaskCont
    216  27aa
    217  27aa		       ac 73 37 	      ldy	taskPtr	; Restore the original Context Error Exit
    218  27ad		       20 86 29 	      jsr	ContextLoad
    219  27b0
    220  27b0		       7a		      ply
    221  27b1		       4c d1 0d 	      jmp	iSetIrqErr	; Bad line number provided
    222  27b4
    223  27b4				   iTaskCont
    224  27b4		       20 4b 29 	      jsr	TaskEmpty	; Find an empty slot, y = new slot
    225  27b7		       90 45		      bcc	iTaskNoEmpty	; There are no more empty slots
    226  27b9
    227  27b9		       a9 82		      lda	#TASKRUNPENDING+TASKACTIVE	; Mark as enabled but suspended
    228  27bb		       99 74 37 	      sta	taskTable,y	; new task as active
    229  27be
    230  27be		       a5 4f		      lda	CURPTR
    231  27c0		       48		      pha		; push a
    232  27c1		       a5 50		      lda	CURPTR+1
    233  27c3		       48		      pha		; push a
    234  27c4
    235  27c4		       20 86 29 	      jsr	ContextLoad	; load the context of the new task
    236  27c7
    237  27c7		       68		      pla		; pop a
    238  27c8		       85 50		      sta	CURPTR+1
    239  27ca		       68		      pla		; pop a
    240  27cb		       85 4f		      sta	CURPTR
    241  27cd		       a9 03		      lda	#3	; Offset to first instruction
    242  27cf		       85 51		      sta	CUROFF
    243  27d1
    244  27d1		       a9 00		      lda	#0
    245  27d3		       85 47		      sta	ILSTACKPTR
    246  27d5		       85 4a		      sta	MATHSTACKPTR
    247  27d7		       85 4d		      sta	GOSUBSTACKPTR
    248  27d9		       a9 40		      lda	#GOSUBSTACKSIZE*4
    249  27db		       85 4e		      sta	MESSAGEPTR
    250  27dd
    251  27dd		       20 57 09 	      jsr	subVINIT	; Clear the variables
    252  27e0
    253  27e0		       a9 ab		      lda	#STMT&$FF
    254  27e2		       85 43		      sta	ILPC
    255  27e4		       a9 32		      lda	#STMT>>8	; set ilpc to point to the STATEMENT processor
    256  27e6		       85 44		      sta	ILPC+1
    257  27e8
    258  27e8		       5a		      phy		; Save the new context offset to return to user
    259  27e9
    260  27e9		       20 77 29    itaskSetSave jsr	ContextSave	; save the updated context
    261  27ec		       ee 72 38 	      inc	taskCounter	; Update the number of Tasks running
    262  27ef
    263  27ef		       ac 73 37 	      ldy	taskPtr
    264  27f2		       20 86 29 	      jsr	ContextLoad	; restore the original context
    265  27f5
    266  27f5							;lda	  #0		 ; Set the R0 upper to zero
    267  27f5		       64 53		      stz	R0+1
    268  27f7		       68		      pla		; Get the task pid we stored				 ; pop a
    269  27f8		       85 52		      sta	R0	; Get the table entry value
    270  27fa
    271  27fa		       7a		      ply		; Restore the y register we saved			 ; pop a   - exit
    272  27fb
    273  27fb		       4c 06 07 	      jmp	pushR0nextIl	; Push R0 and continue
    274  27fe				   iTaskNoEmpty
    275  27fe		       ac 73 37 	      ldy	taskPtr
    276  2801		       20 86 29 	      jsr	ContextLoad
    277  2804
    278  2804		       7a		      ply
    279  2805
    280  2805		       a2 0e		      ldx	#ERR_NO_EMPTY_TASK_SLOT
    281  2807		       a9 00		      lda	#0
    282  2809		       4c 66 06 	      jmp	iErr2
    283  280c							;
    284  280c							;===============================================================
    285  280c							; Run the task whos PID is on the stack, preserve the stack
    286  280c							;
    287  280c				   iTaskEnable
    288  280c		       5a		      phy
    289  280d		       20 73 2d 	      jsr	popR1
    290  2810		       20 41 2d 	      jsr	pushR1
    291  2813		       20 75 2a 	      jsr	ipc_getcontext	; get context pointer into mq
    292  2816		       a0 00		      ldy	#0
    293  2818		       b1 56		      lda	(MQ),y
    294  281a		       49 02		      eor	#TASKRUNPENDING	; Turn off the Suspend flags
    295  281c		       09 80		      ora	#TASKACTIVE
    296  281e		       91 56		      sta	(MQ),y
    297  2820		       7a		      ply
    298  2821		       4c 9e 02 	      jmp	NextIL
    299  2824
    300  2824							;
    301  2824							;===============================================================
    302  2824							; Suspend the task whos PID  is on the stack, preserve the stack
    303  2824							;
    304  2824				   iTaskSuspend
    305  2824		       5a		      phy
    306  2825		       20 73 2d 	      jsr	popR1
    307  2828		       20 41 2d 	      jsr	pushR1
    308  282b		       20 75 2a 	      jsr	ipc_getcontext	; get context pointer into mq
    309  282e		       a0 00		      ldy	#0
    310  2830		       b1 56		      lda	(MQ),y
    311  2832		       09 02		      ora	#TASKRUNPENDING	; Turn off the Suspend flags
    312  2834		       09 80		      ora	#TASKACTIVE
    313  2836		       7a		      ply
    314  2837		       4c 9e 02 	      jmp	NextIL
    315  283a
    316  283a							;================================================================
    317  283a							; Returns task Status
    318  283a				   iTaskStat
    319  283a		       98		      tya
    320  283b		       48		      pha
    321  283c		       20 4e 28 	      jsr	iTaskValid	; returns pointer to task entry
    322  283f		       b9 74 37 	      lda	taskTable,y
    323  2842		       f0 05		      beq	iTaskStatExit
    324  2844		       68		      pla
    325  2845		       a8		      tay
    326  2846		       4c 63 0d 	      jmp	iTruth
    327  2849				   iTaskStatExit
    328  2849		       68		      pla
    329  284a		       a8		      tay
    330  284b		       4c 6c 0d 	      jmp	iFalse
    331  284e
    332  284e							;
    333  284e							;================================================================
    334  284e							; Validate the task number on top of the stack
    335  284e							; on exit y points to the requested task entry
    336  284e							;
    337  284e		       20 5b 2d    iTaskValid jsr	popR0	; get result of the multiply
    338  2851		       a5 53		      lda	R0+1
    339  2853		       d0 06		      bne	iTaskValidErr	; high byte must be zero
    340  2855		       a5 52		      lda	R0
    341  2857		       c9 fa		      cmp	#TASKTABLELEN
    342  2859		       90 09		      bcc	iTaskIsValid
    343  285b
    344  285b		       68	   iTaskValidErr pla		;remove return address
    345  285c		       68		      pla
    346  285d		       a2 10		      ldx	#ERR_INVALID_PID
    347  285f		       a9 00		      lda	#0
    348  2861		       4c 66 06 	      jmp	iErr2
    349  2864
    350  2864		       a8	   iTaskIsValid tay
    351  2865		       60		      rts
    352  2866							;
    353  2866							;================================================================
    354  2866							; Kill a running task, do nothing if already stopped
    355  2866		       20 4e 28    iTaskKill  jsr	iTaskValid
    356  2869		       a9 00		      lda	#0
    357  286b		       99 74 37 	      sta	taskTable,y	; Fall thru to go to ntask - nexttask
    358  286e							;
    359  286e							;================================================================
    360  286e							;Skip to next task
    361  286e				   iNTask
    362  286e		       a9 01		      lda	#1
    363  2870		       8d 6e 38 	      sta	taskCurrentCycles
    364  2873		       8d 6f 38 	      sta	taskCurrentCycles+1
    365  2876		       4c 9e 02 	      jmp	NextIL
    366  2879							;
    367  2879							;=======================================================
    368  2879							; Wait for a task to complete
    369  2879				   iWTASK
    370  2879		       20 b6 2a 	      jsr	getILByte
    371  287c		       8d e4 43 	      sta	offset
    372  287f							;
    373  287f		       20 99 2c 	      jsr	saveIL	;in case of failure
    374  2882
    375  2882		       20 4e 28 	      jsr	iTaskValid	; returns pointer to task entry from stack, y is offset
    376  2885		       b9 74 37 	      lda	taskTable,y
    377  2888		       d0 03		      bne	iWTASKWAIT
    378  288a				   iWTASKEXITED
    379  288a		       4c 9e 02 	      jmp	NextIL
    380  288d				   iWTASKWAIT
    381  288d		       20 af 2c 	      jsr	pushR0	; Push R0 back onto the stack
    382  2890		       a9 01		      lda	#1
    383  2892		       8d 6e 38 	      sta	taskCurrentCycles	; Give up the cycles
    384  2895		       8d 6f 38 	      sta	taskCurrentCycles+1
    385  2898		       20 a4 2c 	      jsr	restoreIL
    386  289b		       4c c0 0b 	      jmp	tstBranch
    387  289e							;
    388  289e							;=======================================================
    389  289e							; Set task io lock
    390  289e		       ee e6 43    iStartIO   inc	taskIOPending
    391  28a1		       4c 9e 02 	      jmp	NextIL
    392  28a4							;
    393  28a4							;=======================================================
    394  28a4							; Release the io lock
    395  28a4		       ad e6 43    iEndIO     lda	taskIOPending
    396  28a7		       f0 03		      beq	iEndIOExit
    397  28a9		       ce e6 43 	      dec	taskIOPending
    398  28ac		       4c 9e 02    iEndIOExit jmp	NextIL
    399  28af							;
    400  28af							;===============================================================
    401  28af							; Return the task PID
    402  28af				   iTASKPID
    403  28af		       a9 00		      lda	#0
    404  28b1		       85 53		      sta	R0+1
    405  28b3		       ad 73 37 	      lda	taskPtr
    406  28b6		       85 52		      sta	R0
    407  28b8		       4c 06 07 	      jmp	pushR0nextIl
    408  28bb							;
    409  28bb							;================================================================
    410  28bb							; Terminate a task
    411  28bb		       ac 73 37    iETask     ldy	taskPtr
    412  28be		       c0 00		      cpy	#0
    413  28c0		       d0 03		      bne	iETaskCont
    414  28c2		       4c eb 05 	      jmp	iFIN	; if the main task does a ETASK then stop
    415  28c5				   iETaskCont
    416  28c5		       a9 00		      lda	#TASKINACTIVE
    417  28c7		       99 74 37 	      sta	taskTable,y	; mark entry as free
    418  28ca		       ce 72 38 	      dec	taskCounter	; reduce the number of active tasks
    419  28cd		       a9 01		      lda	#1
    420  28cf		       8d 6e 38 	      sta	taskCurrentCycles	; Make it 1 as rtn will dec and check
    421  28d2		       8d 6f 38 	      sta	taskCurrentCycles+1
    422  28d5		       20 66 29 	      jsr	TaskSetExitCode
    423  28d8				   iETaskExit
    424  28d8		       4c 9e 02 	      jmp	NextIL
    425  28db							;================================================================
    426  28db							; make the current tasks math stack equal another tasks stack
    427  28db							; The task to get is stored on the math stack
    428  28db
    429  28db				   iTaskGetMathStack
    430  28db		       20 99 2f 	      jsr	CopyStackR1	; Get the top of stack to R1
    431  28de		       20 75 2a 	      jsr	ipc_getcontext	; MQ now has the context address
    432  28e1		       a0 0a		      ldy	#MATHSTACKPTRPOS
    433  28e3		       b1 56		      lda	(MQ),y
    434  28e5		       85 4a		      sta	MATHSTACKPTR
    435  28e7		       a0 08		      ldy	#MATHSTACKPOS
    436  28e9		       b1 56		      lda	(MQ),y
    437  28eb		       85 48		      sta	MATHSTACK
    438  28ed		       c8		      iny
    439  28ee		       b1 56		      lda	(MQ),y
    440  28f0		       85 49		      sta	MATHSTACK+1
    441  28f2		       4c 9e 02 	      jmp	NextIL
    442  28f5							;==================================================================
    443  28f5							; Updates the tasks math stack pointer with contents of R2
    444  28f5							; PID is on top of the stack
    445  28f5				   iTaskPutMathPtr
    446  28f5		       20 99 2f 	      jsr	CopyStackR1	; Get the top of stack to R1
    447  28f8		       20 75 2a 	      jsr	ipc_getcontext	; MQ now has the context address
    448  28fb		       a5 58		      lda	R2	; R2 contains the number of parameters/offset
    449  28fd		       a0 0a		      ldy	#MATHSTACKPTRPOS	; Pointer to new tasks stack pointer
    450  28ff		       91 56		      sta	(MQ),y	; update it to point to the free space on stack
    451  2901							;if parm count > 0 then we need to create a parameter block on the tasks gosubStack
    452  2901		       c9 00		      cmp	#0	; if no parameters then
    453  2903		       f0 26		      beq	iTaskPutMathPtrExit	; just get out of here
    454  2905
    455  2905		       a0 0b		      ldy	#GOSUBSTKPOS
    456  2907		       b1 56		      lda	(MQ),y	; get the address of the new tasks gosub stack into R1
    457  2909		       85 54		      sta	R1
    458  290b		       c8		      iny
    459  290c		       b1 56		      lda	(MQ),y
    460  290e		       85 55		      sta	R1+1
    461  2910
    462  2910		       a9 00		      lda	#0	; Store the math stack offset into new gosub stack, always 0
    463  2912		       91 54		      sta	(R1),y
    464  2914
    465  2914		       c8		      iny
    466  2915		       18		      clc		; We need to turn stack ptr to actual parm count
    467  2916		       e9 01		      sbc	#1	; Stack pointer always point to next free byte
    468  2918		       0a		      asl
    469  2919		       91 54		      sta	(R1),y
    470  291b
    471  291b		       c8		      iny
    472  291c		       a9 ff		      lda	#$FF	; Dummy field, not used
    473  291e		       91 54		      sta	(R1),y
    474  2920		       c8		      iny
    475  2921		       a9 05		      lda	#GOSUB_STACK_FRAME	; Tell its a stack frame, ie identify param cnt etc
    476  2923		       91 54		      sta	(R1),y
    477  2925		       c8		      iny
    478  2926		       98		      tya
    479  2927		       a0 0d		      ldy	#GOSUBPTRPOS
    480  2929		       91 56		      sta	(MQ),y	; update the new tasks gosub stk pointer
    481  292b
    482  292b				   iTaskPutMathPtrExit
    483  292b		       4c 9e 02 	      jmp	NextIL
    484  292e							;
    485  292e							;================================================================
    486  292e							; Set the time slice for each task
    487  292e				   iSLICE
    488  292e		       20 5b 2d 	      jsr	popR0
    489  2931		       a5 52		      lda	R0
    490  2933		       8d 70 38 	      sta	taskResetValue
    491  2936		       a5 53		      lda	R0+1
    492  2938		       8d 71 38 	      sta	taskResetValue+1
    493  293b		       d0 0b		      bne	iSliceSet
    494  293d		       ee 71 38 	      inc	taskResetValue+1	; must be at least 1 high counter
    495  2940		       a9 01		      lda	#1
    496  2942		       8d 6e 38 	      sta	taskCurrentCycles
    497  2945		       8d 6f 38 	      sta	taskCurrentCycles+1
    498  2948				   iSliceSet
    499  2948		       4c 9e 02 	      jmp	NextIL
    500  294b							;================================================================
    501  294b							; Find an empty slot in the taskTable
    502  294b							; Return the index in y
    503  294b							; on exit   c set if an empty slot is found
    504  294b							;	     c clear if not found
    505  294b							;================================================================
    506  294b							;
    507  294b		       ad 72 38    TaskEmpty  lda	taskCounter
    508  294e		       c9 0a		      cmp	#TASKCOUNT
    509  2950		       b0 10		      bcs	TaskNoSlot
    510  2952		       a0 19		      ldy	#CONTEXTLEN	;The first slot is always the main line SKIP
    511  2954				   TaskLoop
    512  2954		       b9 74 37 	      lda	taskTable,y
    513  2957		       f0 0b		      beq	TaskEmptyFnd
    514  2959		       98		      tya
    515  295a		       18		      clc
    516  295b		       69 19		      adc	#CONTEXTLEN
    517  295d		       a8		      tay
    518  295e		       c0 fa		      cpy	#TASKTABLELEN
    519  2960		       90 f2		      bcc	TaskLoop	; Y is never zero
    520  2962				   TaskNoSlot
    521  2962		       18		      clc
    522  2963		       60		      rts
    523  2964				   TaskEmptyFnd
    524  2964		       38		      sec
    525  2965		       60		      rts
    526  2966							;====================================================
    527  2966							; Set the task exit code called from the return command
    528  2966							; on entry stack top hold exit value
    529  2966				   TaskSetExitCode
    530  2966		       5a		      phy
    531  2967		       20 5b 2d 	      jsr	popR0
    532  296a		       a0 48		      ldy	#TASKEXITCODE
    533  296c		       a5 52		      lda	R0
    534  296e		       91 41		      sta	(VARIABLES),y
    535  2970		       c8		      iny
    536  2971		       a5 53		      lda	R0+1
    537  2973		       91 41		      sta	(VARIABLES),y
    538  2975		       7a		      ply
    539  2976		       60		      rts
    540  2977
    541  2977							;
    542  2977							;=====================================================
    543  2977							; Save Context Store the context to the TASK Table
    544  2977							; on entry y contains the task table entry to save to
    545  2977							; on exit y points to next task table entry
    546  2977							;	   x contains the number of bytes copied
    547  2977		       a2 00	   ContextSave ldx	#0
    548  2979		       c8		      iny		;inc past the task flags
    549  297a		       b5 41	   ContextSvLoop lda	CONTEXT,x
    550  297c		       99 74 37 	      sta	taskTable,y
    551  297f		       c8		      iny
    552  2980		       e8		      inx
    553  2981		       e0 18		      cpx	#[CONTEXTLEN-1]
    554  2983		       90 f5		      bcc	ContextSvLoop
    555  2985		       60		      rts
    556  2986							;
    557  2986							; Load Context transfer context from task table to the Current Context
    558  2986							; on entry y contains the task table entry to transfer
    559  2986							; on exit y points to the original task table entry
    560  2986							;	   x contains the number of bytes copied
    561  2986		       98	   ContextLoad tya
    562  2987		       48		      pha
    563  2988		       a2 00		      ldx	#0
    564  298a		       c8		      iny		;inc past the task flags
    565  298b		       b9 74 37    ContextLDLoop lda	taskTable,y
    566  298e		       95 41		      sta	CONTEXT,x
    567  2990		       c8		      iny
    568  2991		       e8		      inx
    569  2992		       e0 18		      cpx	#[CONTEXTLEN-1]
    570  2994		       90 f5		      bcc	ContextLDLoop
    571  2996		       68		      pla
    572  2997		       a8		      tay
    573  2998		       60		      rts
------- FILE mytb.asm
------- FILE ipc.asm LEVEL 2 PASS 6
      0  2999					      include	"ipc.asm"
      1  2999							;======================================================
      2  2999							; Inter process communications.
      3  2999							; Tasks may write/read integer messages among
      4  2999							; them selves.
      5  2999							; This uses each tasks gosub stack as a message queue
      6  2999							; Gosub calls start at the highest address and the
      7  2999							; msg queue starts at the highest address.
      8  2999							;
      9  2999							;======================================================
     10  2999							; ipcs   - Send msg to another task or many tasks
     11  2999							; on entry  math stack contains the  top PID
     12  2999							;				      2ND Message value
     13  2999							; on exit   math stack contain top True-good or False-failed
     14  2999							;
     15  2999							; it may not be sent if queue is full
     16  2999							;
     17  2999							; a = ipcs(<message-expression>,<task PID-expression>)
     18  2999							;
     19  2999				   iIPCS
     20  2999		       5a		      phy
     21  299a		       20 fa 29 	      jsr	ipc_enqueue
     22  299d		       b0 08		      bcs	iIPC_BAD
     23  299f		       20 8b 2f 	      jsr	pushTrue
     24  29a2		       68		      pla
     25  29a3		       a8		      tay
     26  29a4		       4c 9e 02 	      jmp	NextIL
     27  29a7				   iIPC_BAD
     28  29a7		       7a		      ply
     29  29a8		       20 95 2f 	      jsr	pushFalse
     30  29ab		       4c 9e 02 	      jmp	NextIL
     31  29ae
     32  29ae							;======================================================
     33  29ae							; ipcr   - Recieve msg from task
     34  29ae							; on exit  the message value is returned from message queue
     35  29ae							;	    message -1	is reserved meaning no entry found
     36  29ae							; The provided variable contains the pid of the sending
     37  29ae							; task. This is optional. This always waits for a message
     38  29ae							; before returning.
     39  29ae							;
     40  29ae							; a = ipcr(<variable name>)
     41  29ae							;
     42  29ae				   iIPCR
     43  29ae		       5a		      phy
     44  29af		       20 3c 2a 	      jsr	ipc_dequeue
     45  29b2		       b0 05		      bcs	iIPCR_Q_Empty
     46  29b4		       68		      pla
     47  29b5		       a8		      tay
     48  29b6		       4c 9e 02 	      jmp	NextIL
     49  29b9				   iIPCR_Q_Empty
     50  29b9		       7a		      ply
     51  29ba		       20 8b 2f 	      jsr	pushTrue	; puts -1 on the stack
     52  29bd		       4c 9e 02 	      jmp	NextIL
     53  29c0
     54  29c0							;=======================================================
     55  29c0							; ipcc   - Check if message available
     56  29c0							; on exit  Stack contains number of messages
     57  29c0							;
     58  29c0							; a = ipcc()
     59  29c0							;
     60  29c0				   iIPCC
     61  29c0		       5a		      phy
     62  29c1		       20 e7 29 	      jsr	ipc_queue_count
     63  29c4		       20 af 2c 	      jsr	pushR0	; return the count
     64  29c7		       7a		      ply
     65  29c8		       4c 9e 02 	      jmp	NextIL
     66  29cb
     67  29cb							;=======================================================
     68  29cb							;ipcio    Turns on the tasks wait ips if nothing in queue
     69  29cb				   iIPCIO
     70  29cb		       5a		      phy
     71  29cc		       20 e7 29 	      jsr	ipc_queue_count
     72  29cf		       a5 52		      lda	R0
     73  29d1		       d0 10		      bne	iIPCIO_No_Halt
     74  29d3		       a9 01		      lda	#1
     75  29d5		       8d 6e 38 	      sta	taskCurrentCycles	; force a task switch
     76  29d8		       a9 01		      lda	#TASKWAITIPC
     77  29da		       ac 73 37 	      ldy	taskPtr
     78  29dd		       19 74 37 	      ora	taskTable,y
     79  29e0		       99 74 37 	      sta	taskTable,y
     80  29e3
     81  29e3				   iIPCIO_No_Halt
     82  29e3		       7a		      ply
     83  29e4		       4c 9e 02 	      jmp	NextIL
     84  29e7							;======================================================
     85  29e7							;ipc_queue_count returns number of entries on the queue
     86  29e7							; waiting to be recieved
     87  29e7							;======================================================
     88  29e7				   ipc_queue_count
     89  29e7		       a5 4e		      lda	MESSAGEPTR
     90  29e9		       18		      clc
     91  29ea		       4a		      lsr		; divide by 4
     92  29eb		       4a		      lsr
     93  29ec		       85 52		      sta	R0	; store into R0
     94  29ee		       a9 10		      lda	#GOSUBSTACKSIZE
     95  29f0		       38		      sec
     96  29f1		       e5 52		      sbc	R0	; Get how many entries on queue
     97  29f3		       85 52		      sta	R0
     98  29f5		       a9 00		      lda	#0
     99  29f7		       85 53		      sta	R0+1
    100  29f9		       60		      rts
    101  29fa							;=======================================================
    102  29fa							; Support functions for messaging
    103  29fa							;
    104  29fa							; Enqueue message -> onto PID's MSG Q
    105  29fa							; on entry top of stack contains the PID
    106  29fa							;	    second contains the Message of the task
    107  29fa							; on exit contains c set if failed
    108  29fa							;		    c cleared if success
    109  29fa							;		    PID's MSG Q PTR points to the message
    110  29fa							;===========================================================
    111  29fa				   ipc_enqueue
    112  29fa		       20 73 2d 	      jsr	popR1	; Get the pid
    113  29fd		       20 75 2a 	      jsr	ipc_getcontext	; Get the PID's context into MQ
    114  2a00
    115  2a00		       a0 0d		      ldy	#GOSUBPTRPOS	; pointer to required information
    116  2a02		       b1 56		      lda	(MQ),Y	; Get the stk ptr gosub queue
    117  2a04		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    118  2a06		       d1 56		      cmp	(MQ),y	; Test if there is already the max messages on stack
    119  2a08		       b0 30		      bcs	ipc_enq_full	; Exit with queue full message
    120  2a0a
    121  2a0a
    122  2a0a							; Get the PID'S stack address into R0
    123  2a0a		       a0 0b		      ldy	#GOSUBSTKPOS
    124  2a0c		       b1 56		      lda	(MQ),y
    125  2a0e		       85 52		      sta	R0
    126  2a10		       c8		      iny
    127  2a11		       b1 56		      lda	(MQ),y
    128  2a13		       85 53		      sta	R0+1	; R0 now points to Task gosub/msg stack
    129  2a15
    130  2a15							; Set y to point to the msg q entry
    131  2a15		       a0 0e		      ldy	#MSGPTRPOS	; Get the offset to the msg q ptr
    132  2a17		       b1 56		      lda	(MQ),y	; Get the index
    133  2a19		       a8		      tay		; Set y to queue offset
    134  2a1a
    135  2a1a							; enqueue the message
    136  2a1a		       88		      dey		; First byte to save to
    137  2a1b		       a9 04		      lda	#GOSUB_MSG	; Get the Entry type
    138  2a1d		       91 52		      sta	(R0),y	; Set the entry type
    139  2a1f
    140  2a1f		       88		      dey
    141  2a20		       ad 73 37 	      lda	taskPtr	; Store the PID into queue
    142  2a23		       91 52		      sta	(R0),y
    143  2a25		       20 73 2d 	      jsr	popR1	; Get the actual message value
    144  2a28		       20 a7 2a 	      jsr	ipc_pushR1	; Store Message value into queue
    145  2a2b
    146  2a2b		       98		      tya		; Save the new q ptr
    147  2a2c		       a0 0e		      ldy	#MSGPTRPOS
    148  2a2e		       91 56		      sta	(MQ),y	; Update the message stack pointer
    149  2a30		       a0 00		      ldy	#0	; points to context root
    150  2a32		       a9 01		      lda	#TASKWAITIPC	; Turn off the ipc wait flag
    151  2a34		       51 56		      eor	(MQ),y	; Turn off the bit
    152  2a36		       91 56		      sta	(MQ),y	; Clear the ipc wait flag
    153  2a38		       18		      clc
    154  2a39		       60		      rts
    155  2a3a				   ipc_enq_full
    156  2a3a		       38		      sec
    157  2a3b		       60		      rts
    158  2a3c							;=============================================================
    159  2a3c							; De-queue for message stack -> local tasks msg q
    160  2a3c							;  on entry  top of math stack contains the Variable to place, or 0 if not to save
    161  2a3c							;  message into
    162  2a3c							;  on exit   math stack contains value of message
    163  2a3c							;				  Variable if provided is pid
    164  2a3c				   ipc_dequeue
    165  2a3c		       20 8a 2d 	      jsr	popMQ	; Variable address to put PID into
    166  2a3f
    167  2a3f		       a4 4e		      ldy	MESSAGEPTR
    168  2a41		       c0 38		      cpy	#[[GOSUBSTACKSIZE - 2] * 4]	; see if anything to pop from stack
    169  2a43		       b0 2e		      bcs	ipc_deq_empty
    170  2a45		       b1 4b		      lda	(GOSUBSTACK),y	; get the message value
    171  2a47		       85 52		      sta	R0
    172  2a49		       c8		      iny
    173  2a4a		       b1 4b		      lda	(GOSUBSTACK),y
    174  2a4c		       85 53		      sta	R0+1
    175  2a4e		       c8		      iny
    176  2a4f		       b1 4b		      lda	(GOSUBSTACK),y	; get the pid value
    177  2a51		       85 54		      sta	R1
    178  2a53		       c8		      iny
    179  2a54		       b1 4b		      lda	(GOSUBSTACK),y	; Get the type of message
    180  2a56		       c8		      iny
    181  2a57		       84 4e		      sty	MESSAGEPTR	; Save the message q ptr
    182  2a59
    183  2a59		       c9 04		      cmp	#GOSUB_MSG	; Should be a message
    184  2a5b		       d0 16		      bne	ipc_deq_empty
    185  2a5d
    186  2a5d		       20 af 2c 	      jsr	pushR0	; place value on stack
    187  2a60
    188  2a60		       a5 56		      lda	MQ
    189  2a62		       05 57		      ora	MQ+1
    190  2a64		       f0 0b		      beq	ipc_deq_done
    191  2a66		       a5 54		      lda	R1
    192  2a68		       a0 00		      ldy	#0
    193  2a6a		       91 56		      sta	(MQ),y
    194  2a6c		       c8		      iny
    195  2a6d		       a9 00		      lda	#0
    196  2a6f		       91 56		      sta	(MQ),y
    197  2a71				   ipc_deq_done
    198  2a71		       18		      clc
    199  2a72		       60		      rts
    200  2a73
    201  2a73				   ipc_deq_empty
    202  2a73		       38		      sec
    203  2a74		       60		      rts
    204  2a75
    205  2a75							;=============================================
    206  2a75							;  Get the context address into MQ from R1 with
    207  2a75							;  context/index/pid
    208  2a75				   ipc_getcontext
    209  2a75		       18		      clc		; Get pointer to Task context
    210  2a76		       a9 74		      lda	#taskTable&$FF	; change ptr to address
    211  2a78		       65 54		      adc	R1
    212  2a7a		       85 56		      sta	MQ
    213  2a7c		       a9 37		      lda	#taskTable>>8
    214  2a7e		       65 55		      adc	R1+1
    215  2a80		       85 57		      sta	MQ+1	; We now have a pointer into the context
    216  2a82		       60		      rts
    217  2a83							;
    218  2a83							;==============================================
    219  2a83							; on entry R1 has a context value,
    220  2a83							; on exit c is set if fails
    221  2a83							;
    222  2a83				   ipc_CONTEXTVALUES
      0  2a83					      db	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      1  2a83		       00 19 32 4b	      .byte.b	$00,CONTEXTLEN,[CONTEXTLEN*2],(CONTEXTLEN*3)
      0  2a87					      db	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      1  2a87		       64 7d 96 af	      .byte.b	(CONTEXTLEN*4),(CONTEXTLEN*5),(CONTEXTLEN*6),(CONTEXTLEN*7)
      0  2a8b					      db	(CONTEXTLEN*8),(CONTEXTLEN*9)
      1  2a8b		       c8 e1		      .byte.b	(CONTEXTLEN*8),(CONTEXTLEN*9)
    226  2a8d
    227  2a8d				   ipc_ValidateContext
    228  2a8d		       48		      pha
    229  2a8e		       da		      phx
    230  2a8f		       a5 55		      lda	R1+1
    231  2a91		       d0 0e		      bne	ipc_Validate_Fail
    232  2a93		       a2 00		      ldx	#0
    233  2a95		       a5 54		      lda	R1
    234  2a97				   ipc_ValidateLoop
    235  2a97		       dd 83 2a 	      cmp	ipc_CONTEXTVALUES,x
    236  2a9a		       f0 08		      beq	ipc_Valid_Context
    237  2a9c		       e8		      inx
    238  2a9d		       e0 0a		      cpx	#TASKCOUNT
    239  2a9f		       90 f6		      bcc	ipc_ValidateLoop
    240  2aa1
    241  2aa1				   ipc_Validate_Fail
    242  2aa1		       fa		      plx
    243  2aa2		       68		      pla
    244  2aa3		       60		      rts
    245  2aa4
    246  2aa4				   ipc_Valid_Context
    247  2aa4		       18		      clc
    248  2aa5		       90 fa		      bcc	ipc_Validate_Fail
    249  2aa7							;
    250  2aa7							;==============================================
    251  2aa7							;Push R1 onto the stack
    252  2aa7							;on entry y = next entry
    253  2aa7							;R0 points to the stack space
    254  2aa7							;on exit y points to next free byte
    255  2aa7				   ipc_pushR1
    256  2aa7		       88		      dey
    257  2aa8		       a5 55		      lda	R1+1	; PID first
    258  2aaa		       91 52		      sta	(R0),y
    259  2aac		       88		      dey
    260  2aad		       a5 54		      lda	R1
    261  2aaf		       91 52		      sta	(R0),y
    262  2ab1		       60		      rts
    263  2ab2
    264  2ab2
    265  2ab2
    266  2ab2
    267  2ab2
    268  2ab2
    269  2ab2
------- FILE mytb.asm
------- FILE support.asm LEVEL 2 PASS 6
      0  2ab2					      include	"support.asm"
      1  2ab2							;
      2  2ab2							;=====================================================
      3  2ab2							;=====================================================
      4  2ab2							;=====================================================
      5  2ab2							; This marks the start of support functions used by
      6  2ab2							; the IL opcodes.  These are support functions, NOT
      7  2ab2							; the IL code.
      8  2ab2							;=====================================================
      9  2ab2							;GOSUBSTACKSIZE  equ	  16	    ;Depth of gosub nesting
     10  2ab2							;=====================================================
     11  2ab2					      Seg	Code
     12  2ab2							;=====================================================
     13  2ab2							; This gets the next two bytes pointed to by ILPC and
     14  2ab2							; returns them; X contains LSB, A contains MSB.  ILPC
     15  2ab2							; is advanced by two, and Y contains 0 on return.
     16  2ab2
     17  2ab2							;
     18  2ab2		       20 b6 2a    getILWord  jsr	getILByte	;LSB
     19  2ab5		       aa		      tax
     20  2ab6							;
     21  2ab6							;=====================================================
     22  2ab6							; This gets the next byte pointed to by ILPC and
     23  2ab6							; returns it in A.  On return, X is unchanged but Y
     24  2ab6							; contains 0.
     25  2ab6							;
     26  2ab6		       a0 00	   getILByte  ldy	#0
     27  2ab8		       b1 43		      lda	(ILPC),y	;get byte
     28  2aba		       08		      php		;save status
     29  2abb		       e6 43		      inc	ILPC	;inc LSB
     30  2abd		       d0 02		      bne	getILb2	;branch if no overflow
     31  2abf		       e6 44		      inc	ILPC+1	;inc MSB
     32  2ac1		       28	   getILb2    plp		;restore status
     33  2ac2		       60		      rts
     34  2ac3							;
     35  2ac3							;=====================================================
     36  2ac3							; Decrement ILPC by one.
     37  2ac3							;
     38  2ac3		       a5 43	   decIL      lda	ILPC
     39  2ac5		       d0 02		      bne	decIL2
     40  2ac7		       c6 44		      dec	ILPC+1
     41  2ac9		       c6 43	   decIL2     dec	ILPC
     42  2acb		       60		      rts
     43  2acc							;
     44  2acc							;=====================================================
     45  2acc							; Push the ILPC onto the return stack.  Actually, this
     46  2acc							; pushes the address of ILPC+2 since that's the next
     47  2acc							; address to execute.
     48  2acc							;
     49  2acc		       a4 47	   pushILPC   ldy	ILSTACKPTR
     50  2ace		       c0 64		      cpy	#ILSTACKSIZE<<1
     51  2ad0		       b0 15		      bcs	pushErr
     52  2ad2		       a5 43		      lda	ILPC
     53  2ad4		       18		      clc
     54  2ad5		       69 02		      adc	#2
     55  2ad7		       91 45		      sta	(ILSTACK),y
     56  2ad9		       08		      php		;save C bit
     57  2ada		       c8		      iny
     58  2adb		       a5 44		      lda	ILPC+1
     59  2add		       28		      plp		;restore C
     60  2ade		       69 00		      adc	#0
     61  2ae0		       91 45		      sta	(ILSTACK),y
     62  2ae2		       c8		      iny
     63  2ae3		       84 47		      sty	ILSTACKPTR
     64  2ae5		       18		      clc
     65  2ae6		       60		      rts
     66  2ae7				   pushErr
     67  2ae7		       38		      sec
     68  2ae8		       60		      rts
     69  2ae9							;
     70  2ae9							;=====================================================
     71  2ae9							; Pull the top entry from return stack and put into
     72  2ae9							; ILPC.
     73  2ae9							;
     74  2ae9		       a4 47	   popILPC    ldy	ILSTACKPTR
     75  2aeb		       f0 fa		      beq	pushErr
     76  2aed		       88		      dey
     77  2aee		       b1 45		      lda	(ILSTACK),y
     78  2af0		       85 44		      sta	ILPC+1
     79  2af2		       88		      dey
     80  2af3		       b1 45		      lda	(ILSTACK),y
     81  2af5		       85 43		      sta	ILPC
     82  2af7		       84 47		      sty	ILSTACKPTR
     83  2af9		       18		      clc
     84  2afa		       60		      rts
     85  2afb							;
     86  2afb							;=====================================================
     87  2afb							; This searches for a specific line number that is in
     88  2afb							; R0.	There are three possible return conditions:
     89  2afb							; Line numbers are now the third byte, the first byte is now
     90  2afb							; a pointer to the next line, of course no longer than 255 byte
     91  2afb							; per line.
     92  2afb							;
     93  2afb							; Exact match was found:
     94  2afb							;    * Z set
     95  2afb							;    * CURPTR points to two-byte line number for that
     96  2afb							;	line.
     97  2afb							;
     98  2afb							; Next highest line found:
     99  2afb							;    * Z cleared
    100  2afb							;    * C set
    101  2afb							;    * CURPTR points to two-byte line number for that
    102  2afb							;	line.
    103  2afb							;
    104  2afb							; End of program reached:
    105  2afb							;    * Z cleared
    106  2afb							;    * C cleared
    107  2afb							;    * CURPTR points to first free byte at end of
    108  2afb							;	program.  Ie, it has save value as PROGRAMEND.
    109  2afb							;
    110  2afb							; A, X, and Y are all undefined on return.
    111  2afb							;
    112  2afb
    113  2afb				   findLine
    114  2afb		       ad ec 43 	      lda	ProgramStart	;Start of program -> CURPTR
    115  2afe		       85 4f		      sta	CURPTR
    116  2b00		       ad ed 43 	      lda	ProgramStart+1
    117  2b03		       85 50		      sta	CURPTR+1
    118  2b05							;
    119  2b05							; At end of code?
    120  2b05							;
    121  2b05				   iXFER1
    122  2b05		       a5 4f		      lda	CURPTR	; chk CURPTR = END PROGRAM
    123  2b07		       cd ee 43 	      cmp	ProgramEnd	; at end of program then stop run
    124  2b0a		       d0 0b		      bne	xfer2	; not end
    125  2b0c		       a5 50		      lda	CURPTR+1
    126  2b0e		       cd ef 43 	      cmp	ProgramEnd+1
    127  2b11		       d0 04		      bne	xfer2	;Not at end
    128  2b13							;
    129  2b13							; Line not found and the end of the program was
    130  2b13							; reached.  Return Z and C both clear.
    131  2b13							;
    132  2b13		       a9 01		      lda	#1	;clear Z
    133  2b15		       18		      clc		;clear C
    134  2b16		       60		      rts
    135  2b17							;
    136  2b17							; Check for an exact line number match
    137  2b17							;
    138  2b17		       a5 52	   xfer2      lda	R0
    139  2b19		       a0 01		      ldy	#1	; changed to skip extra length byte
    140  2b1b		       d1 4f		      cmp	(CURPTR),y
    141  2b1d		       d0 08		      bne	xfernotit
    142  2b1f		       c8		      iny
    143  2b20		       a5 53		      lda	R0+1
    144  2b22		       d1 4f		      cmp	(CURPTR),y
    145  2b24		       d0 01		      bne	xfernotit	; not a matching line number
    146  2b26							;
    147  2b26							; This is exactly the line we want.
    148  2b26							;
    149  2b26		       60		      rts		;it matches exactly
    150  2b27							;
    151  2b27							; See if this line is greater than the one we're
    152  2b27							; searching for.
    153  2b27							;
    154  2b27		       a0 02	   xfernotit  ldy	#2	;Changed from to skip leading length and least significat digit
    155  2b29		       b1 4f		      lda	(CURPTR),y	;compare MSB first
    156  2b2b		       c5 53		      cmp	R0+1
    157  2b2d		       90 0b		      bcc	xfer3
    158  2b2f		       d0 07		      bne	xfer4
    159  2b31		       88		      dey
    160  2b32		       b1 4f		      lda	(CURPTR),y	;compare LSB
    161  2b34		       c5 52		      cmp	R0
    162  2b36		       90 02		      bcc	xfer3
    163  2b38							;
    164  2b38							; This line is greater than the one we want, so
    165  2b38							; return Z clear and C set.
    166  2b38							;
    167  2b38		       38	   xfer4      sec		;We found a line number greater
    168  2b39		       60		      rts		;both conditions set
    169  2b3a							;
    170  2b3a							; Not the line (or droid) we're looking for.  Move to
    171  2b3a							; the next line.
    172  2b3a							;
    173  2b3a		       20 40 2b    xfer3      jsr	FindNextLine
    174  2b3d		       4c 05 2b 	      jmp	iXFER1
    175  2b40							;
    176  2b40							;=====================================================
    177  2b40							; This advances CURPTR to the next line.  If there
    178  2b40							; are no more lines, this leaves CURPTR equal to
    179  2b40							; ProgramEnd.	Returns CUROFF set to 3.  This assumes
    180  2b40							; CURPTR is pointing to a valid line on entry.  This
    181  2b40							; pointer points to the two-byte line number.
    182  2b40							; Update this points to the 1 byte line length  ****************
    183  2b40							;
    184  2b40				   FindNextLine
    185  2b40		       a0 03		      ldy	#3	;skip line number and length byte
    186  2b42		       84 51		      sty	CUROFF	;this is the new offset
    187  2b44		       a0 00		      ldy	#0
    188  2b46		       b1 4f		      lda	(CURPTR),y	;Get the length
    189  2b48		       18		      clc
    190  2b49		       65 4f		      adc	CURPTR
    191  2b4b		       85 4f		      sta	CURPTR
    192  2b4d		       a5 50		      lda	CURPTR+1
    193  2b4f		       69 00		      adc	#0
    194  2b51		       85 50		      sta	CURPTR+1
    195  2b53		       60	   FindNext4  rts
    196  2b54							;
    197  2b54							;=====================================================
    198  2b54							; This compares CURPTR to PROGRAMEND and returns Z set
    199  2b54							; if they are equal, Z clear if not.
    200  2b54							;
    201  2b54		       a5 4f	   AtEnd      lda	CURPTR
    202  2b56		       cd ee 43 	      cmp	ProgramEnd
    203  2b59		       d0 05		      bne	atendexit
    204  2b5b		       a5 50		      lda	CURPTR+1
    205  2b5d		       cd ef 43 	      cmp	ProgramEnd+1
    206  2b60		       60	   atendexit  rts
    207  2b61							;
    208  2b61
    209  2b61							;
    210  2b61							;=====================================================
    211  2b61							; Convert an ASCII string to a number.  On input,
    212  2b61							; (CURPTR),Y points to the first digit.  This gets
    213  2b61							; digit-by-digit until finding a non-number.  Returns
    214  2b61							; Y pointing to the non-digit, and R0 contains the
    215  2b61							; number.  This does NOT check for valid ranges, so
    216  2b61							; a value like "123456789" will produce something,
    217  2b61							; but not what you had expected.
    218  2b61							;
    219  2b61		       a9 00	   getDecimal lda	#0
    220  2b63		       85 52		      sta	R0
    221  2b65		       85 53		      sta	R0+1
    222  2b67		       85 59		      sta	dpl	;temporary negative flag
    223  2b69							;
    224  2b69							; See if it's negative...
    225  2b69							;
    226  2b69							;sty	  $0013 	Removed as no idea why here JUSTLOSTINTIME
    227  2b69		       b1 4f		      lda	(CURPTR),y
    228  2b6b		       c9 2d		      cmp	#'-
    229  2b6d		       d0 02		      bne	getDecLoop
    230  2b6f		       e6 59		      inc	dpl	;it's negative
    231  2b71							;
    232  2b71		       b1 4f	   getDecLoop lda	(CURPTR),y
    233  2b73		       f0 3a		      beq	getDdone	;Added this incase we hit eol JUSTLOSTINTIME
    234  2b75		       c9 30		      cmp	#'0
    235  2b77		       90 36		      bcc	getDdone
    236  2b79		       c9 3a		      cmp	#'9+1
    237  2b7b		       b0 32		      bcs	getDdone
    238  2b7d		       38		      sec
    239  2b7e		       e9 30		      sbc	#'0	;convert to binary
    240  2b80		       48		      pha
    241  2b81							;
    242  2b81							; Now multiply R0 by 10.  Remember that
    243  2b81							; 2*N + 8*N = 10*N.
    244  2b81							;
    245  2b81		       06 52		      asl	R0
    246  2b83		       26 53		      rol	R0+1	;*2
    247  2b85		       a5 52		      lda	R0
    248  2b87		       85 54		      sta	R1
    249  2b89		       a5 53		      lda	R0+1
    250  2b8b		       85 55		      sta	R1+1
    251  2b8d		       06 52		      asl	R0
    252  2b8f		       26 53		      rol	R0+1	;*4
    253  2b91		       06 52		      asl	R0
    254  2b93		       26 53		      rol	R0+1	;*8
    255  2b95		       18		      clc		;now add the partial sums...
    256  2b96		       a5 52		      lda	R0	;...to get *10
    257  2b98		       65 54		      adc	R1
    258  2b9a		       85 52		      sta	R0
    259  2b9c		       a5 53		      lda	R0+1
    260  2b9e		       65 55		      adc	R1+1
    261  2ba0		       85 53		      sta	R0+1
    262  2ba2							;
    263  2ba2							; Add in the new digit
    264  2ba2							;
    265  2ba2		       68		      pla
    266  2ba3		       18		      clc
    267  2ba4		       65 52		      adc	R0
    268  2ba6		       85 52		      sta	R0
    269  2ba8		       90 02		      bcc	getD2
    270  2baa		       e6 53		      inc	R0+1
    271  2bac							;
    272  2bac							; Move to next character
    273  2bac							;
    274  2bac		       c8	   getD2      iny
    275  2bad		       d0 c2		      bne	getDecLoop
    276  2baf							;
    277  2baf							; All done with digits, so now deal with it being
    278  2baf							; negative.  If zero, then don't check for negative
    279  2baf							; flag.  Ie, -0 is stored as 0.
    280  2baf							;
    281  2baf		       a5 52	   getDdone   lda	R0
    282  2bb1		       05 53		      ora	R0+1
    283  2bb3		       f0 16		      beq	getDone2	;zero
    284  2bb5		       a5 59		      lda	dpl
    285  2bb7		       f0 12		      beq	getDone2	;positive
    286  2bb9							;
    287  2bb9							; Invert all the bits, then add one.
    288  2bb9							;
    289  2bb9		       a5 52		      lda	R0
    290  2bbb		       49 ff		      eor	#$ff
    291  2bbd		       85 52		      sta	R0
    292  2bbf		       a5 53		      lda	R0+1
    293  2bc1		       49 ff		      eor	#$ff
    294  2bc3		       85 53		      sta	R0+1
    295  2bc5							;
    296  2bc5		       e6 52		      inc	R0
    297  2bc7		       d0 02		      bne	getDone2
    298  2bc9		       e6 53		      inc	R0+1
    299  2bcb				   getDone2
    300  2bcb							; removed next few lines as no idea why they are here JUSTLOSTINTIME
    301  2bcb							;lda	  R0
    302  2bcb							;sta	  $0010
    303  2bcb							;lda	  R0+1
    304  2bcb							;sta	  $0011
    305  2bcb							;lda	  dpl
    306  2bcb							;sta	  $012
    307  2bcb
    308  2bcb		       60		      rts
    309  2bcc
    310  2bcc							;=====================================================
    311  2bcc							; Gets a line of input into LINBUF.
    312  2bcc							;
    313  2bcc							; On entry:
    314  2bcc							;    A contains the prompt character, or 0 if none.
    315  2bcc							;    X = 1 Background read
    316  2bcc							;    x = 0 Forground read with wait
    317  2bcc							;
    318  2bcc							; On exit:
    319  2bcc							;    CURPTR points to LINBUF
    320  2bcc							;    LINBUF contains the line with 0 at the end.
    321  2bcc							;    Y has offset to first non-space character
    322  2bcc							;    CURROFF has the same as Y.
    323  2bcc							;
    324  2bcc		       20 1b 2c    GetLine    jsr	ReadPrompt
    325  2bcf		       e0 00		      cpx	#0
    326  2bd1		       f0 14		      beq	GetLineRetry
    327  2bd3		       ae 73 37 	      ldx	taskPtr
    328  2bd6		       bd 74 37 	      lda	taskTable,x
    329  2bd9		       29 40		      and	#TASKWAITIO	;Task Active and waiting for IO
    330  2bdb		       d0 3d		      bne	taskWaitingIO
    331  2bdd		       09 40		      ora	#TASKWAITIO	;Mark Task as waiting for IO
    332  2bdf		       9d 74 37 	      sta	taskTable,x	;Mark the state for task as waiting io
    333  2be2		       ce 1a 2c 	      dec	taskWaitingIO	;Start polling the input and make task wait
    334  2be5		       f0 33		      beq	taskWaitingIO	;Get out of here and wait for io to complete
    335  2be7
    336  2be7							;
    337  2be7							; Now read a line and wait for the CR
    338  2be7							;
    339  2be7				   GetLineRetry
    340  2be7		       a9 00		      lda	#0	;Wait for input to complete
    341  2be9		       20 33 2c 	      jsr	ReadLine
    342  2bec
    343  2bec							;
    344  2bec							; Point to the line we just read
    345  2bec							; Set the current pointer to point to the input line
    346  2bec							;
    347  2bec		       a0 00	   ReadComplete ldy	#0
    348  2bee		       84 51		      sty	CUROFF
    349  2bf0		       a2 4f		      ldx	#LINBUF&$ff
    350  2bf2		       86 4f		      stx	CURPTR
    351  2bf4		       a2 43		      ldx	#LINBUF>>8
    352  2bf6		       86 50		      stx	CURPTR+1
    353  2bf8							;
    354  2bf8							; Output a CR/LF
    355  2bf8							;
    356  2bf8		       20 14 2e 	      jsr	CRLF
    357  2bfb							;
    358  2bfb							; If a blank line, prompt again.
    359  2bfb							;
    360  2bfb		       20 0b 2e 	      jsr	SkipSpaces
    361  2bfe		       b1 4f		      lda	(CURPTR),y
    362  2c00		       d0 10		      bne	GetLineDone	;We have data then exit
    363  2c02		       20 1e 2c 	      jsr	ReadPromptRetry
    364  2c05		       ae 73 37 	      ldx	taskPtr	;if this task is waiting for IO
    365  2c08		       bd 74 37 	      lda	taskTable,x	;then get out, wait for line to
    366  2c0b		       29 40		      and	#TASKWAITIO	;Complete again
    367  2c0d		       d0 0b		      bne	taskWaitingIO
    368  2c0f		       4c e7 2b 	      jmp	GetLineRetry	;If the IO is wait then jump to start
    369  2c12
    370  2c12				   GetLineDone
    371  2c12		       ae 73 37 	      ldx	taskPtr
    372  2c15		       a9 80		      lda	#TASKACTIVE
    373  2c17		       9d 74 37 	      sta	taskTable,x	;IO is complete
    374  2c1a
    375  2c1a				   taskWaitingIO
    376  2c1a		       60		      rts
    377  2c1b
    378  2c1b							;
    379  2c1b							;=======================================================================
    380  2c1b							; Display the prompt character
    381  2c1b							; On entry
    382  2c1b							;	    A contains the prompt character
    383  2c1b							; On exit
    384  2c1b							;	    The readbuffer index is reset to 0
    385  2c1b							;
    386  2c1b		       8d d6 43    ReadPrompt sta	promptChar
    387  2c1e
    388  2c1e							;
    389  2c1e							; Prompt
    390  2c1e							;
    391  2c1e
    392  2c1e		       ad d6 43    ReadPromptRetry lda	promptChar
    393  2c21		       09 00		      ora	#0	;any prompt?
    394  2c23		       f0 08		      beq	getlinenp
    395  2c25		       20 1f 1a 	      jsr	VOUTCH
    396  2c28		       a9 20		      lda	#$20
    397  2c2a		       20 1f 1a 	      jsr	VOUTCH	;Space after prompt
    398  2c2d							;
    399  2c2d		       a2 00	   getlinenp  ldx	#0	;offset into LINBUF
    400  2c2f		       8e d3 43 	      stx	getlinx
    401  2c32		       60		      rts
    402  2c33							;
    403  2c33							;===============================================================
    404  2c33							; This fuction is the driver for the line input
    405  2c33							; on call if a = 0 then it waits for all input
    406  2c33							;	      a = 1 then nowait for input
    407  2c33							; On exit
    408  2c33							;		       c clear if not complete line
    409  2c33							;		       c set if it was a complete line
    410  2c33
    411  2c33				   ReadLine
    412  2c33		       8d d5 43 	      sta	inputNoWait
    413  2c36		       c9 00		      cmp	#0
    414  2c38		       f0 05		      beq	getline1
    415  2c3a		       20 0f f0 	      jsr	ISCHAR	; if there is no character just get out
    416  2c3d		       f0 2b		      beq	GetLineNoWait
    417  2c3f		       20 22 1a    getline1   jsr	VGETCH
    418  2c42					      if	CTMON65
    419  2c42		       48		      pha
    420  2c43		       20 1f 1a 	      jsr	VOUTCH	;echo echo echo
    421  2c46		       68		      pla
    422  2c47					      endif
    423  2c47		       c9 0d		      cmp	#CR
    424  2c49		       f0 15		      beq	getlind	;end of line
    425  2c4b		       c9 08		      cmp	#BS	;backspace?
    426  2c4d		       f0 1d		      beq	getlinebs
    427  2c4f		       ae d3 43 	      ldx	getlinx
    428  2c52		       9d 4f 43 	      sta	LINBUF,x
    429  2c55		       e8		      inx
    430  2c56		       8e d3 43 	      stx	getlinx
    431  2c59		       ad d5 43 	      lda	inputNoWait
    432  2c5c		       f0 e1		      beq	getline1
    433  2c5e		       d0 0a		      bne	GetLineNoWait
    434  2c60							;
    435  2c60							; CR was hit
    436  2c60							;
    437  2c60		       a9 00	   getlind    lda	#0	; set the end pf buffer
    438  2c62		       ae d3 43 	      ldx	getlinx
    439  2c65		       9d 4f 43 	      sta	LINBUF,x
    440  2c68
    441  2c68		       38		      sec		; Carry set then cr received
    442  2c69		       60		      rts
    443  2c6a
    444  2c6a				   GetLineNoWait
    445  2c6a		       18		      clc		; Carry clear no end of line
    446  2c6b		       60		      rts
    447  2c6c							;
    448  2c6c							; Backspace was hit
    449  2c6c							;
    450  2c6c		       ae d3 43    getlinebs  ldx	getlinx
    451  2c6f		       f0 0e		      beq	getlineEOL	;at start of line
    452  2c71		       ca		      dex
    453  2c72		       8e d3 43 	      stx	getlinx
    454  2c75		       20 80 21    getlinepbs jsr	puts
      0  2c78					      db	27,"[K",0
      1  2c78		       1b 5b 4b 00	      .byte.b	27,"[K",0
    456  2c7c		       4c 3f 2c 	      jmp	getline1
    457  2c7f		       a9 20	   getlineEOL lda	#SPACE
    458  2c81		       20 1f 1a 	      jsr	VOUTCH
    459  2c84		       d0 ef		      bne	getlinepbs
    460  2c86							;
    461  2c86							;=====================================================
    462  2c86							; Count the length of the line currently in LINBUF
    463  2c86							; starting at offset Y.  Returns the length in X.  The
    464  2c86							; starting offset in Y should point past the ASCII
    465  2c86							; line number.  Also counts the trailing NULL and two
    466  2c86							; extra bytes for where the line number will be.
    467  2c86							; Update must now include leading length byte not the null at end ****************
    468  2c86							;
    469  2c86				   getLineLength
    470  2c86		       a2 00		      ldx	#0	;size
    471  2c88		       b9 4f 43    getLineL2  lda	LINBUF,y
    472  2c8b		       f0 04		      beq	getLineL3
    473  2c8d		       c8		      iny
    474  2c8e		       e8		      inx
    475  2c8f		       d0 f7		      bne	getLineL2
    476  2c91		       e8	   getLineL3  inx		;count null at end
    477  2c92		       e8		      inx		;line number LSB
    478  2c93		       e8		      inx		;MSB
    479  2c94		       e8		      inx		;change: count new leading line length
    480  2c95		       8e e5 43 	      stx	lineLength
    481  2c98		       60		      rts
    482  2c99							;
    483  2c99							;=====================================================
    484  2c99							; Count the length of the line pointed to by CURPTR.
    485  2c99							; This also counts the line number and the terminating
    486  2c99							; null.  Ie, this string returns 8:
    487  2c99							;
    488  2c99							; <lineLow><lineHi>Hello<null>
    489  2c99							;
    490  2c99							; Another way of looking at it: add the return value
    491  2c99							; to the CURPTR and it'll point to the next line's
    492  2c99							; line number.  Returns the value in Y.
    493  2c99							; Update to ject get the leading byte length ********************
    494  2c99							;
    495  2c99							;getCURPTRLength
    496  2c99							;		ldy	CURPTR
    497  2c99							;		ldy	#3	;change: skip line number and leading length byte
    498  2c99							;getCLineL2	lda	(CURPTR),y
    499  2c99							;		beq	getCLineL3
    500  2c99							;		iny
    501  2c99							;		bne	getCLineL2
    502  2c99							;getCLineL3	iny		;count null at end
    503  2c99							;		rts
    504  2c99
    505  2c99							;
    506  2c99							;=====================================================
    507  2c99							; This saves ILPC.  This saves to a single save area,
    508  2c99							; so it can't be called more than once.
    509  2c99							;
    510  2c99		       a5 43	   saveIL     lda	ILPC
    511  2c9b		       8d e1 43 	      sta	tempIL
    512  2c9e		       a5 44		      lda	ILPC+1
    513  2ca0		       8d e2 43 	      sta	tempIL+1
    514  2ca3		       60		      rts
    515  2ca4							;
    516  2ca4							;=====================================================
    517  2ca4							; This restores ILPC.
    518  2ca4							;
    519  2ca4		       ad e1 43    restoreIL  lda	tempIL
    520  2ca7		       85 43		      sta	ILPC
    521  2ca9		       ad e2 43 	      lda	tempIL+1
    522  2cac		       85 44		      sta	ILPC+1
    523  2cae		       60		      rts
    524  2caf							;
    525  2caf							;=====================================================
    526  2caf							; This pushes R0 onto the stack.
    527  2caf							;
    528  2caf		       8c dc 43    pushR0     sty	rtemp1
    529  2cb2		       a4 4a		      ldy	MATHSTACKPTR
    530  2cb4		       c0 28		      cpy	#MATHSTACKSIZE<<1
    531  2cb6		       b0 38		      bcs	pusherr
    532  2cb8		       a5 52		      lda	R0
    533  2cba		       91 48		      sta	(MATHSTACK),y
    534  2cbc		       c8		      iny
    535  2cbd		       a5 53		      lda	R0+1
    536  2cbf		       91 48		      sta	(MATHSTACK),y
    537  2cc1		       c8		      iny
    538  2cc2		       84 4a		      sty	MATHSTACKPTR
    539  2cc4		       ac dc 43 	      ldy	rtemp1
    540  2cc7		       18		      clc
    541  2cc8		       60		      rts
    542  2cc9
    543  2cc9							;=====================================================
    544  2cc9							; This pushes curptr basic current line onto the call stack.
    545  2cc9							; and CUROFF. Also marks entry type as 1 = GOSUB
    546  2cc9
    547  2cc9				   pushLN
    548  2cc9		       8d dd 43 	      STA	rtemp1+1	; Store type of push being done
    549  2ccc		       8c dc 43 	      sty	rtemp1
    550  2ccf		       a5 4e		      lda	MESSAGEPTR	; stack and msg Q grow together see if they cross!
    551  2cd1		       c5 4d		      cmp	GOSUBSTACKPTR
    552  2cd3		       90 1b		      bcc	pusherr	; No error
    553  2cd5		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Go Stack Pointer
    554  2cd7		       a2 00		      ldx	#0	; Start of bytes to copy
    555  2cd9				   pushLoop
    556  2cd9		       b5 4f		      lda	CURPTR,x	; Get the current pointer Start address
    557  2cdb		       91 4b		      sta	(GOSUBSTACK),y	; put it onto the stack
    558  2cdd		       c8		      iny		; Next destination
    559  2cde		       e8		      inx		; Next Source byte
    560  2cdf		       e0 03		      cpx	#3	; 4 bytes per entry on the stack
    561  2ce1		       d0 f6		      bne	pushLoop	; Jump if not done for next byte
    562  2ce3
    563  2ce3		       ad dd 43    pushDone   lda	rtemp1+1	; Type of stack entry
    564  2ce6		       91 4b		      sta	(GOSUBSTACK),y	; Store Type of stack entry
    565  2ce8		       c8		      iny		; Next entry
    566  2ce9
    567  2ce9		       84 4d		      sty	GOSUBSTACKPTR	; Save the new stack pointer
    568  2ceb		       ac dc 43 	      ldy	rtemp1
    569  2cee		       18		      clc
    570  2cef		       60		      rts
    571  2cf0				   pusherr
    572  2cf0		       38		      sec
    573  2cf1		       60		      rts
    574  2cf2
    575  2cf2							;Pop an absolute address from the  Math Stack
    576  2cf2		       5a	   popMath    phy
    577  2cf3		       a4 4a		      ldy	MATHSTACKPTR
    578  2cf5		       88		      dey
    579  2cf6		       98		      tya
    580  2cf7		       c9 ff		      cmp	#$FF
    581  2cf9		       f0 3e		      beq	poperr
    582  2cfb		       b1 48		      lda	(MATHSTACK),y
    583  2cfd		       85 50		      sta	CURPTR+1
    584  2cff		       88		      dey
    585  2d00		       b1 48		      lda	(MATHSTACK),y
    586  2d02		       85 4f		      sta	CURPTR
    587  2d04		       84 4a		      sty	MATHSTACKPTR
    588  2d06		       7a		      ply
    589  2d07		       18		      clc
    590  2d08		       60		      rts
    591  2d09				   poperr1
    592  2d09		       7a		      ply
    593  2d0a		       38		      sec
    594  2d0b		       60		      rts
    595  2d0c
    596  2d0c							;=====================================================
    597  2d0c							; This pops Top Off gosub call Stack and
    598  2d0c							; places it in CURPTR/CUROFF.
    599  2d0c							; This checks if the type = 1 GOSUB
    600  2d0c							; if not it removes what ever is on the stack
    601  2d0c							; until it finds the next return. Allowing
    602  2d0c							; a return from within a for/next
    603  2d0c							; on exit a contains the type of return from, gosub_rtn, gosub_rtn_value....
    604  2d0c
    605  2d0c
    606  2d0c		       8c dc 43    popLN      sty	rtemp1
    607  2d0f		       a4 4d		      ldy	GOSUBSTACKPTR	; Get the Gosub/for stack pointer
    608  2d11		       a2 03		      ldx	#3	; each stack entry is 3 bytes
    609  2d13
    610  2d13				   popContinue
    611  2d13		       c0 04		      cpy	#4	; if less than 4 on stack then error
    612  2d15		       90 22		      bcc	poperr	; Process an error
    613  2d17
    614  2d17		       88		      dey		; Position to read entry type
    615  2d18		       b1 4b		      lda	(GOSUBSTACK),y	; get the stack entry type
    616  2d1a		       8d dd 43 	      sta	rtemp1+1	; Save to be returned
    617  2d1d		       c9 01		      cmp	#GOSUB_RTN	; Type is a gosub entry
    618  2d1f		       f0 04		      beq	popLoop	; Restore the line
    619  2d21		       c9 81		      cmp	#GOSUB_RTN_VALUE	; Also restore the line
    620  2d23		       d0 16		      bne	popSkipEntry	; No then just skip this
    621  2d25
    622  2d25				   popLoop
    623  2d25		       88		      dey
    624  2d26		       ca		      dex
    625  2d27		       b1 4b		      lda	(GOSUBSTACK),y
    626  2d29		       95 4f		      sta	CURPTR,x
    627  2d2b		       e0 00		      cpx	#0
    628  2d2d		       d0 f6		      bne	popLoop	; Loop until all moved
    629  2d2f
    630  2d2f		       84 4d	   PopDone    sty	GOSUBSTACKPTR
    631  2d31		       ac dc 43 	      ldy	rtemp1
    632  2d34		       ad dd 43 	      lda	rtemp1+1	; get the type of return
    633  2d37		       18		      clc
    634  2d38		       60		      rts
    635  2d39
    636  2d39		       38	   poperr     sec
    637  2d3a		       60		      rts
    638  2d3b
    639  2d3b		       88	   popSkipEntry dey
    640  2d3c		       88		      dey
    641  2d3d		       88		      dey
    642  2d3e		       4c 13 2d 	      jmp	popContinue
    643  2d41
    644  2d41							;
    645  2d41							;=====================================================
    646  2d41							; This pushes R1 onto the stack
    647  2d41							;
    648  2d41		       8c dc 43    pushR1     sty	rtemp1
    649  2d44		       a4 4a		      ldy	MATHSTACKPTR
    650  2d46		       c0 28		      cpy	#MATHSTACKSIZE<<1
    651  2d48		       b0 ef		      bcs	poperr
    652  2d4a		       a5 54		      lda	R1
    653  2d4c		       91 48		      sta	(MATHSTACK),y
    654  2d4e		       c8		      iny
    655  2d4f		       a5 55		      lda	R1+1
    656  2d51		       91 48		      sta	(MATHSTACK),y
    657  2d53		       c8		      iny
    658  2d54		       84 4a		      sty	MATHSTACKPTR
    659  2d56		       ac dc 43 	      ldy	rtemp1
    660  2d59		       18		      clc
    661  2d5a		       60		      rts
    662  2d5b							;
    663  2d5b							;=====================================================
    664  2d5b							; This pops Top Of Stack and places it in R0.
    665  2d5b							;
    666  2d5b		       8c dc 43    popR0      sty	rtemp1
    667  2d5e		       a4 4a		      ldy	MATHSTACKPTR
    668  2d60		       f0 d7		      beq	poperr
    669  2d62		       88		      dey
    670  2d63		       b1 48		      lda	(MATHSTACK),y
    671  2d65		       85 53		      sta	R0+1
    672  2d67		       88		      dey
    673  2d68		       b1 48		      lda	(MATHSTACK),y
    674  2d6a		       85 52		      sta	R0
    675  2d6c		       84 4a		      sty	MATHSTACKPTR
    676  2d6e		       ac dc 43 	      ldy	rtemp1
    677  2d71		       18		      clc
    678  2d72		       60		      rts
    679  2d73
    680  2d73							;
    681  2d73							;=====================================================
    682  2d73							; This pops TOS and places it in R1.
    683  2d73							;
    684  2d73		       8c dc 43    popR1      sty	rtemp1
    685  2d76		       a4 4a		      ldy	MATHSTACKPTR
    686  2d78		       f0 bf		      beq	poperr
    687  2d7a		       88		      dey
    688  2d7b		       b1 48		      lda	(MATHSTACK),y
    689  2d7d		       85 55		      sta	R1+1
    690  2d7f		       88		      dey
    691  2d80		       b1 48		      lda	(MATHSTACK),y
    692  2d82		       85 54		      sta	R1
    693  2d84		       84 4a		      sty	MATHSTACKPTR
    694  2d86		       ac dc 43 	      ldy	rtemp1
    695  2d89		       60		      rts
    696  2d8a							;
    697  2d8a							;=====================================================
    698  2d8a							; This pops TOS and places it in MQ.
    699  2d8a							;
    700  2d8a		       8c dc 43    popMQ      sty	rtemp1
    701  2d8d		       a4 4a		      ldy	MATHSTACKPTR
    702  2d8f		       f0 a8		      beq	poperr
    703  2d91		       88		      dey
    704  2d92		       b1 48		      lda	(MATHSTACK),y
    705  2d94		       85 57		      sta	MQ+1
    706  2d96		       88		      dey
    707  2d97		       b1 48		      lda	(MATHSTACK),y
    708  2d99		       85 56		      sta	MQ
    709  2d9b		       84 4a		      sty	MATHSTACKPTR
    710  2d9d		       ac dc 43 	      ldy	rtemp1
    711  2da0		       60		      rts
    712  2da1							;
    713  2da1							;=====================================================
    714  2da1							; This assists with multiplication and division by
    715  2da1							; looking at R0 and R1 and saving a flag as to what
    716  2da1							; sign the result will be.  Math is always done on
    717  2da1							; positive numbers, so this converts negative numbers
    718  2da1							; into positives.  On exit, R0 and R1 are both
    719  2da1							; positive.  If the signs were different then 'signs'
    720  2da1							; will be non-zero.
    721  2da1							;
    722  2da1		       a9 00	   SaveSigns  lda	#0
    723  2da3		       8d db 43 	      sta	sign	;assume positive
    724  2da6		       a5 53		      lda	R0+1	;MSB
    725  2da8		       10 13		      bpl	SaveSigns1
    726  2daa		       ee db 43 	      inc	sign	;it's negative
    727  2dad		       49 ff		      eor	#$ff	;flip bits
    728  2daf		       85 53		      sta	R0+1
    729  2db1		       a5 52		      lda	R0
    730  2db3		       49 ff		      eor	#$ff
    731  2db5		       85 52		      sta	R0
    732  2db7		       e6 52		      inc	R0
    733  2db9		       d0 02		      bne	SaveSigns1
    734  2dbb		       e6 53		      inc	R0+1
    735  2dbd		       a5 55	   SaveSigns1 lda	R1+1
    736  2dbf		       10 1a		      bpl	SaveSigns2
    737  2dc1		       48		      pha
    738  2dc2		       ad db 43 	      lda	sign
    739  2dc5		       49 01		      eor	#1
    740  2dc7		       8d db 43 	      sta	sign
    741  2dca		       68		      pla
    742  2dcb		       49 ff		      eor	#$ff	;flip bits
    743  2dcd		       85 55		      sta	R1+1
    744  2dcf		       a5 54		      lda	R1
    745  2dd1		       49 ff		      eor	#$ff
    746  2dd3		       85 54		      sta	R1
    747  2dd5		       e6 54		      inc	R1
    748  2dd7		       d0 02		      bne	SaveSigns2
    749  2dd9		       e6 55		      inc	R1+1
    750  2ddb		       60	   SaveSigns2 rts
    751  2ddc							;
    752  2ddc							;=====================================================
    753  2ddc							; This looks at the value of 'signs' and will convert
    754  2ddc							; both R0 and R1 to negative if set.
    755  2ddc							;
    756  2ddc				   RestoreSigns
    757  2ddc		       ad db 43 	      lda	sign
    758  2ddf		       f0 28		      beq	restoresigns2
    759  2de1							;
    760  2de1		       a5 52		      lda	R0
    761  2de3		       d0 02		      bne	restoresigns3
    762  2de5		       c6 53		      dec	R0+1
    763  2de7				   restoresigns3
    764  2de7		       c6 52		      dec	R0
    765  2de9		       a5 52		      lda	R0
    766  2deb		       49 ff		      eor	#$ff
    767  2ded		       85 52		      sta	R0
    768  2def		       a5 53		      lda	R0+1
    769  2df1		       49 ff		      eor	#$ff
    770  2df3		       85 53		      sta	R0+1
    771  2df5							;
    772  2df5		       a5 54		      lda	R1
    773  2df7		       d0 02		      bne	restoresigns4
    774  2df9		       c6 55		      dec	R1+1
    775  2dfb				   restoresigns4
    776  2dfb		       c6 54		      dec	R1
    777  2dfd		       a5 54		      lda	R1
    778  2dff		       49 ff		      eor	#$ff
    779  2e01		       85 54		      sta	R1
    780  2e03		       a5 55		      lda	R1+1
    781  2e05		       49 ff		      eor	#$ff
    782  2e07		       85 55		      sta	R1+1
    783  2e09							;
    784  2e09				   restoresigns2
    785  2e09		       60		      rts
    786  2e0a							;
    787  2e0a							;=====================================================
    788  2e0a							; Skip over spaces.  Returns Y with the offset to
    789  2e0a							; either the last character in the line, or the first
    790  2e0a							; non-space character.
    791  2e0a							;
    792  2e0a
    793  2e0a		       c8	   skipsp2    iny
    794  2e0b		       b1 4f	   SkipSpaces lda	(CURPTR),y
    795  2e0d		       f0 04		      beq	Skip3	;end of line
    796  2e0f		       c9 20		      cmp	#SPACE
    797  2e11		       f0 f7		      beq	skipsp2
    798  2e13		       60	   Skip3      rts
    799  2e14							;*********************************************************
    800  2e14							; Output a CR/LF combination to the console.  Preserves
    801  2e14							; all registers.
    802  2e14							;
    803  2e14		       48	   tbcrlf     pha
    804  2e15		       a9 0d		      lda	#CR
    805  2e17		       20 1f 1a 	      jsr	VOUTCH
    806  2e1a		       a9 0a		      lda	#LF
    807  2e1c		       20 1f 1a 	      jsr	VOUTCH
    808  2e1f		       68		      pla
    809  2e20		       60		      rts
    810  2e21							;
    811  2e21							;=====================================================
    812  2e21							; Some logic to print the Line of basic code being executed
    813  2e21				   idbgBasic
    814  2e21		       24 40		      bit	ILTrace
    815  2e23		       50 75		      bvc	dbgBasicNone
    816  2e25		       5a		      phy
    817  2e26		       20 ac 2f 	      jsr	SetOutDebug
    818  2e29
    819  2e29		       a5 4f		      lda	CURPTR
    820  2e2b		       85 59		      sta	dpl
    821  2e2d		       a5 50		      lda	CURPTR+1
    822  2e2f		       85 5a		      sta	dpl+1
    823  2e31
    824  2e31		       20 13 22 	      jsr	PrintProgramLine
    825  2e34
    826  2e34		       a5 40		      lda	ILTrace
    827  2e36		       29 01		      and	#$01	; Check if the Basic debug should be interactive
    828  2e38		       f0 5c		      beq	dbgBasicDone
    829  2e3a		       20 c3 2f 	      jsr	SetInDebug
    830  2e3d		       20 80 21 	      jsr	puts
      0  2e40					      db	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
      1  2e40		       50 72 65 73*	      .byte.b	"Press s - Stop",CR,LF,"d - display Vars",CR,LF,"anything else to step",CR,LF," > ",0
    832  2e7d				   dbgBasicLoop
    833  2e7d		       20 22 1a 	      jsr	VGETCH
    834  2e80		       48		      pha
    835  2e81		       20 14 2e 	      jsr	CRLF
    836  2e84		       20 e7 2f 	      jsr	SetInDebugEnd
    837  2e87
    838  2e87		       68		      pla
    839  2e88				   dbgTestPoint
    840  2e88		       c9 73		      cmp	#'s	; Quit program
    841  2e8a		       f0 11		      beq	dbgBasicStop
    842  2e8c
    843  2e8c		       c9 64		      cmp	#'d	; Display Variables
    844  2e8e		       d0 06		      bne	dbgBasicDone
    845  2e90
    846  2e90		       20 db 21 	      jsr	PrintAllVars
    847  2e93		       18		      clc
    848  2e94		       90 e7		      bcc	dbgBasicLoop	; Next char
    849  2e96
    850  2e96		       20 da 2f    dbgBasicDone jsr	SetOutDebugEnd
    851  2e99		       7a		      ply
    852  2e9a
    853  2e9a		       4c 9e 02    dbgBasicNone jmp	NextIL
    854  2e9d
    855  2e9d				   dbgBasicStop
    856  2e9d		       20 da 2f 	      jsr	SetOutDebugEnd
    857  2ea0		       7a		      ply
    858  2ea1		       4c eb 05 	      jmp	iFIN
    859  2ea4
    860  2ea4							;
    861  2ea4							;=====================================================
    862  2ea4							; This is some debug logic which displays the current
    863  2ea4							; value of the ILPC and the line buffer.
    864  2ea4							;
    865  2ea4				   dbgLine
    866  2ea4
    867  2ea4		       24 40		      bit	ILTrace
    868  2ea6		       30 01		      bmi	dbgPrt
    869  2ea8		       60		      rts
    870  2ea9				   dbgPrt
    871  2ea9		       20 ac 2f 	      jsr	SetOutDebug
    872  2eac		       20 80 21 	      jsr	puts
      0  2eaf					      db	"ILPC:",0
      1  2eaf		       49 4c 50 43*	      .byte.b	"ILPC:",0
    874  2eb5		       a5 44		      lda	ILPC+1
    875  2eb7		       20 63 21 	      jsr	OUTHEX
    876  2eba		       a5 43		      lda	ILPC
    877  2ebc		       20 63 21 	      jsr	OUTHEX
    878  2ebf		       a9 20		      lda	#SPACE
    879  2ec1		       20 1f 1a 	      jsr	VOUTCH
    880  2ec4
    881  2ec4		       a0 00		      ldy	#0
    882  2ec6		       b1 43		      lda	(ILPC),y	;Get the il pcode value
    883  2ec8					      if	IL_DEBUG_TEXT
    884  2ec8		       20 db 18 	      jsr	PrintILText
    885  2ecb				  -	      else
    886  2ecb				  -	      jsr	OUTHEX
    887  2ecb					      endif
    888  2ecb		       20 80 21 	      jsr	puts
      0  2ece					      db	" ILSP:",0
      1  2ece		       20 49 4c 53*	      .byte.b	" ILSP:",0
    890  2ed5		       a5 47		      lda	ILSTACKPTR
    891  2ed7		       20 63 21 	      jsr	OUTHEX
    892  2eda		       a9 20		      lda	#SPACE
    893  2edc		       20 1f 1a 	      jsr	VOUTCH
    894  2edf
    895  2edf							; Display the CURPTR value and offset
    896  2edf							;
    897  2edf		       20 80 21 	      jsr	puts
      0  2ee2					      db	", CURPTR: ",0
      1  2ee2		       2c 20 43 55*	      .byte.b	", CURPTR: ",0
    899  2eed		       a5 50		      lda	CURPTR+1
    900  2eef		       20 63 21 	      jsr	OUTHEX
    901  2ef2		       a5 4f		      lda	CURPTR
    902  2ef4		       20 63 21 	      jsr	OUTHEX
    903  2ef7		       a9 2b		      lda	#'+
    904  2ef9		       20 1f 1a 	      jsr	VOUTCH
    905  2efc		       a5 51		      lda	CUROFF
    906  2efe		       20 63 21 	      jsr	OUTHEX
    907  2f01							;
    908  2f01		       20 14 2e 	      jsr	CRLF
    909  2f04		       20 da 2f 	      jsr	SetOutDebugEnd
    910  2f07		       20 3a 2f 	      jsr	ILChkRange
    911  2f0a		       b0 02		      bcs	dbgLineErr
    912  2f0c		       18		      clc
    913  2f0d		       60		      rts
    914  2f0e
    915  2f0e				   dbgLineErr
    916  2f0e		       20 ac 2f 	      jsr	SetOutDebug
    917  2f11		       20 80 21 	      jsr	puts
      0  2f14					      db	"Outside Valid IL Address Range",CR,LF,0
      1  2f14		       4f 75 74 73*	      .byte.b	"Outside Valid IL Address Range",CR,LF,0
    919  2f35		       20 da 2f 	      jsr	SetOutDebugEnd
    920  2f38		       38		      sec
    921  2f39		       60		      rts
    922  2f3a
    923  2f3a		       a5 44	   ILChkRange lda	ILPC+1
    924  2f3c		       c9 32		      cmp	#IL>>8
    925  2f3e		       90 18		      bcc	ILBadRange
    926  2f40		       d0 06		      bne	ILChkHigh
    927  2f42
    928  2f42		       a5 43		      lda	ILPC
    929  2f44		       c9 9d		      cmp	#IL&$ff
    930  2f46		       90 10		      bcc	ILBadRange
    931  2f48
    932  2f48		       a5 44	   ILChkHigh  lda	ILPC+1
    933  2f4a		       c9 37		      cmp	#ILEND>>8
    934  2f4c		       90 08		      bcc	ILGoodRange
    935  2f4e		       d0 08		      bne	ILBadRange
    936  2f50
    937  2f50		       a5 43		      lda	ILPC
    938  2f52		       c9 20		      cmp	#ILEND&$ff
    939  2f54		       b0 02		      bcs	ILBadRange
    940  2f54					      endif
    941  2f56		       18	   ILGoodRange clc
    942  2f57		       60		      rts
    943  2f58
    944  2f58				   ILBadRange
    945  2f58		       38		      sec
    946  2f59		       60		      rts
    947  2f5a
    948  2f5a							;=====================================================
    949  2f5a							; Set output vector to the console output function
    950  2f5a							;
    951  2f5a				   SetOutConsole
    952  2f5a		       48		      pha
    953  2f5b		       a9 0c		      lda	#OUTCH&$ff
    954  2f5d		       8d 25 37 	      sta	BOutVec
    955  2f60		       a9 f0		      lda	#OUTCH>>8
    956  2f62		       8d 26 37 	      sta	BOutVec+1
    957  2f65		       68		      pla
    958  2f66		       60		      rts
    959  2f67
    960  2f67				   SetInConsole
    961  2f67		       48		      pha
    962  2f68		       a9 09		      lda	#GETCH&$ff
    963  2f6a		       8d 23 37 	      sta	BInVec
    964  2f6d		       a9 f0		      lda	#GETCH>>8
    965  2f6f		       8d 24 37 	      sta	BInVec+1
    966  2f72		       68		      pla
    967  2f73		       60		      rts
    968  2f74
    969  2f74							;====================================================
    970  2f74							;Clear the terminal assume it is ansii or vt100
    971  2f74							;
    972  2f74				   iCLEARSCREEN
    973  2f74		       20 80 21 	      jsr	puts
      0  2f77					      db	$1b,'[,'2,'J,$1b,'[,'1,';,'1,'H,$1b,'[,'?,'2,'5,'h,0
      1  2f77		       1b 5b 32 4a*	      .byte.b	$1b,'[,'2,'J,$1b,'[,'1,';,'1,'H,$1b,'[,'?,'2,'5,'h,0
    975  2f88		       4c 9e 02 	      jmp	NextIL
    976  2f8b
    977  2f8b							;====================================================
    978  2f8b							; Push true and false onto math stack
    979  2f8b				   pushTrue
    980  2f8b		       a9 ff		      lda	#$ff
    981  2f8d		       85 52	   pushTF     sta	R0
    982  2f8f		       85 53		      sta	R0+1
    983  2f91		       20 af 2c 	      jsr	pushR0
    984  2f94		       60		      rts
    985  2f95		       a9 00	   pushFalse  lda	#0
    986  2f97		       f0 f4		      beq	pushTF
    987  2f99
    988  2f99							;======================================================
    989  2f99							; Copy stack top to R1
    990  2f99				   CopyStackR1
    991  2f99		       5a		      phy
    992  2f9a		       a4 4a		      ldy	MATHSTACKPTR
    993  2f9c		       88		      dey
    994  2f9d		       b1 48		      lda	(MATHSTACK),y
    995  2f9f		       85 55		      sta	R1+1
    996  2fa1		       88		      dey
    997  2fa2		       b1 48		      lda	(MATHSTACK),y
    998  2fa4		       85 54		      sta	R1
    999  2fa6		       7a		      ply
   1000  2fa7		       60		      rts
   1001  2fa8
   1002  2fa8							;====================================================
   1003  2fa8							;Swap the out debug call for standard calls
   1004  2fa8		       00 00	   DebugIOSave ds	2
   1005  2faa		       00 00	   DebugInSave ds	2
   1006  2fac				   SetOutDebug
   1007  2fac		       ad 25 37 	      lda	BOutVec
   1008  2faf		       8d a8 2f 	      sta	DebugIOSave
   1009  2fb2		       ad 26 37 	      lda	BOutVec+1
   1010  2fb5		       8d a9 2f 	      sta	DebugIOSave+1
   1011  2fb8		       a9 3e		      lda	#OUTDEBUG&$ff	; Put the Debug output
   1012  2fba		       8d 25 37 	      sta	BOutVec
   1013  2fbd		       a9 30		      lda	#OUTDEBUG>>8
   1014  2fbf		       8d 26 37 	      sta	BOutVec+1
   1015  2fc2		       60		      rts
   1016  2fc3				   SetInDebug
   1017  2fc3		       ad 23 37 	      lda	BInVec
   1018  2fc6		       8d aa 2f 	      sta	DebugInSave
   1019  2fc9		       ad 24 37 	      lda	BInVec+1
   1020  2fcc		       8d ab 2f 	      sta	DebugInSave+1
   1021  2fcf		       a9 42		      lda	#INDEBUG&$ff
   1022  2fd1		       8d 23 37 	      sta	BInVec
   1023  2fd4		       a9 30		      lda	#INDEBUG>>8
   1024  2fd6		       8d 24 37 	      sta	BInVec+1
   1025  2fd9		       60		      rts
   1026  2fda				   SetOutDebugEnd
   1027  2fda		       ad a8 2f 	      lda	DebugIOSave
   1028  2fdd		       8d 25 37 	      sta	BOutVec
   1029  2fe0		       ad a9 2f 	      lda	DebugIOSave+1
   1030  2fe3		       8d 26 37 	      sta	BOutVec+1
   1031  2fe6		       60		      rts
   1032  2fe7				   SetInDebugEnd
   1033  2fe7		       ad aa 2f 	      lda	DebugInSave
   1034  2fea		       8d 23 37 	      sta	BInVec
   1035  2fed		       ad ab 2f 	      lda	DebugInSave+1
   1036  2ff0		       8d 24 37 	      sta	BInVec+1
   1037  2ff3		       60		      rts
   1038  2ff4							;
   1039  2ff4							;====================================================
   1040  2ff4							; Set the input and output terminal address
   1041  2ff4							; The math stack stack byte is the output io slot
   1042  2ff4							; The math stack  is the input io slot
   1043  2ff4
   1044  2ff4				   iSetTerminal
   1045  2ff4		       20 5b 2d 	      jsr	popR0	; Process the output io addresses
   1046  2ff7		       20 21 30 	      jsr	CalcSlot
   1047  2ffa		       a5 52		      lda	R0
   1048  2ffc		       09 01		      ora	#1
   1049  2ffe		       8d 3f 30 	      sta	TerminalOutputPort
   1050  3001		       a5 53		      lda	R0+1
   1051  3003		       8d 40 30 	      sta	TerminalOutputPort+1
   1052  3006
   1053  3006		       20 5b 2d 	      jsr	popR0	; Process the input io address
   1054  3009		       20 21 30 	      jsr	CalcSlot
   1055  300c		       a5 52		      lda	R0
   1056  300e		       8d 43 30 	      sta	TerminalStatusPort
   1057  3011		       09 01		      ora	#1
   1058  3013		       8d 4a 30 	      sta	TerminalInputPort
   1059  3016		       a5 53		      lda	R0+1
   1060  3018		       8d 4b 30 	      sta	TerminalInputPort+1
   1061  301b		       8d 44 30 	      sta	TerminalStatusPort+1
   1062  301e		       4c 9e 02 	      jmp	NextIL
   1063  3021
   1064  3021							;===================================================
   1065  3021							; Calculate the slot address the the slot number
   1066  3021							; R0 contains the slot number 0-255
   1067  3021
   1068  3021				   CalcSlot
   1069  3021		       da		      phx
   1070  3022
   1071  3022		       a2 04		      ldx	#4
   1072  3024				   CalcSlotLoop
   1073  3024		       18		      clc
   1074  3025		       26 52		      rol	R0
   1075  3027		       26 53		      rol	R0+1
   1076  3029		       ca		      dex
   1077  302a		       d0 f8		      bne	CalcSlotLoop
   1078  302c
   1079  302c		       a9 e0		      lda	#$E0
   1080  302e		       05 53		      ora	R0+1
   1081  3030		       85 53		      sta	R0+1
   1082  3032		       fa		      plx
   1083  3033		       60		      rts
   1084  3034							;
   1085  3034							;====================================================
   1086  3034							; Output to the Terminal/Debug console
   1087  3034							;     x = high address byte
   1088  3034							;     y = low address byte
   1089  3034							;     a = Terminator for string
   1090  3034				   TerminalWrite
   1091  3034				   DebugWrite
   1092  3034		       20 ac 2f 	      jsr	SetOutDebug
   1093  3037		       20 be 21 	      jsr	PrtStr
   1094  303a		       20 da 2f 	      jsr	SetOutDebugEnd
   1095  303d		       60		      rts
   1096  303e
   1097  303e				   TerminalIOblock
   1098  303e				   OUTDEBUG
   1099  303e		       8d		      .byte.b	$8D	; STA
   1100  303f				   TerminalOutputPort
   1101  303f		       21 e0	   DEBUGPORT  .word.w	$E021	; Dont check anything just output the byte
   1102  3041		       60		      RTS
   1103  3042
   1104  3042				   TerminalRead
   1105  3042				   INDEBUG
   1106  3042		       ad		      .byte.b	$AD	; LDA
   1107  3043				   TerminalStatusPort
   1108  3043		       20 e0	   DEBUGPORTSTATUS .word.w	$E020
   1109  3045
   1110  3045		       29 01		      and	#$01
   1111  3047		       f0 f9		      beq	INDEBUG
   1112  3049
   1113  3049		       ad		      .byte.b	$AD	; LDA
   1114  304a				   TerminalInputPort
   1115  304a		       21 e0	   DEBUGPORTIN .word.w	$E021
   1116  304c		       60		      rts
   1117  304d				   TerminalIOblockEnd
   1118  304d							;======================================================================
   1119  304d							;Copy Quoted string to buffer, terminate with 0 byte
   1120  304d							; R0  Source tring points to tString type
   1121  304d							; x is terminator
   1122  304d							; R1 points to destinition location
   1123  304d							; On exit R0 contains length of copy Plus Term and leading bytes
   1124  304d
   1125  304d				   qstrcpy
   1126  304d		       20 af 2c 	      jsr	pushR0
   1127  3050		       20 9d 30 	      jsr	IncR0	; point past the tString
   1128  3053		       20 9d 30 	      jsr	IncR0	; Point Past the opening "
   1129  3056		       a2 22		      ldx	#'"	; copy Termination
   1130  3058		       20 72 30 	      jsr	pstrcpy
   1131  305b		       20 9d 30 	      jsr	IncR0	; point to "
   1132  305e		       20 9d 30 	      jsr	IncR0	; Point to next free byte
   1133  3061		       20 73 2d 	      jsr	popR1
   1134  3064		       38		      sec
   1135  3065		       a5 52		      lda	R0
   1136  3067		       e5 54		      sbc	R1
   1137  3069		       85 52		      sta	R0
   1138  306b		       a5 53		      lda	R0+1
   1139  306d		       e5 55		      sbc	R1+1
   1140  306f		       85 53		      sta	R0+1
   1141  3071		       60		      rts
   1142  3072
   1143  3072							;=========================================================================
   1144  3072							;Copy string from R0 to R1, terminator in x
   1145  3072							; On exit    R0 contains the length of the copy
   1146  3072				   pstrcpy
   1147  3072		       a0 00		      ldy	#0
   1148  3074		       86 58		      stx	R2
   1149  3076
   1150  3076				   strcpyLoop
   1151  3076		       b1 52		      lda	(R0),y
   1152  3078		       c5 58		      cmp	R2
   1153  307a		       f0 0a		      beq	strcpyDone
   1154  307c		       91 54		      sta	(R1),y
   1155  307e		       20 9d 30 	      jsr	IncR0
   1156  3081		       20 8b 30 	      jsr	IncR1
   1157  3084		       90 f0		      bcc	strcpyLoop
   1158  3086				   strcpyDone
   1159  3086		       a9 00		      lda	#0
   1160  3088		       91 54		      sta	(R1),y
   1161  308a
   1162  308a		       60		      rts
   1163  308b
   1164  308b							;=========================================================================
   1165  308b							; on exit c is set on overflow
   1166  308b				   IncR1
   1167  308b		       48		      pha
   1168  308c		       18		      clc
   1169  308d		       a9 01		      lda	#1
   1170  308f		       65 54		      adc	R1
   1171  3091		       85 54		      sta	R1
   1172  3093		       90 06		      bcc	IncR1Done
   1173  3095		       a9 00		      lda	#0
   1174  3097		       65 55		      adc	R1+1
   1175  3099		       85 55		      sta	R1+1
   1176  309b				   IncR1Done
   1177  309b		       68		      pla
   1178  309c		       60		      rts
   1179  309d							;=========================================================================
   1180  309d							; on exit c is set on overflow
   1181  309d				   IncR0
   1182  309d		       48		      pha
   1183  309e		       18		      clc
   1184  309f		       a9 01		      lda	#1
   1185  30a1		       65 52		      adc	R0
   1186  30a3		       85 52		      sta	R0
   1187  30a5		       90 06		      bcc	IncR0Done
   1188  30a7		       a9 00		      lda	#0
   1189  30a9		       65 53		      adc	R0+1
   1190  30ab		       85 53		      sta	R0+1
   1191  30ad				   IncR0Done
   1192  30ad		       68		      pla
   1193  30ae		       60		      rts
------- FILE mytb.asm
   2477  30af
   2478  30af					      if	DISK_ACCESS
------- FILE storage.asm LEVEL 2 PASS 6
      0  30af					      include	"storage.asm"
      1  30af							;
      2  30af							;=====================================================
      3  30af							;=====================================================
      4  30af							;=====================================================
      5  30af							; This file contains the functions for saving and
      6  30af							; restoring programs from some sort of mass storage
      7  30af							; device.  This particular version is for using the
      8  30af							; Corsham Tech SD Card System.
      9  30af							;=====================================================
     10  30af							;=====================================================
     11  30af							;=====================================================
     12  30af
     13 U3731					      seg.u	TBData
     14 U3731		       00	   diskBufLength ds	1
     15 U3732		       00	   diskBufOffset ds	1
     16 U3733		       00 00 00 00*DiskFileName ds	64
     17 U3773
     18  30af					      SEG	Code
     19  30af
     20  30af							;
     21  30af							;=====================================================
     22  30af							; Open a file for reading as a program.  The next
     23  30af							; thing on the line should be the filename.
     24  30af							;
     25  30af				   iOPENREAD
     26  30af					      if	XKIM || CTMON65
     27  30af		       20 c9 30 	      jsr	setFileName	;Set the file name to open
     28  30b2		       20 36 f0 	      jsr	DiskOpenRead	;attempt to open file
     29  30b5		       90 07		      bcc	Ropenok	;branch if opened ok
     30  30b7							;
     31  30b7							; Open failed
     32  30b7							;
     33  30b7		       a2 07	   Rdfail     ldx	#ERR_READ_FAIL
     34  30b9		       a9 00	   Rdfail2    lda	#0
     35  30bb		       4c 66 06 	      jmp	iErr2
     36  30be							;
     37  30be							; Clear counts and offsets so the next read will
     38  30be							; cause the file to be read.
     39  30be							;
     40  30be		       a9 00	   Ropenok    lda	#0
     41  30c0		       8d 32 37 	      sta	diskBufOffset
     42  30c3		       8d 31 37 	      sta	diskBufLength
     43  30c6		       4c 9e 02 	      jmp	NextIL
     44  30c9					      endif
     45  30c9
     46  30c9							;===============================================================
     47  30c9							; Set file name
     48  30c9				   setFileName
     49  30c9		       a4 51		      ldy	CUROFF
     50  30cb		       b1 4f		      lda	(CURPTR),y
     51  30cd		       c9 a0		      cmp	#tString	;Must be a quoted string
     52  30cf		       d0 24		      bne	setFileNameNotFound	;Must be a filename
     53  30d1
     54  30d1		       18		      clc
     55  30d2		       98		      tya
     56  30d3		       65 4f		      adc	CURPTR
     57  30d5		       85 52		      sta	R0	;LSB
     58  30d7		       a5 50		      lda	CURPTR+1
     59  30d9		       69 00		      adc	#0
     60  30db		       85 53		      sta	R0+1
     61  30dd		       a9 33		      lda	#DiskFileName&$ff
     62  30df		       85 54		      sta	R1
     63  30e1		       a9 37		      lda	#DiskFileName>>8
     64  30e3		       85 55		      sta	R1+1
     65  30e5		       20 4d 30 	      jsr	qstrcpy	; on exit R0 contains the total copy length index accross source not dest
     66  30e8		       a5 52		      lda	R0
     67  30ea		       18		      clc
     68  30eb		       65 51		      adc	CUROFF	; add the current offset
     69  30ed		       85 51		      sta	CUROFF	; Update the buffer pointer after complete
     70  30ef				   ResetFileName
     71  30ef		       a0 33		      ldy	#DiskFileName&$ff
     72  30f1		       a2 37		      ldx	#DiskFileName>>8
     73  30f3		       18		      clc
     74  30f4		       60		      rts
     75  30f5
     76  30f5				   setFileNameNotFound
     77  30f5		       68		      pla
     78  30f6		       68		      pla		; remove the return address from the stack
     79  30f7		       a9 00		      lda	#0
     80  30f9		       a2 09		      ldx	#ERR_NO_FILENAME
     81  30fb		       4c 66 06 	      jmp	iErr2
     82  30fe
     83  30fe							;
     84  30fe							;==============================JUSTLOSTINTIME 08/02/2022========
     85  30fe							;Remove a file from the disk
     86  30fe				   iRMFILE
     87  30fe					      if	XKIM || CTMON65
     88  30fe		       20 c9 30 	      jsr	setFileName
     89  3101		       20 45 f0 	      jsr	DiskRmFile	;attempt to remove file
     90  3104		       90 07		      bcc	wrmOk	;branch if removed ok
     91  3106		       a9 00		      lda	#0
     92  3108		       a2 0a		      ldx	#ERR_FILE_NOT_FOUND
     93  310a		       4c 66 06 	      jmp	iErr2
     94  310d				   wrmOk
     95  310d		       4c 9e 02 	      jmp	NextIL
     96  3110
     97  3110					      endif
     98  3110							;
     99  3110							;=====================================================
    100  3110				   iOPENWRITE
    101  3110					      if	XKIM || CTMON65
    102  3110		       20 c9 30 	      jsr	setFileName
    103  3113		       20 b6 2a 	      jsr	getILByte	;get the append or create byte
    104  3116		       c9 01		      cmp	#1	;create/truncate
    105  3118		       d0 06		      bne	iopencont
    106  311a		       20 ef 30 	      jsr	ResetFileName	;point back to the file name
    107  311d		       20 45 f0 	      jsr	DiskRmFile	;by default files opened for write are append
    108  3120
    109  3120				   iopencont
    110  3120		       20 ef 30 	      jsr	ResetFileName	;point back to the file name
    111  3123		       20 39 f0 	      jsr	DiskOpenWrite	;attempt to open file
    112  3126		       90 07		      bcc	Wopenok	;branch if opened ok
    113  3128							;
    114  3128							; Open failed
    115  3128							;
    116  3128		       a9 00	   Wdfail     lda	#0
    117  312a		       a2 08		      ldx	#ERR_WRITE_FAIL
    118  312c		       4c 66 06 	      jmp	iErr2
    119  312f							;
    120  312f		       4c 9e 02    Wopenok    jmp	NextIL
    121  3132					      endif
    122  3132							;
    123  3132							;=====================================================
    124  3132							; Gets a line of input from the disk file and puts it
    125  3132							; into LINBUF.
    126  3132							;
    127  3132							; On exit:
    128  3132							;    CURPTR points to LINBUF
    129  3132							;    LINBUF contains the line with 0 at the end.
    130  3132							;    Y has offset to first non-space character
    131  3132							;    CURROFF has the same as Y.
    132  3132							;
    133  3132				   iDGETLINE
    134  3132					      if	XKIM || CTMON65
    135  3132		       a2 4f		      ldx	#LINBUF&$ff
    136  3134		       86 4f		      stx	CURPTR
    137  3136		       a2 43		      ldx	#LINBUF>>8
    138  3138		       86 50		      stx	CURPTR+1
    139  313a							;
    140  313a		       a2 00		      ldx	#0	;offset
    141  313c		       8e d3 43    iDgetLoop  stx	getlinx
    142  313f		       20 aa 31 	      jsr	getNextFileByte
    143  3142		       b0 16		      bcs	iGetEOF
    144  3144		       c9 0d		      cmp	#CR
    145  3146		       f0 0d		      beq	iGetEOL
    146  3148		       c9 0a		      cmp	#LF
    147  314a		       f0 09		      beq	iGetEOL
    148  314c		       ae d3 43 	      ldx	getlinx
    149  314f		       9d 4f 43 	      sta	LINBUF,x
    150  3152		       e8		      inx
    151  3153		       d0 e7		      bne	iDgetLoop
    152  3155							;
    153  3155							; Handle end of line.	If the line has nothing, loop
    154  3155							; back and get another line.
    155  3155							;
    156  3155		       ae d3 43    iGetEOL    ldx	getlinx	;blank line?
    157  3158		       f0 e2		      beq	iDgetLoop	;yes, ignore it
    158  315a							;
    159  315a							; This can fall through when there is a line, or
    160  315a							; called directly when EOF is encountered.
    161  315a							;
    162  315a		       ae d3 43    iGetEOF    ldx	getlinx
    163  315d		       a9 00		      lda	#0
    164  315f		       9d 4f 43 	      sta	LINBUF,x
    165  3162		       a0 00		      ldy	#0
    166  3164		       20 0b 2e 	      jsr	SkipSpaces
    167  3167		       20 23 1d 	      jsr	ParseInputLine
    168  316a		       a9 20		      lda	#TOKENBUFFER&$ff
    169  316c		       85 4f		      sta	CURPTR
    170  316e		       a9 1c		      lda	#TOKENBUFFER>>8
    171  3170		       85 50		      sta	CURPTR+1
    172  3172		       a9 01		      lda	#1
    173  3174		       85 51		      sta	CUROFF
    174  3176		       4c 9e 02 	      jmp	NextIL
    175  3179					      endif
    176  3179
    177  3179							;
    178  3179							; THIS IS CALLED TO DISPLAY THE CONTENTS OF THE
    179  3179							; DISK
    180  3179							;
    181  3179				   iDDIR
    182  3179					      if	XKIM || CTMON65
    183  3179		       20 30 f0 	      jsr	DiskDir
    184  317c							;
    185  317c							; Get/Display each entry
    186  317c							;
    187  317c		       a2 37	   DiskDirLoop ldx	#DiskFileName>>8	;pointer to buffer
    188  317e		       a0 33		      ldy	#DiskFileName&$ff
    189  3180		       20 33 f0 	      jsr	DiskDirNext	;get next entry
    190  3183		       b0 16		      bcs	DiskDirEnd	;carry = end of list
    191  3185		       20 80 21 	      jsr	puts
      0  3188					      db	"   ",0
      1  3188		       20 20 20 00	      .byte.b	"   ",0
    193  318c							; Print the line to the console
    194  318c		       a2 37		      ldx	#DiskFileName>>8	;pointer to buffer
    195  318e		       a0 33		      ldy	#DiskFileName&$ff
    196  3190		       a5 00		      lda	0
    197  3192		       20 be 21 	      jsr	PrtStr	;else print name
    198  3195		       20 18 f0 	      jsr	crlf
    199  3198
    200  3198		       4c 7c 31 	      jmp	DiskDirLoop	;do next entry
    201  319b
    202  319b		       4c 9e 02    DiskDirEnd jmp	NextIL
    203  319e					      endif
    204  319e							;
    205  319e							;=====================================================
    206  319e							; Does a LIST to a Disk file.
    207  319e							;
    208  319e				   iDLIST
    209  319e					      if	XKIM || CTMON65
    210  319e		       20 d9 31 	      jsr	SetOutDisk
    211  31a1		       4c 1f 08 	      jmp	iLST2
    212  31a4					      endif
    213  31a4							;
    214  31a4							;=====================================================
    215  31a4							; Closes any pending disk file.  Okay to call if there
    216  31a4							; is no open file.
    217  31a4							;
    218  31a4				   iDCLOSE
    219  31a4					      if	XKIM || CTMON65
    220  31a4		       20 42 f0 	      jsr	DiskClose
    221  31a7		       4c 9e 02 	      jmp	NextIL
    222  31aa					      endif
    223  31aa							;
    224  31aa							;=====================================================
    225  31aa							; This gets the next byte from an open disk file.  If
    226  31aa							; there are no more bytes left, this returns C set.
    227  31aa							; Else, C is clear and A contains the character.
    228  31aa							;
    229  31aa				   getNextFileByte
    230  31aa					      if	XKIM || CTMON65
    231  31aa		       ae 32 37 	      ldx	diskBufOffset
    232  31ad		       ec 31 37 	      cpx	diskBufLength
    233  31b0		       d0 14		      bne	hasdata	;branch if still data
    234  31b2							;
    235  31b2							; There is no data left in the buffer, so read a
    236  31b2							; block from the SD system.
    237  31b2							;
    238  31b2		       a9 84		      lda	#BUFFER_SIZE
    239  31b4		       a2 df		      ldx	#buffer>>8
    240  31b6		       a0 0a		      ldy	#buffer&$ff
    241  31b8		       20 3c f0 	      jsr	DiskRead
    242  31bb		       b0 12		      bcs	getNextEof
    243  31bd							;
    244  31bd							; A contains the number of bytes actually read.
    245  31bd							;
    246  31bd		       8d 31 37 	      sta	diskBufLength	;save length
    247  31c0		       c9 00		      cmp	#0	;shouldn't happen
    248  31c2		       f0 0b		      beq	getNextEof
    249  31c4							;
    250  31c4		       a2 00		      ldx	#0
    251  31c6		       bd 0a df    hasdata    lda	buffer,x
    252  31c9		       e8		      inx
    253  31ca		       8e 32 37 	      stx	diskBufOffset
    254  31cd		       18		      clc
    255  31ce		       60		      rts
    256  31cf							;
    257  31cf		       a9 00	   getNextEof lda	#0
    258  31d1		       8d 32 37 	      sta	diskBufOffset
    259  31d4		       8d 31 37 	      sta	diskBufLength
    260  31d7		       38		      sec
    261  31d8		       60		      rts
    262  31d9							;
    263  31d9							;=====================================================
    264  31d9							; Set output vector to the disk output function
    265  31d9							;
    266  31d9		       a9 e4	   SetOutDisk lda	#DOUT&$ff
    267  31db		       8d 25 37 	      sta	BOutVec
    268  31de		       a9 31		      lda	#DOUT/256
    269  31e0		       8d 26 37 	      sta	BOutVec+1
    270  31e3		       60		      rts
    271  31e4							;
    272  31e4							;=====================================================
    273  31e4							; input a contains charater to write to open file
    274  31e4							; output:
    275  31e4							;	    C flag clear if no error
    276  31e4							;
    277  31e4		       8e 33 37    DOUT       stx	DiskFileName	; Save the x value, fulename not used
    278  31e7		       8c 34 37 	      sty	DiskFileName+1	; Save the y value  filename not actually used
    279  31ea		       8d 0a df 	      sta	buffer	; Store the byte to send into the buffer
    280  31ed		       a9 01		      lda	#1	; set number of bytes to send to 1
    281  31ef		       a0 0a		      ldy	#buffer&$ff	; Load the low order address of buffer to y
    282  31f1		       a2 df		      ldx	#buffer>>8	; Load the high order address of buffer to x
    283  31f3		       20 3f f0 	      jsr	DiskWrite	; Place the character to disk if a file is open
    284  31f6		       ae 33 37 	      ldx	DiskFileName	; Restore the x value that was saved
    285  31f9		       ac 34 37 	      ldy	DiskFileName+1	; Restore the y value saved
    286  31fc		       60		      rts
    287  31fd							;=======================================================
    288  31fd							; output:
    289  31fd							;	  c flag is clear if no error, a contains bytes read
    290  31fd							;	  c flag set Reached eof, a undefined
    291  31fd							;
    292  31fd		       8e 33 37    DIN	      stx	DiskFileName	; Save the x value, filename not used just storage
    293  3200		       8c 34 37 	      sty	DiskFileName+1	; Save the y value  filename not actually used
    294  3203		       a9 01		      lda	#1	; set number of bytes to read to 1
    295  3205		       a0 0a		      ldy	#buffer&$ff	; Load the low order address of buffer to y
    296  3207		       a2 df		      ldx	#buffer>>8	; Load the high order address of buffer to x
    297  3209		       20 3c f0 	      jsr	DiskRead
    298  320c		       ad 0a df 	      lda	buffer	; Get the byte just read
    299  320f		       ae 33 37 	      ldx	DiskFileName
    300  3212		       ac 34 37 	      ldy	DiskFileName+1
    301  3215		       60		      rts
    302  3216
    303  3216							;========================================================
    304  3216							; Dstat / open/close/stat files
    305  3216				   DSTAT
    306  3216		       60		      rts
    307  3217							;========================================================
    308  3217					      endif
------- FILE mytb.asm
   2480  3217					      endif
------- FILE IL.inc LEVEL 2 PASS 6
      0  3217					      include	"IL.inc"
      1  3217
      2  3217							;=====================================================
      3  3217							; IL.inc
      4  3217							; These are macros for IL instructions
      5  3217							;
      6  3217					      mac	dw
      7  3217					      .word	{0}
      8  3217					      endm
      9  3217					      mac	db
     10  3217					      .byte	{0}
     11  3217					      endm
     12  3217					      macro	xinit
     13  3217					      db	0
     14  3217					      endm		;reset the il to start clear all
     15  3217							;
     16  3217					      macro	done
     17  3217					      db	1
     18  3217					      endm		;print an error if not end of line
     19  3217							;
     20  3217					      macro	prs
     21  3217					      db	2
     22  3217					      endm		;print a quoted string
     23  3217							;
     24  3217					      macro	prn
     25  3217					      db	3
     26  3217					      endm		;print a number
     27  3217							;
     28  3217					      macro	spc
     29  3217					      db	4
     30  3217					      endm		;print space til new tabstop
     31  3217							;
     32  3217					      macro	nline
     33  3217					      db	5
     34  3217					      endm		;print a new line crlf
     35  3217							;
     36  3217							; My NXT is a bit different in that it takes one
     37  3217							; parameter, which is an address.  If the BASIC
     38  3217							; program is currently running then move to the
     39  3217							; next line and continue execution.  However, if
     40  3217							; in direct mode, jump to the specified IL label.
     41  3217							;
     42  3217					      macro	nxt
     43  3217					      db	6
     44  3217					      dw	{1}	; addr
     45  3217					      endm		; addr
     46  3217							;
     47  3217					      macro	xfer
     48  3217					      db	7
     49  3217					      endm
     50  3217							;
     51  3217					      macro	sav
     52  3217					      db	8
     53  3217					      db	{1}
     54  3217					      endm
     55  3217							;
     56  3217							;  Passed jump if function called, and true false value returned
     57  3217					      macro	rstr
     58  3217					      db	9
     59  3217					      db	({1}-*)-1	;(addr-*)-1
     60  3217					      db	{2}
     61  3217					      endm
     62  3217							;
     63  3217					      macro	cmpr
     64  3217					      db	10
     65  3217					      endm
     66  3217							;
     67  3217					      macro	innum
     68  3217					      db	11
     69  3217					      endm
     70  3217							;
     71  3217					      macro	fin
     72  3217					      db	12
     73  3217					      endm
     74  3217							;
     75  3217							; ERR is followed by an error number.	The error
     76  3217							; code is printed along with the line number.
     77  3217							; Control is passed to the statement set with
     78  3217							; the ERRGOTO statement.
     79  3217							;
     80  3217					      macro	errmsg
     81  3217					      db	13
     82  3217					      dw	{1}	;ecode
     83  3217					      endm		;ecode
     84  3217							;
     85  3217					      macro	add
     86  3217					      db	14
     87  3217					      endm
     88  3217							;
     89  3217					      macro	sub
     90  3217					      db	15
     91  3217					      endm
     92  3217							;
     93  3217					      macro	neg
     94  3217					      db	16
     95  3217					      endm
     96  3217							;
     97  3217					      macro	mul
     98  3217					      db	17
     99  3217					      endm
    100  3217							;
    101  3217					      macro	div
    102  3217					      db	18
    103  3217					      endm
    104  3217							;
    105  3217					      macro	store
    106  3217					      db	19
    107  3217					      endm
    108  3217							;
    109  3217					      macro	ind
    110  3217					      db	20
    111  3217					      endm
    112  3217							;
    113  3217					      macro	lst
    114  3217					      db	21
    115  3217					      endm
    116  3217							;
    117  3217					      macro	init
    118  3217					      db	22
    119  3217					      endm
    120  3217							;
    121  3217					      macro	getline
    122  3217					      db	23
    123  3217					      endm
    124  3217							;
    125  3217					      macro	insert
    126  3217					      db	24
    127  3217					      endm
    128  3217							;
    129  3217					      macro	rtn
    130  3217					      db	25
    131  3217					      endm
    132  3217							;
    133  3217					      macro	exit
    134  3217					      db	26
    135  3217					      endm
    136  3217							;
    137  3217					      macro	lit
    138  3217					      db	27
    139  3217					      dw	{1}	;value
    140  3217					      endm		; value LIT
    141  3217							;
    142  3217					      macro	call
    143  3217					      db	28
    144  3217					      dw	{1}	;addr
    145  3217					      endm		;addr
    146  3217							;
    147  3217							; IJMP will set the IL PC to the specified value.
    148  3217							;
    149  3217					      macro	ijmp
    150  3217					      db	29
    151  3217					      dw	{1}	;addr
    152  3217					      endm		;addr
    153  3217							;
    154  3217					      macro	vinit
    155  3217					      db	30
    156  3217					      endm
    157  3217							;
    158  3217							; ERRGOTO sets the point in the code where the IL
    159  3217							; interpreter will go after any error.
    160  3217							;
    161  3217					      macro	errgoto
    162  3217					      db	31
    163  3217					      dw	{1}	;addr
    164  3217					      endm		;addr
    165  3217							;
    166  3217					      macro	tst
    167  3217					      db	32
    168  3217					      db	({1}-*)-1	;(addr-*)-1
    169  3217					      db	{2},0	;string,0
    170  3217					      endm		;addr,string
    171  3217							;
    172  3217					      macro	tstv
    173  3217					      db	33
    174  3217					      db	({1}-*)-1	;(addr-*)-1
    175  3217					      endm		;addr
    176  3217							;
    177  3217					      macro	tstl
    178  3217					      db	34
    179  3217					      db	({1}-*)-1	;(addr-*)-1
    180  3217					      endm		;addr
    181  3217							;
    182  3217					      macro	tstn
    183  3217					      db	35
    184  3217					      db	({1}-*)-1	;(addr-*)-1
    185  3217					      endm		;addr
    186  3217							;
    187  3217							; FREE returns the amount of free RAM on top of
    188  3217							; the stack.  This is the amount of room the user
    189  3217							; program has available.
    190  3217							;
    191  3217					      macro	free
    192  3217					      db	36
    193  3217					      endm
    194  3217							;
    195  3217							; RANDOM takes the top item off the stack and
    196  3217							; replaces it with a random number that is
    197  3217							; MOD the initial value.  Ie, if the TOS is
    198  3217							; 42 then RANDOM returns a value from 0 to 41.
    199  3217							;
    200  3217					      macro	random
    201  3217					      db	37
    202  3217					      endm
    203  3217							;
    204  3217							; ABS will replace the top of stack with the
    205  3217							; absolute value.
    206  3217							;
    207  3217					      macro	abs
    208  3217					      db	38
    209  3217					      endm
    210  3217							;
    211  3217							; OPENREAD opens a file for reading, as in getting
    212  3217							; statements from it.
    213  3217							;
    214  3217					      macro	openread
    215  3217					      db	39
    216  3217					      endm
    217  3217							;
    218  3217							; OPENWRITE opens a file for writing, as in saving
    219  3217							; the current program to it.
    220  3217							;
    221  3217					      macro	openwrite
    222  3217					      db	40
    223  3217					      db	{1}	; 0= append 1 = create/truncate
    224  3217					      endm
    225  3217							;
    226  3217							; DCLOSE closes any open disk file.
    227  3217							;
    228  3217					      macro	dclose
    229  3217					      db	41
    230  3217					      endm
    231  3217							;
    232  3217							; DGETLINE gets one line from the disk file and puts it
    233  3217							; into LINBUFF.
    234  3217							;
    235  3217					      macro	dgetline
    236  3217					      db	42
    237  3217					      endm
    238  3217							;
    239  3217							; DLIST saves the program to an open disk file.
    240  3217							;
    241  3217					      macro	dlist
    242  3217					      db	43
    243  3217					      endm
    244  3217							; DDIR list the current directory
    245  3217							;
    246  3217					      macro	ddir
    247  3217					      db	44
    248  3217					      endm
    249  3217
    250  3217							; RMFILE remove a fle from disk
    251  3217					      macro	rmfile
    252  3217					      db	45
    253  3217					      endm
    254  3217
    255  3217							; CLEARSCREEN clear the screen
    256  3217					      macro	clearscreen
    257  3217					      db	46
    258  3217					      endm
    259  3217							; POKEMEM Poke value into memory
    260  3217					      macro	pokemem
    261  3217					      db	47
    262  3217					      endm
    263  3217							; PEEKMEM peek at value in memory
    264  3217					      macro	peekmem
    265  3217					      db	48
    266  3217					      endm
    267  3217							; TSTLET Test if the statement is a let without the keyword let
    268  3217					      macro	tstlet
    269  3217					      db	49
    270  3217					      db	({1}-*)-1	;(addr-*)-1
    271  3217					      endm		;addr
    272  3217							; TSTDONE if we reach the end of a statement
    273  3217					      macro	tstdone
    274  3217					      db	50
    275  3217					      db	({1}-*)-1	;(addr-*)-1
    276  3217					      endm		;addr
    277  3217							; GETCHAR	get a character from the input line leave it in RO
    278  3217					      macro	getchar
    279  3217					      db	51
    280  3217					      endm
    281  3217							; PUTCHAR	Put a character to the terminal
    282  3217					      macro	putchar
    283  3217					      db	52
    284  3217					      endm
    285  3217							; Call		Call a machine function return a to stack
    286  3217					      macro	callfunc
    287  3217					      db	53
    288  3217					      endm
    289  3217
    290  3217							; IBRANCH branch if value on stack = 0 false, nextil if value not = zero
    291  3217					      macro	ibranch
    292  3217					      db	54
    293  3217					      endm
    294  3217
    295  3217							; TSTSTR	 Tests for the open quote in a string
    296  3217					      macro	tststr
    297  3217					      db	55
    298  3217					      db	({1}-*)-1	;(addr-*)-1
    299  3217					      endm
    300  3217							; SETIRQ	Sets the line number to run when an irq happens irq 550
    301  3217					      macro	setirq
    302  3217					      db	56
    303  3217					      endm
    304  3217
    305  3217							; TSTIRQ	Test for irq pending,
    306  3217							;		if so push the IRQ LINE NUMBER into RO, onto stack
    307  3217					      macro	tstirq
    308  3217					      db	57
    309  3217					      db	({1}-*)-1	;(addr-*)-1
    310  3217					      endm
    311  3217
    312  3217							; IRET    return from interupt service
    313  3217					      macro	iret
    314  3217					      db	58
    315  3217					      endm
    316  3217
    317  3217							; INSTR   read a string from the input
    318  3217					      macro	instr
    319  3217					      db	59
    320  3217					      endm
    321  3217
    322  3217							; MODULO Returns the remainder of the division
    323  3217					      macro	modulo
    324  3217					      db	60
    325  3217					      endm
    326  3217							; Set a task line
    327  3217					      macro	taskcreate
    328  3217					      db	61
    329  3217					      endm
    330  3217							; End a task
    331  3217					      macro	etask
    332  3217					      db	62
    333  3217					      endm
    334  3217							; Skip to next task
    335  3217					      macro	ntask
    336  3217					      db	63
    337  3217					      endm
    338  3217							; Subscript
    339  3217					      macro	subscript
    340  3217					      db	64
    341  3217					      db	{1}
    342  3217					      endm
    343  3217							; KILL Task
    344  3217					      macro	taskkill
    345  3217					      db	65
    346  3217					      endm
    347  3217							; STAT Task
    348  3217					      macro	taskstat
    349  3217					      db	66
    350  3217					      endm
    351  3217							;  output value as hex
    352  3217					      macro	hexprt
    353  3217					      db	67
    354  3217					      endm
    355  3217							;  Read in background has completed
    356  3217					      macro	readcomplete
    357  3217					      db	68
    358  3217					      endm
    359  3217							;  ReadInput line
    360  3217					      macro	readstart
    361  3217					      db	69
    362  3217					      endm
    363  3217							; Startio request
    364  3217					      macro	startio
    365  3217					      db	70
    366  3217					      endm
    367  3217							; Endio
    368  3217					      macro	endio
    369  3217					      db	71
    370  3217					      endm
    371  3217							; Logical not
    372  3217					      macro	lognot
    373  3217					      db	72
    374  3217					      endm
    375  3217							; Logical OR
    376  3217					      macro	logor
    377  3217					      db	73
    378  3217					      endm
    379  3217							;Logical and
    380  3217					      macro	logand
    381  3217					      db	74
    382  3217					      endm
    383  3217							;Logical XOR
    384  3217					      macro	logxor
    385  3217					      db	75
    386  3217					      endm
    387  3217							;Wait for task to complete, or list of tasks
    388  3217					      macro	wtask
    389  3217					      db	76
    390  3217					      db	({1}-*)-1	;(addr-*)-1
    391  3217					      endm
    392  3217							;Get the current task id
    393  3217					      MACRO	taskpid
    394  3217					      db	77
    395  3217					      endm
    396  3217							;Trace the basic execution
    397  3217					      Macro	traceprogram
    398  3217					      db	78
    399  3217					      endm
    400  3217							;Do a basic program Trace
    401  3217					      Macro	debugbasic
    402  3217					      db	79
    403  3217					      endm
    404  3217
    405  3217							; Inter Process communications instructions
    406  3217					      Macro	ipcsend
    407  3217					      db	80
    408  3217					      endm
    409  3217					      Macro	ipcreceive
    410  3217					      db	81
    411  3217					      endm
    412  3217					      Macro	ipccheck
    413  3217					      db	82
    414  3217					      endm
    415  3217					      Macro	ipcio
    416  3217					      db	83
    417  3217					      endm
    418  3217					      Macro	pushmathstack
    419  3217					      db	84
    420  3217					      endm
    421  3217					      Macro	popmathstack
    422  3217					      db	85
    423  3217					      endm
    424  3217					      Macro	savemathstack
    425  3217					      db	86
    426  3217					      endm
    427  3217					      Macro	restoremathstack
    428  3217					      db	87
    429  3217					      endm
    430  3217					      Macro	incparmcount
    431  3217					      db	88
    432  3217					      endm
    433  3217					      Macro	taskgetmathstack
    434  3217					      db	89
    435  3217					      endm
    436  3217					      Macro	taskenable
    437  3217					      db	90
    438  3217					      endm
    439  3217					      Macro	tasksuspend
    440  3217					      db	91
    441  3217					      endm
    442  3217					      Macro	taskputmathptr
    443  3217					      db	92
    444  3217					      endm
    445  3217							; Test for an extension type of variable that allows access to a tasks variables
    446  3217							; Using  PID!<Var name>
    447  3217					      Macro	tstvt
    448  3217					      db	93
    449  3217					      db	({1}-*)-1	;(addr-*)-1
    450  3217					      endm
    451  3217
    452  3217							; Provide access to R2 for the IL program
    453  3217					      Macro	setr2
    454  3217					      db	94
    455  3217					      db	{1}	; R2 is only one byte
    456  3217					      endm
    457  3217
    458  3217							;Move stack top to temp
    459  3217					      Macro	stk2tmp
    460  3217					      db	95
    461  3217					      endm
    462  3217
    463  3217					      Macro	tmp2stk
    464  3217					      db	96
    465  3217					      endm
    466  3217
    467  3217					      Macro	tstbyte
    468  3217					      db	97
    469  3217					      db	({1}-*)-1	; (addr-*)-1 goto if match
    470  3217					      dw	{2}	; address to check
    471  3217					      db	{3}	; Value to compare
    472  3217					      endm
    473  3217
    474  3217					      Macro	incvar
    475  3217					      db	98
    476  3217					      endm
    477  3217					      Macro	decvar
    478  3217					      db	99
    479  3217					      endm
    480  3217
    481  3217					      Macro	slice
    482  3217					      db	100
    483  3217					      endm
    484  3217
    485  3217					      Macro	tstb
    486  3217					      db	101
    487  3217					      db	({1}-*)-1
    488  3217					      db	{2}
    489  3217					      endm
    490  3217
    491  3217					      Macro	tstw
    492  3217					      db	102
    493  3217					      db	({1}-*)-1
    494  3217					      dw	{2}
    495  3217					      endm
    496  3217
    497  3217					      Macro	ongoto
    498  3217					      db	103
    499  3217					      dw	{1}
    500  3217					      dw	{2}
    501  3217					      endm
    502  3217
    503  3217					      Macro	tstrelop
    504  3217					      db	104
    505  3217					      db	({1}-*)-1
    506  3217					      endm
    507  3217
    508  3217					      Macro	repeatline
    509  3217					      db	105
    510  3217					      endm
    511  3217
    512  3217							; Check for a precompiled branch, will take branch if precompiled value present
    513  3217					      Macro	tstbranch
    514  3217					      db	106
    515  3217					      db	({1}-*)-1
    516  3217					      endm
    517  3217
    518  3217					      Macro	fastxfer
    519  3217					      db	107
    520  3217					      endm
    521  3217
    522  3217							; Set all io to to a terminal for input output
    523  3217							; SETTERMINAL outterm,interm	 ; the numbers corrispond to the ct65 slot number each slot id 16 bytes,
    524  3217							; so 0 = 0, 1 = io address 16, 2 = io address 32 .... etc
    525  3217					      Macro	setterminal
    526  3217					      db	108
    527  3217					      endm
    528  3217
    529  3217							;Fetch a single byte from memory
    530  3217					      Macro	indb
    531  3217					      db	109
    532  3217					      endm
    533  3217
    534  3217							; Set a block of memory to a fixed value, byte or word
    535  3217							; Stack must contain destiniation address, length to set in bytes, value {byte of word} to initialize to
    536  3217					      Macro	setblock
    537  3217					      db	110
    538  3217					      db	{1}	; the data type to initialize	tByte or tInteger
    539  3217					      endm
    540  3217
    541  3217							; Copy a block of memory
    542  3217							; Stack must contain source address, destination address, length in bytes
    543  3217					      Macro	copyblock
    544  3217					      db	111
    545  3217					      endm
    546  3217
    547  3217							; Compare one block of memory to another
    548  3217							; Stack contains Length, Source1 Source 2
    549  3217							; Place on stack 0 equal, 1 s1>s2, -1 s1 < s2
    550  3217					      Macro	cmpmem
    551  3217					      db	112
    552  3217					      endm
    553  3217
    554  3217							; Shift Left and Right
    555  3217					      Macro	shift
    556  3217					      db	113
    557  3217					      db	{1}	; direction  0 = left 1 = right
    558  3217					      endm
    559  3217
    560  3217							; set of timer macros
    561  3217					      Macro	timerset
    562  3217					      db	114,1
    563  3217					      db	{1}	; value 9 = 1 second, 1-5 = value * 10ms 6 = 10ms, 7=250ms, 8=500ms
    564  3217					      endm
    565  3217
    566  3217					      Macro	timerstop
    567  3217					      db	114,0,0
    568  3217					      endm
    569  3217
    570  3217					      Macro	timervaluelow
    571  3217					      db	114,2,0
    572  3217					      endm
    573  3217
    574  3217					      Macro	timervaluehigh
    575  3217					      db	114,3,0
    576  3217					      endm
    577  3217
    578  3217					      Macro	timer
    579  3217					      db	114
    580  3217					      endm
    581  3217
    582  3217							; jump to end of block if false
    583  3217					      Macro	jmpend
    584  3217					      db	115
    585  3217					      db	{1}
    586  3217					      endm
    587  3217
    588  3217							; Jump to start of block, while, for, if endif
    589  3217					      Macro	jmpstart
    590  3217					      db	116
    591  3217					      db	{1}
    592  3217					      endm
    593  3217
    594  3217							; Begin a block, while, for, if endif
    595  3217					      Macro	beginblock
    596  3217					      db	117
    597  3217					      db	{1},{2}
    598  3217					      endm
    599  3217
    600  3217					      Macro	iftrue
    601  3217					      db	118
    602  3217					      db	({1}-*)-1
    603  3217					      endm
    604  3217
    605  3217					      Macro	iffalse
    606  3217					      db	119
    607  3217					      db	({1}-*)-1
    608  3217					      endm
    609  3217
    610  3217					      Macro	fasterxfer
    611  3217					      db	120
    612  3217					      db	{1}
    613  3217					      endm
------- FILE mytb.asm
   2482  3217							;
   2483  3217				  -	      if	FIXED
   2484  3217				  -	      org	$1000
   2485  3217					      endif
------- FILE basic.il LEVEL 2 PASS 6
      0  3217					      include	"basic.il"
      1  3217					      seg	Code
      2  3217							; on goto table
      3  3217							; format :   first byte is value Base, subtracted from value found
      4  3217							;	      second byte is the number of entries in the table max is 128... always a limit somewhere... lol
      5  3217				   BasicStmts
      0  3217					      db	kBeginKey,(kKeyCount+1)	; Base address of table, length of table
      1  3217		       01 28		      .byte.b	kBeginKey,(kKeyCount+1)
      0  3219					      dw	ekLet
      1  3219		       b0 32		      .word.w	ekLet
      0  321b					      dw	ekInc
      1  321b		       e2 32		      .word.w	ekInc
      0  321d					      dw	ekDec
      1  321d		       ef 32		      .word.w	ekDec
      0  321f					      dw	ekIreturn
      1  321f		       fc 32		      .word.w	ekIreturn
      0  3221					      dw	ekIf
      1  3221		       01 33		      .word.w	ekIf
      0  3223					      dw	ekThen
      1  3223		       07 33		      .word.w	ekThen
      0  3225					      dw	ekGoto
      1  3225		       0b 33		      .word.w	ekGoto
      0  3227					      dw	ekGosub
      1  3227		       c7 36		      .word.w	ekGosub
      0  3229					      dw	ekReturn
      1  3229		       d5 36		      .word.w	ekReturn
      0  322b					      dw	ekRem
      1  322b		       1b 33		      .word.w	ekRem
      0  322d					      dw	ekPrint	; should be entry for print
      1  322d		       31 33		      .word.w	ekPrint
      0  322f					      dw	ekTaske
      1  322f		       7e 33		      .word.w	ekTaske
      0  3231					      dw	ekTaskn
      1  3231		       94 33		      .word.w	ekTaskn
      0  3233					      dw	ekTaskw
      1  3233		       9b 33		      .word.w	ekTaskw
      0  3235					      dw	ekPoke
      1  3235		       b6 33		      .word.w	ekPoke
      0  3237					      dw	ekPutch
      1  3237		       18 34		      .word.w	ekPutch
      0  3239					      dw	ekCls
      1  3239		       23 34		      .word.w	ekCls
      0  323b					      dw	ekInput
      1  323b		       2a 34		      .word.w	ekInput
      0  323d					      dw	ekEnd
      1  323d		       58 34		      .word.w	ekEnd
      0  323f					      dw	ekIrq
      1  323f		       5c 34		      .word.w	ekIrq
      0  3241					      dw	ekKill
      1  3241		       67 34		      .word.w	ekKill
      0  3243					      dw	ekList
      1  3243		       72 34		      .word.w	ekList
      0  3245					      dw	ekRun
      1  3245		       77 34		      .word.w	ekRun
      0  3247					      dw	ekNew
      1  3247		       80 34		      .word.w	ekNew
      0  3249					      dw	ekSlice
      1  3249		       84 34		      .word.w	ekSlice
      0  324b					      dw	ekTrace
      1  324b		       8f 34		      .word.w	ekTrace
      0  324d					      dw	ekExit
      1  324d		       a0 34		      .word.w	ekExit
      0  324f					      dw	ekSave
      1  324f		       a1 34		      .word.w	ekSave
      0  3251					      dw	ekLoad
      1  3251		       a8 34		      .word.w	ekLoad
      0  3253					      dw	ekErase
      1  3253		       b8 34		      .word.w	ekErase
      0  3255					      dw	ekDir
      1  3255		       b4 34		      .word.w	ekDir
      0  3257					      dw	ekSetTerm
      1  3257		       21 33		      .word.w	ekSetTerm
      0  3259					      dw	ekSetMemB
      1  3259		       cd 33		      .word.w	ekSetMemB
      0  325b					      dw	ekSetMemW
      1  325b		       d9 33		      .word.w	ekSetMemW
      0  325d					      dw	ekCopyMem
      1  325d		       fb 33		      .word.w	ekCopyMem
      0  325f					      dw	ekWhile
      1  325f		       aa 36		      .word.w	ekWhile
      0  3261					      dw	ekWend
      1  3261		       b9 36		      .word.w	ekWend
      0  3263					      dw	ekFor
      1  3263		       c7 36		      .word.w	ekFor
      0  3265					      dw	ekNext
      1  3265		       c7 36		      .word.w	ekNext
      0  3267					      dw	ekStep
      1  3267		       c7 36		      .word.w	ekStep
     47  3269							;
     48  3269							; Logical operators
      0  3269				   BasicLogical db	kOr,3
      1  3269		       2a 03		      .byte.b	kOr,3
      0  326b					      dw	ekOr
      1  326b		       ed 34		      .word.w	ekOr
      0  326d					      dw	ekXor
      1  326d		       f2 34		      .word.w	ekXor
      0  326f					      dw	ekAnd
      1  326f		       e8 34		      .word.w	ekAnd
     53  3271
      0  3271				   BasicShift db	kShr,2
      1  3271		       2d 02		      .byte.b	kShr,2
      0  3273					      dw	ekShiftRight
      1  3273		       dd 34		      .word.w	ekShiftRight
      0  3275					      dw	ekShiftLeft
      1  3275		       d7 34		      .word.w	ekShiftLeft
     57  3277
     58  3277							;functions returning values
     59  3277
      0  3277				   BasicFuncs db	kBeginFunc,kFuncCount
      1  3277		       2f 12		      .byte.b	kBeginFunc,kFuncCount
      0  3279					      dw	ekTrue
      1  3279		       47 35		      .word.w	ekTrue
      0  327b					      dw	ekFalse
      1  327b		       4b 35		      .word.w	ekFalse
      0  327d					      dw	ekFree
      1  327d		       4f 35		      .word.w	ekFree
      0  327f					      dw	ekGetch
      1  327f		       57 35		      .word.w	ekGetch
      0  3281					      dw	ekPeek
      1  3281		       9c 35		      .word.w	ekPeek
      0  3283					      dw	ekTask
      1  3283		       a7 35		      .word.w	ekTask
      0  3285					      dw	ekIpcc
      1  3285		       f3 35		      .word.w	ekIpcc
      0  3287					      dw	ekIpcs
      1  3287		       ce 35		      .word.w	ekIpcs
      0  3289					      dw	ekIpcr
      1  3289		       df 35		      .word.w	ekIpcr
      0  328b					      dw	ekRnd
      1  328b		       fe 35		      .word.w	ekRnd
      0  328d					      dw	ekStat
      1  328d		       1c 36		      .word.w	ekStat
      0  328f					      dw	ekAbs
      1  328f		       11 36		      .word.w	ekAbs
      0  3291					      dw	ekCall
      1  3291		       29 36		      .word.w	ekCall
      0  3293					      dw	ekGofn
      1  3293		       ce 36		      .word.w	ekGofn
      0  3295					      dw	ekPid
      1  3295		       27 36		      .word.w	ekPid
      0  3297					      dw	ekAddr
      1  3297		       5f 35		      .word.w	ekAddr
      0  3299					      dw	ekCmpMem
      1  3299		       6e 35		      .word.w	ekCmpMem
      0  329b					      dw	eKTimer
      1  329b		       85 35		      .word.w	eKTimer
     79  329d							;
     80  329d							;====================================================
     81  329d							; file constants
     82  329d		       00 00	   OPEN_APPEND equ	0	; append to file
     83  329d		       00 01	   OPEN_CREATE equ	1	; truncate/create file
     84  329d
     85  329d							;=====================================================
     86  329d							; This is the IL of the BASIC (or whatever) language.
     87  329d							; Because of the way macros are implemented by as65,
     88  329d							; labels can't be on the same line as a macro
     89  329d							; invocation, so that's why labels are on separate
     90  329d							; lines.
     91  329d							;
     92  329d		       32 9d	   IL	      equ	*
     93  329d
     94  329d							;THE IL CONTROL SECTION
     95  329d
     96  329d				   START
      0  329d					      INIT		;INITIALIZE
      0  329d					      db	22
      1  329d		       16		      .byte.b	22
      0  329e					      NLINE		;WRITE CRLF
      0  329e					      db	5
      1  329e		       05		      .byte.b	5
      0  329f					      ERRGOTO	CO	;where to go after an error
      0  329f					      db	31
      1  329f		       1f		      .byte.b	31
      0  32a0					      dw	CO
      1  32a0		       a3 32		      .word.w	CO
      0  32a2					      VINIT		;clear all variables
      0  32a2					      db	30
      1  32a2		       1e		      .byte.b	30
    101  32a3							;
    102  32a3							; This is where we jump to get a line of commands or
    103  32a3							; a program from the user.
    104  32a3							;
    105  32a3				   CO
      0  32a3					      GETLINE		;WRITE PROMPT AND GET LINE
      0  32a3					      db	23
      1  32a3		       17		      .byte.b	23
      0  32a4					      TSTL	XEC	;TEST FOR LINE NUMBER, if none then execute the line
      0  32a4					      db	34
      1  32a4		       22		      .byte.b	34
      0  32a5					      db	(XEC-*)-1
      1  32a5		       04		      .byte.b	(XEC-*)-1
      0  32a6					      INSERT		;INSERT IT (MAY BE DELETE)
      0  32a6					      db	24
      1  32a6		       18		      .byte.b	24
      0  32a7					      IJMP	CO
      0  32a7					      db	29
      1  32a7		       1d		      .byte.b	29
      0  32a8					      dw	CO
      1  32a8		       a3 32		      .word.w	CO
    110  32aa				   XEC
      0  32aa					      XINIT		;INITIALIZE
      0  32aa					      db	0
      1  32aa		       00		      .byte.b	0
    112  32ab							;============================================================================
    113  32ab							;STATEMENT EXECUTOR DO not change the NAME as task manager uses this
    114  32ab							;
    115  32ab				   STMT
      0  32ab					      TSTIRQ	notirq	;if it is an irq posted, this will cause transfer to irq handler
      0  32ab					      db	57
      1  32ab		       39		      .byte.b	57
      0  32ac					      db	(notirq-*)-1
      1  32ac		       00		      .byte.b	(notirq-*)-1
    117  32ad							;==========================================================================================
    118  32ad							; Process a let statement implied or explicit.
    119  32ad							;
    120  32ad				   notirq
    121  32ad
      0  32ad					      DEBUGBASIC		; Check if we are doing a debug for this session
      0  32ad					      db	79
      1  32ad		       4f		      .byte.b	79
    123  32ae
      0  32ae					      TSTLET	DoVector	; Test if Let keyword or a variable
      0  32ae					      db	49
      1  32ae		       31		      .byte.b	49
      0  32af					      db	(DoVector-*)-1
      1  32af		       2d		      .byte.b	(DoVector-*)-1
    125  32b0				   ekLet
      0  32b0					      TSTV	DoVector	; Test for variable
      0  32b0					      db	33
      1  32b0		       21		      .byte.b	33
      0  32b1					      db	(DoVector-*)-1
      1  32b1		       2b		      .byte.b	(DoVector-*)-1
      0  32b2					      CALL	FactVarPtrNoTst	; get a pointer to the variable
      0  32b2					      db	28
      1  32b2		       1c		      .byte.b	28
      0  32b3					      dw	FactVarPtrNoTst
      1  32b3		       70 36		      .word.w	FactVarPtrNoTst
    128  32b5
    129  32b5				   LETINDEX_ALL
      0  32b5					      TSTB	ERRMissingEquals,oEqual	; (This line originally omitted)
      0  32b5					      db	101
      1  32b5		       65		      .byte.b	101
      0  32b6					      db	(ERRMissingEquals-*)-1
      1  32b6		       20		      .byte.b	(ERRMissingEquals-*)-1
      0  32b7					      db	oEqual
      1  32b7		       f2		      .byte.b	oEqual
    131  32b8				   LETBE
      0  32b8					      TSTBYTE	LETAssignByte,R2,tByte	; Check for a byte conversion
      0  32b8					      db	97
      1  32b8		       61		      .byte.b	97
      0  32b9					      db	(LETAssignByte-*)-1
      1  32b9		       10		      .byte.b	(LETAssignByte-*)-1
      0  32ba					      dw	R2
      1  32ba		       58 00		      .word.w	R2
      0  32bc					      db	tByte
      1  32bc		       a2		      .byte.b	tByte
      0  32bd					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  32bd					      db	28
      1  32bd		       1c		      .byte.b	28
      0  32be					      dw	EXPR
      1  32be		       c0 34		      .word.w	EXPR
      0  32c0					      DONE		; REPORT ERROR IF NOT NEXT
      0  32c0					      db	1
      1  32c0		       01		      .byte.b	1
      0  32c1					      SETR2	tInteger	; Store an integer type
      0  32c1					      db	94
      1  32c1		       5e		      .byte.b	94
      0  32c2					      db	tInteger
      1  32c2		       a4		      .byte.b	tInteger
      0  32c3					      STORE		; STORE RESULT at variable address
      0  32c3					      db	19
      1  32c3		       13		      .byte.b	19
      0  32c4					      NXT	CO	; AND SEQUENCE TO NEXT
      0  32c4					      db	6
      1  32c4		       06		      .byte.b	6
      0  32c5					      dw	CO
      1  32c5		       a3 32		      .word.w	CO
      0  32c7					      IJMP	STMT	; Next statement
      0  32c7					      db	29
      1  32c7		       1d		      .byte.b	29
      0  32c8					      dw	STMT
      1  32c8		       ab 32		      .word.w	STMT
    139  32ca
    140  32ca				   LETAssignByte
      0  32ca					      CALL	EXPR	; PLACE EXPR VALUE ON MathSTK
      0  32ca					      db	28
      1  32ca		       1c		      .byte.b	28
      0  32cb					      dw	EXPR
      1  32cb		       c0 34		      .word.w	EXPR
      0  32cd					      DONE		; REPORT ERROR IF NOT NEXT
      0  32cd					      db	1
      1  32cd		       01		      .byte.b	1
      0  32ce					      SETR2	tByte	; Set to store a byte value
      0  32ce					      db	94
      1  32ce		       5e		      .byte.b	94
      0  32cf					      db	tByte
      1  32cf		       a2		      .byte.b	tByte
      0  32d0					      STORE		; STORE RESULT at variable address
      0  32d0					      db	19
      1  32d0		       13		      .byte.b	19
      0  32d1					      NXT	CO	; AND SEQUENCE TO NEXT
      0  32d1					      db	6
      1  32d1		       06		      .byte.b	6
      0  32d2					      dw	CO
      1  32d2		       a3 32		      .word.w	CO
      0  32d4					      IJMP	STMT	; Next statement
      0  32d4					      db	29
      1  32d4		       1d		      .byte.b	29
      0  32d5					      dw	STMT
      1  32d5		       ab 32		      .word.w	STMT
    147  32d7
    148  32d7				   ERRMissingEquals
      0  32d7					      ERRMSG	ERR_MISSINGEQUALSIGN	; Missing asignment
      0  32d7					      db	13
      1  32d7		       0d		      .byte.b	13
      0  32d8					      dw	ERR_MISSINGEQUALSIGN
      1  32d8		       18 00		      .word.w	ERR_MISSINGEQUALSIGN
    150  32da
    151  32da				   ERRVEC2
      0  32da					      IJMP	UNKNOWN
      0  32da					      db	29
      1  32da		       1d		      .byte.b	29
      0  32db					      dw	UNKNOWN
      1  32db		       bc 34		      .word.w	UNKNOWN
    153  32dd							;=============================================================
    154  32dd							;Branch on a valid statement start
    155  32dd				   DoVector
      0  32dd					      OnGoto	BasicStmts,UNKNOWN	; use the table provided if not in table branch to unknown
      0  32dd					      db	103
      1  32dd		       67		      .byte.b	103
      0  32de					      dw	BasicStmts
      1  32de		       17 32		      .word.w	BasicStmts
      0  32e0					      dw	UNKNOWN
      1  32e0		       bc 34		      .word.w	UNKNOWN
    157  32e2							;This will never return here!
    158  32e2							;=============================================================
    159  32e2							; Inc or dec a variable
    160  32e2				   ekInc
      0  32e2					      TSTV	ERRVEC2	; Verify we have a variable
      0  32e2					      db	33
      1  32e2		       21		      .byte.b	33
      0  32e3					      db	(ERRVEC2-*)-1
      1  32e3		       f6		      .byte.b	(ERRVEC2-*)-1
      0  32e4					      CALL	FactVarPtrNoTst	; Get a pointer to the memory location to increment
      0  32e4					      db	28
      1  32e4		       1c		      .byte.b	28
      0  32e5					      dw	FactVarPtrNoTst
      1  32e5		       70 36		      .word.w	FactVarPtrNoTst
    163  32e7							;	  TSTB	     eDoInc,oBang		    ; Allow to inc or dec other tasks variables
    164  32e7							;	  IND					    ; we just got a pid
    165  32e7							;	  TSTVT      ERRVEC2			    ; if it is not another variabe then error, Call test var. task
    166  32e7				   eDoInc
      0  32e7					      INCVAR		; Do the increment of the variable
      0  32e7					      db	98
      1  32e7		       62		      .byte.b	98
      0  32e8					      DONE		; Test for end of line or end of statement ":"
      0  32e8					      db	1
      1  32e8		       01		      .byte.b	1
      0  32e9					      NXT	CO	; Get the next statement, branch CO if end of program
      0  32e9					      db	6
      1  32e9		       06		      .byte.b	6
      0  32ea					      dw	CO
      1  32ea		       a3 32		      .word.w	CO
      0  32ec					      IJMP	STMT	; Process the next statement
      0  32ec					      db	29
      1  32ec		       1d		      .byte.b	29
      0  32ed					      dw	STMT
      1  32ed		       ab 32		      .word.w	STMT
    171  32ef							;S1Dec:
    172  32ef							;	  TSTB	     S1Iret,kDec		    ; Dec variable
    173  32ef				   ekDec
      0  32ef					      TSTV	ERRVEC2	; Must be followed by a variable
      0  32ef					      db	33
      1  32ef		       21		      .byte.b	33
      0  32f0					      db	(ERRVEC2-*)-1
      1  32f0		       e9		      .byte.b	(ERRVEC2-*)-1
      0  32f1					      CALL	FactVarPtrNoTst	; Get a pointer to the variable to update
      0  32f1					      db	28
      1  32f1		       1c		      .byte.b	28
      0  32f2					      dw	FactVarPtrNoTst
      1  32f2		       70 36		      .word.w	FactVarPtrNoTst
    176  32f4							;	  TSTB	     eDoDec,oBang		    ; Allow to inc or dec other tasks variables
    177  32f4							;	  IND					    ; we just got a pid
    178  32f4							;	  TSTVT      ERRVEC2			    ; if it is not another variabe then error, Call test var. task
    179  32f4				   eDoDec
      0  32f4					      DECVAR		; Decrement the actual variable
      0  32f4					      db	99
      1  32f4		       63		      .byte.b	99
      0  32f5					      DONE		; Test if end of line or : statement
      0  32f5					      db	1
      1  32f5		       01		      .byte.b	1
      0  32f6					      NXT	CO	; If at end of program then got the console
      0  32f6					      db	6
      1  32f6		       06		      .byte.b	6
      0  32f7					      dw	CO
      1  32f7		       a3 32		      .word.w	CO
      0  32f9					      IJMP	STMT	; Process the next statement of command line
      0  32f9					      db	29
      1  32f9		       1d		      .byte.b	29
      0  32fa					      dw	STMT
      1  32fa		       ab 32		      .word.w	STMT
    184  32fc							;=============================================================================================================================
    185  32fc							; iret or ireturn, Return from interupt process
    186  32fc							;
    187  32fc							;S1Iret:
    188  32fc							;	  TSTB	     S1S1,kIreturn		 ; test return from interupt
    189  32fc							;S1Sa:
    190  32fc				   ekIreturn
      0  32fc					      DONE		; Must be only thing on the line
      0  32fc					      db	1
      1  32fc		       01		      .byte.b	1
      0  32fd					      IRET		; RESTORE LINE NUMBER OF CALL
      0  32fd					      db	58
      1  32fd		       3a		      .byte.b	58
      0  32fe					      IJMP	STMT
      0  32fe					      db	29
      1  32fe		       1d		      .byte.b	29
      0  32ff					      dw	STMT
      1  32ff		       ab 32		      .word.w	STMT
    194  3301							;==============================================================================================================================
    195  3301							;Process if statement, if true then process all statements until end of line reached
    196  3301							;S1S1:
    197  3301							;	  TSTB	     S1Z,kIf			      ; IF STATEMENT
    198  3301				   ekIf
      0  3301					      CALL	EXPR	; GET EXPRESSION rel ops now valid expression 0 false, everything else true
      0  3301					      db	28
      1  3301		       1c		      .byte.b	28
      0  3302					      dw	EXPR
      1  3302		       c0 34		      .word.w	EXPR
      0  3304					      TSTB	ekThen,kThen	; (This line originally omitted) not required
      0  3304					      db	101
      1  3304		       65		      .byte.b	101
      0  3305					      db	(ekThen-*)-1
      1  3305		       01		      .byte.b	(ekThen-*)-1
      0  3306					      db	kThen
      1  3306		       06		      .byte.b	kThen
    201  3307				   ekThen
      0  3307					      IBRANCH		; PERFORM COMPARISON -- PERFORMS NXT IF FALSE calls iBranch
      0  3307					      db	54
      1  3307		       36		      .byte.b	54
      0  3308					      IJMP	STMT
      0  3308					      db	29
      1  3308		       1d		      .byte.b	29
      0  3309					      dw	STMT
      1  3309		       ab 32		      .word.w	STMT
    204  330b							;===============================================================================================================================
    205  330b							; Test for GOTO
    206  330b							;S1Z:
    207  330b							;	  TSTB	     S2,kGoto			    ; YES...TO, OR...SUB
    208  330b							;
    209  330b				   ekGoto
      0  330b					      TSTBRANCH	ekGotoCompiled	; test the two byte vector following the goto if zero then normal line lookup
      0  330b					      db	106
      1  330b		       6a		      .byte.b	106
      0  330c					      db	(ekGotoCompiled-*)-1
      1  330c		       0c		      .byte.b	(ekGotoCompiled-*)-1
    211  330d							; Else we have the address and just goto that address
      0  330d					      TSTB	ekGotoLine,oPeriod	; If it is a period, then just go to start of this line
      0  330d					      db	101
      1  330d		       65		      .byte.b	101
      0  330e					      db	(ekGotoLine-*)-1
      1  330e		       05		      .byte.b	(ekGotoLine-*)-1
      0  330f					      db	oPeriod
      1  330f		       e9		      .byte.b	oPeriod
      0  3310					      REPEATLINE		; Repeat the same line again
      0  3310					      db	105
      1  3310		       69		      .byte.b	105
      0  3311					      IJMP	STMT	; Go do the statement
      0  3311					      db	29
      1  3311		       1d		      .byte.b	29
      0  3312					      dw	STMT
      1  3312		       ab 32		      .word.w	STMT
    215  3314
    216  3314				   ekGotoLine
      0  3314					      CALL	EXPR	; GET LABEL
      0  3314					      db	28
      1  3314		       1c		      .byte.b	28
      0  3315					      dw	EXPR
      1  3315		       c0 34		      .word.w	EXPR
    218  3317							;	  lit	     0				   ; Place indicator for line num on stack
      0  3317					      FASTERXFER	0
      0  3317					      db	120
      1  3317		       78		      .byte.b	120
      0  3318					      db	0
      1  3318		       00		      .byte.b	0
    220  3319
    221  3319				   ekGotoCompiled
    222  3319							;	  lit	     1				    ; tell it that mempointer on the stack
      0  3319					      FASTERXFER	1	; put top of stack into curptr
      0  3319					      db	120
      1  3319		       78		      .byte.b	120
      0  331a					      db	1
      1  331a		       01		      .byte.b	1
    224  331b
    225  331b							;==================================================================================================================================
    226  331b							; Process REM statement
    227  331b							;
    228  331b							;S2a:
    229  331b							;	  TSTB	     S3,kRem			    ; REMark.  Skip rest of line
    230  331b				   ekRem
      0  331b					      NXT	CO	; The rest of the line is ignored
      0  331b					      db	6
      1  331b		       06		      .byte.b	6
      0  331c					      dw	CO
      1  331c		       a3 32		      .word.w	CO
      0  331e					      IJMP	STMT	; Process the next statement
      0  331e					      db	29
      1  331e		       1d		      .byte.b	29
      0  331f					      dw	STMT
      1  331f		       ab 32		      .word.w	STMT
    233  3321							;====================================================================================================================================
    234  3321							; Set the Task input output slot each slot is 16 byte starting at e000
    235  3321							; so 0,1,...
    236  3321				   ekSetTerm
      0  3321					      CALL	EXPR
      0  3321					      db	28
      1  3321		       1c		      .byte.b	28
      0  3322					      dw	EXPR
      1  3322		       c0 34		      .word.w	EXPR
      0  3324					      TSTB	ERRVEC,oComma
      0  3324					      db	101
      1  3324		       65		      .byte.b	101
      0  3325					      db	(ERRVEC-*)-1
      1  3325		       2f		      .byte.b	(ERRVEC-*)-1
      0  3326					      db	oComma
      1  3326		       e2		      .byte.b	oComma
      0  3327					      CALL	EXPR
      0  3327					      db	28
      1  3327		       1c		      .byte.b	28
      0  3328					      dw	EXPR
      1  3328		       c0 34		      .word.w	EXPR
      0  332a					      SETTERMINAL
      0  332a					      db	108
      1  332a		       6c		      .byte.b	108
      0  332b					      NXT	CO	;Next statement to execute
      0  332b					      db	6
      1  332b		       06		      .byte.b	6
      0  332c					      dw	CO
      1  332c		       a3 32		      .word.w	CO
      0  332e					      IJMP	STMT
      0  332e					      db	29
      1  332e		       1d		      .byte.b	29
      0  332f					      dw	STMT
      1  332f		       ab 32		      .word.w	STMT
    243  3331							;==================================================================================================================================
    244  3331							; Print statement
    245  3331							;
    246  3331							;S3:
    247  3331							;	  TSTB	     S8,kPrint			    ; ? or Print symonym for print
    248  3331				   ekPrint
      0  3331					      STARTIO		; Lock task until io completes
      0  3331					      db	70
      1  3331		       46		      .byte.b	70
    250  3332				   S4
      0  3332					      TSTDONE	S4a	; Test if we just want crlf printed
      0  3332					      db	50
      1  3332		       32		      .byte.b	50
      0  3333					      db	(S4a-*)-1
      1  3333		       03		      .byte.b	(S4a-*)-1
      0  3334					      IJMP	S6
      0  3334					      db	29
      1  3334		       1d		      .byte.b	29
      0  3335					      dw	S6
      1  3335		       4c 33		      .word.w	S6
    253  3337
    254  3337				   S4a
      0  3337					      TSTB	S7,tString	; TEST FOR QUOTED String
      0  3337					      db	101
      1  3337		       65		      .byte.b	101
      0  3338					      db	(S7-*)-1
      1  3338		       1f		      .byte.b	(S7-*)-1
      0  3339					      db	tString
      1  3339		       a0		      .byte.b	tString
      0  333a					      PRS		; PRINT STRING
      0  333a					      db	2
      1  333a		       02		      .byte.b	2
    257  333b				   S5
      0  333b					      TSTB	S6A,oComma	; IS THERE MORE?
      0  333b					      db	101
      1  333b		       65		      .byte.b	101
      0  333c					      db	(S6A-*)-1
      1  333c		       07		      .byte.b	(S6A-*)-1
      0  333d					      db	oComma
      1  333d		       e2		      .byte.b	oComma
      0  333e					      SPC		; SPACE TO NEXT ZONE
      0  333e					      db	4
      1  333e		       04		      .byte.b	4
      0  333f					      TSTDONE	S4	; Not end of line jump back
      0  333f					      db	50
      1  333f		       32		      .byte.b	50
      0  3340					      db	(S4-*)-1
      1  3340		       f1		      .byte.b	(S4-*)-1
      0  3341					      IJMP	S6Z	; YES JUMP BACK
      0  3341					      db	29
      1  3341		       1d		      .byte.b	29
      0  3342					      dw	S6Z
      1  3342		       4e 33		      .word.w	S6Z
    262  3344
    263  3344							;
    264  3344							; If a semicolon, don't do anything.
    265  3344							;
    266  3344				   S6A
      0  3344					      TSTB	S6,oSemiColon	; IF semicolon also check if end of line
      0  3344					      db	101
      1  3344		       65		      .byte.b	101
      0  3345					      db	(S6-*)-1
      1  3345		       06		      .byte.b	(S6-*)-1
      0  3346					      db	oSemiColon
      1  3346		       e3		      .byte.b	oSemiColon
      0  3347					      TSTDONE	S4	; Jump Back if not end of line
      0  3347					      db	50
      1  3347		       32		      .byte.b	50
      0  3348					      db	(S4-*)-1
      1  3348		       e9		      .byte.b	(S4-*)-1
      0  3349					      IJMP	S6Z
      0  3349					      db	29
      1  3349		       1d		      .byte.b	29
      0  334a					      dw	S6Z
      1  334a		       4e 33		      .word.w	S6Z
    270  334c
    271  334c				   S6
    272  334c
      0  334c					      DONE		; ERROR IF CR NOT NEXT
      0  334c					      db	1
      1  334c		       01		      .byte.b	1
      0  334d					      NLINE
      0  334d					      db	5
      1  334d		       05		      .byte.b	5
    275  334e				   S6Z
      0  334e					      ENDIO		; release task io completed
      0  334e					      db	71
      1  334e		       47		      .byte.b	71
      0  334f					      NXT	CO	; exit here if , or ; at end of print
      0  334f					      db	6
      1  334f		       06		      .byte.b	6
      0  3350					      dw	CO
      1  3350		       a3 32		      .word.w	CO
      0  3352					      IJMP	STMT
      0  3352					      db	29
      1  3352		       1d		      .byte.b	29
      0  3353					      dw	STMT
      1  3353		       ab 32		      .word.w	STMT
    279  3355							;
    280  3355							; A jump for code too far away for relative branch
    281  3355							;
    282  3355				   ERRVEC
      0  3355					      IJMP	UNKNOWN
      0  3355					      db	29
      1  3355		       1d		      .byte.b	29
      0  3356					      dw	UNKNOWN
      1  3356		       bc 34		      .word.w	UNKNOWN
    284  3358							;
    285  3358							; Get here if there is an expression to print
    286  3358				   S7
      0  3358					      TSTB	S7AUnsigned,oDollar	; Print the value in Hex format
      0  3358					      db	101
      1  3358		       65		      .byte.b	101
      0  3359					      db	(S7AUnsigned-*)-1
      1  3359		       08		      .byte.b	(S7AUnsigned-*)-1
      0  335a					      db	oDollar
      1  335a		       e7		      .byte.b	oDollar
      0  335b					      CALL	EXPR
      0  335b					      db	28
      1  335b		       1c		      .byte.b	28
      0  335c					      dw	EXPR
      1  335c		       c0 34		      .word.w	EXPR
      0  335e					      HEXPRT
      0  335e					      db	67
      1  335e		       43		      .byte.b	67
      0  335f					      IJMP	S5
      0  335f					      db	29
      1  335f		       1d		      .byte.b	29
      0  3360					      dw	S5
      1  3360		       3b 33		      .word.w	S5
    291  3362
    292  3362				   S7AUnsigned
    293  3362
      0  3362					      TSTB	S7A,oPercent	; Print the value as an unsigned number
      0  3362					      db	101
      1  3362		       65		      .byte.b	101
      0  3363					      db	(S7A-*)-1
      1  3363		       0a		      .byte.b	(S7A-*)-1
      0  3364					      db	oPercent
      1  3364		       ed		      .byte.b	oPercent
      0  3365					      CALL	EXPR
      0  3365					      db	28
      1  3365		       1c		      .byte.b	28
      0  3366					      dw	EXPR
      1  3366		       c0 34		      .word.w	EXPR
      0  3368					      SETR2	tUint
      0  3368					      db	94
      1  3368		       5e		      .byte.b	94
      0  3369					      db	tUint
      1  3369		       a9		      .byte.b	tUint
      0  336a					      PRN
      0  336a					      db	3
      1  336a		       03		      .byte.b	3
      0  336b					      IJMP	S5
      0  336b					      db	29
      1  336b		       1d		      .byte.b	29
      0  336c					      dw	S5
      1  336c		       3b 33		      .word.w	S5
    299  336e
    300  336e				   S7A
    301  336e
      0  336e					      CALL	EXPR
      0  336e					      db	28
      1  336e		       1c		      .byte.b	28
      0  336f					      dw	EXPR
      1  336f		       c0 34		      .word.w	EXPR
      0  3371					      TSTB	S7B,oDollar	; Print the value as a single character
      0  3371					      db	101
      1  3371		       65		      .byte.b	101
      0  3372					      db	(S7B-*)-1
      1  3372		       05		      .byte.b	(S7B-*)-1
      0  3373					      db	oDollar
      1  3373		       e7		      .byte.b	oDollar
      0  3374					      PUTCHAR
      0  3374					      db	52
      1  3374		       34		      .byte.b	52
      0  3375					      IJMP	S5
      0  3375					      db	29
      1  3375		       1d		      .byte.b	29
      0  3376					      dw	S5
      1  3376		       3b 33		      .word.w	S5
    306  3378
    307  3378				   S7B
      0  3378					      SETR2	tInteger	; Print the value as a signed number
      0  3378					      db	94
      1  3378		       5e		      .byte.b	94
      0  3379					      db	tInteger
      1  3379		       a4		      .byte.b	tInteger
      0  337a					      PRN		; PRINT IT
      0  337a					      db	3
      1  337a		       03		      .byte.b	3
      0  337b					      IJMP	S5	; IS THERE MORE?
      0  337b					      db	29
      1  337b		       1d		      .byte.b	29
      0  337c					      dw	S5
      1  337c		       3b 33		      .word.w	S5
    311  337e							;
    312  337e							;===========================================================
    313  337e							; PROCESS ALL THE TASK STATEMENTS
    314  337e							;
    315  337e							;S8:
    316  337e							;	  TSTB	      S8G,kTaske		 ; End Task
    317  337e				   ekTaske
      0  337e					      TSTB	S8NoParm,oLeftBracket
      0  337e					      db	101
      1  337e		       65		      .byte.b	101
      0  337f					      db	(S8NoParm-*)-1
      1  337f		       0c		      .byte.b	(S8NoParm-*)-1
      0  3380					      db	oLeftBracket
      1  3380		       e0		      .byte.b	oLeftBracket
      0  3381					      CALL	EXPR
      0  3381					      db	28
      1  3381		       1c		      .byte.b	28
      0  3382					      dw	EXPR
      1  3382		       c0 34		      .word.w	EXPR
      0  3384					      TSTB	UNKNOWNLnk,oRightBracket
      0  3384					      db	101
      1  3384		       65		      .byte.b	101
      0  3385					      db	(UNKNOWNLnk-*)-1
      1  3385		       2d		      .byte.b	(UNKNOWNLnk-*)-1
      0  3386					      db	oRightBracket
      1  3386		       e1		      .byte.b	oRightBracket
      0  3387					      ETASK
      0  3387					      db	62
      1  3387		       3e		      .byte.b	62
      0  3388					      DONE
      0  3388					      db	1
      1  3388		       01		      .byte.b	1
      0  3389					      IJMP	STMT
      0  3389					      db	29
      1  3389		       1d		      .byte.b	29
      0  338a					      dw	STMT
      1  338a		       ab 32		      .word.w	STMT
    324  338c				   S8NoParm
      0  338c					      LIT	0
      0  338c					      db	27
      1  338c		       1b		      .byte.b	27
      0  338d					      dw	0
      1  338d		       00 00		      .word.w	0
      0  338f					      ETASK
      0  338f					      db	62
      1  338f		       3e		      .byte.b	62
      0  3390					      DONE		; Must be last thing on a line
      0  3390					      db	1
      1  3390		       01		      .byte.b	1
      0  3391					      IJMP	STMT
      0  3391					      db	29
      1  3391		       1d		      .byte.b	29
      0  3392					      dw	STMT
      1  3392		       ab 32		      .word.w	STMT
    329  3394							;
    330  3394							;===========================================================
    331  3394							; The task gives up the rest of the cycles
    332  3394							;S8G:
    333  3394							;	  TSTB	      S8a,kTaskn	 ;Next task
    334  3394				   ekTaskn
      0  3394					      NTASK
      0  3394					      db	63
      1  3394		       3f		      .byte.b	63
      0  3395					      NXT	CO	;Next statement to execute
      0  3395					      db	6
      1  3395		       06		      .byte.b	6
      0  3396					      dw	CO
      1  3396		       a3 32		      .word.w	CO
      0  3398					      IJMP	STMT
      0  3398					      db	29
      1  3398		       1d		      .byte.b	29
      0  3399					      dw	STMT
      1  3399		       ab 32		      .word.w	STMT
    338  339b							;
    339  339b							;===========================================================
    340  339b							; Waits for a task or list of tasks to complete
    341  339b
    342  339b				   ekTaskw
      0  339b					      TSTB	UNKNOWNLnk,oLeftBracket
      0  339b					      db	101
      1  339b		       65		      .byte.b	101
      0  339c					      db	(UNKNOWNLnk-*)-1
      1  339c		       16		      .byte.b	(UNKNOWNLnk-*)-1
      0  339d					      db	oLeftBracket
      1  339d		       e0		      .byte.b	oLeftBracket
    344  339e				   S8TSK
      0  339e					      Call	EXPR	;Gets the PID of task to wait for
      0  339e					      db	28
      1  339e		       1c		      .byte.b	28
      0  339f					      dw	EXPR
      1  339f		       c0 34		      .word.w	EXPR
    346  33a1				   S8LOOP
      0  33a1					      WTASK	S8LOOP	;Chks for the task PID to finish in a loop, gives up time slice if not done
      0  33a1					      db	76
      1  33a1		       4c		      .byte.b	76
      0  33a2					      db	(S8LOOP-*)-1
      1  33a2		       fe		      .byte.b	(S8LOOP-*)-1
      0  33a3					      TSTB	S8aa,oComma	;Checks for more tasks
      0  33a3					      db	101
      1  33a3		       65		      .byte.b	101
      0  33a4					      db	(S8aa-*)-1
      1  33a4		       04		      .byte.b	(S8aa-*)-1
      0  33a5					      db	oComma
      1  33a5		       e2		      .byte.b	oComma
      0  33a6					      IJMP	S8TSK	;Go for the next task number
      0  33a6					      db	29
      1  33a6		       1d		      .byte.b	29
      0  33a7					      dw	S8TSK
      1  33a7		       9e 33		      .word.w	S8TSK
    350  33a9				   S8aa
      0  33a9					      TSTB	UNKNOWNLnk,oRightBracket	;end of list
      0  33a9					      db	101
      1  33a9		       65		      .byte.b	101
      0  33aa					      db	(UNKNOWNLnk-*)-1
      1  33aa		       08		      .byte.b	(UNKNOWNLnk-*)-1
      0  33ab					      db	oRightBracket
      1  33ab		       e1		      .byte.b	oRightBracket
      0  33ac					      DONE
      0  33ac					      db	1
      1  33ac		       01		      .byte.b	1
      0  33ad					      NXT	CO
      0  33ad					      db	6
      1  33ad		       06		      .byte.b	6
      0  33ae					      dw	CO
      1  33ae		       a3 32		      .word.w	CO
      0  33b0					      IJMP	STMT	;Next Statement
      0  33b0					      db	29
      1  33b0		       1d		      .byte.b	29
      0  33b1					      dw	STMT
      1  33b1		       ab 32		      .word.w	STMT
    355  33b3
    356  33b3				   UNKNOWNLnk
      0  33b3					      iJMP	UNKNOWN
      0  33b3					      db	29
      1  33b3		       1d		      .byte.b	29
      0  33b4					      dw	UNKNOWN
      1  33b4		       bc 34		      .word.w	UNKNOWN
    358  33b6
    359  33b6							;
    360  33b6							;===========================================================
    361  33b6							; Update a memory location with a value
    362  33b6							;  Use @[offset] to write a word value to memory
    363  33b6							;
    364  33b6							;S8a1:
    365  33b6							;	  TSTB	      S8b,kPoke 			  ; Poke a value into memory
    366  33b6				   ekPoke
      0  33b6					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  33b6					      db	101
      1  33b6		       65		      .byte.b	101
      0  33b7					      db	(UNKNOWNV-*)-1
      1  33b7		       a1		      .byte.b	(UNKNOWNV-*)-1
      0  33b8					      db	oLeftBracket
      1  33b8		       e0		      .byte.b	oLeftBracket
      0  33b9					      CALL	EXPR	; Get address to write to
      0  33b9					      db	28
      1  33b9		       1c		      .byte.b	28
      0  33ba					      dw	EXPR
      1  33ba		       c0 34		      .word.w	EXPR
      0  33bc					      TSTB	UNKNOWNV,oComma	; Must have a coma
      0  33bc					      db	101
      1  33bc		       65		      .byte.b	101
      0  33bd					      db	(UNKNOWNV-*)-1
      1  33bd		       9b		      .byte.b	(UNKNOWNV-*)-1
      0  33be					      db	oComma
      1  33be		       e2		      .byte.b	oComma
      0  33bf					      CALL	EXPR	; Get the value to poke
      0  33bf					      db	28
      1  33bf		       1c		      .byte.b	28
      0  33c0					      dw	EXPR
      1  33c0		       c0 34		      .word.w	EXPR
      0  33c2					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  33c2					      db	101
      1  33c2		       65		      .byte.b	101
      0  33c3					      db	(UNKNOWNV-*)-1
      1  33c3		       95		      .byte.b	(UNKNOWNV-*)-1
      0  33c4					      db	oRightBracket
      1  33c4		       e1		      .byte.b	oRightBracket
      0  33c5					      POKEMEM
      0  33c5					      db	47
      1  33c5		       2f		      .byte.b	47
      0  33c6					      DONE
      0  33c6					      db	1
      1  33c6		       01		      .byte.b	1
      0  33c7					      NXT	CO	;AND SEQUENCE TO NEXT
      0  33c7					      db	6
      1  33c7		       06		      .byte.b	6
      0  33c8					      dw	CO
      1  33c8		       a3 32		      .word.w	CO
      0  33ca					      IJMP	STMT
      0  33ca					      db	29
      1  33ca		       1d		      .byte.b	29
      0  33cb					      dw	STMT
      1  33cb		       ab 32		      .word.w	STMT
    376  33cd							;
    377  33cd							;================================================================
    378  33cd							; Set a block of memory to a value word or byte
    379  33cd							; SetMem(Value, Length, Destination)
    380  33cd				   ekSetMemB
      0  33cd					      CALL	ekSetMem
      0  33cd					      db	28
      1  33cd		       1c		      .byte.b	28
      0  33ce					      dw	ekSetMem
      1  33ce		       e5 33		      .word.w	ekSetMem
      0  33d0					      SETBLOCK	tByte	; set value as byte
      0  33d0					      db	110
      1  33d0		       6e		      .byte.b	110
      0  33d1					      db	tByte
      1  33d1		       a2		      .byte.b	tByte
      0  33d2					      DONE
      0  33d2					      db	1
      1  33d2		       01		      .byte.b	1
      0  33d3					      NXT	CO
      0  33d3					      db	6
      1  33d3		       06		      .byte.b	6
      0  33d4					      dw	CO
      1  33d4		       a3 32		      .word.w	CO
      0  33d6					      IJMP	STMT
      0  33d6					      db	29
      1  33d6		       1d		      .byte.b	29
      0  33d7					      dw	STMT
      1  33d7		       ab 32		      .word.w	STMT
    386  33d9
    387  33d9				   ekSetMemW
      0  33d9					      CALL	ekSetMem
      0  33d9					      db	28
      1  33d9		       1c		      .byte.b	28
      0  33da					      dw	ekSetMem
      1  33da		       e5 33		      .word.w	ekSetMem
      0  33dc					      SETBLOCK	tInteger	; set value as byte
      0  33dc					      db	110
      1  33dc		       6e		      .byte.b	110
      0  33dd					      db	tInteger
      1  33dd		       a4		      .byte.b	tInteger
      0  33de					      DONE
      0  33de					      db	1
      1  33de		       01		      .byte.b	1
      0  33df					      NXT	CO
      0  33df					      db	6
      1  33df		       06		      .byte.b	6
      0  33e0					      dw	CO
      1  33e0		       a3 32		      .word.w	CO
      0  33e2					      IJMP	STMT
      0  33e2					      db	29
      1  33e2		       1d		      .byte.b	29
      0  33e3					      dw	STMT
      1  33e3		       ab 32		      .word.w	STMT
    393  33e5
    394  33e5				   ekSetMem
      0  33e5					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  33e5					      db	101
      1  33e5		       65		      .byte.b	101
      0  33e6					      db	(UNKNOWNV-*)-1
      1  33e6		       72		      .byte.b	(UNKNOWNV-*)-1
      0  33e7					      db	oLeftBracket
      1  33e7		       e0		      .byte.b	oLeftBracket
      0  33e8					      CALL	EXPR	; Value to set
      0  33e8					      db	28
      1  33e8		       1c		      .byte.b	28
      0  33e9					      dw	EXPR
      1  33e9		       c0 34		      .word.w	EXPR
      0  33eb					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  33eb					      db	101
      1  33eb		       65		      .byte.b	101
      0  33ec					      db	(UNKNOWNV-*)-1
      1  33ec		       6c		      .byte.b	(UNKNOWNV-*)-1
      0  33ed					      db	oComma
      1  33ed		       e2		      .byte.b	oComma
      0  33ee					      CALL	EXPR	; Get The Length
      0  33ee					      db	28
      1  33ee		       1c		      .byte.b	28
      0  33ef					      dw	EXPR
      1  33ef		       c0 34		      .word.w	EXPR
      0  33f1					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  33f1					      db	101
      1  33f1		       65		      .byte.b	101
      0  33f2					      db	(UNKNOWNV-*)-1
      1  33f2		       66		      .byte.b	(UNKNOWNV-*)-1
      0  33f3					      db	oComma
      1  33f3		       e2		      .byte.b	oComma
      0  33f4					      CALL	EXPR	; GET the address to start at
      0  33f4					      db	28
      1  33f4		       1c		      .byte.b	28
      0  33f5					      dw	EXPR
      1  33f5		       c0 34		      .word.w	EXPR
      0  33f7					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  33f7					      db	101
      1  33f7		       65		      .byte.b	101
      0  33f8					      db	(UNKNOWNV-*)-1
      1  33f8		       60		      .byte.b	(UNKNOWNV-*)-1
      0  33f9					      db	oRightBracket
      1  33f9		       e1		      .byte.b	oRightBracket
      0  33fa					      RTN
      0  33fa					      db	25
      1  33fa		       19		      .byte.b	25
    403  33fb							;
    404  33fb							;================================================================
    405  33fb							; Copy a block of memory
    406  33fb							; CopyMem(Length, Destination, Source)
    407  33fb				   ekCopyMem
      0  33fb					      TSTB	UNKNOWNV,oLeftBracket	; opening bracket
      0  33fb					      db	101
      1  33fb		       65		      .byte.b	101
      0  33fc					      db	(UNKNOWNV-*)-1
      1  33fc		       5c		      .byte.b	(UNKNOWNV-*)-1
      0  33fd					      db	oLeftBracket
      1  33fd		       e0		      .byte.b	oLeftBracket
      0  33fe					      CALL	EXPR	; Length
      0  33fe					      db	28
      1  33fe		       1c		      .byte.b	28
      0  33ff					      dw	EXPR
      1  33ff		       c0 34		      .word.w	EXPR
      0  3401					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  3401					      db	101
      1  3401		       65		      .byte.b	101
      0  3402					      db	(UNKNOWNV-*)-1
      1  3402		       56		      .byte.b	(UNKNOWNV-*)-1
      0  3403					      db	oComma
      1  3403		       e2		      .byte.b	oComma
      0  3404					      CALL	EXPR	; Destination
      0  3404					      db	28
      1  3404		       1c		      .byte.b	28
      0  3405					      dw	EXPR
      1  3405		       c0 34		      .word.w	EXPR
      0  3407					      TSTB	UNKNOWNV,oComma	; Must have a comma
      0  3407					      db	101
      1  3407		       65		      .byte.b	101
      0  3408					      db	(UNKNOWNV-*)-1
      1  3408		       50		      .byte.b	(UNKNOWNV-*)-1
      0  3409					      db	oComma
      1  3409		       e2		      .byte.b	oComma
      0  340a					      CALL	EXPR	; Source
      0  340a					      db	28
      1  340a		       1c		      .byte.b	28
      0  340b					      dw	EXPR
      1  340b		       c0 34		      .word.w	EXPR
      0  340d					      TSTB	UNKNOWNV,oRightBracket	; closing bracket
      0  340d					      db	101
      1  340d		       65		      .byte.b	101
      0  340e					      db	(UNKNOWNV-*)-1
      1  340e		       4a		      .byte.b	(UNKNOWNV-*)-1
      0  340f					      db	oRightBracket
      1  340f		       e1		      .byte.b	oRightBracket
      0  3410					      COPYBLOCK		; Copy the memory
      0  3410					      db	111
      1  3410		       6f		      .byte.b	111
      0  3411					      DONE
      0  3411					      db	1
      1  3411		       01		      .byte.b	1
      0  3412					      NXT	CO
      0  3412					      db	6
      1  3412		       06		      .byte.b	6
      0  3413					      dw	CO
      1  3413		       a3 32		      .word.w	CO
      0  3415					      IJMP	STMT
      0  3415					      db	29
      1  3415		       1d		      .byte.b	29
      0  3416					      dw	STMT
      1  3416		       ab 32		      .word.w	STMT
    419  3418
    420  3418							;================================================================
    421  3418							; Write a single byte to the output device
    422  3418							;
    423  3418				   ekPutch
      0  3418					      CALL	EXPR
      0  3418					      db	28
      1  3418		       1c		      .byte.b	28
      0  3419					      dw	EXPR
      1  3419		       c0 34		      .word.w	EXPR
      0  341b					      PUTCHAR
      0  341b					      db	52
      1  341b		       34		      .byte.b	52
      0  341c					      DONE
      0  341c					      db	1
      1  341c		       01		      .byte.b	1
      0  341d					      NXT	CO	;AND SEQUENCE TO NEXT
      0  341d					      db	6
      1  341d		       06		      .byte.b	6
      0  341e					      dw	CO
      1  341e		       a3 32		      .word.w	CO
      0  3420					      IJMP	STMT
      0  3420					      db	29
      1  3420		       1d		      .byte.b	29
      0  3421					      dw	STMT
      1  3421		       ab 32		      .word.w	STMT
    429  3423							;================================================================
    430  3423							; Clear the screen lines
    431  3423							;  Uses the vt100 control seq, so must be connected to vt100 terminal
    432  3423							;
    433  3423				   ekCls
      0  3423					      CLEARSCREEN
      0  3423					      db	46
      1  3423		       2e		      .byte.b	46
      0  3424					      NXT	CO	;AND SEQUENCE TO NEXT
      0  3424					      db	6
      1  3424		       06		      .byte.b	6
      0  3425					      dw	CO
      1  3425		       a3 32		      .word.w	CO
      0  3427					      IJMP	STMT
      0  3427					      db	29
      1  3427		       1d		      .byte.b	29
      0  3428					      dw	STMT
      1  3428		       ab 32		      .word.w	STMT
    437  342a							;==================================================================
    438  342a							; Get input from the terminal
    439  342a							;   Reads from the currently active input device
    440  342a							;
    441  342a				   ekInput
    442  342a				   S10
      0  342a					      TSTB	S10A,tString	;If there is a string print the prompt
      0  342a					      db	101
      1  342a		       65		      .byte.b	101
      0  342b					      db	(S10A-*)-1
      1  342b		       05		      .byte.b	(S10A-*)-1
      0  342c					      db	tString
      1  342c		       a0		      .byte.b	tString
      0  342d					      PRS
      0  342d					      db	2
      1  342d		       02		      .byte.b	2
      0  342e					      TSTB	S10Z,oSemiColon	;Must follow the prompt
      0  342e					      db	101
      1  342e		       65		      .byte.b	101
      0  342f					      db	(S10Z-*)-1
      1  342f		       1e		      .byte.b	(S10Z-*)-1
      0  3430					      db	oSemiColon
      1  3430		       e3		      .byte.b	oSemiColon
    446  3431				   S10A
      0  3431					      TSTB	InNoString,oDollar	; Check if we are reading characters
      0  3431					      db	101
      1  3431		       65		      .byte.b	101
      0  3432					      db	(InNoString-*)-1
      1  3432		       0c		      .byte.b	(InNoString-*)-1
      0  3433					      db	oDollar
      1  3433		       e7		      .byte.b	oDollar
      0  3434					      TSTV	UNKNOWN
      0  3434					      db	33
      1  3434		       21		      .byte.b	33
      0  3435					      db	(UNKNOWN-*)-1
      1  3435		       86		      .byte.b	(UNKNOWN-*)-1
      0  3436					      CALL	FactVarPtrNoTst
      0  3436					      db	28
      1  3436		       1c		      .byte.b	28
      0  3437					      dw	FactVarPtrNoTst
      1  3437		       70 36		      .word.w	FactVarPtrNoTst
      0  3439					      INSTR		;Move character From tty to AESTK
      0  3439					      db	59
      1  3439		       3b		      .byte.b	59
      0  343a					      SETR2	tByte
      0  343a					      db	94
      1  343a		       5e		      .byte.b	94
      0  343b					      db	tByte
      1  343b		       a2		      .byte.b	tByte
      0  343c					      IJMP	S10A2
      0  343c					      db	29
      1  343c		       1d		      .byte.b	29
      0  343d					      dw	S10A2
      1  343d		       47 34		      .word.w	S10A2
    453  343f
    454  343f				   InNoString
      0  343f					      TSTV	UNKNOWN	; GET VAR ADDRESS (Originally CALL VAR = nonexist)
      0  343f					      db	33
      1  343f		       21		      .byte.b	33
      0  3440					      db	(UNKNOWN-*)-1
      1  3440		       7b		      .byte.b	(UNKNOWN-*)-1
      0  3441					      CALL	FactVarPtrNoTst
      0  3441					      db	28
      1  3441		       1c		      .byte.b	28
      0  3442					      dw	FactVarPtrNoTst
      1  3442		       70 36		      .word.w	FactVarPtrNoTst
      0  3444					      INNUM		;MOVE NUMBER FROM TTY TO AESTK
      0  3444					      db	11
      1  3444		       0b		      .byte.b	11
      0  3445					      SETR2	tInteger
      0  3445					      db	94
      1  3445		       5e		      .byte.b	94
      0  3446					      db	tInteger
      1  3446		       a4		      .byte.b	tInteger
    459  3447
    460  3447				   S10A2
      0  3447					      STORE		;STORE IT
      0  3447					      db	19
      1  3447		       13		      .byte.b	19
      0  3448					      TSTB	S11,oComma	;IS THERE MORE?
      0  3448					      db	101
      1  3448		       65		      .byte.b	101
      0  3449					      db	(S11-*)-1
      1  3449		       07		      .byte.b	(S11-*)-1
      0  344a					      db	oComma
      1  344a		       e2		      .byte.b	oComma
      0  344b					      IJMP	S10	;YES
      0  344b					      db	29
      1  344b		       1d		      .byte.b	29
      0  344c					      dw	S10
      1  344c		       2a 34		      .word.w	S10
    464  344e				   S10Z
      0  344e					      iJMP	UNKNOWN
      0  344e					      db	29
      1  344e		       1d		      .byte.b	29
      0  344f					      dw	UNKNOWN
      1  344f		       bc 34		      .word.w	UNKNOWN
    466  3451				   S11
      0  3451					      DONE		;MUST BE CR
      0  3451					      db	1
      1  3451		       01		      .byte.b	1
      0  3452					      NXT	CO	;SEQUENCE TO NEXT
      0  3452					      db	6
      1  3452		       06		      .byte.b	6
      0  3453					      dw	CO
      1  3453		       a3 32		      .word.w	CO
      0  3455					      IJMP	STMT
      0  3455					      db	29
      1  3455		       1d		      .byte.b	29
      0  3456					      dw	STMT
      1  3456		       ab 32		      .word.w	STMT
    470  3458							;=====================================================================
    471  3458							; End of program, return to command line process
    472  3458							; Main Task may also use taske or return to stopped
    473  3458							;
    474  3458				   ekEnd
      0  3458					      FIN
      0  3458					      db	12
      1  3458		       0c		      .byte.b	12
    476  3459				   UNKNOWNV
      0  3459					      IJMP	UNKNOWN
      0  3459					      db	29
      1  3459		       1d		      .byte.b	29
      0  345a					      dw	UNKNOWN
      1  345a		       bc 34		      .word.w	UNKNOWN
    478  345c							;====================================================================
    479  345c							; IRQ <IRQ-HANDLER-Line expression>
    480  345c							;   Specify a line number subroutine to call when an interupt is processed
    481  345c							;   These subroutines must use iret to return.
    482  345c							;
    483  345c				   ekIrq
      0  345c					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  345c					      db	28
      1  345c		       1c		      .byte.b	28
      0  345d					      dw	EXPR
      1  345d		       c0 34		      .word.w	EXPR
      0  345f					      DONE		;must be CR
      0  345f					      db	1
      1  345f		       01		      .byte.b	1
      0  3460					      SETIRQ		;Set the line number now
      0  3460					      db	56
      1  3460		       38		      .byte.b	56
      0  3461					      NXT	CO	;SEQUENCE TO NEXT STATEMENT
      0  3461					      db	6
      1  3461		       06		      .byte.b	6
      0  3462					      dw	CO
      1  3462		       a3 32		      .word.w	CO
      0  3464					      IJMP	STMT
      0  3464					      db	29
      1  3464		       1d		      .byte.b	29
      0  3465					      dw	STMT
      1  3465		       ab 32		      .word.w	STMT
    489  3467
    490  3467							;=========================================================================
    491  3467							; KILL PID-expression	 kill a running task
    492  3467							;  ignored of task has already stopped
    493  3467							;
    494  3467				   ekKill
      0  3467					      CALL	EXPR
      0  3467					      db	28
      1  3467		       1c		      .byte.b	28
      0  3468					      dw	EXPR
      1  3468		       c0 34		      .word.w	EXPR
      0  346a					      DONE
      0  346a					      db	1
      1  346a		       01		      .byte.b	1
      0  346b					      TASKKILL
      0  346b					      db	65
      1  346b		       41		      .byte.b	65
      0  346c					      NXT	CO
      0  346c					      db	6
      1  346c		       06		      .byte.b	6
      0  346d					      dw	CO
      1  346d		       a3 32		      .word.w	CO
      0  346f					      IJMP	STMT
      0  346f					      db	29
      1  346f		       1d		      .byte.b	29
      0  3470					      dw	STMT
      1  3470		       ab 32		      .word.w	STMT
    500  3472
    501  3472							;============================================================================
    502  3472							; List all program lines
    503  3472							;
    504  3472				   ekList
      0  3472					      DONE
      0  3472					      db	1
      1  3472		       01		      .byte.b	1
      0  3473					      LST
      0  3473					      db	21
      1  3473		       15		      .byte.b	21
      0  3474					      IJMP	CO
      0  3474					      db	29
      1  3474		       1d		      .byte.b	29
      0  3475					      dw	CO
      1  3475		       a3 32		      .word.w	CO
    508  3477							;=======================================================================
    509  3477							;RUN begin to executed the program in memory
    510  3477							;
    511  3477				   ekRun
      0  3477					      DONE
      0  3477					      db	1
      1  3477		       01		      .byte.b	1
      0  3478					      VINIT		;clear variables compile the line numbers
      0  3478					      db	30
      1  3478		       1e		      .byte.b	30
      0  3479					      LIT	1	;GOTO line 1
      0  3479					      db	27
      1  3479		       1b		      .byte.b	27
      0  347a					      dw	1
      1  347a		       01 00		      .word.w	1
      0  347c					      XFER		;Bob's addition
      0  347c					      db	7
      1  347c		       07		      .byte.b	7
    516  347d							; EXIT
      0  347d					      IJMP	STMT	;and run!
      0  347d					      db	29
      1  347d		       1d		      .byte.b	29
      0  347e					      dw	STMT
      1  347e		       ab 32		      .word.w	STMT
    518  3480							;=========================================================================
    519  3480							;Clear the program memory, delete all proram lines
    520  3480							;
    521  3480				   ekNew
      0  3480					      DONE
      0  3480					      db	1
      1  3480		       01		      .byte.b	1
      0  3481					      IJMP	START
      0  3481					      db	29
      1  3481		       1d		      .byte.b	29
      0  3482					      dw	START
      1  3482		       9d 32		      .word.w	START
    524  3484
    525  3484							;========================================================================
    526  3484							; Slice(slice legth expression)
    527  3484							;   set the length of time between task switches
    528  3484							;
    529  3484				   ekSlice
      0  3484					      CALL	EXPR
      0  3484					      db	28
      1  3484		       1c		      .byte.b	28
      0  3485					      dw	EXPR
      1  3485		       c0 34		      .word.w	EXPR
      0  3487					      SLICE
      0  3487					      db	100
      1  3487		       64		      .byte.b	100
      0  3488					      DONE
      0  3488					      db	1
      1  3488		       01		      .byte.b	1
      0  3489					      NXT	CO
      0  3489					      db	6
      1  3489		       06		      .byte.b	6
      0  348a					      dw	CO
      1  348a		       a3 32		      .word.w	CO
      0  348c					      IJMP	STMT
      0  348c					      db	29
      1  348c		       1d		      .byte.b	29
      0  348d					      dw	STMT
      1  348d		       ab 32		      .word.w	STMT
    535  348f							;==========================================================================
    536  348f							; Turn off and on the trace functions
    537  348f							; a debug terminal needs to be available
    538  348f							; Trace( Trace flag expression)
    539  348f							;	128 trace IL code, 64 trace basic code, 1 turn on interactive debug
    540  348f							;	for individual lines of basic code. These can be combined
    541  348f				   ekTrace
      0  348f					      TSTB	UNKNOWN,oLeftBracket	;Are we going to trace
      0  348f					      db	101
      1  348f		       65		      .byte.b	101
      0  3490					      db	(UNKNOWN-*)-1
      1  3490		       2b		      .byte.b	(UNKNOWN-*)-1
      0  3491					      db	oLeftBracket
      1  3491		       e0		      .byte.b	oLeftBracket
      0  3492					      CALL	EXPR
      0  3492					      db	28
      1  3492		       1c		      .byte.b	28
      0  3493					      dw	EXPR
      1  3493		       c0 34		      .word.w	EXPR
      0  3495					      TSTB	UNKNOWN,oRightBracket
      0  3495					      db	101
      1  3495		       65		      .byte.b	101
      0  3496					      db	(UNKNOWN-*)-1
      1  3496		       25		      .byte.b	(UNKNOWN-*)-1
      0  3497					      db	oRightBracket
      1  3497		       e1		      .byte.b	oRightBracket
      0  3498					      TRACEPROGRAM
      0  3498					      db	78
      1  3498		       4e		      .byte.b	78
      0  3499					      DONE
      0  3499					      db	1
      1  3499		       01		      .byte.b	1
      0  349a					      NXT	CO
      0  349a					      db	6
      1  349a		       06		      .byte.b	6
      0  349b					      dw	CO
      1  349b		       a3 32		      .word.w	CO
      0  349d					      IJMP	STMT
      0  349d					      db	29
      1  349d		       1d		      .byte.b	29
      0  349e					      dw	STMT
      1  349e		       ab 32		      .word.w	STMT
    549  34a0							;=====================================================================
    550  34a0							; Exit basic to machine monitor
    551  34a0							;
    552  34a0				   ekExit
      0  34a0					      EXIT
      0  34a0					      db	26
      1  34a0		       1a		      .byte.b	26
    554  34a1
    555  34a1							;=======================================================================
    556  34a1							; Commands related to saving/restoring programs
    557  34a1							; to/from mass storage.
    558  34a1							;=======================================================================
    559  34a1							; Save a program file
    560  34a1							;
    561  34a1					      if	(XKIM || CTMON65) && DISK_ACCESS
    562  34a1
    563  34a1				   ekSave
      0  34a1					      OPENWRITE	OPEN_CREATE
      0  34a1					      db	40
      1  34a1		       28		      .byte.b	40
      0  34a2					      db	OPEN_CREATE
      1  34a2		       01		      .byte.b	OPEN_CREATE
      0  34a3					      DLIST
      0  34a3					      db	43
      1  34a3		       2b		      .byte.b	43
      0  34a4					      DCLOSE
      0  34a4					      db	41
      1  34a4		       29		      .byte.b	41
      0  34a5					      IJMP	CO
      0  34a5					      db	29
      1  34a5		       1d		      .byte.b	29
      0  34a6					      dw	CO
      1  34a6		       a3 32		      .word.w	CO
    568  34a8							;=========================================================================
    569  34a8							; Load a program file
    570  34a8							;
    571  34a8				   ekLoad
      0  34a8					      OPENREAD
      0  34a8					      db	39
      1  34a8		       27		      .byte.b	39
    573  34a9				   S17CLP
      0  34a9					      DGETLINE		;get line from file
      0  34a9					      db	42
      1  34a9		       2a		      .byte.b	42
      0  34aa					      TSTL	S17EOL	;no line num means EOL
      0  34aa					      db	34
      1  34aa		       22		      .byte.b	34
      0  34ab					      db	(S17EOL-*)-1
      1  34ab		       04		      .byte.b	(S17EOL-*)-1
      0  34ac					      INSERT		;put it into the program
      0  34ac					      db	24
      1  34ac		       18		      .byte.b	24
      0  34ad					      IJMP	S17CLP	;keep going
      0  34ad					      db	29
      1  34ad		       1d		      .byte.b	29
      0  34ae					      dw	S17CLP
      1  34ae		       a9 34		      .word.w	S17CLP
    578  34b0				   S17EOL
      0  34b0					      DCLOSE		;close disk file
      0  34b0					      db	41
      1  34b0		       29		      .byte.b	41
      0  34b1					      IJMP	CO	;back to start
      0  34b1					      db	29
      1  34b1		       1d		      .byte.b	29
      0  34b2					      dw	CO
      1  34b2		       a3 32		      .word.w	CO
    581  34b4							;=========================================================================
    582  34b4							; Display the directory content
    583  34b4							;
    584  34b4				   ekDir
      0  34b4					      DDIR		;Display the directory content
      0  34b4					      db	44
      1  34b4		       2c		      .byte.b	44
      0  34b5					      IJMP	CO
      0  34b5					      db	29
      1  34b5		       1d		      .byte.b	29
      0  34b6					      dw	CO
      1  34b6		       a3 32		      .word.w	CO
    587  34b8							;=========================================================================
    588  34b8							; Erase a file from disk
    589  34b8							;
    590  34b8				   ekErase
      0  34b8					      RMFILE		;Erase the file from the disk
      0  34b8					      db	45
      1  34b8		       2d		      .byte.b	45
      0  34b9					      IJMP	CO
      0  34b9					      db	29
      1  34b9		       1d		      .byte.b	29
      0  34ba					      dw	CO
      1  34ba		       a3 32		      .word.w	CO
    593  34bc
    594  34bc					      endif
    595  34bc
    596  34bc							;===========================================================================
    597  34bc							; Else, unknown command.
    598  34bc							;
    599  34bc				   UNKNOWN
      0  34bc					      ENDIO
      0  34bc					      db	71
      1  34bc		       47		      .byte.b	71
    601  34bd
    602  34bd				   NotKnownStatement
    603  34bd
      0  34bd					      ERRMSG	ERR_SYNTAX	;SYNTAX ERROR
      0  34bd					      db	13
      1  34bd		       0d		      .byte.b	13
      0  34be					      dw	ERR_SYNTAX
      1  34be		       05 00		      .word.w	ERR_SYNTAX
    605  34c0
    606  34c0							;=======================================================
    607  34c0							; Process Expresions, precidence is represented by the
    608  34c0							; various call levels
    609  34c0							;
    610  34c0				   EXPR
      0  34c0					      TSTB	EXPRLOGS,kNot
      0  34c0					      db	101
      1  34c0		       65		      .byte.b	101
      0  34c1					      db	(EXPRLOGS-*)-1
      1  34c1		       06		      .byte.b	(EXPRLOGS-*)-1
      0  34c2					      db	kNot
      1  34c2		       29		      .byte.b	kNot
    612  34c3				   ekNot
      0  34c3					      Call	EXPR
      0  34c3					      db	28
      1  34c3		       1c		      .byte.b	28
      0  34c4					      dw	EXPR
      1  34c4		       c0 34		      .word.w	EXPR
      0  34c6					      LOGNOT
      0  34c6					      db	72
      1  34c6		       48		      .byte.b	72
      0  34c7					      RTN
      0  34c7					      db	25
      1  34c7		       19		      .byte.b	25
    616  34c8
    617  34c8							;=========================================================
    618  34c8							;Look for logical operators, but does get first part of expression
    619  34c8				   EXPRLOGS
      0  34c8					      Call	EXPR2	; get the left first expression
      0  34c8					      db	28
      1  34c8		       1c		      .byte.b	28
      0  34c9					      dw	EXPR2
      1  34c9		       f7 34		      .word.w	EXPR2
      0  34cb					      TSTRELOP	EXPSHIFT	; Exit level if no rel ops found
      0  34cb					      db	104
      1  34cb		       68		      .byte.b	104
      0  34cc					      db	(EXPSHIFT-*)-1
      1  34cc		       05		      .byte.b	(EXPSHIFT-*)-1
    622  34cd							;	  TSTB	     iR0,oEqual
    623  34cd							;	  LIT	     2		     ;=
    624  34cd							;	  IJMP	     iRFound
    625  34cd							;iR0:
    626  34cd							;	  TSTB	      iR1,oLessEqual
    627  34cd							;	  LIT	      3 	      ;<=
    628  34cd							;	  IJMP	     iRFound
    629  34cd							;iR1:
    630  34cd							;	  TSTB	     iR3,oNotEqual
    631  34cd							;	  LIT	     5		      ;<>
    632  34cd							;	      IJMP	  iRFound
    633  34cd							;iR3:
    634  34cd							;	  TSTB	     iR4,oLess
    635  34cd							;	  LIT	     1		     ;<
    636  34cd							;	      IJMP	  iRFound
    637  34cd							;iR4:
    638  34cd							;	  TST	     iR5,oGreaterEqual
    639  34cd							;	  LIT	     6		     ;>=
    640  34cd							;	      IJMP	  iRFound
    641  34cd							;iR5:
    642  34cd							;	  TSTB	     iRDone,oGreater
    643  34cd							;	  LIT	     4		     ;>
    644  34cd				   iRFound
      0  34cd					      Call	EXPR2	; EXPR; get the right side of the expression
      0  34cd					      db	28
      1  34cd		       1c		      .byte.b	28
      0  34ce					      dw	EXPR2
      1  34ce		       f7 34		      .word.w	EXPR2
      0  34d0					      CMPR		; Push the value of the true false onto the stack
      0  34d0					      db	10
      1  34d0		       0a		      .byte.b	10
      0  34d1					      RTN
      0  34d1					      db	25
      1  34d1		       19		      .byte.b	25
    648  34d2
    649  34d2							;=========================================================
    650  34d2							;Look for shift left and shift right level
    651  34d2				   EXPSHIFT
      0  34d2					      OnGoto	BasicShift,EXPRLOGICAL
      0  34d2					      db	103
      1  34d2		       67		      .byte.b	103
      0  34d3					      dw	BasicShift
      1  34d3		       71 32		      .word.w	BasicShift
      0  34d5					      dw	EXPRLOGICAL
      1  34d5		       e3 34		      .word.w	EXPRLOGICAL
    653  34d7
    654  34d7				   ekShiftLeft
      0  34d7					      Call	EXPR
      0  34d7					      db	28
      1  34d7		       1c		      .byte.b	28
      0  34d8					      dw	EXPR
      1  34d8		       c0 34		      .word.w	EXPR
      0  34da					      SHIFT	0
      0  34da					      db	113
      1  34da		       71		      .byte.b	113
      0  34db					      db	0
      1  34db		       00		      .byte.b	0
      0  34dc					      RTN
      0  34dc					      db	25
      1  34dc		       19		      .byte.b	25
    658  34dd
    659  34dd				   ekShiftRight
      0  34dd					      Call	EXPR
      0  34dd					      db	28
      1  34dd		       1c		      .byte.b	28
      0  34de					      dw	EXPR
      1  34de		       c0 34		      .word.w	EXPR
      0  34e0					      SHIFT	1
      0  34e0					      db	113
      1  34e0		       71		      .byte.b	113
      0  34e1					      db	1
      1  34e1		       01		      .byte.b	1
      0  34e2					      RTN
      0  34e2					      db	25
      1  34e2		       19		      .byte.b	25
    663  34e3
    664  34e3							;======================================================================
    665  34e3				   EXPRLOGICAL
      0  34e3					      OnGoto	BasicLogical,iLOGExit
      0  34e3					      db	103
      1  34e3		       67		      .byte.b	103
      0  34e4					      dw	BasicLogical
      1  34e4		       69 32		      .word.w	BasicLogical
      0  34e6					      dw	iLOGExit
      1  34e6		       f6 34		      .word.w	iLOGExit
    667  34e8				   ekAnd
      0  34e8					      Call	EXPR
      0  34e8					      db	28
      1  34e8		       1c		      .byte.b	28
      0  34e9					      dw	EXPR
      1  34e9		       c0 34		      .word.w	EXPR
      0  34eb					      LOGAND
      0  34eb					      db	74
      1  34eb		       4a		      .byte.b	74
      0  34ec					      RTN
      0  34ec					      db	25
      1  34ec		       19		      .byte.b	25
    671  34ed				   ekOr
      0  34ed					      Call	EXPR
      0  34ed					      db	28
      1  34ed		       1c		      .byte.b	28
      0  34ee					      dw	EXPR
      1  34ee		       c0 34		      .word.w	EXPR
      0  34f0					      LOGOR
      0  34f0					      db	73
      1  34f0		       49		      .byte.b	73
      0  34f1					      RTN
      0  34f1					      db	25
      1  34f1		       19		      .byte.b	25
    675  34f2				   ekXor
      0  34f2					      Call	EXPR
      0  34f2					      db	28
      1  34f2		       1c		      .byte.b	28
      0  34f3					      dw	EXPR
      1  34f3		       c0 34		      .word.w	EXPR
      0  34f5					      LOGXOR
      0  34f5					      db	75
      1  34f5		       4b		      .byte.b	75
    678  34f6				   iLOGExit
      0  34f6					      RTN
      0  34f6					      db	25
      1  34f6		       19		      .byte.b	25
    680  34f7
    681  34f7							; get the right part of an expression
    682  34f7				   EXPR2
      0  34f7					      TSTB	E0,oMinus	; Look for leading - to negate term
      0  34f7					      db	101
      1  34f7		       65		      .byte.b	101
      0  34f8					      db	(E0-*)-1
      1  34f8		       08		      .byte.b	(E0-*)-1
      0  34f9					      db	oMinus
      1  34f9		       eb		      .byte.b	oMinus
      0  34fa					      CALL	TERM	; Get value to negate FOR UNARY -.
      0  34fa					      db	28
      1  34fa		       1c		      .byte.b	28
      0  34fb					      dw	TERM
      1  34fb		       1d 35		      .word.w	TERM
      0  34fd					      NEG		; Make value negated
      0  34fd					      db	16
      1  34fd		       10		      .byte.b	16
      0  34fe					      IJMP	E1	; We have Left term process operators next
      0  34fe					      db	29
      1  34fe		       1d		      .byte.b	29
      0  34ff					      dw	E1
      1  34ff		       07 35		      .word.w	E1
    687  3501				   E0
      0  3501					      TSTB	E1A,oPlus	; Look for a leading + for value and disgard it if found
      0  3501					      db	101
      1  3501		       65		      .byte.b	101
      0  3502					      db	(E1A-*)-1
      1  3502		       01		      .byte.b	(E1A-*)-1
      0  3503					      db	oPlus
      1  3503		       ea		      .byte.b	oPlus
    689  3504				   E1A
      0  3504					      CALL	TERM	; Get the left term if it was not negated
      0  3504					      db	28
      1  3504		       1c		      .byte.b	28
      0  3505					      dw	TERM
      1  3505		       1d 35		      .word.w	TERM
    691  3507				   E1
      0  3507					      TST	E2,oPlus	; Check if we are adding left term to something
      0  3507					      db	32
      1  3507		       20		      .byte.b	32
      0  3508					      db	(E2-*)-1
      1  3508		       09		      .byte.b	(E2-*)-1
      0  3509					      db	oPlus,0
      1  3509		       ea 00		      .byte.b	oPlus,0
      0  350b					      CALL	TERM	; if adding then get the right side term
      0  350b					      db	28
      1  350b		       1c		      .byte.b	28
      0  350c					      dw	TERM
      1  350c		       1d 35		      .word.w	TERM
      0  350e					      ADD		; Add it to left term
      0  350e					      db	14
      1  350e		       0e		      .byte.b	14
      0  350f					      IJMP	E1	; look for next + or -
      0  350f					      db	29
      1  350f		       1d		      .byte.b	29
      0  3510					      dw	E1
      1  3510		       07 35		      .word.w	E1
    696  3512				   E2
      0  3512					      TSTB	E3,oMinus	; Check if we are subtractig something
      0  3512					      db	101
      1  3512		       65		      .byte.b	101
      0  3513					      db	(E3-*)-1
      1  3513		       08		      .byte.b	(E3-*)-1
      0  3514					      db	oMinus
      1  3514		       eb		      .byte.b	oMinus
      0  3515					      CALL	TERM	; get right side to subtract Diffrence
      0  3515					      db	28
      1  3515		       1c		      .byte.b	28
      0  3516					      dw	TERM
      1  3516		       1d 35		      .word.w	TERM
      0  3518					      SUB		; Subtract the value
      0  3518					      db	15
      1  3518		       0f		      .byte.b	15
      0  3519					      IJMP	E1	; Look for next + or -
      0  3519					      db	29
      1  3519		       1d		      .byte.b	29
      0  351a					      dw	E1
      1  351a		       07 35		      .word.w	E1
    701  351c				   E3			; Finish processing the expression
      0  351c					      RTN		; We are finished processing the Expression
      0  351c					      db	25
      1  351c		       19		      .byte.b	25
    703  351d							;
    704  351d							; Get one of the terms of an expression
    705  351d							;
    706  351d				   TERM
      0  351d					      CALL	FACT	; Get a value
      0  351d					      db	28
      1  351d		       1c		      .byte.b	28
      0  351e					      dw	FACT
      1  351e		       42 35		      .word.w	FACT
    708  3520				   T0			; Check for higher precidence operators
      0  3520					      TSTB	T1,oMultiply	; Check for *
      0  3520					      db	101
      1  3520		       65		      .byte.b	101
      0  3521					      db	(T1-*)-1
      1  3521		       08		      .byte.b	(T1-*)-1
      0  3522					      db	oMultiply
      1  3522		       ee		      .byte.b	oMultiply
      0  3523					      CALL	FACT	; Get right side of term PRODUCT FACTOR.
      0  3523					      db	28
      1  3523		       1c		      .byte.b	28
      0  3524					      dw	FACT
      1  3524		       42 35		      .word.w	FACT
      0  3526					      MUL		; Multiply factors
      0  3526					      db	17
      1  3526		       11		      .byte.b	17
      0  3527					      IJMP	T0	; Check for * or /
      0  3527					      db	29
      1  3527		       1d		      .byte.b	29
      0  3528					      dw	T0
      1  3528		       20 35		      .word.w	T0
    713  352a				   T1
      0  352a					      TSTB	T2,oDivide	; Check for a division
      0  352a					      db	101
      1  352a		       65		      .byte.b	101
      0  352b					      db	(T2-*)-1
      1  352b		       08		      .byte.b	(T2-*)-1
      0  352c					      db	oDivide
      1  352c		       ec		      .byte.b	oDivide
      0  352d					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  352d					      db	28
      1  352d		       1c		      .byte.b	28
      0  352e					      dw	FACT
      1  352e		       42 35		      .word.w	FACT
      0  3530					      DIV		; do division
      0  3530					      db	18
      1  3530		       12		      .byte.b	18
      0  3531					      IJMP	T0	; check for more * or /
      0  3531					      db	29
      1  3531		       1d		      .byte.b	29
      0  3532					      dw	T0
      1  3532		       20 35		      .word.w	T0
    718  3534				   T2
      0  3534					      TSTB	T3,oModulo	; Check for a division
      0  3534					      db	101
      1  3534		       65		      .byte.b	101
      0  3535					      db	(T3-*)-1
      1  3535		       08		      .byte.b	(T3-*)-1
      0  3536					      db	oModulo
      1  3536		       ed		      .byte.b	oModulo
      0  3537					      CALL	FACT	; get right side QUOTIENT FACTOR.
      0  3537					      db	28
      1  3537		       1c		      .byte.b	28
      0  3538					      dw	FACT
      1  3538		       42 35		      .word.w	FACT
      0  353a					      MODULO		; do division for remainder
      0  353a					      db	60
      1  353a		       3c		      .byte.b	60
      0  353b					      IJMP	T0	; check for more * or / or %
      0  353b					      db	29
      1  353b		       1d		      .byte.b	29
      0  353c					      dw	T0
      1  353c		       20 35		      .word.w	T0
    723  353e				   T3			; Finish processing the Term
      0  353e					      RTN
      0  353e					      db	25
      1  353e		       19		      .byte.b	25
    725  353f
    726  353f				   UNKNOWNVEC
      0  353f					      IJMP	UNKNOWN
      0  353f					      db	29
      1  353f		       1d		      .byte.b	29
      0  3540					      dw	UNKNOWN
      1  3540		       bc 34		      .word.w	UNKNOWN
    728  3542
    729  3542							;=============================================================================================
    730  3542							; Factor an expression.  Always test for functions
    731  3542							; first or else they'll be confused for variables.
    732  3542							;
    733  3542				   FACT
      0  3542					      OnGoto	BasicFuncs,FactNumber
      0  3542					      db	103
      1  3542		       67		      .byte.b	103
      0  3543					      dw	BasicFuncs
      1  3543		       77 32		      .word.w	BasicFuncs
      0  3545					      dw	FactNumber
      1  3545		       42 36		      .word.w	FactNumber
    735  3547
    736  3547							;FACTCONTINUE:
    737  3547							;	  TSTB	     F1AA,kTrue
    738  3547				   ekTrue
      0  3547					      LIT	-1
      0  3547					      db	27
      1  3547		       1b		      .byte.b	27
      0  3548					      dw	-1
      1  3548		       ff ff		      .word.w	-1
      0  354a					      RTN
      0  354a					      db	25
      1  354a		       19		      .byte.b	25
    741  354b							;F1AA:
    742  354b							;	  TSTB	     F1AB,kFalse
    743  354b				   ekFalse
      0  354b					      LIT	0
      0  354b					      db	27
      1  354b		       1b		      .byte.b	27
      0  354c					      dw	0
      1  354c		       00 00		      .word.w	0
      0  354e					      RTN
      0  354e					      db	25
      1  354e		       19		      .byte.b	25
    746  354f							;==================================================================================
    747  354f							; Returns the amount of free SPACE
    748  354f				   ekFree
      0  354f					      TSTB	UNKNOWNVEC,oLeftBracket
      0  354f					      db	101
      1  354f		       65		      .byte.b	101
      0  3550					      db	(UNKNOWNVEC-*)-1
      1  3550		       ee		      .byte.b	(UNKNOWNVEC-*)-1
      0  3551					      db	oLeftBracket
      1  3551		       e0		      .byte.b	oLeftBracket
      0  3552					      TSTB	UNKNOWNVEC,oRightBracket
      0  3552					      db	101
      1  3552		       65		      .byte.b	101
      0  3553					      db	(UNKNOWNVEC-*)-1
      1  3553		       eb		      .byte.b	(UNKNOWNVEC-*)-1
      0  3554					      db	oRightBracket
      1  3554		       e1		      .byte.b	oRightBracket
      0  3555					      FREE
      0  3555					      db	36
      1  3555		       24		      .byte.b	36
      0  3556					      RTN
      0  3556					      db	25
      1  3556		       19		      .byte.b	25
    753  3557							;===================================================================================
    754  3557							; getch() read a character from the input device
    755  3557							;
    756  3557				   ekGetch
      0  3557					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3557					      db	101
      1  3557		       65		      .byte.b	101
      0  3558					      db	(UNKNOWNVEC-*)-1
      1  3558		       e6		      .byte.b	(UNKNOWNVEC-*)-1
      0  3559					      db	oLeftBracket
      1  3559		       e0		      .byte.b	oLeftBracket
      0  355a					      TSTB	UNKNOWNVEC,oRightBracket
      0  355a					      db	101
      1  355a		       65		      .byte.b	101
      0  355b					      db	(UNKNOWNVEC-*)-1
      1  355b		       e3		      .byte.b	(UNKNOWNVEC-*)-1
      0  355c					      db	oRightBracket
      1  355c		       e1		      .byte.b	oRightBracket
      0  355d					      GETCHAR
      0  355d					      db	51
      1  355d		       33		      .byte.b	51
      0  355e					      RTN
      0  355e					      db	25
      1  355e		       19		      .byte.b	25
    761  355f							;
    762  355f							;====================================================================================
    763  355f							; addr(variable definition)
    764  355f							; Returns the address of a variable on top of the stack
    765  355f				   ekAddr
      0  355f					      TSTB	UNKNOWNVEC,oLeftBracket
      0  355f					      db	101
      1  355f		       65		      .byte.b	101
      0  3560					      db	(UNKNOWNVEC-*)-1
      1  3560		       de		      .byte.b	(UNKNOWNVEC-*)-1
      0  3561					      db	oLeftBracket
      1  3561		       e0		      .byte.b	oLeftBracket
      0  3562					      TSTV	ExpectedVariable
      0  3562					      db	33
      1  3562		       21		      .byte.b	33
      0  3563					      db	(ExpectedVariable-*)-1
      1  3563		       07		      .byte.b	(ExpectedVariable-*)-1
      0  3564					      CALL	FactVarPtrNoTst
      0  3564					      db	28
      1  3564		       1c		      .byte.b	28
      0  3565					      dw	FactVarPtrNoTst
      1  3565		       70 36		      .word.w	FactVarPtrNoTst
      0  3567					      TSTB	UNKNOWNVEC,oRightBracket
      0  3567					      db	101
      1  3567		       65		      .byte.b	101
      0  3568					      db	(UNKNOWNVEC-*)-1
      1  3568		       d6		      .byte.b	(UNKNOWNVEC-*)-1
      0  3569					      db	oRightBracket
      1  3569		       e1		      .byte.b	oRightBracket
      0  356a					      RTN
      0  356a					      db	25
      1  356a		       19		      .byte.b	25
    771  356b
    772  356b				   ExpectedVariable
      0  356b					      ERRMSG	ERR_SYNTAX	;Expected Variable
      0  356b					      db	13
      1  356b		       0d		      .byte.b	13
      0  356c					      dw	ERR_SYNTAX
      1  356c		       05 00		      .word.w	ERR_SYNTAX
    774  356e							;
    775  356e							;================================================================
    776  356e							; Compare a block of memory
    777  356e							; CmpMem(Length, Source 1, Source 2)
    778  356e							; returns on the stack 0 equal, 1 s1>s2, -1 s1<s2
    779  356e				   ekCmpMem
      0  356e					      TSTB	UNKNOWNVEC,oLeftBracket	; opening bracket
      0  356e					      db	101
      1  356e		       65		      .byte.b	101
      0  356f					      db	(UNKNOWNVEC-*)-1
      1  356f		       cf		      .byte.b	(UNKNOWNVEC-*)-1
      0  3570					      db	oLeftBracket
      1  3570		       e0		      .byte.b	oLeftBracket
      0  3571					      CALL	EXPR	; Length
      0  3571					      db	28
      1  3571		       1c		      .byte.b	28
      0  3572					      dw	EXPR
      1  3572		       c0 34		      .word.w	EXPR
      0  3574					      TSTB	UNKNOWNVEC,oComma	; Must have a comma
      0  3574					      db	101
      1  3574		       65		      .byte.b	101
      0  3575					      db	(UNKNOWNVEC-*)-1
      1  3575		       c9		      .byte.b	(UNKNOWNVEC-*)-1
      0  3576					      db	oComma
      1  3576		       e2		      .byte.b	oComma
      0  3577					      CALL	EXPR	; Source 1
      0  3577					      db	28
      1  3577		       1c		      .byte.b	28
      0  3578					      dw	EXPR
      1  3578		       c0 34		      .word.w	EXPR
      0  357a					      TSTB	UNKNOWNVEC,oComma	; Must have a comma
      0  357a					      db	101
      1  357a		       65		      .byte.b	101
      0  357b					      db	(UNKNOWNVEC-*)-1
      1  357b		       c3		      .byte.b	(UNKNOWNVEC-*)-1
      0  357c					      db	oComma
      1  357c		       e2		      .byte.b	oComma
      0  357d					      CALL	EXPR	; Source 2
      0  357d					      db	28
      1  357d		       1c		      .byte.b	28
      0  357e					      dw	EXPR
      1  357e		       c0 34		      .word.w	EXPR
      0  3580					      TSTB	UNKNOWNVEC,oRightBracket	; closing bracket
      0  3580					      db	101
      1  3580		       65		      .byte.b	101
      0  3581					      db	(UNKNOWNVEC-*)-1
      1  3581		       bd		      .byte.b	(UNKNOWNVEC-*)-1
      0  3582					      db	oRightBracket
      1  3582		       e1		      .byte.b	oRightBracket
      0  3583					      CMPMEM		; Compare the memory
      0  3583					      db	112
      1  3583		       70		      .byte.b	112
      0  3584					      RTN
      0  3584					      db	25
      1  3584		       19		      .byte.b	25
    789  3585							;
    790  3585							;===============================================================================
    791  3585							; Set/stop/return timer values
    792  3585							;value 9 = 1 second, 1-5 = value * 10ms 6 = 10ms, 7=250ms, 8=500ms
    793  3585							;cmd	0 =
    794  3585				   eKTimer
      0  3585					      TSTB	UNKNOWNVEC,oLeftBracket	; opening bracket
      0  3585					      db	101
      1  3585		       65		      .byte.b	101
      0  3586					      db	(UNKNOWNVEC-*)-1
      1  3586		       b8		      .byte.b	(UNKNOWNVEC-*)-1
      0  3587					      db	oLeftBracket
      1  3587		       e0		      .byte.b	oLeftBracket
      0  3588					      CALL	EXPR	; purpose 0-4
      0  3588					      db	28
      1  3588		       1c		      .byte.b	28
      0  3589					      dw	EXPR
      1  3589		       c0 34		      .word.w	EXPR
      0  358b					      TSTB	eKTimerZero,oComma	; Must have a comma if more than one value
      0  358b					      db	101
      1  358b		       65		      .byte.b	101
      0  358c					      db	(eKTimerZero-*)-1
      1  358c		       07		      .byte.b	(eKTimerZero-*)-1
      0  358d					      db	oComma
      1  358d		       e2		      .byte.b	oComma
      0  358e					      CALL	EXPR	; only used by set parameters
      0  358e					      db	28
      1  358e		       1c		      .byte.b	28
      0  358f					      dw	EXPR
      1  358f		       c0 34		      .word.w	EXPR
      0  3591					      iJMP	eKTimerOut	; get out
      0  3591					      db	29
      1  3591		       1d		      .byte.b	29
      0  3592					      dw	eKTimerOut
      1  3592		       97 35		      .word.w	eKTimerOut
    800  3594				   eKTimerZero
      0  3594					      lit	0	; no second parameter
      0  3594					      db	27
      1  3594		       1b		      .byte.b	27
      0  3595					      dw	0
      1  3595		       00 00		      .word.w	0
    802  3597				   eKTimerOut
      0  3597					      TSTB	UNKNOWNVEC,oRightBracket	; closing bracket
      0  3597					      db	101
      1  3597		       65		      .byte.b	101
      0  3598					      db	(UNKNOWNVEC-*)-1
      1  3598		       a6		      .byte.b	(UNKNOWNVEC-*)-1
      0  3599					      db	oRightBracket
      1  3599		       e1		      .byte.b	oRightBracket
      0  359a					      Timer
      0  359a					      db	114
      1  359a		       72		      .byte.b	114
      0  359b					      RTN
      0  359b					      db	25
      1  359b		       19		      .byte.b	25
    806  359c
    807  359c							;====================================================================================
    808  359c							; peek(mem address) return the value of a byte in memory
    809  359c							; @[offset] return a word value from offset -- see tstv
    810  359c							;
    811  359c							;F1A2:
    812  359c							;	  TSTB	      F2AZ,kPeek		      ;Return a value from memory
    813  359c				   ekPeek
      0  359c					      TSTB	UNKNOWNVEC,oLeftBracket
      0  359c					      db	101
      1  359c		       65		      .byte.b	101
      0  359d					      db	(UNKNOWNVEC-*)-1
      1  359d		       a1		      .byte.b	(UNKNOWNVEC-*)-1
      0  359e					      db	oLeftBracket
      1  359e		       e0		      .byte.b	oLeftBracket
      0  359f					      CALL	EXPR	;Get the address to write to
      0  359f					      db	28
      1  359f		       1c		      .byte.b	28
      0  35a0					      dw	EXPR
      1  35a0		       c0 34		      .word.w	EXPR
      0  35a2					      TSTB	UNKNOWNVEC,oRightBracket
      0  35a2					      db	101
      1  35a2		       65		      .byte.b	101
      0  35a3					      db	(UNKNOWNVEC-*)-1
      1  35a3		       9b		      .byte.b	(UNKNOWNVEC-*)-1
      0  35a4					      db	oRightBracket
      1  35a4		       e1		      .byte.b	oRightBracket
      0  35a5					      PEEKMEM
      0  35a5					      db	48
      1  35a5		       30		      .byte.b	48
      0  35a6					      RTN
      0  35a6					      db	25
      1  35a6		       19		      .byte.b	25
    819  35a7							;=======================================================================================
    820  35a7							; TASK(line-num expr,[Parm1,....]) start a task with or without Parameters
    821  35a7							;
    822  35a7							;F2AZ:
    823  35a7							;	  TSTB	      F2AZ1,kTask		      ;Check if we are setting a task start
    824  35a7				   ekTask
      0  35a7					      TSTBRANCH	ekTaskCompiled
      0  35a7					      db	106
      1  35a7		       6a		      .byte.b	106
      0  35a8					      db	(ekTaskCompiled-*)-1
      1  35a8		       0c		      .byte.b	(ekTaskCompiled-*)-1
      0  35a9					      TSTB	UNKNOWNVEC,oLeftBracket
      0  35a9					      db	101
      1  35a9		       65		      .byte.b	101
      0  35aa					      db	(UNKNOWNVEC-*)-1
      1  35aa		       94		      .byte.b	(UNKNOWNVEC-*)-1
      0  35ab					      db	oLeftBracket
      1  35ab		       e0		      .byte.b	oLeftBracket
      0  35ac					      CALL	EXPR	;Get the LABEL .. line NUMBER
      0  35ac					      db	28
      1  35ac		       1c		      .byte.b	28
      0  35ad					      dw	EXPR
      1  35ad		       c0 34		      .word.w	EXPR
      0  35af					      lit	0
      0  35af					      db	27
      1  35af		       1b		      .byte.b	27
      0  35b0					      dw	0
      1  35b0		       00 00		      .word.w	0
      0  35b2					      iJMP	ekTaskLinenum
      0  35b2					      db	29
      1  35b2		       1d		      .byte.b	29
      0  35b3					      dw	ekTaskLinenum
      1  35b3		       b8 35		      .word.w	ekTaskLinenum
    830  35b5
    831  35b5				   ekTaskCompiled
      0  35b5					      lit	1
      0  35b5					      db	27
      1  35b5		       1b		      .byte.b	27
      0  35b6					      dw	1
      1  35b6		       01 00		      .word.w	1
    833  35b8
    834  35b8				   ekTaskLinenum
      0  35b8					      TASKCREATE		;Allocate the task and initialize it, Suspended
      0  35b8					      db	61
      1  35b8		       3d		      .byte.b	61
      0  35b9					      TSTB	F2AZNoParms,oComma	;Parameters to be passed to task
      0  35b9					      db	101
      1  35b9		       65		      .byte.b	101
      0  35ba					      db	(F2AZNoParms-*)-1
      1  35ba		       0e		      .byte.b	(F2AZNoParms-*)-1
      0  35bb					      db	oComma
      1  35bb		       e2		      .byte.b	oComma
      0  35bc					      SAVEMATHSTACK		;Push The mathstack
      0  35bc					      db	86
      1  35bc		       56		      .byte.b	86
      0  35bd					      TASKGETMATHSTACK		;Make the New Task Stack The current stack
      0  35bd					      db	89
      1  35bd		       59		      .byte.b	89
    839  35be
    840  35be				   F2AZLOOP
      0  35be					      CALL	EXPR
      0  35be					      db	28
      1  35be		       1c		      .byte.b	28
      0  35bf					      dw	EXPR
      1  35bf		       c0 34		      .word.w	EXPR
      0  35c1					      TSTB	F2AZEndParm,oComma	;Parameters to be passed tp task
      0  35c1					      db	101
      1  35c1		       65		      .byte.b	101
      0  35c2					      db	(F2AZEndParm-*)-1
      1  35c2		       04		      .byte.b	(F2AZEndParm-*)-1
      0  35c3					      db	oComma
      1  35c3		       e2		      .byte.b	oComma
      0  35c4					      IJMP	F2AZLOOP	;check for more
      0  35c4					      db	29
      1  35c4		       1d		      .byte.b	29
      0  35c5					      dw	F2AZLOOP
      1  35c5		       be 35		      .word.w	F2AZLOOP
    844  35c7
    845  35c7				   F2AZEndParm
      0  35c7					      RESTOREMATHSTACK		;Back to normal stack
      0  35c7					      db	87
      1  35c7		       57		      .byte.b	87
      0  35c8					      TASKPUTMATHPTR		;Update the tasks stack pointer with parameter count
      0  35c8					      db	92
      1  35c8		       5c		      .byte.b	92
    848  35c9
    849  35c9				   F2AZNoParms
      0  35c9					      TSTB	UNKNOWNVEC,oRightBracket	;must be )
      0  35c9					      db	101
      1  35c9		       65		      .byte.b	101
      0  35ca					      db	(UNKNOWNVEC-*)-1
      1  35ca		       74		      .byte.b	(UNKNOWNVEC-*)-1
      0  35cb					      db	oRightBracket
      1  35cb		       e1		      .byte.b	oRightBracket
    851  35cc
      0  35cc					      TASKENABLE		;Enable the task to execute
      0  35cc					      db	90
      1  35cc		       5a		      .byte.b	90
    853  35cd
      0  35cd					      RTN		;Returns the Task number
      0  35cd					      db	25
      1  35cd		       19		      .byte.b	25
    855  35ce							;=========================================================================================
    856  35ce							; Check for IPC interproccess instructions
    857  35ce							;   IPCS  - Send a message
    858  35ce							;
    859  35ce							;F2AZ1:
    860  35ce							;	  TSTB	      F2AZa,kIpcs		      ;Test if one of the IPC functions
    861  35ce				   ekIpcs
      0  35ce					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  35ce					      db	101
      1  35ce		       65		      .byte.b	101
      0  35cf					      db	(UNKNOWNVEC-*)-1
      1  35cf		       6f		      .byte.b	(UNKNOWNVEC-*)-1
      0  35d0					      db	oLeftBracket
      1  35d0		       e0		      .byte.b	oLeftBracket
      0  35d1					      CALL	EXPR	;Get the message value
      0  35d1					      db	28
      1  35d1		       1c		      .byte.b	28
      0  35d2					      dw	EXPR
      1  35d2		       c0 34		      .word.w	EXPR
      0  35d4					      TSTB	UNKNOWNVEC,oComma
      0  35d4					      db	101
      1  35d4		       65		      .byte.b	101
      0  35d5					      db	(UNKNOWNVEC-*)-1
      1  35d5		       69		      .byte.b	(UNKNOWNVEC-*)-1
      0  35d6					      db	oComma
      1  35d6		       e2		      .byte.b	oComma
      0  35d7					      CALL	EXPR	;Get pid of task to send to
      0  35d7					      db	28
      1  35d7		       1c		      .byte.b	28
      0  35d8					      dw	EXPR
      1  35d8		       c0 34		      .word.w	EXPR
      0  35da					      TSTB	UNKNOWNVEC,oRightBracket
      0  35da					      db	101
      1  35da		       65		      .byte.b	101
      0  35db					      db	(UNKNOWNVEC-*)-1
      1  35db		       63		      .byte.b	(UNKNOWNVEC-*)-1
      0  35dc					      db	oRightBracket
      1  35dc		       e1		      .byte.b	oRightBracket
      0  35dd					      IPCSEND		;Send msg and clear pid msg pending
      0  35dd					      db	80
      1  35dd		       50		      .byte.b	80
      0  35de					      RTN
      0  35de					      db	25
      1  35de		       19		      .byte.b	25
    869  35df							;================================================================================
    870  35df							; IPCR() --- recieve a message, IPCR(VARIABLE) -- receive msg and return pid in var
    871  35df							;
    872  35df				   ekIpcr
      0  35df					      TSTB	UNKNOWNVEC,oLeftBracket	;IPCS - send a message
      0  35df					      db	101
      1  35df		       65		      .byte.b	101
      0  35e0					      db	(UNKNOWNVEC-*)-1
      1  35e0		       5e		      .byte.b	(UNKNOWNVEC-*)-1
      0  35e1					      db	oLeftBracket
      1  35e1		       e0		      .byte.b	oLeftBracket
      0  35e2					      TSTB	F2AZa1,oRightBracket
      0  35e2					      db	101
      1  35e2		       65		      .byte.b	101
      0  35e3					      db	(F2AZa1-*)-1
      1  35e3		       07		      .byte.b	(F2AZa1-*)-1
      0  35e4					      db	oRightBracket
      1  35e4		       e1		      .byte.b	oRightBracket
      0  35e5					      LIT	0	;We dont want the pid returned to us
      0  35e5					      db	27
      1  35e5		       1b		      .byte.b	27
      0  35e6					      dw	0
      1  35e6		       00 00		      .word.w	0
      0  35e8					      IJMP	ekIpcrComplete
      0  35e8					      db	29
      1  35e8		       1d		      .byte.b	29
      0  35e9					      dw	ekIpcrComplete
      1  35e9		       f0 35		      .word.w	ekIpcrComplete
    877  35eb				   F2AZa1
      0  35eb					      TSTV	UNKNOWNVEC	;must be a variable to return pid of message to
      0  35eb					      db	33
      1  35eb		       21		      .byte.b	33
      0  35ec					      db	(UNKNOWNVEC-*)-1
      1  35ec		       52		      .byte.b	(UNKNOWNVEC-*)-1
      0  35ed					      TSTB	UNKNOWNVEC,oRightBracket
      0  35ed					      db	101
      1  35ed		       65		      .byte.b	101
      0  35ee					      db	(UNKNOWNVEC-*)-1
      1  35ee		       50		      .byte.b	(UNKNOWNVEC-*)-1
      0  35ef					      db	oRightBracket
      1  35ef		       e1		      .byte.b	oRightBracket
    880  35f0
    881  35f0				   ekIpcrComplete
      0  35f0					      IPCIO		;Set the io bit and exit task till message
      0  35f0					      db	83
      1  35f0		       53		      .byte.b	83
      0  35f1					      IPCRECEIVE		;Get the message
      0  35f1					      db	81
      1  35f1		       51		      .byte.b	81
      0  35f2					      RTN
      0  35f2					      db	25
      1  35f2		       19		      .byte.b	25
    885  35f3							;===============================================================================
    886  35f3							; IPCC ---- check if a message is available
    887  35f3				   ekIpcc
      0  35f3					      TSTB	UNKNOWNVEC,oLeftBracket
      0  35f3					      db	101
      1  35f3		       65		      .byte.b	101
      0  35f4					      db	(UNKNOWNVEC-*)-1
      1  35f4		       4a		      .byte.b	(UNKNOWNVEC-*)-1
      0  35f5					      db	oLeftBracket
      1  35f5		       e0		      .byte.b	oLeftBracket
      0  35f6					      TSTB	UNKNOWNVEC,oRightBracket
      0  35f6					      db	101
      1  35f6		       65		      .byte.b	101
      0  35f7					      db	(UNKNOWNVEC-*)-1
      1  35f7		       47		      .byte.b	(UNKNOWNVEC-*)-1
      0  35f8					      db	oRightBracket
      1  35f8		       e1		      .byte.b	oRightBracket
      0  35f9					      IPCCHECK
      0  35f9					      db	82
      1  35f9		       52		      .byte.b	82
      0  35fa					      RTN
      0  35fa					      db	25
      1  35fa		       19		      .byte.b	25
    892  35fb
    893  35fb				   UNKNOWNID
      0  35fb					      IJMP	UNKNOWN
      0  35fb					      db	29
      1  35fb		       1d		      .byte.b	29
      0  35fc					      dw	UNKNOWN
      1  35fc		       bc 34		      .word.w	UNKNOWN
    895  35fe							;============================================================
    896  35fe							; RND() is supposed to have an argument but if none
    897  35fe							; was provided, just assume a large value.
    898  35fe							;
    899  35fe				   ekRnd
      0  35fe					      TSTB	UNKNOWNVEC,oLeftBracket
      0  35fe					      db	101
      1  35fe		       65		      .byte.b	101
      0  35ff					      db	(UNKNOWNVEC-*)-1
      1  35ff		       3f		      .byte.b	(UNKNOWNVEC-*)-1
      0  3600					      db	oLeftBracket
      1  3600		       e0		      .byte.b	oLeftBracket
      0  3601					      TSTB	F2A1,oRightBracket
      0  3601					      db	101
      1  3601		       65		      .byte.b	101
      0  3602					      db	(F2A1-*)-1
      1  3602		       06		      .byte.b	(F2A1-*)-1
      0  3603					      db	oRightBracket
      1  3603		       e1		      .byte.b	oRightBracket
      0  3604					      LIT	32766
      0  3604					      db	27
      1  3604		       1b		      .byte.b	27
      0  3605					      dw	32766
      1  3605		       fe 7f		      .word.w	32766
      0  3607					      RANDOM
      0  3607					      db	37
      1  3607		       25		      .byte.b	37
      0  3608					      RTN
      0  3608					      db	25
      1  3608		       19		      .byte.b	25
    905  3609
    906  3609				   F2A1
      0  3609					      CALL	EXPR	;GET RANGE
      0  3609					      db	28
      1  3609		       1c		      .byte.b	28
      0  360a					      dw	EXPR
      1  360a		       c0 34		      .word.w	EXPR
      0  360c					      TSTB	UNKNOWNVEC,oRightBracket
      0  360c					      db	101
      1  360c		       65		      .byte.b	101
      0  360d					      db	(UNKNOWNVEC-*)-1
      1  360d		       31		      .byte.b	(UNKNOWNVEC-*)-1
      0  360e					      db	oRightBracket
      1  360e		       e1		      .byte.b	oRightBracket
      0  360f					      RANDOM
      0  360f					      db	37
      1  360f		       25		      .byte.b	37
      0  3610					      RTN
      0  3610					      db	25
      1  3610		       19		      .byte.b	25
    911  3611							;==========================================================
    912  3611							;	Return absolute value of expresion
    913  3611							;
    914  3611				   ekAbs
      0  3611					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3611					      db	101
      1  3611		       65		      .byte.b	101
      0  3612					      db	(UNKNOWNVEC-*)-1
      1  3612		       2c		      .byte.b	(UNKNOWNVEC-*)-1
      0  3613					      db	oLeftBracket
      1  3613		       e0		      .byte.b	oLeftBracket
      0  3614					      CALL	EXPR	;get value
      0  3614					      db	28
      1  3614		       1c		      .byte.b	28
      0  3615					      dw	EXPR
      1  3615		       c0 34		      .word.w	EXPR
      0  3617					      TSTB	UNKNOWNVEC,oRightBracket
      0  3617					      db	101
      1  3617		       65		      .byte.b	101
      0  3618					      db	(UNKNOWNVEC-*)-1
      1  3618		       26		      .byte.b	(UNKNOWNVEC-*)-1
      0  3619					      db	oRightBracket
      1  3619		       e1		      .byte.b	oRightBracket
      0  361a					      ABS
      0  361a					      db	38
      1  361a		       26		      .byte.b	38
      0  361b					      RTN
      0  361b					      db	25
      1  361b		       19		      .byte.b	25
    920  361c							;============================================================
    921  361c							;     Return the the status of a task, provide the PID
    922  361c							;
    923  361c				   ekStat
      0  361c					      TSTB	UNKNOWNVEC,oLeftBracket
      0  361c					      db	101
      1  361c		       65		      .byte.b	101
      0  361d					      db	(UNKNOWNVEC-*)-1
      1  361d		       21		      .byte.b	(UNKNOWNVEC-*)-1
      0  361e					      db	oLeftBracket
      1  361e		       e0		      .byte.b	oLeftBracket
      0  361f					      Call	EXPR
      0  361f					      db	28
      1  361f		       1c		      .byte.b	28
      0  3620					      dw	EXPR
      1  3620		       c0 34		      .word.w	EXPR
      0  3622					      TSTB	UNKNOWNVEC,oRightBracket
      0  3622					      db	101
      1  3622		       65		      .byte.b	101
      0  3623					      db	(UNKNOWNVEC-*)-1
      1  3623		       1b		      .byte.b	(UNKNOWNVEC-*)-1
      0  3624					      db	oRightBracket
      1  3624		       e1		      .byte.b	oRightBracket
      0  3625					      TASKSTAT
      0  3625					      db	66
      1  3625		       42		      .byte.b	66
      0  3626					      RTN
      0  3626					      db	25
      1  3626		       19		      .byte.b	25
    929  3627							;==============================================================
    930  3627							; Return the current tasks pid
    931  3627							;
    932  3627				   ekPid
      0  3627					      TASKPID
      0  3627					      db	77
      1  3627		       4d		      .byte.b	77
      0  3628					      RTN
      0  3628					      db	25
      1  3628		       19		      .byte.b	25
    935  3629							;===========================================================================
    936  3629							; Call a machine function, provide the address to call and optionally
    937  3629							; the value to be passed in reg A
    938  3629				   ekCall
      0  3629					      TSTB	UNKNOWNVEC,oLeftBracket
      0  3629					      db	101
      1  3629		       65		      .byte.b	101
      0  362a					      db	(UNKNOWNVEC-*)-1
      1  362a		       14		      .byte.b	(UNKNOWNVEC-*)-1
      0  362b					      db	oLeftBracket
      1  362b		       e0		      .byte.b	oLeftBracket
      0  362c					      CALL	EXPR
      0  362c					      db	28
      1  362c		       1c		      .byte.b	28
      0  362d					      dw	EXPR
      1  362d		       c0 34		      .word.w	EXPR
      0  362f					      TSTB	F2B2A,oComma
      0  362f					      db	101
      1  362f		       65		      .byte.b	101
      0  3630					      db	(F2B2A-*)-1
      1  3630		       09		      .byte.b	(F2B2A-*)-1
      0  3631					      db	oComma
      1  3631		       e2		      .byte.b	oComma
      0  3632					      CALL	EXPR
      0  3632					      db	28
      1  3632		       1c		      .byte.b	28
      0  3633					      dw	EXPR
      1  3633		       c0 34		      .word.w	EXPR
      0  3635					      TSTB	UNKNOWNVEC,oRightBracket
      0  3635					      db	101
      1  3635		       65		      .byte.b	101
      0  3636					      db	(UNKNOWNVEC-*)-1
      1  3636		       08		      .byte.b	(UNKNOWNVEC-*)-1
      0  3637					      db	oRightBracket
      1  3637		       e1		      .byte.b	oRightBracket
      0  3638					      CALLFUNC
      0  3638					      db	53
      1  3638		       35		      .byte.b	53
      0  3639					      RTN
      0  3639					      db	25
      1  3639		       19		      .byte.b	25
    946  363a							; Run the gosub within this function
    947  363a				   F2B2A
      0  363a					      TSTB	UNKNOWNID,oRightBracket
      0  363a					      db	101
      1  363a		       65		      .byte.b	101
      0  363b					      db	(UNKNOWNID-*)-1
      1  363b		       bf		      .byte.b	(UNKNOWNID-*)-1
      0  363c					      db	oRightBracket
      1  363c		       e1		      .byte.b	oRightBracket
      0  363d					      LIT	0	; No parameter passed so just load zero to A
      0  363d					      db	27
      1  363d		       1b		      .byte.b	27
      0  363e					      dw	0
      1  363e		       00 00		      .word.w	0
      0  3640					      CALLFUNC
      0  3640					      db	53
      1  3640		       35		      .byte.b	53
      0  3641					      RTN
      0  3641					      db	25
      1  3641		       19		      .byte.b	25
    952  3642
    953  3642							;=================================================================================
    954  3642							;Check for a number !
    955  3642							;
    956  3642				   FactNumber
      0  3642					      TSTN	FactVariable	;NUMBER, GET ITS VALUE.
      0  3642					      db	35
      1  3642		       23		      .byte.b	35
      0  3643					      db	(FactVariable-*)-1
      1  3643		       0f		      .byte.b	(FactVariable-*)-1
      0  3644					      RTN
      0  3644					      db	25
      1  3644		       19		      .byte.b	25
    959  3645
    960  3645				   FactWithBracket
      0  3645					      TSTB	F2RTN,oLeftBracket	;PARENTHESIZED EXPR.
      0  3645					      db	101
      1  3645		       65		      .byte.b	101
      0  3646					      db	(F2RTN-*)-1
      1  3646		       08		      .byte.b	(F2RTN-*)-1
      0  3647					      db	oLeftBracket
      1  3647		       e0		      .byte.b	oLeftBracket
      0  3648					      CALL	EXPR
      0  3648					      db	28
      1  3648		       1c		      .byte.b	28
      0  3649					      dw	EXPR
      1  3649		       c0 34		      .word.w	EXPR
      0  364b					      TST	F2,oRightBracket
      0  364b					      db	32
      1  364b		       20		      .byte.b	32
      0  364c					      db	(F2-*)-1
      1  364c		       03		      .byte.b	(F2-*)-1
      0  364d					      db	oRightBracket,0
      1  364d		       e1 00		      .byte.b	oRightBracket,0
    964  364f				   F2RTN
      0  364f					      RTN
      0  364f					      db	25
      1  364f		       19		      .byte.b	25
    966  3650
    967  3650				   F2
      0  3650					      ERRMSG	ERR_SYNTAX	;ERROR.
      0  3650					      db	13
      1  3650		       0d		      .byte.b	13
      0  3651					      dw	ERR_SYNTAX
      1  3651		       05 00		      .word.w	ERR_SYNTAX
    969  3653							;
    970  3653							;=============================================================================
    971  3653							; See if this is just a simple variable
    972  3653							;  Allow a subscript for any variable
    973  3653							;
    974  3653				   FactVariable
    975  3653
      0  3653					      SETR2	tInteger
      0  3653					      db	94
      1  3653		       5e		      .byte.b	94
      0  3654					      db	tInteger
      1  3654		       a4		      .byte.b	tInteger
      0  3655					      TSTV	FactWithBracket
      0  3655					      db	33
      1  3655		       21		      .byte.b	33
      0  3656					      db	(FactWithBracket-*)-1
      1  3656		       ee		      .byte.b	(FactWithBracket-*)-1
      0  3657					      TSTBYTE	FactFNParm,R2,GOSUB_RTN_VALUE
      0  3657					      db	97
      1  3657		       61		      .byte.b	97
      0  3658					      db	(FactFNParm-*)-1
      1  3658		       08		      .byte.b	(FactFNParm-*)-1
      0  3659					      dw	R2
      1  3659		       58 00		      .word.w	R2
      0  365b					      db	GOSUB_RTN_VALUE
      1  365b		       81		      .byte.b	GOSUB_RTN_VALUE
      0  365c					      CALL	FactVarPTR
      0  365c					      db	28
      1  365c		       1c		      .byte.b	28
      0  365d					      dw	FactVarPTR
      1  365d		       70 36		      .word.w	FactVarPTR
    980  365f							;	  CALL	      FactVariableValue
      0  365f					      IND		; get the variable value
      0  365f					      db	20
      1  365f		       14		      .byte.b	20
      0  3660					      RTN
      0  3660					      db	25
      1  3660		       19		      .byte.b	25
    983  3661
    984  3661				   FactFNParm
      0  3661					      TSTB	FactExpectedOpeningBracket,oLeftSQBracket
      0  3661					      db	101
      1  3661		       65		      .byte.b	101
      0  3662					      db	(FactExpectedOpeningBracket-*)-1
      1  3662		       44		      .byte.b	(FactExpectedOpeningBracket-*)-1
      0  3663					      db	oLeftSQBracket
      1  3663		       e4		      .byte.b	oLeftSQBracket
      0  3664					      CALL	EXPR
      0  3664					      db	28
      1  3664		       1c		      .byte.b	28
      0  3665					      dw	EXPR
      1  3665		       c0 34		      .word.w	EXPR
      0  3667					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  3667					      db	101
      1  3667		       65		      .byte.b	101
      0  3668					      db	(FactMissingRightBracket-*)-1
      1  3668		       3b		      .byte.b	(FactMissingRightBracket-*)-1
      0  3669					      db	oRightSQBracket
      1  3669		       e5		      .byte.b	oRightSQBracket
      0  366a					      SUBSCRIPT	GOSUB_RTN_VALUE
      0  366a					      db	64
      1  366a		       40		      .byte.b	64
      0  366b					      db	GOSUB_RTN_VALUE
      1  366b		       81		      .byte.b	GOSUB_RTN_VALUE
      0  366c					      SETR2	tInteger
      0  366c					      db	94
      1  366c		       5e		      .byte.b	94
      0  366d					      db	tInteger
      1  366d		       a4		      .byte.b	tInteger
      0  366e					      IND
      0  366e					      db	20
      1  366e		       14		      .byte.b	20
      0  366f					      RTN
      0  366f					      db	25
      1  366f		       19		      .byte.b	25
    992  3670
    993  3670				   FactVarPTR
    994  3670				   FactVarPtrNoTst
      0  3670					      TSTB	F2CLocalTask,oBang
      0  3670					      db	101
      1  3670		       65		      .byte.b	101
      0  3671					      db	(F2CLocalTask-*)-1
      1  3671		       04		      .byte.b	(F2CLocalTask-*)-1
      0  3672					      db	oBang
      1  3672		       e8		      .byte.b	oBang
      0  3673					      IND		; we just got a pid
      0  3673					      db	20
      1  3673		       14		      .byte.b	20
      0  3674					      TSTVT	UNKNOWNID	; if it is not another variable then error, Call test var. task
      0  3674					      db	93
      1  3674		       5d		      .byte.b	93
      0  3675					      db	(UNKNOWNID-*)-1
      1  3675		       85		      .byte.b	(UNKNOWNID-*)-1
    998  3676
    999  3676				   F2CLocalTask
      0  3676					      SETR2	tInteger	; Sets the default type to integer
      0  3676					      db	94
      1  3676		       5e		      .byte.b	94
      0  3677					      db	tInteger
      1  3677		       a4		      .byte.b	tInteger
      0  3678					      TSTB	F2INTEGER,oDollar	; Check if this will be a byte array @$[index] or a..z$[index] use a byte array
      0  3678					      db	101
      1  3678		       65		      .byte.b	101
      0  3679					      db	(F2INTEGER-*)-1
      1  3679		       11		      .byte.b	(F2INTEGER-*)-1
      0  367a					      db	oDollar
      1  367a		       e7		      .byte.b	oDollar
      0  367b					      SETR2	tByte
      0  367b					      db	94
      1  367b		       5e		      .byte.b	94
      0  367c					      db	tByte
      1  367c		       a2		      .byte.b	tByte
      0  367d					      TSTB	F2PTRLOADED,oLeftSQBracket
      0  367d					      db	101
      1  367d		       65		      .byte.b	101
      0  367e					      db	(F2PTRLOADED-*)-1
      1  367e		       22		      .byte.b	(F2PTRLOADED-*)-1
      0  367f					      db	oLeftSQBracket
      1  367f		       e4		      .byte.b	oLeftSQBracket
      0  3680					      CALL	EXPR
      0  3680					      db	28
      1  3680		       1c		      .byte.b	28
      0  3681					      dw	EXPR
      1  3681		       c0 34		      .word.w	EXPR
      0  3683					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  3683					      db	101
      1  3683		       65		      .byte.b	101
      0  3684					      db	(FactMissingRightBracket-*)-1
      1  3684		       1f		      .byte.b	(FactMissingRightBracket-*)-1
      0  3685					      db	oRightSQBracket
      1  3685		       e5		      .byte.b	oRightSQBracket
      0  3686					      SUBSCRIPT	tByte	; Byte type array
      0  3686					      db	64
      1  3686		       40		      .byte.b	64
      0  3687					      db	tByte
      1  3687		       a2		      .byte.b	tByte
      0  3688					      SETR2	tByte	; Set byte data type
      0  3688					      db	94
      1  3688		       5e		      .byte.b	94
      0  3689					      db	tByte
      1  3689		       a2		      .byte.b	tByte
      0  368a					      RTN
      0  368a					      db	25
      1  368a		       19		      .byte.b	25
   1009  368b
   1010  368b				   F2INTEGER
      0  368b					      TSTB	F2PTRLOADED,oLeftSQBracket
      0  368b					      db	101
      1  368b		       65		      .byte.b	101
      0  368c					      db	(F2PTRLOADED-*)-1
      1  368c		       14		      .byte.b	(F2PTRLOADED-*)-1
      0  368d					      db	oLeftSQBracket
      1  368d		       e4		      .byte.b	oLeftSQBracket
      0  368e					      CALL	EXPR
      0  368e					      db	28
      1  368e		       1c		      .byte.b	28
      0  368f					      dw	EXPR
      1  368f		       c0 34		      .word.w	EXPR
      0  3691					      TSTB	FactMissingRightBracket,oRightSQBracket
      0  3691					      db	101
      1  3691		       65		      .byte.b	101
      0  3692					      db	(FactMissingRightBracket-*)-1
      1  3692		       11		      .byte.b	(FactMissingRightBracket-*)-1
      0  3693					      db	oRightSQBracket
      1  3693		       e5		      .byte.b	oRightSQBracket
      0  3694					      SUBSCRIPT	tInteger	; Integer type array
      0  3694					      db	64
      1  3694		       40		      .byte.b	64
      0  3695					      db	tInteger
      1  3695		       a4		      .byte.b	tInteger
      0  3696					      SETR2	tInteger	; Set word datatype
      0  3696					      db	94
      1  3696		       5e		      .byte.b	94
      0  3697					      db	tInteger
      1  3697		       a4		      .byte.b	tInteger
      0  3698					      TSTB	F2PTRLOADED,oBang	; for a word it can be fillowed by a! as ref to other task variables
      0  3698					      db	101
      1  3698		       65		      .byte.b	101
      0  3699					      db	(F2PTRLOADED-*)-1
      1  3699		       07		      .byte.b	(F2PTRLOADED-*)-1
      0  369a					      db	oBang
      1  369a		       e8		      .byte.b	oBang
      0  369b					      IND		; Get the value of the task context to access
      0  369b					      db	20
      1  369b		       14		      .byte.b	20
      0  369c					      TSTVT	UNKNOWNID	; if it is not another variable name then it is a halt error
      0  369c					      db	93
      1  369c		       5d		      .byte.b	93
      0  369d					      db	(UNKNOWNID-*)-1
      1  369d		       5d		      .byte.b	(UNKNOWNID-*)-1
      0  369e					      IJMP	FactVarPTR	; Process the value on the other side
      0  369e					      db	29
      1  369e		       1d		      .byte.b	29
      0  369f					      dw	FactVarPTR
      1  369f		       70 36		      .word.w	FactVarPTR
   1020  36a1				   F2PTRLOADED
      0  36a1					      RTN
      0  36a1					      db	25
      1  36a1		       19		      .byte.b	25
   1022  36a2
   1023  36a2				   FactVariableValue
      0  36a2					      IND		; YES, GET THE VALUE as word
      0  36a2					      db	20
      1  36a2		       14		      .byte.b	20
      0  36a3					      RTN
      0  36a3					      db	25
      1  36a3		       19		      .byte.b	25
   1026  36a4
   1027  36a4				   FactMissingRightBracket
      0  36a4					      IJMP	ReturnExpectBracket
      0  36a4					      db	29
      1  36a4		       1d		      .byte.b	29
      0  36a5					      dw	ReturnExpectBracket
      1  36a5		       f5 36		      .word.w	ReturnExpectBracket
   1029  36a7				   FactExpectedOpeningBracket
      0  36a7					      ERRMSG	ERR_EXPECTED_OPENING_BRACKET
      0  36a7					      db	13
      1  36a7		       0d		      .byte.b	13
      0  36a8					      dw	ERR_EXPECTED_OPENING_BRACKET
      1  36a8		       1a 00		      .word.w	ERR_EXPECTED_OPENING_BRACKET
   1031  36aa							;===============================================================================================================================
   1032  36aa							;
   1033  36aa							;===============================================================================================================================
   1034  36aa							;while .. wend statement
   1035  36aa							;
   1036  36aa				   ekWhile
      0  36aa					      BeginBlock	kWhile,kWend	; push the info to stack as a while loop
      0  36aa					      db	117
      1  36aa		       75		      .byte.b	117
      0  36ab					      db	kWhile,kWend
      1  36ab		       24 25		      .byte.b	kWhile,kWend
   1038  36ad				   xWhileTest
      0  36ad					      CALL	EXPR	; test if condition is true
      0  36ad					      db	28
      1  36ad		       1c		      .byte.b	28
      0  36ae					      dw	EXPR
      1  36ae		       c0 34		      .word.w	EXPR
      0  36b0					      DONE		; should be nothing else on the line
      0  36b0					      db	1
      1  36b0		       01		      .byte.b	1
      0  36b1					      IFFALSE	xWhileCleanup	; if false goto end of block
      0  36b1					      db	119
      1  36b1		       77		      .byte.b	119
      0  36b2					      db	(xWhileCleanup-*)-1
      1  36b2		       0c		      .byte.b	(xWhileCleanup-*)-1
      0  36b3					      NXT	CO	; next line or exit
      0  36b3					      db	6
      1  36b3		       06		      .byte.b	6
      0  36b4					      dw	CO
      1  36b4		       a3 32		      .word.w	CO
      0  36b6					      IJMP	STMT	; do the next statement
      0  36b6					      db	29
      1  36b6		       1d		      .byte.b	29
      0  36b7					      dw	STMT
      1  36b7		       ab 32		      .word.w	STMT
   1044  36b9
      0  36b9				   ekWend     DONE		; should be only thing on the line
      0  36b9					      db	1
      1  36b9		       01		      .byte.b	1
      0  36ba					      JmpStart	kWhile	; always set user program PC to beginning of the block
      0  36ba					      db	116
      1  36ba		       74		      .byte.b	116
      0  36bb					      db	kWhile
      1  36bb		       24		      .byte.b	kWhile
      0  36bc					      IJMP	xWhileTest
      0  36bc					      db	29
      1  36bc		       1d		      .byte.b	29
      0  36bd					      dw	xWhileTest
      1  36bd		       ad 36		      .word.w	xWhileTest
   1048  36bf				   xWhileCleanup
      0  36bf					      JmpEnd	kWhile
      0  36bf					      db	115
      1  36bf		       73		      .byte.b	115
      0  36c0					      db	kWhile
      1  36c0		       24		      .byte.b	kWhile
      0  36c1					      NXT	CO
      0  36c1					      db	6
      1  36c1		       06		      .byte.b	6
      0  36c2					      dw	CO
      1  36c2		       a3 32		      .word.w	CO
      0  36c4					      IJMP	STMT	; next statement after the while block
      0  36c4					      db	29
      1  36c4		       1d		      .byte.b	29
      0  36c5					      dw	STMT
      1  36c5		       ab 32		      .word.w	STMT
   1052  36c7							;
   1053  36c7							;==========================for next step interface =============================================================================
   1054  36c7							;
   1055  36c7				   ekFor
   1056  36c7				   ekNext
   1057  36c7				   ekStep
   1058  36c7							;
   1059  36c7							;========================= Gosub and function interface ========================================================================
   1060  36c7							; Process gosub 1000(Parm1, ...) no return value
   1061  36c7							;
   1062  36c7				   ekGosub
      0  36c7					      CALL	GOSUBSTATEMENT	; Do the gosub
      0  36c7					      db	28
      1  36c7		       1c		      .byte.b	28
      0  36c8					      dw	GOSUBSTATEMENT
      1  36c8		       f9 36		      .word.w	GOSUBSTATEMENT
      0  36ca					      DONE		; ERROR IF CR NOT NEXT
      0  36ca					      db	1
      1  36ca		       01		      .byte.b	1
      0  36cb					      SAV	GOSUB_RTN	; SAVE RETURN LINE
      0  36cb					      db	8
      1  36cb		       08		      .byte.b	8
      0  36cc					      db	GOSUB_RTN
      1  36cc		       01		      .byte.b	GOSUB_RTN
      0  36cd					      FASTXFER		; AND JUMP to sub rtn
      0  36cd					      db	107
      1  36cd		       6b		      .byte.b	107
   1067  36ce							;
   1068  36ce							; End of gosub processing
   1069  36ce							;===========================================================================
   1070  36ce							; Same as gosub but expects a return value
   1071  36ce							;   FN 1000(parm1, ....)  Expects an integer to be returned
   1072  36ce							;
   1073  36ce				   ekGofn
      0  36ce					      Call	GOSUBSTATEMENT
      0  36ce					      db	28
      1  36ce		       1c		      .byte.b	28
      0  36cf					      dw	GOSUBSTATEMENT
      1  36cf		       f9 36		      .word.w	GOSUBSTATEMENT
      0  36d1					      SAV	GOSUB_RTN_VALUE	;SAVE RETURN LINE
      0  36d1					      db	8
      1  36d1		       08		      .byte.b	8
      0  36d2					      db	GOSUB_RTN_VALUE
      1  36d2		       81		      .byte.b	GOSUB_RTN_VALUE
      0  36d3					      FASTXFER
      0  36d3					      db	107
      1  36d3		       6b		      .byte.b	107
   1077  36d4
   1078  36d4				   GOFNRet
      0  36d4					      RTN
      0  36d4					      db	25
      1  36d4		       19		      .byte.b	25
   1080  36d5							;===============================================================================================================================
   1081  36d5							; Return from a gosub
   1082  36d5							;
   1083  36d5				   ekReturn
      0  36d5					      TSTB	S2NoReturnValue,oLeftBracket	; Check if we will return some value
      0  36d5					      db	101
      1  36d5		       65		      .byte.b	101
      0  36d6					      db	(S2NoReturnValue-*)-1
      1  36d6		       11		      .byte.b	(S2NoReturnValue-*)-1
      0  36d7					      db	oLeftBracket
      1  36d7		       e0		      .byte.b	oLeftBracket
      0  36d8					      CALL	EXPR
      0  36d8					      db	28
      1  36d8		       1c		      .byte.b	28
      0  36d9					      dw	EXPR
      1  36d9		       c0 34		      .word.w	EXPR
      0  36db					      TSTB	ReturnExpectBracket,oRightBracket	; Now a value is on the stack
      0  36db					      db	101
      1  36db		       65		      .byte.b	101
      0  36dc					      db	(ReturnExpectBracket-*)-1
      1  36dc		       18		      .byte.b	(ReturnExpectBracket-*)-1
      0  36dd					      db	oRightBracket
      1  36dd		       e1		      .byte.b	oRightBracket
      0  36de					      DONE
      0  36de					      db	1
      1  36de		       01		      .byte.b	1
      0  36df					      RSTR	S2RetFunc,1	; decides if call was a func or statement, branch on func, return value
      0  36df					      db	9
      1  36df		       09		      .byte.b	9
      0  36e0					      db	(S2RetFunc-*)-1
      1  36e0		       11		      .byte.b	(S2RetFunc-*)-1
      0  36e1					      db	1
      1  36e1		       01		      .byte.b	1
      0  36e2					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  36e2					      db	6
      1  36e2		       06		      .byte.b	6
      0  36e3					      dw	CO
      1  36e3		       a3 32		      .word.w	CO
      0  36e5					      IJMP	STMT	; Process the new statement
      0  36e5					      db	29
      1  36e5		       1d		      .byte.b	29
      0  36e6					      dw	STMT
      1  36e6		       ab 32		      .word.w	STMT
   1091  36e8
   1092  36e8				   S2NoReturnValue
      0  36e8					      DONE
      0  36e8					      db	1
      1  36e8		       01		      .byte.b	1
      0  36e9					      RSTR	S2RetFunc,0	; decides if call was a func or statement, branch on func, no return value
      0  36e9					      db	9
      1  36e9		       09		      .byte.b	9
      0  36ea					      db	(S2RetFunc-*)-1
      1  36ea		       07		      .byte.b	(S2RetFunc-*)-1
      0  36eb					      db	0
      1  36eb		       00		      .byte.b	0
      0  36ec					      NXT	CO	; SEQUENCE TO NEXT STATEMENT
      0  36ec					      db	6
      1  36ec		       06		      .byte.b	6
      0  36ed					      dw	CO
      1  36ed		       a3 32		      .word.w	CO
      0  36ef					      IJMP	STMT	; Process the new statement
      0  36ef					      db	29
      1  36ef		       1d		      .byte.b	29
      0  36f0					      dw	STMT
      1  36f0		       ab 32		      .word.w	STMT
   1097  36f2
   1098  36f2				   S2RetFunc
      0  36f2					      IJMP	GOFNRet	; Back into the Function
      0  36f2					      db	29
      1  36f2		       1d		      .byte.b	29
      0  36f3					      dw	GOFNRet
      1  36f3		       d4 36		      .word.w	GOFNRet
   1100  36f5
   1101  36f5				   ReturnExpectBracket
      0  36f5					      ENDIO
      0  36f5					      db	71
      1  36f5		       47		      .byte.b	71
      0  36f6					      ERRMSG	ERR_CLOSINGBRACKET
      0  36f6					      db	13
      1  36f6		       0d		      .byte.b	13
      0  36f7					      dw	ERR_CLOSINGBRACKET
      1  36f7		       17 00		      .word.w	ERR_CLOSINGBRACKET
   1104  36f9							;
   1105  36f9							; End of return from gosub
   1106  36f9							;=============================================================
   1107  36f9							; Gosub can be both a Function and a Subroutine
   1108  36f9				   GOSUBSTATEMENT
      0  36f9					      TSTBRANCH	GOSUBCOMPILED	; if the two bytes after gosub are not zero then direct transfer
      0  36f9					      db	106
      1  36f9		       6a		      .byte.b	106
      0  36fa					      db	(GOSUBCOMPILED-*)-1
      1  36fa		       0a		      .byte.b	(GOSUBCOMPILED-*)-1
      0  36fb					      CALL	EXPR	; GET DESTINATION
      0  36fb					      db	28
      1  36fb		       1c		      .byte.b	28
      0  36fc					      dw	EXPR
      1  36fc		       c0 34		      .word.w	EXPR
      0  36fe					      CALL	GOSUBCONT
      0  36fe					      db	28
      1  36fe		       1c		      .byte.b	28
      0  36ff					      dw	GOSUBCONT
      1  36ff		       0c 37		      .word.w	GOSUBCONT
      0  3701					      lit	0	; mark as lookup on stack
      0  3701					      db	27
      1  3701		       1b		      .byte.b	27
      0  3702					      dw	0
      1  3702		       00 00		      .word.w	0
      0  3704					      RTN
      0  3704					      db	25
      1  3704		       19		      .byte.b	25
   1114  3705
   1115  3705				   GOSUBCOMPILED
      0  3705					      CALL	GOSUBCONT
      0  3705					      db	28
      1  3705		       1c		      .byte.b	28
      0  3706					      dw	GOSUBCONT
      1  3706		       0c 37		      .word.w	GOSUBCONT
      0  3708					      lit	1	;mark as compiled on stack
      0  3708					      db	27
      1  3708		       1b		      .byte.b	27
      0  3709					      dw	1
      1  3709		       01 00		      .word.w	1
      0  370b					      RTN
      0  370b					      db	25
      1  370b		       19		      .byte.b	25
   1119  370c
   1120  370c				   GOSUBCONT
      0  370c					      TSTB	GOSUBDONE,oLeftBracket	;Check if any Parameters If not bracket get out
      0  370c					      db	101
      1  370c		       65		      .byte.b	101
      0  370d					      db	(GOSUBDONE-*)-1
      1  370d		       11		      .byte.b	(GOSUBDONE-*)-1
      0  370e					      db	oLeftBracket
      1  370e		       e0		      .byte.b	oLeftBracket
      0  370f					      STK2TMP		;Transfer stack top to temp, temp gets line to goto
      0  370f					      db	95
      1  370f		       5f		      .byte.b	95
      0  3710					      PUSHMATHSTACK		;Record stack frame for return
      0  3710					      db	84
      1  3710		       54		      .byte.b	84
   1124  3711				   GOSUBLOOP
      0  3711					      CALL	EXPR	; Allows what ever fits onto stack
      0  3711					      db	28
      1  3711		       1c		      .byte.b	28
      0  3712					      dw	EXPR
      1  3712		       c0 34		      .word.w	EXPR
      0  3714					      INCPARMCOUNT
      0  3714					      db	88
      1  3714		       58		      .byte.b	88
      0  3715					      TSTB	GOSUBParmDONE,oComma
      0  3715					      db	101
      1  3715		       65		      .byte.b	101
      0  3716					      db	(GOSUBParmDONE-*)-1
      1  3716		       04		      .byte.b	(GOSUBParmDONE-*)-1
      0  3717					      db	oComma
      1  3717		       e2		      .byte.b	oComma
      0  3718					      IJMP	GOSUBLOOP
      0  3718					      db	29
      1  3718		       1d		      .byte.b	29
      0  3719					      dw	GOSUBLOOP
      1  3719		       11 37		      .word.w	GOSUBLOOP
   1129  371b				   GOSUBParmDONE
      0  371b					      TSTB	ReturnExpectBracket,oRightBracket
      0  371b					      db	101
      1  371b		       65		      .byte.b	101
      0  371c					      db	(ReturnExpectBracket-*)-1
      1  371c		       d8		      .byte.b	(ReturnExpectBracket-*)-1
      0  371d					      db	oRightBracket
      1  371d		       e1		      .byte.b	oRightBracket
      0  371e					      TMP2STK		; Restore line to goto
      0  371e					      db	96
      1  371e		       60		      .byte.b	96
   1132  371f				   GOSUBDONE
      0  371f					      RTN
      0  371f					      db	25
      1  371f		       19		      .byte.b	25
   1134  3720
   1135  3720		       37 20	   ILEND      equ	*
------- FILE mytb.asm
   2487  3720		       37 20	   PROGEND    equ	*
   2488  3720
   2489  3720							;=====================================================
   2490  3720							; Define start of non page zero data
   2491 U3773					      seg.u	TBData
   2492 U3773
   2493 U3773							;=====================================================
   2494 U3773							; These are storage items not in page zero.
   2495 U3773							;==================================================================================================
   2496 U3773							; Task Management information
   2497 U3773							; Tasks may be created by the Task <expr>,<expr>,[<expr>]   Slot number, Cycles per switch command
   2498 U3773							; Tasks are ended by the Endtask command   This with clear the entry from the task table
   2499 U3773							; Task switchs happen at the beginning of the next Basic command line
   2500 U3773							; It will not happen during an input or output operations
   2501 U3773							; Task switches otherwise are prememtive, The cycle count defaults to 100.
   2502 U3773							; Task Zero is always the root task, main line program
   2503 U3773							;
   2504 U3773							; Layout is repeated for each configured task
   2505 U3773							; Task Table Byte   use masks follow
   2506 U3773		       00 00	   TASKINACTIVE equ	%00000000	; Task is inactive
   2507 U3773		       00 80	   TASKACTIVE equ	%10000000	; Active task
   2508 U3773		       00 40	   TASKWAITIO equ	%01000000	; Task is waiting for io
   2509 U3773		       00 01	   TASKWAITIPC equ	%00000001	; Task is waiting for message
   2510 U3773		       00 02	   TASKRUNPENDING equ	%00000010	; Task Is initialized but suspended
   2511 U3773
   2512 U3773		       00	   taskPtr    ds	1	; Current offset into task table CONTEXTLEN modulo entry
   2513 U3774		       00 00 00 00*taskTable  ds	[TASKCOUNT * CONTEXTLEN]	; Task Table Offset and pointer to Basic code, active flag
   2514 U3774		       38 6e	   TASKTABLEEND equ	*	; End of task table
   2515 U3774		       00 fa	   TASKTABLELEN equ	[TASKTABLEEND-taskTable]	; actual length of the task table
   2516 U386e
   2517 U386e							;Task Cycle Counter and reset count
   2518 U386e		       00 00	   taskCurrentCycles ds	2
   2519 U3870		       00 00	   taskResetValue ds	2
   2520 U3872		       00	   taskCounter ds	1	; Count of active tasks
   2521 U3873
   2522 U3873							;
   2523 U3873							; Math stack and IL call and Gosub/For-next return stack definitions
   2524 U3873							;
   2525 U3873		       38 73	   STACKSTART equ	*
   2526 U3873		       00 00 00 00*mathStack  ds	[MATHSTACKSIZE * 2 * TASKCOUNT]	; Stack used for math expressions
   2527 U3a03		       00 00 00 00*ilStack    ds	[ILSTACKSIZE * 2 * TASKCOUNT]	; stack used by the IL for calls and returns
   2528 U3deb		       00 00 00 00*gosubStack ds	[GOSUBSTACKSIZE * 4 * TASKCOUNT]	; stack size for gosub stacks
   2529 U406b		       00 00 00 00*variableStack ds	[VARIABLESSIZE * 2 * TASKCOUNT]	; Stack of variables, 26 A-Z-task exit code,taskio block
   2530 U434f							;									  stdin,stdout,stdstat,iostatus
   2531 U434f		       00 48	   TASKEXITCODE equ	[[VARIABLESSIZE * 2] - 2]	; Offset to exit code location
   2532 U434f		       43 4f	   STACKEND   equ	*
   2533 U434f		       0a dc	   STACKLEN   equ	STACKEND-STACKSTART	; total space used for stacks
   2534 U434f							;
   2535 U434f							;
   2536 U434f		       00 00 00 00*LINBUF     ds	BUFFER_SIZE
   2537 U43d3		       00	   getlinx    ds	1	;temp for x during GetLine functions
   2538 U43d4		       00	   printtx    ds	1	;temp X for print funcs
   2539 U43d5		       00	   inputNoWait ds	1	;Wait no wait for line buff input
   2540 U43d6		       00	   promptChar ds	1	;the character to use for a prompt
   2541 U43d7		       00	   diddigit   ds	1	;for leading zero suppression
   2542 U43d8		       00	   putsy      ds	1
   2543 U43d9		       00 00	   errGoto    ds	2	;where to set ILPC on err
   2544 U43db		       00	   sign       ds	1	;0 = positive, else negative
   2545 U43dc		       00 00	   rtemp1     ds	2	;Temp for x and y
   2546 U43de		       00 00	   random     ds	2
   2547 U43e0		       00	   tempy      ds	1	;temp y storage
   2548 U43e1
   2549 U43e1							; Moved from page zero as one clock cycle diff gives more space on page zero
   2550 U43e1		       00 00	   tempIL     ds	2	;Temp IL programcounter storage
   2551 U43e3		       00	   tempIlY    ds	1	;Temp IL Y register storage
   2552 U43e4		       00	   offset     ds	1	;IL Offset to next inst when test fails
   2553 U43e5		       00	   lineLength ds	1	;Length of current line
   2554 U43e6
   2555 U43e6		       00	   taskIOPending ds	1	; 1 = pending Set when a task wants to read keyboard/ write to screen
   2556 U43e7		       00	   taskRDPending ds	1	; 1 = background read is pending
   2557 U43e8		       00 00 00 00 timercounter ds	4	; if timer is running then this is continuously incremented
   2558 U43ec
   2559 U43ec				  -	      if	XKIM
   2560 U43ec				  -buffer     ds	BUFFER_SIZE
   2561 U43ec					      endif
   2562 U43ec							;
   2563 U43ec							; PROGRAMEND is the end of the user's BASIC program.
   2564 U43ec							; More precisely, it is one byte past the end.  Or,
   2565 U43ec							; it's where the next line added to the end will be
   2566 U43ec							; placed.
   2567 U43ec							;
   2568 U43ec		       00 00	   ProgramStart ds	2	; Start Of usable memory
   2569 U43ee		       00 00	   ProgramEnd ds	2	; End of users basic program, Next free byte after end
   2570 U43f0		       00 00	   HighMem    ds	2	; highest location
   2571 U43f2		       00 00	   UsedMem    ds	2	; size of user program
   2572 U43f4		       00 00	   FreeMem    ds	2	; amount of free memory
   2573 U43f6							;
   2574 U43f6							;=====================================================
   2575 U43f6							; This is the start of the user's BASIC program space.
   2576 U43f6							;
   2577 U43f6							; PERSONAL GOAL: This should be no larger than $0DFF. *JustLostInTim abandoned, just for fun
   2578 U43f6							;		  0200-05FF = 1K
   2579 U43f6							;		  0200-09FF = 2K
   2580 U43f6							;		  0200-0DFF = 3K
   2581 U43f6							;		  0200-11FF = 4K
   2582 U43f6							;		  0200-13FF = 4.5K
   2583 U43f6							;
   2584 U43f6				  -	      if	FIXED
   2585 U43f6				  -	      org	$2000
   2586 U43f6					      endif
   2587 U43f6
   2588 U43f6		       43 f6	   FreeMemStart equ	*
   2589 U43f6							;/*
   2590 U43f6							;  if	  CTMON65 || XKIM
   2591 U43f6							;	  SEG Code
   2592 U43f6							;	  org	  AutoRun
   2593 U43f6							;	  dw	  TBasicCold
   2594 U43f6							;  endif
   2595 U43f6							;*/
   2596 U43f6					      end
