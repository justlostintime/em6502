------- FILE ctmon65.asm LEVEL 1 PASS 2
      1  10000					       Processor	6502
      2 U00f6 ????				      seg.U	ZEROPAGE
      3 U0000					      org	$0000
      4 U0000							;*********************************************************
      5 U0000							; CTMON65
      6 U0000							;
      7 U0000							; This is the monitor for the Corsham Techologies, LLC
      8 U0000							; SS-50 65C02 board.  It's a fairly generic monitor that
      9 U0000							; can be ported to other 6502 based systems.
     10 U0000							;
     11 U0000							; Written mostly while on a family vacation in 2018, but
     12 U0000							; ideas and code were taken from other Corsham Tech
     13 U0000							; projects and various web pages (credit given in the
     14 U0000							; code).
     15 U0000							;
     16 U0000							; Bob Applegate
     17 U0000							; bob@corshamtech.com
     18 U0000							; www.corshamtech.com
     19 U0000					      mac	db
     20 U0000					      .byte	{0}
     21 U0000					      endm
     22 U0000					      Mac	dw
     23 U0000					      .word	{0}
     24 U0000					      endm
     25 U0000
     26 U0000							;*********************************************************
     27 U0000							;
------- FILE config.inc LEVEL 2 PASS 2
      0 U0000					      include	"config.inc"
      1 U0000					      Processor	6502
      2 U0000							;*********************************************************
      3 U0000							; FILE: config.inc
      4 U0000							;
      5 U0000							; General configuration file
      6 U0000							;*********************************************************
      7 U0000							;
      8 U0000		       00 00	   FALSE      equ	0
      9 U0000		       00 01	   TRUE       equ	!FALSE
     10 U0000							;
     11 U0000							; SS-50 bus constants
     12 U0000							;
     13 U0000		       e0 00	   IO_BASE    equ	$E000
     14 U0000		       00 10	   IO_SIZE    equ	16
     15 U0000							;
     16 U0000							; Memory usage
     17 U0000							;
     18 U0000		       00 f0	   ZERO_PAGE_START equ	$00f0
     19 U0000		       f0 00	   ROM_START  equ	$f000
     20 U0000		       df 00	   RAM_START  equ	$df00
     21 U0000							;
     22 U0000							; If enabled, turn on buffered input code.
     23 U0000							;
     24 U0000		       00 00	   BUFFERED_INPUT equ	FALSE
     25 U0000							;
     26 U0000		       00 05	   MAX_ARGC   equ	5
     27 U0000							;
     28 U0000							; If enabled, the debugger will display the flag register
     29 U0000							; in ASCII.  Nice, but takes more code.
     30 U0000							;
     31 U0000		       00 01	   FULL_STATUS equ	TRUE
     32 U0000							;
     33 U0000							; Enable EXTENDED_CMDS to allow linking external commands
     34 U0000							; to the command handler.
     35 U0000							;
     36 U0000		       00 00	   EXTENDED_CMDS equ	FALSE
     37 U0000							;
     38 U0000							; Define to enable SD related functions
     39 U0000							;
     40 U0000		       00 01	   SD_ENABLED equ	TRUE
     41 U0000							;
     42 U0000							; Size of the keyboard buffer
     43 U0000							;
     44 U0000		       00 84	   BUFFER_SIZE equ	132
     45 U0000
------- FILE ctmon65.asm
     29 U0000							;
     30 U0000							; Current version and revision
     31 U0000							;
     32 U0000		       00 00	   VERSION    equ	0
     33 U0000		       00 04	   REVISION   equ	4
     34 U0000							;
     35 U0000							;---------------------------------------------------------
     36 U0000							; ASCII constants
     37 U0000							;
     38 U0000		       00 07	   BELL       equ	$07
     39 U0000		       00 08	   BS	      equ	$08
     40 U0000		       00 0a	   LF	      equ	$0a
     41 U0000		       00 0d	   CR	      equ	$0d
     42 U0000							;
     43 U0000							; Max number of bytes per line for hex dump
     44 U0000							;
     45 U0000		       00 10	   BYTESLINE  equ	16
     46 U0000							;
     47 U0000							; These are various buffer sizes
     48 U0000							;
     49 U0000		       00 0c	   FILENAME_SIZE equ	12
     50 U0000							;
     51 U0000							; Intel HEX record types
     52 U0000							;
     53 U0000		       00 00	   DATA_RECORD equ	$00
     54 U0000		       00 01	   EOF_RECORD equ	$01
     55 U0000							;
     56 U0000							; Zero-page data
     57 U0000							;
     58 U0000							;		zpage
     59 U0000					      seg.U	ZEROPAGE
     60 U00f0					      org	ZERO_PAGE_START
     61 U00f0		       00 00	   sptr       ds	2
     62 U00f2		       00	   INL	      ds	1
     63 U00f3		       00	   INH	      ds	1
     64 U00f4		       00 00	   putsp      ds	2
     65 U00f6							;
     66 U00f6							; Non zero-page data
     67 U00f6							;
     68 Udfad ????				      Seg.u	RomScratch
     69 Udf00					      org	RAM_START
     70 Udf00							;
     71 Udf00							; The use of memory starting from here will remain
     72 Udf00							; constant through different versions of CTMON65.
     73 Udf00							;
     74 Udf00		       00 00	   IRQvec     ds	2
     75 Udf02		       00 00	   NMIvec     ds	2
     76 Udf04							;
     77 Udf04							; Before a L(oad) command, these are set to $FF.
     78 Udf04							; After loading, if they are different, jump to
     79 Udf04							; that address.
     80 Udf04							;
     81 Udf04		       00 00	   AutoRun    ds	2
     82 Udf06							;
     83 Udf06							; Pointer to the subroutine that gets the next input
     84 Udf06							; character.  Used for doing disk/console input.
     85 Udf06							;
     86 Udf06		       00 00	   inputVector ds	2
     87 Udf08							;
     88 Udf08							; Same thing for output.
     89 Udf08							;
     90 Udf08		       00 00	   outputVector ds	2
     91 Udf0a							;
     92 Udf0a							; Buffer for GETLINE
     93 Udf0a							;
     94 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
     95 Udf8e							;
     96 Udf8e							; Anything from here can be moved between versions.
     97 Udf8e							;
     98 Udf8e		       00	   SaveA      ds	1
     99 Udf8f		       00	   SaveX      ds	1
    100 Udf90		       00	   SaveY      ds	1
    101 Udf91		       00 00	   SavePC     ds	2
    102 Udf93		       00	   SaveC      ds	1
    103 Udf94		       00	   SaveSP     ds	1
    104 Udf95		       00	   SAL	      ds	1
    105 Udf96		       00	   SAH	      ds	1
    106 Udf97		       00	   EAL	      ds	1
    107 Udf98		       00	   EAH	      ds	1
    108 Udf99		       00	   tempA      ds	1
    109 Udf9a		       00 00 00 00*filename   ds	FILENAME_SIZE+1
    110 Udfa7		       00	   diskBufOffset ds	1
    111 Udfa8		       00	   diskBufLength ds	1
    112 Udfa9		       00	   CHKL       ds	1
    113 Udfaa		       00	   ID	      ds	1
    114 Udfab		       00	   Temp16L    ds	1
    115 Udfac		       00	   Temp16H    ds	1
    116 Udfad							;
    117 Udfad							; This weird bit of DBs is to allow for the fact that
    118 Udfad							; I'm putting a 4K monitor into the top half of an
    119 Udfad							; 8K EEPROM.  This forces the actual code to the top
    120 Udfad							; 4K section.
    121 Udfad							;
    122 Udfad							;		Seg  rcode
    123 Udfad							;		org	ROM_START-$1000
    124 Udfad							;		db	"This space for rent.",CR,LF
    125 Udfad							;		db	"Actually, this just forces the "
    126 Udfad							;		db	"binary file to be 8K long."
    127 Udfad
    128 Udfad
    129  10000 ????				       Seg	Code
    130  f000					      org	ROM_START
    131  f000							;
    132  f000							;=========================================================
    133  f000							; Jump table to common functions.  The entries in this
    134  f000							; table are used by external programs, so nothing can be
    135  f000							; moved or removed from this table.  New entries always
    136  f000							; go at the end.  Many of these are internal functions
    137  f000							; and I figured they might be handy for others.
    138  f000							;
    139  f000		       4c 48 f0    COLDvec    jmp	RESET
    140  f003		       4c f9 f0    WARMvec    jmp	WARM
    141  f006							;
    142  f006							; These are the major and minor revision numbers so that
    143  f006							; code can check to see which CTMON65 version is running.
    144  f006							;
      0  f006				   CTMON65ver db	VERSION
      1  f006		       00		      .byte.b	VERSION
      0  f007				   CTMON65rev db	REVISION
      1  f007		       04		      .byte.b	REVISION
      0  f008					      db	0
      1  f008		       00		      .byte.b	0
    148  f009							;
    149  f009							; Console related functions
    150  f009							;
    151  f009		       4c 9a fb    CINvec     jmp	cin
    152  f00c		       4c 8d fb    COUTvec    jmp	cout
    153  f00f		       4c a5 fb    CSTATvec   jmp	cstatus
    154  f012		       4c 08 fb    PUTSILvec  jmp	putsil
    155  f015		       4c 46 fb    GETLINEvec jmp	getline
    156  f018		       4c 66 fb    CRLFvec    jmp	crlf
    157  f01b		       4c 49 fb    OUTHEXvec  jmp	HexA
    158  f01e							;
    159  f01e							; Low-level functions to access the SD card system
    160  f01e							;
    161  f01e					      if	SD_ENABLED
    162  f01e		       4c ab fb    XPARINITvev jmp	xParInit
    163  f021		       4c ab fb    XPARSETWRITEvec jmp	xParSetWrite
    164  f024		       4c ae fb    XPARSETREADvec jmp	xParSetRead
    165  f027		       4c b1 fb    XPARWRITEvec jmp	xParWriteByte
    166  f02a		       4c b5 fb    XPARREADvec jmp	xParReadByte
    167  f02d							;
    168  f02d							; Higher level SD card functions
    169  f02d							;
    170  f02d		       4c c0 fb    DISKPINGvec jmp	DiskPing
    171  f030		       4c d3 fb    DISKDIRvec jmp	DiskDir
    172  f033		       4c dd fb    DISKDIRNEXTVEC jmp	DiskDirNext
    173  f036		       4c 0e fc    DISKOPENREADvec jmp	DiskOpenRead
    174  f039		       4c 3f fc    DISKOPENWRITvec jmp	DiskOpenWrite
    175  f03c		       4c 49 fc    DISKREADvec jmp	DiskRead
    176  f03f		       4c 7b fc    DISKWRITEvec jmp	DiskWrite
    177  f042		       4c b2 fc    DISKCLOSEvec jmp	DiskClose
    178  f045		       4c 44 fc    DISKRMvec  JMP	DiskRemoveFile
    179  f048					      endif		;SD_ENABLED
    180  f048							;
    181  f048							;---------------------------------------------------------
    182  f048							; Cold start entry point
    183  f048							;
    184  f048		       a2 ff	   RESET      ldx	#$ff
    185  f04a		       9a		      txs
    186  f04b		       20 81 fb 	      jsr	cinit
    187  f04e		       20 ab fb 	      jsr	xParInit
    188  f051							;
    189  f051							; Reset the NMI and IRQ vectors
    190  f051							;
    191  f051		       a9 bd		      lda	#DefaultNMI&$ff
    192  f053		       8d 02 df 	      sta	NMIvec
    193  f056		       a9 fc		      lda	#DefaultNMI>>8
    194  f058		       8d 03 df 	      sta	NMIvec+1
    195  f05b							;
    196  f05b		       a9 bd		      lda	#DefaultIRQ&$ff
    197  f05d		       8d 00 df 	      sta	IRQvec
    198  f060		       a9 fc		      lda	#DefaultIRQ>>8
    199  f062		       8d 01 df 	      sta	IRQvec+1
    200  f065							;
    201  f065							; Print start-up message
    202  f065							;
    203  f065		       20 08 fb 	      jsr	putsil
      0  f068					      db	CR,LF,LF,LF,LF
      1  f068		       0d 0a 0a 0a*	      .byte.b	CR,LF,LF,LF,LF
      0  f06d					      db	"CTMON65 rev "
      1  f06d		       43 54 4d 4f*	      .byte.b	"CTMON65 rev "
      0  f079					      db	VERSION+'0,'.
      1  f079		       30 2e		      .byte.b	VERSION+'0,'.
      0  f07b					      db	REVISION+'0
      1  f07b		       34		      .byte.b	REVISION+'0
      0  f07c					      db	CR,LF
      1  f07c		       0d 0a		      .byte.b	CR,LF
      0  f07e					      db	"04/13/2022 by Bob Applegate K2UT/JustLostInTime"
      1  f07e		       30 34 2f 31*	      .byte.b	"04/13/2022 by Bob Applegate K2UT/JustLostInTime"
      0  f0ad					      db	CR,LF
      1  f0ad		       0d 0a		      .byte.b	CR,LF
      0  f0af					      db	"Authors: bob@corshamtech.com, https://github.com/justlostintime/em6502"
      1  f0af		       41 75 74 68*	      .byte.b	"Authors: bob@corshamtech.com, https://github.com/justlostintime/em6502"
      0  f0f5					      db	CR,LF,LF,0
      1  f0f5		       0d 0a 0a 00	      .byte.b	CR,LF,LF,0
    213  f0f9							;
    214  f0f9							;---------------------------------------------------------
    215  f0f9							; Warm start entry point.  This is the best place to jump
    216  f0f9							; in the code after a user program has ended.	Go through
    217  f0f9							; the vector, of course!
    218  f0f9							;
    219  f0f9		       a2 ff	   WARM       ldx	#$ff
    220  f0fb		       9a		      txs
    221  f0fc							;
    222  f0fc							; Prompt the user and get a line of text
    223  f0fc							;
    224  f0fc		       20 f4 f9    prompt     jsr	setOutputConsole
    225  f0ff		       20 0f fa 	      jsr	setInputConsole
    226  f102		       20 08 fb 	      jsr	putsil
      0  f105					      db	CR,LF
      1  f105		       0d 0a		      .byte.b	CR,LF
      0  f107					      db	"CTMON65> "
      1  f107		       43 54 4d 4f*	      .byte.b	"CTMON65> "
      0  f110					      db	0
      1  f110		       00		      .byte.b	0
    230  f111		       20 9a fb    prompt2    jsr	cin
    231  f114		       c9 0d		      cmp	#CR
    232  f116		       f0 e4		      beq	prompt
    233  f118		       c9 0a		      cmp	#LF
    234  f11a		       f0 f5		      beq	prompt2	;don't prompt
    235  f11c		       8d 99 df 	      sta	tempA
    236  f11f							;
    237  f11f							; Now cycle through the list of commands looking for
    238  f11f							; what the user just pressed.
    239  f11f							;
    240  f11f		       a9 38		      lda	#commandTable&$ff
    241  f121		       85 f0		      sta	sptr
    242  f123		       a9 f1		      lda	#commandTable/256
    243  f125		       85 f1		      sta	sptr+1
    244  f127		       20 dd f2 	      jsr	searchCmd	;try to find it
    245  f12a							;
    246  f12a							; Hmmm... wasn't one of the built in commands, so
    247  f12a							; see if it's an extended command.
    248  f12a							;
    249  f12a				  -	      if	EXTENDED_CMDS
    250  f12a				  -	      lda	ExtensionAddr
    251  f12a				  -	      sta	sptr
    252  f12a				  -	      lda	ExtensionAddr+1
    253  f12a				  -	      sta	sptr+1
    254  f12a				  -	      jsr	searchCmd	;try to find it
    255  f12a					      endif
    256  f12a							;
    257  f12a							; If that returns, then the command was not found.
    258  f12a							; Print that it's unknown.
    259  f12a							;
    260  f12a		       20 08 fb 	      jsr	putsil
      0  f12d					      db	" - Huh?",0
      1  f12d		       20 2d 20 48*	      .byte.b	" - Huh?",0
    262  f135		       4c fc f0    cmdFound   jmp	prompt
    263  f138							;
    264  f138							;=====================================================
    265  f138							; Vector table of commands.  Each entry consists of a
    266  f138							; single ASCII character (the command), a pointer to
    267  f138							; the function which handles the command, and a pointer
    268  f138							; to a string that describes the command.
    269  f138							;
    270  f138				   commandTable
      0  f138					      db	'?
      1  f138		       3f		      .byte.b	'?
      0  f139					      dw	showHelp
      1  f139		       07 f8		      .word.w	showHelp
      0  f13b					      dw	quesDesc
      1  f13b		       75 f1		      .word.w	quesDesc
    274  f13d							;
      0  f13d					      db	'C
      1  f13d		       43		      .byte.b	'C
      0  f13e					      dw	doContinue
      1  f13e		       70 f7		      .word.w	doContinue
      0  f140					      dw	cDesc
      1  f140		       92 f1		      .word.w	cDesc
    278  f142							;
      0  f142					      db	'D
      1  f142		       44		      .byte.b	'D
      0  f143					      dw	doDiskDir
      1  f143		       9a f9		      .word.w	doDiskDir
      0  f145					      dw	dDesc
      1  f145		       b3 f1		      .word.w	dDesc
    282  f147							;
      0  f147					      db	'E	;edit memory
      1  f147		       45		      .byte.b	'E
      0  f148					      dw	editMemory
      1  f148		       b2 f3		      .word.w	editMemory
      0  f14a					      dw	eDesc
      1  f14a		       d0 f1		      .word.w	eDesc
    286  f14c							;
      0  f14c					      db	'H	;hex dump
      1  f14c		       48		      .byte.b	'H
      0  f14d					      dw	hexDump
      1  f14d		       22 f3		      .word.w	hexDump
      0  f14f					      dw	hDesc
      1  f14f		       ea f1		      .word.w	hDesc
    290  f151							;
      0  f151					      db	'J	;jump to address
      1  f151		       4a		      .byte.b	'J
      0  f152					      dw	jumpAddress
      1  f152		       08 f3		      .word.w	jumpAddress
      0  f154					      dw	jDesc
      1  f154		       08 f2		      .word.w	jDesc
    294  f156							;
      0  f156					      db	'L	;load Intel HEX file
      1  f156		       4c		      .byte.b	'L
      0  f157					      dw	loadHex
      1  f157		       13 f4		      .word.w	loadHex
      0  f159					      dw	lDesc
      1  f159		       26 f2		      .word.w	lDesc
    298  f15b							;
      0  f15b					      db	'M	;perform memory test
      1  f15b		       4d		      .byte.b	'M
      0  f15c					      dw	memTest
      1  f15c		       5a f8		      .word.w	memTest
      0  f15e					      dw	mDesc
      1  f15e		       42 f2		      .word.w	mDesc
    302  f160							;
      0  f160					      db	'P	;ping remote disk
      1  f160		       50		      .byte.b	'P
      0  f161					      dw	pingDisk
      1  f161		       7a f9		      .word.w	pingDisk
      0  f163					      dw	pDesc
      1  f163		       5c f2		      .word.w	pDesc
    306  f165							;
      0  f165					      db	'R	;remove a file from disk
      1  f165		       52		      .byte.b	'R
      0  f166					      dw	rmFile
      1  f166		       68 fa		      .word.w	rmFile
      0  f168					      dw	rDesc
      1  f168		       7f f2		      .word.w	rDesc
    310  f16a							;
      0  f16a					      db	'S	;save memory as hex file
      1  f16a		       53		      .byte.b	'S
      0  f16b					      dw	saveHex
      1  f16b		       59 f5		      .word.w	saveHex
      0  f16d					      dw	sDesc
      1  f16d		       9e f2		      .word.w	sDesc
    314  f16f							;
      0  f16f					      db	'T	;type a file on SD
      1  f16f		       54		      .byte.b	'T
      0  f170					      dw	typeFile
      1  f170		       9f fa		      .word.w	typeFile
      0  f172					      dw	tDesc
      1  f172		       c0 f2		      .word.w	tDesc
    318  f174							;
      0  f174					      db	0	;marks end of table
      1  f174		       00		      .byte.b	0
    320  f175							;
    321  f175							;=====================================================
    322  f175							; Descriptions for each command in the command table.
    323  f175							; This wastes a lot of space... I'm open for any
    324  f175							; suggestions to keep the commands clear but reducing
    325  f175							; the amount of space this table consumes.
    326  f175							;
      0  f175				   quesDesc   db	"? ........... Show this help",0
      1  f175		       3f 20 2e 2e*	      .byte.b	"? ........... Show this help",0
      0  f192				   cDesc      db	"C ........... Continue execution",0
      1  f192		       43 20 2e 2e*	      .byte.b	"C ........... Continue execution",0
      0  f1b3				   dDesc      db	"D ........... Disk directory",0
      1  f1b3		       44 20 2e 2e*	      .byte.b	"D ........... Disk directory",0
      0  f1d0				   eDesc      db	"E xxxx ...... Edit memory",0
      1  f1d0		       45 20 78 78*	      .byte.b	"E xxxx ...... Edit memory",0
      0  f1ea				   hDesc      db	"H xxxx xxxx . Hex dump memory",0
      1  f1ea		       48 20 78 78*	      .byte.b	"H xxxx xxxx . Hex dump memory",0
      0  f208				   jDesc      db	"J xxxx ...... Jump to address",0
      1  f208		       4a 20 78 78*	      .byte.b	"J xxxx ...... Jump to address",0
      0  f226				   lDesc      db	"L ........... Load HEX file",0
      1  f226		       4c 20 2e 2e*	      .byte.b	"L ........... Load HEX file",0
      0  f242				   mDesc      db	"M xxxx xxxx . Memory test",0
      1  f242		       4d 20 78 78*	      .byte.b	"M xxxx xxxx . Memory test",0
      0  f25c				   pDesc      db	"P ........... Ping disk controller",0
      1  f25c		       50 20 2e 2e*	      .byte.b	"P ........... Ping disk controller",0
      0  f27f				   rDesc      db	"R ........... Remove disk file",0
      1  f27f		       52 20 2e 2e*	      .byte.b	"R ........... Remove disk file",0
      0  f29e				   sDesc      db	"S xxxx xxxx . Save memory to file",0
      1  f29e		       53 20 78 78*	      .byte.b	"S xxxx xxxx . Save memory to file",0
      0  f2c0				   tDesc      db	"T ........... Type disk file",0
      1  f2c0		       54 20 2e 2e*	      .byte.b	"T ........... Type disk file",0
    339  f2dd							;
    340  f2dd							;=====================================================
    341  f2dd							; This subroutine will search for a command in a table
    342  f2dd							; and call the appropriate handler.  See the command
    343  f2dd							; table near the start of the code for what the format
    344  f2dd							; is.	If a match is found, pop off the return address
    345  f2dd							; from the stack and jump to the code.  Else, return.
    346  f2dd							;
    347  f2dd		       a0 00	   searchCmd  ldy	#0
    348  f2df		       b1 f0	   cmdLoop    lda	(sptr),y
    349  f2e1		       f0 24		      beq	cmdNotFound
    350  f2e3		       cd 99 df 	      cmp	tempA	;compare to user's input
    351  f2e6		       f0 0e		      beq	cmdMatch
    352  f2e8		       09 20		      ora	#$20	;allow lower case cmds
    353  f2ea		       cd 99 df 	      cmp	tempA	;try users input again
    354  f2ed		       f0 07		      beq	cmdMatch
    355  f2ef		       c8		      iny		;start of function ptr
    356  f2f0		       c8		      iny
    357  f2f1		       c8		      iny		;start of help
    358  f2f2		       c8		      iny
    359  f2f3		       c8		      iny		;move to next command
    360  f2f4		       d0 e9		      bne	cmdLoop
    361  f2f6							;
    362  f2f6							; It's found!	Load up the address of the code to call,
    363  f2f6							; pop the return address off the stack and jump to the
    364  f2f6							; handler.
    365  f2f6							;
    366  f2f6		       c8	   cmdMatch   iny
    367  f2f7		       b1 f0		      lda	(sptr),y	;handler LSB
    368  f2f9		       48		      pha
    369  f2fa		       c8		      iny
    370  f2fb		       b1 f0		      lda	(sptr),y	;handler MSB
    371  f2fd		       85 f1		      sta	sptr+1
    372  f2ff		       68		      pla
    373  f300		       85 f0		      sta	sptr
    374  f302		       68		      pla		;pop return address
    375  f303		       68		      pla
    376  f304		       6c f0 00 	      jmp	(sptr)
    377  f307							;
    378  f307							; Not found, so just return.
    379  f307							;
    380  f307		       60	   cmdNotFound rts
    381  f308							;
    382  f308							;=====================================================
    383  f308							; Handles the command to prompt for an address and then
    384  f308							; jump to it.
    385  f308							;
    386  f308		       20 08 fb    jumpAddress jsr	putsil
      0  f30b					      db	"Jump to ",0
      1  f30b		       4a 75 6d 70*	      .byte.b	"Jump to ",0
    388  f314		       20 c4 f7 	      jsr	getStartAddr
    389  f317		       b0 06		      bcs	cmdRet	;branch on bad address
    390  f319		       20 66 fb 	      jsr	crlf
    391  f31c		       6c 95 df 	      jmp	(SAL)	;else jump to address
    392  f31f							;
    393  f31f		       4c fc f0    cmdRet     jmp	prompt
    394  f322							;
    395  f322							;=====================================================
    396  f322							; Do a hex dump of a region of memory.
    397  f322							;
    398  f322							; Slight bug: the starting address is rounded down to
    399  f322							; a multiple of 16.  I'll fix it eventually.
    400  f322							;
    401  f322		       20 08 fb    hexDump    jsr	putsil
      0  f325					      db	"Hex dump ",0
      1  f325		       48 65 78 20*	      .byte.b	"Hex dump ",0
    403  f32f		       20 e8 f7 	      jsr	getAddrRange
    404  f332		       b0 eb		      bcs	cmdRet
    405  f334		       20 66 fb 	      jsr	crlf
    406  f337							;
    407  f337							; Move start address to sptr but rounded down to the
    408  f337							; 16 byte boundary.  While it's really cool to start at
    409  f337							; the exact address specified by the user, it adds
    410  f337							; code that really doesn't add much (any?) value.
    411  f337							;
    412  f337		       ad 96 df 	      lda	SAH
    413  f33a		       85 f1		      sta	sptr+1
    414  f33c		       ad 95 df 	      lda	SAL
    415  f33f		       29 f0		      and	#$f0	;force to 16 byte
    416  f341		       85 f0		      sta	sptr
    417  f343							;
    418  f343							;-----------------------------------------------------
    419  f343							; This starts each line.  Set flag to indcate we're
    420  f343							; doing the hex portion, print address, etc.
    421  f343							;
    422  f343		       20 66 fb    hexdump1   jsr	crlf
    423  f346		       a5 f1		      lda	sptr+1
    424  f348		       20 49 fb 	      jsr	HexA	;print the address
    425  f34b		       a5 f0		      lda	sptr
    426  f34d		       20 49 fb 	      jsr	HexA
    427  f350		       20 76 fb 	      jsr	space2	;two spaces after address
    428  f353							;
    429  f353							;-----------------------------------------------------
    430  f353							; This loop gets the next byte, prints the value in
    431  f353							; hex and adds the appropriate ASCII character to the
    432  f353							; buffer.
    433  f353							;
    434  f353		       a0 00		      ldy	#0	;offset from sptr
    435  f355		       a2 00	   hexdump3   ldx	#0	;bytes on line
    436  f357		       b1 f0	   hexdump2   lda	(sptr),y	;get byte
    437  f359		       20 49 fb 	      jsr	HexA	;print hex version of it
    438  f35c		       20 79 fb 	      jsr	space	;space before next value
    439  f35f							;
    440  f35f							; Put the byte into the buffer.  If it is not printable
    441  f35f							; ASCII then substitute a dot instead.
    442  f35f							;
    443  f35f		       c9 20		      cmp	#$20
    444  f361		       90 04		      bcc	hexdot
    445  f363		       c9 7e		      cmp	#'~
    446  f365		       90 02		      bcc	hexpr
    447  f367		       a9 2e	   hexdot     lda	#'.
    448  f369		       9d 0a df    hexpr      sta	buffer,x	;save for later
    449  f36c							;
    450  f36c							; See if the end of the user defined area was just dumped
    451  f36c							;
    452  f36c		       a5 f0	   hexdumpchk lda	sptr
    453  f36e		       cd 97 df 	      cmp	EAL
    454  f371		       d0 07		      bne	hexdump4
    455  f373		       a5 f1		      lda	sptr+1
    456  f375		       cd 98 df 	      cmp	EAH
    457  f378		       f0 0e		      beq	hexdumpend
    458  f37a							;
    459  f37a							; Not done yet, so see if at end of the line
    460  f37a							;
    461  f37a		       20 73 f9    hexdump4   jsr	INCPT	;move to next address
    462  f37d		       e8		      inx
    463  f37e		       e0 10		      cpx	#BYTESLINE
    464  f380		       d0 d5		      bne	hexdump2
    465  f382							;
    466  f382							; At end, so dump ASCII contents
    467  f382							;
    468  f382		       20 92 f3 	      jsr	dumpBuffer
    469  f385		       4c 43 f3 	      jmp	hexdump1
    470  f388							;
    471  f388							; At the end but still need to dump the ASCII version.
    472  f388							;
    473  f388		       e8	   hexdumpend inx		;count last byte output
    474  f389		       20 92 f3 	      jsr	dumpBuffer
    475  f38c		       20 66 fb 	      jsr	crlf
    476  f38f		       4c fc f0    ret1       jmp	prompt
    477  f392							;
    478  f392							;=====================================================
    479  f392							; A helper function that prints the ASCII data in the
    480  f392							; buffer.  On entry X contains the number of bytes
    481  f392							; in the buffer.
    482  f392							;
    483  f392		       e0 10	   dumpBuffer cpx	#BYTESLINE	;is buffer full?
    484  f394		       f0 0b		      beq	hexdump91	;jump if so
    485  f396		       a9 20		      lda	#$20	;else fill with spaces
    486  f398		       9d 0a df 	      sta	buffer,x
    487  f39b		       20 73 fb 	      jsr	space3	;and space over
    488  f39e		       e8		      inx
    489  f39f		       d0 f1		      bne	dumpBuffer
    490  f3a1							;
    491  f3a1		       20 73 fb    hexdump91  jsr	space3	;separate the two passes
    492  f3a4		       a2 00		      ldx	#0
    493  f3a6		       bd 0a df    hexdump99  lda	buffer,x
    494  f3a9		       20 8d fb 	      jsr	cout	;print char in buffer
    495  f3ac		       e8		      inx
    496  f3ad		       e0 10		      cpx	#BYTESLINE
    497  f3af		       d0 f5		      bne	hexdump99
    498  f3b1		       60		      rts
    499  f3b2							;
    500  f3b2							;=====================================================
    501  f3b2							; Edit memory.  This waits for a starting address to be
    502  f3b2							; entered.  It will display the current address and its
    503  f3b2							; contents.  Possible user inputs and actions:
    504  f3b2							;
    505  f3b2							;   Two hex digits will place that value in memory
    506  f3b2							;   RETURN moves to next address
    507  f3b2							;   BACKSPACE moves back one address
    508  f3b2							;
    509  f3b2		       20 08 fb    editMemory jsr	putsil
      0  f3b5					      db	"Edit memory ",0
      1  f3b5		       45 64 69 74*	      .byte.b	"Edit memory ",0
    511  f3c2		       20 c4 f7 	      jsr	getStartAddr
    512  f3c5		       b0 c8		      bcs	ret1
    513  f3c7		       ad 95 df 	      lda	SAL	;move address into...
    514  f3ca		       85 f0		      sta	sptr	;...POINT
    515  f3cc		       ad 96 df 	      lda	SAH
    516  f3cf		       85 f1		      sta	sptr+1
    517  f3d1							;
    518  f3d1							; Display the current location
    519  f3d1							;
    520  f3d1		       20 66 fb    editMem1   jsr	crlf
    521  f3d4		       a5 f1		      lda	sptr+1
    522  f3d6		       20 49 fb 	      jsr	HexA
    523  f3d9		       a5 f0		      lda	sptr
    524  f3db		       20 49 fb 	      jsr	HexA
    525  f3de		       20 79 fb 	      jsr	space
    526  f3e1		       a0 00		      ldy	#0
    527  f3e3		       b1 f0		      lda	(sptr),y	;get byte
    528  f3e5		       20 49 fb 	      jsr	HexA	;print it
    529  f3e8		       20 79 fb 	      jsr	space
    530  f3eb							;
    531  f3eb		       20 8a f7 	      jsr	getHex
    532  f3ee		       b0 0d		      bcs	editMem2	;not hex
    533  f3f0		       a0 00		      ldy	#0
    534  f3f2		       91 f0		      sta	(sptr),y	;save new value
    535  f3f4							;
    536  f3f4							; Bump POINT to next location
    537  f3f4							;
    538  f3f4		       e6 f0	   editMem3   inc	sptr
    539  f3f6		       d0 d9		      bne	editMem1
    540  f3f8		       e6 f1		      inc	sptr+1
    541  f3fa		       4c d1 f3 	      jmp	editMem1
    542  f3fd							;
    543  f3fd							; Not hex, so see if another command
    544  f3fd							;
    545  f3fd		       c9 0d	   editMem2   cmp	#CR
    546  f3ff		       f0 f3		      beq	editMem3	;move to next
    547  f401		       c9 08		      cmp	#BS
    548  f403		       d0 8a		      bne	ret1	;else exit
    549  f405							;
    550  f405							; Move back one location
    551  f405							;
    552  f405		       38		      sec
    553  f406		       a5 f0		      lda	sptr
    554  f408		       e9 01		      sbc	#1
    555  f40a		       85 f0		      sta	sptr
    556  f40c		       b0 c3		      bcs	editMem1
    557  f40e		       c6 f1		      dec	sptr+1
    558  f410		       4c d1 f3 	      jmp	editMem1
    559  f413							;
    560  f413							;=====================================================
    561  f413							; This handles the Load hex command.
    562  f413							;
    563  f413		       a9 ff	   loadHex    lda	#$ff
    564  f415		       8d 05 df 	      sta	AutoRun+1
    565  f418							;
    566  f418		       20 08 fb 	      jsr	putsil
      0  f41b					      db	CR,LF
      1  f41b		       0d 0a		      .byte.b	CR,LF
      0  f41d					      db	"Enter filename, or Enter to "
      1  f41d		       45 6e 74 65*	      .byte.b	"Enter filename, or Enter to "
      0  f439					      db	"load from console: ",0
      1  f439		       6c 6f 61 64*	      .byte.b	"load from console: ",0
    570  f44d							;
    571  f44d		       20 87 f6 	      jsr	getFileName	;get filename
    572  f450		       ad 9a df 	      lda	filename	;null?
    573  f453		       f0 2d		      beq	loadHexConsole	;load from console
    574  f455							;
    575  f455							; Open the file
    576  f455							;
    577  f455		       a0 9a		      ldy	#filename&$ff
    578  f457		       a2 df		      ldx	#filename/256
    579  f459		       20 0e fc 	      jsr	DiskOpenRead
    580  f45c		       90 1e		      bcc	loadHexOk	;opened ok
    581  f45e							;
    582  f45e		       20 08 fb    openfail   jsr	putsil
      0  f461					      db	CR,LF
      1  f461		       0d 0a		      .byte.b	CR,LF
      0  f463					      db	"Failed to open file"
      1  f463		       46 61 69 6c*	      .byte.b	"Failed to open file"
      0  f476					      db	CR,LF,0
      1  f476		       0d 0a 00 	      .byte.b	CR,LF,0
    586  f479		       4c fc f0    cmdRet3    jmp	prompt
    587  f47c							;
    588  f47c		       20 23 fa    loadHexOk  jsr	setInputFile	;redirect input
    589  f47f		       4c b0 f4 	      jmp	loadStart
    590  f482							;
    591  f482							; They are loading from the console
    592  f482							;
    593  f482		       20 08 fb    loadHexConsole jsr	putsil
      0  f485					      db	CR,LF
      1  f485		       0d 0a		      .byte.b	CR,LF
      0  f487					      db	"Waiting for file, or ESC to"
      1  f487		       57 61 69 74*	      .byte.b	"Waiting for file, or ESC to"
      0  f4a2					      db	" exit..."
      1  f4a2		       20 65 78 69*	      .byte.b	" exit..."
      0  f4aa					      db	CR,LF,0
      1  f4aa		       0d 0a 00 	      .byte.b	CR,LF,0
    598  f4ad		       20 0f fa 	      jsr	setInputConsole
    599  f4b0							;
    600  f4b0							; The start of a line.  First character should be a
    601  f4b0							; colon, but toss out CRs, LFs, etc.  Anything else
    602  f4b0							; causes an abort.
    603  f4b0							;
    604  f4b0		       20 36 fa    loadStart  jsr	redirectedGetch	;get start of line
    605  f4b3		       c9 0d		      cmp	#CR
    606  f4b5		       f0 f9		      beq	loadStart
    607  f4b7		       c9 0a		      cmp	#LF
    608  f4b9		       f0 f5		      beq	loadStart
    609  f4bb		       c9 3a		      cmp	#':	;what we expect
    610  f4bd		       d0 34		      bne	loadAbort
    611  f4bf							;
    612  f4bf							; Get the header of the record
    613  f4bf							;
    614  f4bf		       a9 00		      lda	#0
    615  f4c1		       8d a9 df 	      sta	CHKL	;initialize checksum
    616  f4c4							;
    617  f4c4		       20 8a f7 	      jsr	getHex	;get byte count
    618  f4c7		       b0 2a		      bcs	loadAbort
    619  f4c9		       8d 8f df 	      sta	SaveX	;save byte count
    620  f4cc		       20 cd f9 	      jsr	updateCrc
    621  f4cf		       20 8a f7 	      jsr	getHex	;get the MSB of offset
    622  f4d2		       b0 1f		      bcs	loadAbort
    623  f4d4		       85 f1		      sta	sptr+1
    624  f4d6		       20 cd f9 	      jsr	updateCrc
    625  f4d9		       20 8a f7 	      jsr	getHex	;get LSB of offset
    626  f4dc		       b0 15		      bcs	loadAbort
    627  f4de		       85 f0		      sta	sptr
    628  f4e0		       20 cd f9 	      jsr	updateCrc
    629  f4e3		       20 8a f7 	      jsr	getHex	;get the record type
    630  f4e6		       b0 0b		      bcs	loadAbort
    631  f4e8		       20 cd f9 	      jsr	updateCrc
    632  f4eb							;
    633  f4eb							; Only handle two record types:
    634  f4eb							;    00 = data record
    635  f4eb							;    01 = end of file record
    636  f4eb							;
    637  f4eb		       c9 00		      cmp	#DATA_RECORD
    638  f4ed		       f0 3a		      beq	loadDataRec
    639  f4ef		       c9 01		      cmp	#EOF_RECORD
    640  f4f1		       f0 16		      beq	loadEof
    641  f4f3							;
    642  f4f3							; Unknown record type
    643  f4f3							;
    644  f4f3		       20 08 fb    loadAbort  jsr	putsil
      0  f4f6					      db	CR,LF
      1  f4f6		       0d 0a		      .byte.b	CR,LF
      0  f4f8					      db	"Aborting"
      1  f4f8		       41 62 6f 72*	      .byte.b	"Aborting"
      0  f500					      db	CR,LF,0
      1  f500		       0d 0a 00 	      .byte.b	CR,LF,0
    648  f503		       20 0f fa    loadExit   jsr	setInputConsole
    649  f506		       4c fc f0 	      jmp	prompt
    650  f509							;
    651  f509							; EOF is easy
    652  f509							;
    653  f509		       20 8a f7    loadEof    jsr	getHex	;get checksum
    654  f50c		       20 08 fb 	      jsr	putsil
      0  f50f					      db	CR,LF
      1  f50f		       0d 0a		      .byte.b	CR,LF
      0  f511					      db	"Success!"
      1  f511		       53 75 63 63*	      .byte.b	"Success!"
      0  f519					      db	CR,LF,0
      1  f519		       0d 0a 00 	      .byte.b	CR,LF,0
    658  f51c							;
    659  f51c							; If the auto-run vector is no longer $ffff, then jump
    660  f51c							; to whatever it points to.
    661  f51c							;
    662  f51c		       ad 05 df 	      lda	AutoRun+1
    663  f51f		       c9 ff		      cmp	#$ff	;unchanged?
    664  f521		       f0 03		      beq	lExit1
    665  f523		       6c 04 df 	      jmp	(AutoRun)	;execute!
    666  f526							;
    667  f526		       4c 03 f5    lExit1     jmp	loadExit
    668  f529							;
    669  f529							; Data records have more work.  After processing the
    670  f529							; line, print a dot to indicate progress.  This should
    671  f529							; be re-thought as it could slow down loading a really
    672  f529							; big file if the console speed is slow.
    673  f529							;
    674  f529		       ae 8f df    loadDataRec ldx	SaveX	;byte count
    675  f52c		       a0 00		      ldy	#0	;offset
    676  f52e		       8e 8f df    loadData1  stx	SaveX
    677  f531		       8c 90 df 	      sty	SaveY
    678  f534		       20 8a f7 	      jsr	getHex
    679  f537		       b0 ba		      bcs	loadAbort
    680  f539		       20 cd f9 	      jsr	updateCrc
    681  f53c		       ac 90 df 	      ldy	SaveY
    682  f53f		       ae 8f df 	      ldx	SaveX
    683  f542		       91 f0		      sta	(sptr),y
    684  f544		       c8		      iny
    685  f545		       ca		      dex
    686  f546		       d0 e6		      bne	loadData1
    687  f548							;
    688  f548							; All the bytes were read so get the checksum and see
    689  f548							; if it agrees.  The checksum is a twos-complement, so
    690  f548							; just add the checksum into what we've been calculating
    691  f548							; and if the result is zero then the record is good.
    692  f548							;
    693  f548		       20 8a f7 	      jsr	getHex	;get checksum
    694  f54b		       18		      clc
    695  f54c		       6d a9 df 	      adc	CHKL
    696  f54f		       d0 a2		      bne	loadAbort	;non-zero is error
    697  f551							;
    698  f551		       a9 2e		      lda	#'.	;sanity indicator when
    699  f553		       20 8d fb 	      jsr	cout	;...loading from file
    700  f556		       4c b0 f4 	      jmp	loadStart
    701  f559							;
    702  f559							;=====================================================
    703  f559							; Handles the command to save a region of memory as a
    704  f559							; file on the SD.
    705  f559							;
    706  f559		       20 e8 f7    saveHex    jsr	getAddrRange	;get range to dump
    707  f55c		       b0 c8		      bcs	lExit1	;abort on error
    708  f55e							;
    709  f55e							; Get the filename to save to
    710  f55e							;
    711  f55e		       20 08 fb 	      jsr	putsil
      0  f561					      db	CR,LF
      1  f561		       0d 0a		      .byte.b	CR,LF
      0  f563					      db	"Enter filename, or Enter to "
      1  f563		       45 6e 74 65*	      .byte.b	"Enter filename, or Enter to "
      0  f57f					      db	"load from console: ",0
      1  f57f		       6c 6f 61 64*	      .byte.b	"load from console: ",0
    715  f593							;
    716  f593		       20 87 f6 	      jsr	getFileName	;get filename
    717  f596		       ad 9a df 	      lda	filename	;null?
    718  f599		       f0 12		      beq	saveHexConsole	;dump to console
    719  f59b							;
    720  f59b							; They selected a file, so try to open it.
    721  f59b							;
    722  f59b		       a2 df		      ldx	#filename>>8
    723  f59d		       a0 9a		      ldy	#filename&$ff
    724  f59f		       20 3f fc 	      jsr	DiskOpenWrite	;attempt to open file
    725  f5a2		       90 03		      bcc	sopenok	;branch if opened ok
    726  f5a4		       4c 5e f4 	      jmp	openfail
    727  f5a7							;
    728  f5a7		       20 ff f9    sopenok    jsr	setOutputFile
    729  f5aa		       4c b0 f5 	      jmp	savehex2
    730  f5ad							;
    731  f5ad							; They are saving to the console.  Set up the output
    732  f5ad							; vector and do the job.
    733  f5ad							;
    734  f5ad		       20 f4 f9    saveHexConsole jsr	setOutputConsole
    735  f5b0							;
    736  f5b0							; Compute the number of bytes to dump
    737  f5b0							;
    738  f5b0		       38	   savehex2   sec
    739  f5b1		       ad 97 df 	      lda	EAL
    740  f5b4		       ed 95 df 	      sbc	SAL
    741  f5b7		       8d ab df 	      sta	Temp16L
    742  f5ba		       ad 98 df 	      lda	EAH
    743  f5bd		       ed 96 df 	      sbc	SAH
    744  f5c0		       8d ac df 	      sta	Temp16H
    745  f5c3		       90 42		      bcc	SDone	;start > end
    746  f5c5		       05 00		      ora	0
    747  f5c7		       30 3e		      bmi	SDone	;more than 32K seems wrong
    748  f5c9							;
    749  f5c9							; Add one to the count
    750  f5c9							;
    751  f5c9		       ee ab df 	      inc	Temp16L
    752  f5cc		       d0 03		      bne	slab1
    753  f5ce		       ee ac df 	      inc	Temp16H
    754  f5d1							;
    755  f5d1							; Move pointer to zero page
    756  f5d1							;
    757  f5d1		       ad 95 df    slab1      lda	SAL
    758  f5d4		       85 f0		      sta	sptr
    759  f5d6		       ad 96 df 	      lda	SAH
    760  f5d9		       85 f1		      sta	sptr+1
    761  f5db							;
    762  f5db							; Top of each loop.  Start by seeing if there are any bytes
    763  f5db							; left to dump.
    764  f5db							;
    765  f5db		       ad ac df    Sloop1     lda	Temp16H
    766  f5de		       d0 2a		      bne	Sgo	;more to do
    767  f5e0		       ad ab df 	      lda	Temp16L
    768  f5e3		       d0 25		      bne	Sgo	;more to do
    769  f5e5							;
    770  f5e5							; At end of the region, so output an end record.  This
    771  f5e5							; probably looks like overkill but keep in mind this
    772  f5e5							; might be going to a file so we can't use the normal
    773  f5e5							; string put functions.
    774  f5e5							;
    775  f5e5		       a9 3a		      lda	#':
    776  f5e7		       20 f1 f9 	      jsr	redirectedOutch
    777  f5ea		       a9 00		      lda	#0
    778  f5ec		       20 d7 f9 	      jsr	HexToOutput
    779  f5ef		       20 d7 f9 	      jsr	HexToOutput
    780  f5f2		       20 d7 f9 	      jsr	HexToOutput
    781  f5f5		       a9 01		      lda	#1
    782  f5f7		       20 d7 f9 	      jsr	HexToOutput
    783  f5fa		       a9 ff		      lda	#$ff
    784  f5fc		       20 d7 f9 	      jsr	HexToOutput
    785  f5ff							;
    786  f5ff							; If output to file, flush and close the file.
    787  f5ff							;
    788  f5ff		       ad 9a df 	      lda	filename
    789  f602		       f0 03		      beq	SDone	;it's going to console
    790  f604		       20 f9 fa 	      jsr	CloseOutFile
    791  f607		       4c fc f0    SDone      jmp	prompt	;back to the monitor
    792  f60a							;
    793  f60a							; This dumps the next line.  See how many bytes are left to do
    794  f60a							; and if more than BYTESLINE, then just do BYTESLINE.
    795  f60a							;
    796  f60a		       ad ac df    Sgo	      lda	Temp16H
    797  f60d		       d0 07		      bne	Sdef	;do default number of bytes
    798  f60f		       ad ab df 	      lda	Temp16L
    799  f612		       c9 10		      cmp	#BYTESLINE
    800  f614		       90 02		      bcc	Scnt	;more than max per line
    801  f616		       a9 10	   Sdef       lda	#BYTESLINE
    802  f618		       8d 99 df    Scnt       sta	tempA	;for decrementing
    803  f61b		       8d aa df 	      sta	ID	;for subtracting
    804  f61e							;
    805  f61e							; Put out the header
    806  f61e							;
    807  f61e		       a9 3a		      lda	#':
    808  f620		       20 f1 f9 	      jsr	redirectedOutch
    809  f623							;
    810  f623		       ad 99 df 	      lda	tempA
    811  f626		       8d a9 df 	      sta	CHKL	;start checksum
    812  f629		       20 d7 f9 	      jsr	HexToOutput
    813  f62c							;
    814  f62c		       a5 f1		      lda	sptr+1	;starting address
    815  f62e		       20 cd f9 	      jsr	updateCrc
    816  f631		       20 d7 f9 	      jsr	HexToOutput
    817  f634		       a5 f0		      lda	sptr
    818  f636		       20 cd f9 	      jsr	updateCrc
    819  f639		       20 d7 f9 	      jsr	HexToOutput
    820  f63c							;
    821  f63c		       a9 00		      lda	#0	;record type - data
    822  f63e		       20 d7 f9 	      jsr	HexToOutput
    823  f641							;
    824  f641							; Now print the proper number of bytes
    825  f641							;
    826  f641		       a0 00	   Sloop2     ldy	#0
    827  f643		       b1 f0		      lda	(sptr),y	;get byte
    828  f645		       20 cd f9 	      jsr	updateCrc
    829  f648		       20 d7 f9 	      jsr	HexToOutput
    830  f64b		       20 73 f9 	      jsr	INCPT	;increment pointer
    831  f64e							;
    832  f64e		       ce 99 df    sdec       dec	tempA
    833  f651		       d0 ee		      bne	Sloop2
    834  f653							;
    835  f653							; Now print checksum
    836  f653							;
    837  f653		       ad a9 df 	      lda	CHKL
    838  f656		       49 ff		      eor	#$ff	;one's complement
    839  f658		       18		      clc
    840  f659		       69 01		      adc	#1	;two's complement
    841  f65b		       20 d7 f9 	      jsr	HexToOutput
    842  f65e							;
    843  f65e							; Output a CR/LF
    844  f65e							;
    845  f65e		       a9 0d		      lda	#CR
    846  f660		       20 f1 f9 	      jsr	redirectedOutch
    847  f663		       a9 0a		      lda	#LF
    848  f665		       20 f1 f9 	      jsr	redirectedOutch
    849  f668							;
    850  f668							; If saving to disk, output a dot to indicate progress.
    851  f668							;
    852  f668		       ad 9a df 	      lda	filename
    853  f66b		       f0 05		      beq	shf2
    854  f66d							;
    855  f66d		       a9 2e		      lda	#'.
    856  f66f		       20 8d fb 	      jsr	cout	;goes to console
    857  f672							;
    858  f672		       38	   shf2       sec
    859  f673		       ad ab df 	      lda	Temp16L
    860  f676		       ed aa df 	      sbc	ID
    861  f679		       8d ab df 	      sta	Temp16L
    862  f67c		       ad ac df 	      lda	Temp16H
    863  f67f		       e9 00		      sbc	#0
    864  f681		       8d ac df 	      sta	Temp16H
    865  f684							;
    866  f684		       4c db f5 	      jmp	Sloop1
    867  f687							;
    868  f687							;=====================================================
    869  f687							; Get a disk filename.
    870  f687							;
    871  f687		       a2 00	   getFileName ldx	#0
    872  f689		       20 9a fb    getFilename1 jsr	cin	;get next key
    873  f68c		       c9 0d		      cmp	#CR	;end of the input?
    874  f68e		       f0 27		      beq	getFnDone
    875  f690		       c9 08		      cmp	#BS	;backspace?
    876  f692		       f0 0d		      beq	getFnDel
    877  f694		       e0 0c		      cpx	#FILENAME_SIZE	;check size
    878  f696		       f0 f1		      beq	getFilename1	;at length limit
    879  f698		       9d 9a df 	      sta	filename,x	;else save it
    880  f69b		       20 8d fb 	      jsr	cout
    881  f69e		       e8		      inx
    882  f69f		       d0 e8		      bne	getFilename1
    883  f6a1							;
    884  f6a1		       ca	   getFnDel   dex
    885  f6a2		       30 10		      bmi	getFnU	;no charac here
    886  f6a4		       a9 08		      lda	#BS
    887  f6a6		       20 8d fb 	      jsr	cout
    888  f6a9		       a9 20		      lda	#$20
    889  f6ab		       20 8d fb 	      jsr	cout
    890  f6ae		       a9 08		      lda	#BS
    891  f6b0		       20 8d fb 	      jsr	cout
    892  f6b3		       ca		      dex
    893  f6b4		       e8	   getFnU     inx		;can't go past start
    894  f6b5		       10 d2		      bpl	getFilename1
    895  f6b7		       a9 00	   getFnDone  lda	#0	;terminate line
    896  f6b9		       9d 9a df 	      sta	filename,x
    897  f6bc		       4c 66 fb 	      jmp	crlf
    898  f6bf							;
    899  f6bf							;=====================================================
    900  f6bf							; Add the byte in A to the output buffer.  If the
    901  f6bf							; buffer is full, flush it to disk.
    902  f6bf							;
    903  f6bf		       ae a7 df    putNextFileByte ldx	diskBufOffset
    904  f6c2		       e0 84		      cpx	#BUFFER_SIZE	;buffer full?
    905  f6c4		       d0 0d		      bne	pNFB	;no
    906  f6c6							;
    907  f6c6							; The buffer is full, so write it out.
    908  f6c6							;
    909  f6c6		       48		      pha		;save byte
    910  f6c7		       a9 84		      lda	#BUFFER_SIZE
    911  f6c9		       a2 df		      ldx	#buffer>>8
    912  f6cb		       a0 0a		      ldy	#buffer&$ff
    913  f6cd		       20 7b fc 	      jsr	DiskWrite
    914  f6d0							;
    915  f6d0		       a2 00		      ldx	#0	;reset index
    916  f6d2		       68		      pla
    917  f6d3		       9d 0a df    pNFB       sta	buffer,x
    918  f6d6		       e8		      inx
    919  f6d7		       8e a7 df 	      stx	diskBufOffset
    920  f6da		       60		      rts
    921  f6db							;
    922  f6db							;*********************************************************
    923  f6db							; Dump the current registers based on values in the Save*
    924  f6db							; locations.
    925  f6db							;
    926  f6db				   DumpRegisters
    927  f6db		       20 08 fb 	      jsr	putsil
      0  f6de					      db	"PC:",0
      1  f6de		       50 43 3a 00	      .byte.b	"PC:",0
    929  f6e2		       ad 92 df 	      lda	SavePC+1
    930  f6e5		       20 49 fb 	      jsr	HexA
    931  f6e8		       ad 91 df 	      lda	SavePC
    932  f6eb		       20 49 fb 	      jsr	HexA
    933  f6ee							;
    934  f6ee		       20 08 fb 	      jsr	putsil
      0  f6f1					      db	" A:",0
      1  f6f1		       20 41 3a 00	      .byte.b	" A:",0
    936  f6f5		       ad 8e df 	      lda	SaveA
    937  f6f8		       20 49 fb 	      jsr	HexA
    938  f6fb							;
    939  f6fb		       20 08 fb 	      jsr	putsil
      0  f6fe					      db	" X:",0
      1  f6fe		       20 58 3a 00	      .byte.b	" X:",0
    941  f702		       ad 8f df 	      lda	SaveX
    942  f705		       20 49 fb 	      jsr	HexA
    943  f708							;
    944  f708		       20 08 fb 	      jsr	putsil
      0  f70b					      db	" Y:",0
      1  f70b		       20 59 3a 00	      .byte.b	" Y:",0
    946  f70f		       ad 90 df 	      lda	SaveY
    947  f712		       20 49 fb 	      jsr	HexA
    948  f715							;
    949  f715		       20 08 fb 	      jsr	putsil
      0  f718					      db	" SP:",0
      1  f718		       20 53 50 3a*	      .byte.b	" SP:",0
    951  f71d		       ad 94 df 	      lda	SaveSP
    952  f720		       20 49 fb 	      jsr	HexA
    953  f723							;
    954  f723							; Last is the condition register.  For this, print the
    955  f723							; actual flags.  Lower case for clear, upper for set.
    956  f723							;
    957  f723		       20 08 fb 	      jsr	putsil
      0  f726					      db	" Flags:",0
      1  f726		       20 46 6c 61*	      .byte.b	" Flags:",0
    959  f72e					      if	FULL_STATUS
    960  f72e							;
    961  f72e							; N - bit 7
    962  f72e							;
    963  f72e		       a9 80		      lda	#$80	;bit to test
    964  f730		       a2 4e		      ldx	#'N	;set ACII char
    965  f732		       20 61 f7 	      jsr	testbit
    966  f735							;
    967  f735							; V - bit 6
    968  f735							;
    969  f735		       a9 40		      lda	#$40	;bit to test
    970  f737		       a2 56		      ldx	#'V	;set ACII char
    971  f739		       20 61 f7 	      jsr	testbit
    972  f73c							;
    973  f73c		       a9 2d		      lda	#'-	;unused bit
    974  f73e		       20 8d fb 	      jsr	cout
    975  f741							;
    976  f741							; B - bit 4
    977  f741							;
    978  f741		       a9 10		      lda	#$10	;bit to test
    979  f743		       a2 42		      ldx	#'B	;set ACII char
    980  f745		       20 61 f7 	      jsr	testbit
    981  f748							;
    982  f748							; D - bit 3
    983  f748							;
    984  f748		       a9 08		      lda	#$08	;bit to test
    985  f74a		       a2 44		      ldx	#'D	;set ACII char
    986  f74c		       20 61 f7 	      jsr	testbit
    987  f74f							;
    988  f74f							; I - bit 2
    989  f74f							;
    990  f74f		       a9 04		      lda	#$04	;bit to test
    991  f751		       a2 49		      ldx	#'I	;set ACII char
    992  f753		       20 61 f7 	      jsr	testbit
    993  f756							;
    994  f756							; Z - bit 1
    995  f756							;
    996  f756		       a9 02		      lda	#$02	;bit to test
    997  f758		       a2 5a		      ldx	#'Z	;set ACII char
    998  f75a		       20 61 f7 	      jsr	testbit
    999  f75d							;
   1000  f75d							; C - bit 0
   1001  f75d							;
   1002  f75d		       a9 01		      lda	#$01	;bit to test
   1003  f75f		       a2 43		      ldx	#'C	;set ACII char
   1004  f761							;
   1005  f761							; Fall through...
   1006  f761							;
   1007  f761							;*********************************************************
   1008  f761							; Given a bit mask in A and an upper case character
   1009  f761							; indicating the flag name in X, see if the flag is set or
   1010  f761							; not.  Output upper case if set, lower case if not.
   1011  f761							;
   1012  f761		       2d 93 df    testbit    and	SaveC	;is bit set?
   1013  f764		       d0 06		      bne	testbit1	;yes
   1014  f766		       8a		      txa
   1015  f767		       09 20		      ora	#$20	;make lower case
   1016  f769		       4c 8d fb 	      jmp	cout
   1017  f76c		       8a	   testbit1   txa
   1018  f76d		       4c 8d fb 	      jmp	cout
   1019  f770				  -	      else
   1020  f770				  -	      lda	SaveSP
   1021  f770				  -	      jmp	HexA
   1022  f770					      endif
   1023  f770							;
   1024  f770							;=====================================================
   1025  f770							; This continues executing from the last saved state,
   1026  f770							; such as from a call to DefaultNMI.
   1027  f770							;
   1028  f770				   doContinue
   1029  f770		       ae 94 df 	      ldx	SaveSP
   1030  f773		       9a		      txs
   1031  f774		       ad 92 df 	      lda	SavePC+1
   1032  f777		       48		      pha
   1033  f778		       ad 91 df 	      lda	SavePC
   1034  f77b		       48		      pha
   1035  f77c		       ad 93 df 	      lda	SaveC
   1036  f77f		       48		      pha
   1037  f780		       ae 8f df 	      ldx	SaveX
   1038  f783		       ac 90 df 	      ldy	SaveY
   1039  f786		       ad 8e df 	      lda	SaveA
   1040  f789		       40		      rti
   1041  f78a							;
   1042  f78a							;=====================================================
   1043  f78a							; This gets two hex characters and returns the value
   1044  f78a							; in A with carry clear.  If a non-hex digit is
   1045  f78a							; entered, then A contans the offending character and
   1046  f78a							; carry is set.
   1047  f78a							;
   1048  f78a		       20 a2 f7    getHex     jsr	getNibble
   1049  f78d		       b0 20		      bcs	getNibBad
   1050  f78f		       0a		      asl		; a
   1051  f790		       0a		      asl		; a
   1052  f791		       0a		      asl		; a
   1053  f792		       0a		      asl		; a
   1054  f793		       29 f0		      and	#$f0
   1055  f795		       8d 99 df 	      sta	tempA
   1056  f798		       20 a2 f7 	      jsr	getNibble
   1057  f79b		       b0 12		      bcs	getNibBad
   1058  f79d		       0d 99 df 	      ora	tempA
   1059  f7a0		       18		      clc
   1060  f7a1		       60		      rts
   1061  f7a2							;
   1062  f7a2							; Helper.  Gets next input char and converts to a
   1063  f7a2							; value from 0-F in A and returns C clear.  If not a
   1064  f7a2							; valid hex character, return C set.
   1065  f7a2							;
   1066  f7a2		       20 36 fa    getNibble  jsr	redirectedGetch
   1067  f7a5		       a2 0f		      ldx	#nibbleHexEnd-nibbleHex-1
   1068  f7a7		       dd b4 f7    getNibble1 cmp	nibbleHex,x
   1069  f7aa		       f0 05		      beq	getNibF	;got match
   1070  f7ac		       ca		      dex
   1071  f7ad		       10 f8		      bpl	getNibble1
   1072  f7af		       38	   getNibBad  sec
   1073  f7b0		       60		      rts
   1074  f7b1
   1075  f7b1		       8a	   getNibF    txa		;index is value
   1076  f7b2		       18		      clc
   1077  f7b3		       60		      rts
   1078  f7b4							;
      0  f7b4				   nibbleHex  db	"0123456789ABCDEF"
      1  f7b4		       30 31 32 33*	      .byte.b	"0123456789ABCDEF"
   1080  f7b4		       f7 c4	   nibbleHexEnd equ	*
   1081  f7c4							;
   1082  f7c4							;=====================================================
   1083  f7c4							; Gets a four digit hex address amd places it in
   1084  f7c4							; SAL and SAH.  Returns C clear if all is well, or C
   1085  f7c4							; set on error and A contains the character.
   1086  f7c4							;
   1087  f7c4		       20 8a f7    getStartAddr jsr	getHex
   1088  f7c7		       b0 0c		      bcs	getDone
   1089  f7c9		       8d 96 df 	      sta	SAH
   1090  f7cc		       20 8a f7 	      jsr	getHex
   1091  f7cf		       b0 04		      bcs	getDone
   1092  f7d1		       8d 95 df 	      sta	SAL
   1093  f7d4		       18		      clc
   1094  f7d5		       60	   getDone    rts
   1095  f7d6							;
   1096  f7d6							;=====================================================
   1097  f7d6							; Gets a four digit hex address and places it in
   1098  f7d6							; EAL and EAH.  Returns C clear if all is well, or C
   1099  f7d6							; set on error and A contains the character.
   1100  f7d6							;
   1101  f7d6		       20 8a f7    getEndAddr jsr	getHex
   1102  f7d9		       b0 fa		      bcs	getDone
   1103  f7db		       8d 98 df 	      sta	EAH
   1104  f7de		       20 8a f7 	      jsr	getHex
   1105  f7e1		       b0 f2		      bcs	getDone
   1106  f7e3		       8d 97 df 	      sta	EAL
   1107  f7e6		       18		      clc
   1108  f7e7		       60		      rts
   1109  f7e8							;
   1110  f7e8							;=====================================================
   1111  f7e8							; Get an address range and leave them in SAL and EAL.
   1112  f7e8							;
   1113  f7e8		       20 08 fb    getAddrRange jsr	putsil
      0  f7eb					      db	"Start: ",0
      1  f7eb		       53 74 61 72*	      .byte.b	"Start: ",0
   1115  f7f3		       20 c4 f7 	      jsr	getStartAddr
   1116  f7f6		       b0 dd		      bcs	getDone
   1117  f7f8		       20 08 fb 	      jsr	putsil
      0  f7fb					      db	", End: ",0
      1  f7fb		       2c 20 45 6e*	      .byte.b	", End: ",0
   1119  f803		       20 d6 f7 	      jsr	getEndAddr
   1120  f806		       60		      rts
   1121  f807							;
   1122  f807							;=====================================================
   1123  f807							; Command handler for the ? command
   1124  f807							;
   1125  f807		       20 08 fb    showHelp   jsr	putsil
      0  f80a					      db	CR,LF
      1  f80a		       0d 0a		      .byte.b	CR,LF
      0  f80c					      db	"Available commands:"
      1  f80c		       41 76 61 69*	      .byte.b	"Available commands:"
      0  f81f					      db	CR,LF,LF,0
      1  f81f		       0d 0a 0a 00	      .byte.b	CR,LF,LF,0
   1129  f823							;
   1130  f823							; Print help for built-in commands...
   1131  f823							;
   1132  f823		       a9 38		      lda	#commandTable&$ff
   1133  f825		       85 f0		      sta	sptr
   1134  f827		       a9 f1		      lda	#commandTable/256
   1135  f829		       85 f1		      sta	sptr+1
   1136  f82b		       20 31 f8 	      jsr	displayHelp	;display help
   1137  f82e							;
   1138  f82e							; Now print help for the extension commands...
   1139  f82e							;
   1140  f82e				  -	      if	EXTENDED_CMDS
   1141  f82e				  -	      lda	ExtensionAddr
   1142  f82e				  -	      sta	sptr
   1143  f82e				  -	      lda	ExtensionAddr+1
   1144  f82e				  -	      sta	sptr+1
   1145  f82e				  -	      jsr	displayHelp
   1146  f82e				  -	      jsr	crlf
   1147  f82e					      endif
   1148  f82e		       4c fc f0 	      jmp	prompt
   1149  f831							;
   1150  f831							;=====================================================
   1151  f831							; Given a pointer to a command table in POINT, display
   1152  f831							; the help text for all commands in the table.
   1153  f831							;
   1154  f831		       a0 00	   displayHelp ldy	#0	;index into command table
   1155  f833		       b1 f0	   showHelpLoop lda	(sptr),y	;get command
   1156  f835		       f0 1c		      beq	showHelpDone	;jump if at end
   1157  f837							;
   1158  f837							; Display this entry's descriptive text
   1159  f837							;
   1160  f837		       c8		      iny		;skip over command
   1161  f838		       c8		      iny		;skip over function ptr
   1162  f839		       c8		      iny
   1163  f83a		       b1 f0		      lda	(sptr),y
   1164  f83c		       85 f2		      sta	INL
   1165  f83e		       c8		      iny
   1166  f83f		       b1 f0		      lda	(sptr),y
   1167  f841		       85 f3		      sta	INH
   1168  f843		       98		      tya
   1169  f844		       48		      pha
   1170  f845		       20 76 fb 	      jsr	space2
   1171  f848		       20 2b fb 	      jsr	puts	;print description
   1172  f84b		       20 66 fb 	      jsr	crlf
   1173  f84e		       68		      pla
   1174  f84f		       a8		      tay
   1175  f850		       c8		      iny		;point to next entry
   1176  f851		       d0 e0		      bne	showHelpLoop
   1177  f853		       60	   showHelpDone rts
   1178  f854							;
   1179  f854							;=====================================================
   1180  f854							; This does a memory test of a region of memory.
   1181  f854							;
   1182  f854							; Asks for the starting and ending locations.
   1183  f854							;
   1184  f854							; This cycles a rolling bit, then adds a ninth
   1185  f854							; pattern to help detect shorted address bits.
   1186  f854							; Ie: 01, 02, 04, 08, 10, 20, 40, 80, BA
   1187  f854							;
   1188  f854		       df 8e	   pattern    equ	SaveA	;re-use some other locations
   1189  f854		       df 8f	   original   equ	SaveX
   1190  f854							;
   1191  f854							; Test patterns
   1192  f854							;
   1193  f854		       00 01	   PATTERN_0  equ	$01
   1194  f854		       00 ba	   PATTERN_9  equ	$ba
   1195  f854							;
   1196  f854		       20 9a fb    memabort   jsr	cin	;eat pending key
   1197  f857		       4c fc f0    cmdRet2    jmp	prompt
   1198  f85a							;
   1199  f85a		       20 08 fb    memTest    jsr	putsil
      0  f85d					      db	"Memory test ",0
      1  f85d		       4d 65 6d 6f*	      .byte.b	"Memory test ",0
   1201  f86a		       20 e8 f7 	      jsr	getAddrRange	;get range
   1202  f86d		       b0 e8		      bcs	cmdRet2	;branch if abort
   1203  f86f							;
   1204  f86f		       20 08 fb 	      jsr	putsil
      0  f872					      db	CR,LF
      1  f872		       0d 0a		      .byte.b	CR,LF
      0  f874					      db	"Testing memory.  Press any key to abort"
      1  f874		       54 65 73 74*	      .byte.b	"Testing memory.  Press any key to abort"
      0  f89b					      db	0
      1  f89b		       00		      .byte.b	0
   1208  f89c		       a9 01		      lda	#PATTERN_0	;only set initial...
   1209  f89e		       8d 8e df 	      sta	pattern	;..pattern once
   1210  f8a1							;
   1211  f8a1							; Start of loop.  This fills/tests one complete pass
   1212  f8a1							; of memory.
   1213  f8a1							;
   1214  f8a1		       20 a5 fb    memTestMain jsr	cstatus	;key pressed?
   1215  f8a4		       d0 ae		      bne	memabort	;branch if yes
   1216  f8a6		       ad 95 df 	      lda	SAL	;reset pointer to start
   1217  f8a9		       85 f0		      sta	sptr
   1218  f8ab		       ad 96 df 	      lda	SAH
   1219  f8ae		       85 f1		      sta	sptr+1
   1220  f8b0							;
   1221  f8b0							; Fill memory with the rolling pattern until the last
   1222  f8b0							; location is filled.
   1223  f8b0							;
   1224  f8b0		       a0 00		      ldy	#0
   1225  f8b2		       ad 8e df 	      lda	pattern
   1226  f8b5		       8d 8f df 	      sta	original
   1227  f8b8		       91 f0	   memTestFill sta	(sptr),y
   1228  f8ba		       c9 ba		      cmp	#PATTERN_9	;at last pattern?
   1229  f8bc		       d0 05		      bne	memFill3
   1230  f8be		       a9 01		      lda	#PATTERN_0	;restart pattern
   1231  f8c0		       4c c8 f8 	      jmp	memFill4
   1232  f8c3							;
   1233  f8c3							; Rotate pattern left one bit
   1234  f8c3							;
   1235  f8c3		       0a	   memFill3   asl		; a
   1236  f8c4		       90 02		      bcc	memFill4	;branch if not overflow
   1237  f8c6		       a9 ba		      lda	#PATTERN_9	;ninth pattern
   1238  f8c8							;
   1239  f8c8							; The new pattern is in A.  Now see if we've reached
   1240  f8c8							; the end of the area to be tested.
   1241  f8c8							;
   1242  f8c8		       48	   memFill4   pha		;save pattern
   1243  f8c9		       a5 f0		      lda	sptr
   1244  f8cb		       cd 97 df 	      cmp	EAL
   1245  f8ce		       d0 07		      bne	memFill5
   1246  f8d0		       a5 f1		      lda	sptr+1
   1247  f8d2		       cd 98 df 	      cmp	EAH
   1248  f8d5		       f0 07		      beq	memCheck
   1249  f8d7							;
   1250  f8d7							; Not done, so move to next address and keep going.
   1251  f8d7							;
   1252  f8d7		       20 73 f9    memFill5   jsr	INCPT
   1253  f8da		       68		      pla		;recover pattern
   1254  f8db		       4c b8 f8 	      jmp	memTestFill
   1255  f8de							;
   1256  f8de							; Okay, memory is filled, so now go back and test it.
   1257  f8de							; We kept a backup copy of the initial pattern to
   1258  f8de							; use, but save the current pattern as the starting
   1259  f8de							; point for the next pass.
   1260  f8de							;
   1261  f8de		       68	   memCheck   pla
   1262  f8df		       8d 8e df 	      sta	pattern	;for next pass
   1263  f8e2		       ad 95 df 	      lda	SAL	;reset pointer to start
   1264  f8e5		       85 f0		      sta	sptr
   1265  f8e7		       ad 96 df 	      lda	SAH
   1266  f8ea		       85 f1		      sta	sptr+1
   1267  f8ec		       ad 8f df 	      lda	original	;restore initial pattern
   1268  f8ef		       a0 00		      ldy	#0
   1269  f8f1		       d1 f0	   memTest2   cmp	(sptr),y
   1270  f8f3		       d0 2c		      bne	memFail
   1271  f8f5		       c9 ba		      cmp	#PATTERN_9
   1272  f8f7		       d0 04		      bne	memTest3
   1273  f8f9							;
   1274  f8f9							; Time to reload the pattern
   1275  f8f9							;
   1276  f8f9		       a9 01		      lda	#PATTERN_0
   1277  f8fb		       d0 05		      bne	memTest4
   1278  f8fd							;
   1279  f8fd							; Rotate pattern left one bit
   1280  f8fd							;
   1281  f8fd		       0a	   memTest3   asl		; a
   1282  f8fe		       90 02		      bcc	memTest4
   1283  f900		       a9 ba		      lda	#PATTERN_9
   1284  f902							;
   1285  f902							; The new pattern is in A.
   1286  f902							;
   1287  f902		       48	   memTest4   pha		;save pattern
   1288  f903		       a5 f0		      lda	sptr
   1289  f905		       cd 97 df 	      cmp	EAL
   1290  f908		       d0 07		      bne	memTest5	;not at end
   1291  f90a		       a5 f1		      lda	sptr+1
   1292  f90c		       cd 98 df 	      cmp	EAH
   1293  f90f		       f0 07		      beq	memDone	;at end of pass
   1294  f911							;
   1295  f911							; Not at end yet, so inc pointer and continue
   1296  f911							;
   1297  f911		       20 73 f9    memTest5   jsr	INCPT
   1298  f914		       68		      pla
   1299  f915		       4c f1 f8 	      jmp	memTest2
   1300  f918							;
   1301  f918							; Another pass has completed.
   1302  f918							;
   1303  f918		       68	   memDone    pla
   1304  f919		       a9 2e		      lda	#'.
   1305  f91b		       20 8d fb 	      jsr	cout
   1306  f91e		       4c a1 f8 	      jmp	memTestMain
   1307  f921							;
   1308  f921							; Failure.  Display the failed address, the expected
   1309  f921							; value and what was actually there.
   1310  f921							;
   1311  f921		       48	   memFail    pha		;save pattern for error report
   1312  f922		       20 08 fb 	      jsr	putsil
      0  f925					      db	CR,LF
      1  f925		       0d 0a		      .byte.b	CR,LF
      0  f927					      db	"Failure at address ",0
      1  f927		       46 61 69 6c*	      .byte.b	"Failure at address ",0
   1315  f93b		       a5 f1		      lda	sptr+1
   1316  f93d		       20 49 fb 	      jsr	HexA
   1317  f940		       a5 f0		      lda	sptr
   1318  f942		       20 49 fb 	      jsr	HexA
   1319  f945		       20 08 fb 	      jsr	putsil
      0  f948					      db	".  Expected ",0
      1  f948		       2e 20 20 45*	      .byte.b	".  Expected ",0
   1321  f955		       68		      pla
   1322  f956		       20 49 fb 	      jsr	HexA
   1323  f959		       20 08 fb 	      jsr	putsil
      0  f95c					      db	" but got ",0
      1  f95c		       20 62 75 74*	      .byte.b	" but got ",0
   1325  f966		       a0 00		      ldy	#0
   1326  f968		       b1 f0		      lda	(sptr),y
   1327  f96a		       20 49 fb 	      jsr	HexA
   1328  f96d		       20 66 fb 	      jsr	crlf
   1329  f970		       4c fc f0    cmdRet4    jmp	prompt
   1330  f973							;
   1331  f973							;=====================================================
   1332  f973							; Increment sptr
   1333  f973							;
   1334  f973		       e6 f0	   INCPT      inc	sptr
   1335  f975		       d0 02		      bne	incpt2
   1336  f977		       e6 f1		      inc	sptr+1
   1337  f979		       60	   incpt2     rts
   1338  f97a							;
   1339  f97a							;=====================================================
   1340  f97a							; Ping the Arduino disk controller.  This just sends the
   1341  f97a							; PING command gets back one character, then returns.
   1342  f97a							; Not much of a test but is sufficient to prove the
   1343  f97a							; link is working.
   1344  f97a							;
   1345  f97a		       20 08 fb    pingDisk   jsr	putsil
      0  f97d					      db	"Ping... ",0
      1  f97d		       50 69 6e 67*	      .byte.b	"Ping... ",0
   1347  f986		       20 c0 fb 	      jsr	DiskPing
   1348  f989		       20 08 fb 	      jsr	putsil
      0  f98c					      db	"success!"
      1  f98c		       73 75 63 63*	      .byte.b	"success!"
      0  f994					      db	CR,LF,0
      1  f994		       0d 0a 00 	      .byte.b	CR,LF,0
   1351  f997		       4c fc f0    doDiskDirEnd jmp	prompt
   1352  f99a							;
   1353  f99a							;=====================================================
   1354  f99a							; Do a disk directory of the SD card.
   1355  f99a							;
   1356  f99a		       20 08 fb    doDiskDir  jsr	putsil
      0  f99d					      db	"Disk Directory..."
      1  f99d		       44 69 73 6b*	      .byte.b	"Disk Directory..."
      0  f9ae					      db	CR,LF,0
      1  f9ae		       0d 0a 00 	      .byte.b	CR,LF,0
   1359  f9b1							;		 jsr	xParInit
   1360  f9b1		       20 d3 fb 	      jsr	DiskDir
   1361  f9b4							;
   1362  f9b4							; Get/Display each entry
   1363  f9b4							;
   1364  f9b4		       a2 df	   doDiskDirLoop ldx	#filename/256	;pointer to buffer
   1365  f9b6		       a0 9a		      ldy	#filename&$ff
   1366  f9b8		       86 f3		      stx	INH	;save for puts
   1367  f9ba		       84 f2		      sty	INL
   1368  f9bc		       20 dd fb 	      jsr	DiskDirNext	;get next entry
   1369  f9bf		       b0 d6		      bcs	doDiskDirEnd	;carry = end of list
   1370  f9c1		       20 73 fb 	      jsr	space3
   1371  f9c4		       20 2b fb 	      jsr	puts	;else print name
   1372  f9c7		       20 66 fb 	      jsr	crlf
   1373  f9ca		       4c b4 f9 	      jmp	doDiskDirLoop	;do next entry
   1374  f9cd							;
   1375  f9cd							;=====================================================
   1376  f9cd							; Adds the character in A to the CRC.	Preserves A.
   1377  f9cd							;
   1378  f9cd		       48	   updateCrc  pha
   1379  f9ce		       18		      clc
   1380  f9cf		       6d a9 df 	      adc	CHKL
   1381  f9d2		       8d a9 df 	      sta	CHKL
   1382  f9d5		       68		      pla
   1383  f9d6		       60		      rts
   1384  f9d7							;
   1385  f9d7							;=====================================================
   1386  f9d7							; Print character in A as two hex digits to the
   1387  f9d7							; current output device (console or file).
   1388  f9d7							;
   1389  f9d7		       48	   HexToOutput pha		;save return value
   1390  f9d8		       48		      pha
   1391  f9d9		       4a		      lsr		;a	;move top nibble to bottom
   1392  f9da		       4a		      lsr		;a
   1393  f9db		       4a		      lsr		;a
   1394  f9dc		       4a		      lsr		;a
   1395  f9dd		       20 e6 f9 	      jsr	hexta	;output nibble
   1396  f9e0		       68		      pla
   1397  f9e1		       20 e6 f9 	      jsr	hexta
   1398  f9e4		       68		      pla		;restore
   1399  f9e5		       60		      rts
   1400  f9e6							;
   1401  f9e6		       29 0f	   hexta      and	#%0001111
   1402  f9e8		       c9 0a		      cmp	#$0a
   1403  f9ea		       18		      clc
   1404  f9eb		       30 02		      bmi	hexta1
   1405  f9ed		       69 07		      adc	#7
   1406  f9ef		       69 30	   hexta1     adc	#'0	;then fall into...
   1407  f9f1							;
   1408  f9f1							;=====================================================
   1409  f9f1							; This is a helper function used for redirected I/O.
   1410  f9f1							; It simply does a jump through the output vector
   1411  f9f1							; pointer to send the character in A to the proper
   1412  f9f1							; device.
   1413  f9f1							;
   1414  f9f1		       6c 08 df    redirectedOutch jmp	(outputVector)
   1415  f9f4							;
   1416  f9f4							;=====================================================
   1417  f9f4							; Set up the output vector to point to the normal
   1418  f9f4							; console output subroutine.
   1419  f9f4							;
   1420  f9f4				   setOutputConsole
   1421  f9f4		       a9 8d		      lda	#cout&$ff
   1422  f9f6		       8d 08 df 	      sta	outputVector
   1423  f9f9		       a9 fb		      lda	#cout/256
   1424  f9fb		       8d 09 df 	      sta	outputVector+1
   1425  f9fe		       60		      rts
   1426  f9ff							;
   1427  f9ff							;=====================================================
   1428  f9ff							; Set up the output vector to point to a file write
   1429  f9ff							; subroutine.
   1430  f9ff							;
   1431  f9ff				   setOutputFile
   1432  f9ff		       a9 bf		      lda	#putNextFileByte&$ff
   1433  fa01		       8d 08 df 	      sta	outputVector
   1434  fa04		       a9 f6		      lda	#putNextFileByte/256
   1435  fa06		       8d 09 df 	      sta	outputVector+1
   1436  fa09							;
   1437  fa09							; Clear counts and offsets so the next read will
   1438  fa09							; cause the file to be read.
   1439  fa09							;
   1440  fa09		       a9 00		      lda	#0
   1441  fa0b		       8d a7 df 	      sta	diskBufOffset
   1442  fa0e		       60		      rts
   1443  fa0f							;
   1444  fa0f							;=====================================================
   1445  fa0f							; Set up the input vector to point to the normal
   1446  fa0f							; console input subroutine.
   1447  fa0f							;
   1448  fa0f				   setInputConsole
   1449  fa0f		       a9 1a		      lda	#cinecho&$ff
   1450  fa11		       8d 06 df 	      sta	inputVector
   1451  fa14		       a9 fa		      lda	#cinecho/256
   1452  fa16		       8d 07 df 	      sta	inputVector+1
   1453  fa19		       60		      rts
   1454  fa1a							;
   1455  fa1a		       20 9a fb    cinecho    jsr	cin
   1456  fa1d		       48		      pha
   1457  fa1e		       20 8d fb 	      jsr	cout
   1458  fa21		       68		      pla
   1459  fa22		       60		      rts
   1460  fa23							;
   1461  fa23							;=====================================================
   1462  fa23							; Set up the input vector to point to a file read
   1463  fa23							; subroutine.
   1464  fa23							;
   1465  fa23				   setInputFile
   1466  fa23		       a9 39		      lda	#getNextFileByte&$ff
   1467  fa25		       8d 06 df 	      sta	inputVector
   1468  fa28		       a9 fa		      lda	#getNextFileByte/256
   1469  fa2a		       8d 07 df 	      sta	inputVector+1
   1470  fa2d							;
   1471  fa2d							; Clear counts and offsets so the next read will
   1472  fa2d							; cause the file to be read.
   1473  fa2d							;
   1474  fa2d		       a9 00		      lda	#0
   1475  fa2f		       8d a7 df 	      sta	diskBufOffset
   1476  fa32		       8d a8 df 	      sta	diskBufLength
   1477  fa35		       60		      rts
   1478  fa36							;
   1479  fa36							;=====================================================
   1480  fa36							; This is a helper function used for redirected I/O.
   1481  fa36							; It simply does a jump through the input vector
   1482  fa36							; pointer to get the next input character.
   1483  fa36							;
   1484  fa36		       6c 06 df    redirectedGetch jmp	(inputVector)
   1485  fa39							;
   1486  fa39							;=====================================================
   1487  fa39							; This gets the next byte from an open disk file.  If
   1488  fa39							; there are no more bytes left, this returns C set.
   1489  fa39							; Else, C is clear and A contains the character.
   1490  fa39							;
   1491  fa39		       ae a7 df    getNextFileByte ldx	diskBufOffset
   1492  fa3c		       ec a8 df 	      cpx	diskBufLength
   1493  fa3f		       d0 14		      bne	hasdata	;branch if still data
   1494  fa41							;
   1495  fa41							; There is no data left in the buffer, so read a
   1496  fa41							; block from the SD system.
   1497  fa41							;
   1498  fa41		       a9 84		      lda	#BUFFER_SIZE
   1499  fa43		       a2 df		      ldx	#buffer>>8
   1500  fa45		       a0 0a		      ldy	#buffer&$ff
   1501  fa47		       20 49 fc 	      jsr	DiskRead
   1502  fa4a		       b0 12		      bcs	getNextEof
   1503  fa4c							;
   1504  fa4c							; A contains the number of bytes actually read.
   1505  fa4c							;
   1506  fa4c		       8d a8 df 	      sta	diskBufLength	;save length
   1507  fa4f		       c9 00		      cmp	#0	;shouldn't happen
   1508  fa51		       f0 0b		      beq	getNextEof
   1509  fa53							;
   1510  fa53		       a2 00		      ldx	#0
   1511  fa55		       bd 0a df    hasdata    lda	buffer,x
   1512  fa58		       e8		      inx
   1513  fa59		       8e a7 df 	      stx	diskBufOffset
   1514  fa5c		       18		      clc
   1515  fa5d		       60		      rts
   1516  fa5e							;
   1517  fa5e		       a9 00	   getNextEof lda	#0
   1518  fa60		       8d a7 df 	      sta	diskBufOffset
   1519  fa63		       8d a8 df 	      sta	diskBufLength
   1520  fa66		       38		      sec
   1521  fa67		       60		      rts
   1522  fa68
   1523  fa68							;page
   1524  fa68							;
   1525  fa68							;========================================jlit 8/2/2022
   1526  fa68							; Remove a file from the disk
   1527  fa68							;
   1528  fa68		       20 08 fb    rmFile     jsr	putsil
      0  fa6b					      db	"Enter filename to rm ",0
      1  fa6b		       45 6e 74 65*	      .byte.b	"Enter filename to rm ",0
   1530  fa81		       20 87 f6 	      jsr	getFileName
   1531  fa84		       a0 9a		      ldy	#filename&$ff
   1532  fa86		       a2 df		      ldx	#filename/256
   1533  fa88							;		jsr	xParInit
   1534  fa88		       20 44 fc 	      jsr	DiskRemoveFile
   1535  fa8b		       90 0f		      bcc	rmOk	; removed ok
   1536  fa8d		       20 08 fb 	      jsr	putsil
      0  fa90					      db	"rm failed"
      1  fa90		       72 6d 20 66*	      .byte.b	"rm failed"
      0  fa99					      db	CR,LF,0
      1  fa99		       0d 0a 00 	      .byte.b	CR,LF,0
   1539  fa9c		       4c fc f0    rmOk       jmp	prompt
   1540  fa9f							;
   1541  fa9f							;=====================================================
   1542  fa9f							; Type the contents of an SD file to console.
   1543  fa9f							;
   1544  fa9f		       20 08 fb    typeFile   jsr	putsil
      0  faa2					      db	"Enter filename to type: ",0
      1  faa2		       45 6e 74 65*	      .byte.b	"Enter filename to type: ",0
   1546  fabb		       20 87 f6 	      jsr	getFileName
   1547  fabe		       a0 9a		      ldy	#filename&$ff
   1548  fac0		       a2 df		      ldx	#filename/256
   1549  fac2							;	     jsr	xParInit
   1550  fac2		       20 0e fc 	      jsr	DiskOpenRead
   1551  fac5		       90 1e		      bcc	typeFile1	;opened ok
   1552  fac7							;
   1553  fac7		       20 08 fb 	      jsr	putsil
      0  faca					      db	CR,LF
      1  faca		       0d 0a		      .byte.b	CR,LF
      0  facc					      db	"Failed to open file"
      1  facc		       46 61 69 6c*	      .byte.b	"Failed to open file"
      0  fadf					      db	CR,LF,0
      1  fadf		       0d 0a 00 	      .byte.b	CR,LF,0
   1557  fae2		       4c fc f0 	      jmp	prompt
   1558  fae5							;
   1559  fae5							; Now just keep reading in bytes and displaying them.
   1560  fae5							;
   1561  fae5		       20 23 fa    typeFile1  jsr	setInputFile	;reading from file
   1562  fae8		       20 39 fa    typeFileLoop jsr	getNextFileByte
   1563  faeb		       b0 06		      bcs	typeEof
   1564  faed		       20 8d fb 	      jsr	cout	;display character
   1565  faf0		       4c e8 fa 	      jmp	typeFileLoop
   1566  faf3							;
   1567  faf3		       20 b2 fc    typeEof    jsr	DiskClose
   1568  faf6		       4c fc f0 	      jmp	prompt
   1569  faf9							;
   1570  faf9							;=====================================================
   1571  faf9							; This flushes any data remaining in the disk buffer
   1572  faf9							; and then closes the file.
   1573  faf9							;
   1574  faf9		       ad a7 df    CloseOutFile lda	diskBufOffset
   1575  fafc		       f0 07		      beq	closeonly
   1576  fafe		       a2 df		      ldx	#buffer>>8
   1577  fb00		       a0 0a		      ldy	#buffer&$ff
   1578  fb02		       20 7b fc 	      jsr	DiskWrite
   1579  fb05							;
   1580  fb05		       4c b2 fc    closeonly  jmp	DiskClose
   1581  fb08							;
------- FILE io.asm LEVEL 2 PASS 2
      0  fb08					      include	"io.asm"
      1  fb08					      Processor	6502
      2  fb08							;*********************************************************
      3  fb08							; FILE: io.asm
      4  fb08							;
      5  fb08							; This contains slightly higher level console related
      6  fb08							; functions like text output, reading a line, etc.
      7  fb08							;*********************************************************
      8  fb08							;
      9  fb08							;
     10  fb08		       00 00	   EnableGetline equ	0	;Disable the Getline function
     11  fb08		       00 00	   EnableParse equ	0	;Disable the parse line function
     12  fb08				  -	      if	EnableGetline
     13  fb08				  -	      SEG.U	RomScratch
     14  fb08				  -BUFFER     ds	BUFFER_SIZE
     15  fb08				  -argc       ds	1
     16  fb08				  -argv       ds	MAX_ARGC
     17  fb08					      endif
     18  fb08					      Seg	Code
     19  fb08							;
     20  fb08							;*********************************************************
     21  fb08							; Print the string that follows the JSR to this code.
     22  fb08							; Taken from http://www.6502.org/source/io/primm.htm
     23  fb08							; The last example by Ross Archer.
     24  fb08							;
     25  fb08		       68	   putsil     pla		;Get the low part of "return" address
     26  fb09							;(data start address)
     27  fb09		       85 f4		      sta	putsp
     28  fb0b		       68		      pla
     29  fb0c		       85 f5		      sta	putsp+1	;Get the high part of "return" address
     30  fb0e							;(data start address)
     31  fb0e							;Note: actually we're pointing one short
     32  fb0e		       a0 01	   PSINB      ldy	#1
     33  fb10		       b1 f4		      lda	(putsp),y	;Get the next string character
     34  fb12		       e6 f4		      inc	putsp	;update the pointer
     35  fb14		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
     36  fb16		       e6 f5		      inc	putsp+1	;account for page crossing
     37  fb18		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
     38  fb1a							;   Accumulator
     39  fb1a		       f0 06		      beq	PSIX1	;don't print the final NULL
     40  fb1c		       20 8d fb 	      jsr	cout	;write it out
     41  fb1f		       4c 0e fb 	      jmp	PSINB	;back around
     42  fb22		       e6 f4	   PSIX1      inc	putsp
     43  fb24		       d0 02		      bne	PSIX2
     44  fb26		       e6 f5		      inc	putsp+1	;account for page crossing
     45  fb28		       6c f4 00    PSIX2      jmp	(putsp)	;return to byte following final NULL
     46  fb2b							;
     47  fb2b							;=====================================================
     48  fb2b							; This prints the null terminated string pointed to by
     49  fb2b							; INL and INH.  Modifies those locations to point to
     50  fb2b							; the end of the string.
     51  fb2b							;
     52  fb2b		       a0 00	   puts       ldy	#0
     53  fb2d		       b1 f2	   putsy      lda	(INL),y
     54  fb2f		       e6 f2		      inc	INL
     55  fb31		       d0 02		      bne	puts1
     56  fb33		       e6 f3		      inc	INH
     57  fb35		       09 00	   puts1      ora	#0
     58  fb37		       f0 0c		      beq	putsdone
     59  fb39		       8c 90 df 	      sty	SaveY
     60  fb3c		       20 8d fb 	      jsr	cout	;print character
     61  fb3f		       ac 90 df 	      ldy	SaveY
     62  fb42		       4c 2d fb 	      jmp	putsy
     63  fb45		       60	   putsdone   rts
     64  fb46							;
     65  fb46							;*********************************************************
     66  fb46							; Get a line of text from the console and put it into
     67  fb46							; BUFFER.  This only allows printable characters, will
     68  fb46							; limit the amount of text to BUFFER_SIZE-1 characters,
     69  fb46							; and allows some editing.  Returns the string with a null
     70  fb46							; byte at the end and the length in A.  If the length is
     71  fb46							; zero, return Z set.
     72  fb46							;
     73  fb46				   getline
     74  fb46				  -	      if	EnableGetline
     75  fb46				  -	      ldx	#0
     76  fb46				  -	      beq	getline1
     77  fb46				  -			;
     78  fb46				  -			; This outputs a bell.  Used when the user
     79  fb46				  -			; does something bad, like non-printable
     80  fb46				  -			; characters or exceeding line length.
     81  fb46				  -			;
     82  fb46				  -getline2   lda	#BELL
     83  fb46				  -	      jsr	cout
     84  fb46				  -			;
     85  fb46				  -			; Get the next character
     86  fb46				  -			;
     87  fb46				  -getline1   jsr	cin	;get character
     88  fb46				  -	      cmp	#' '
     89  fb46				  -	      bcc	getline2	;not printable
     90  fb46				  -	      cmp	#'~'+1
     91  fb46				  -	      bcs	getline2	;not printable
     92  fb46				  -	      cmp	#CR	;end of input?
     93  fb46				  -	      beq	getline3
     94  fb46				  -	      cpx	#BUFFER_SIZE-1
     95  fb46				  -	      beq	getline1	;too long
     96  fb46				  -	      sta	BUFFER,x
     97  fb46				  -	      jsr	cout	;echo, echo, echo...
     98  fb46				  -	      inx
     99  fb46				  -	      bne	getline1
    100  fb46				  -			;
    101  fb46				  -			; Got a CR, so terminate the string.
    102  fb46				  -			;
    103  fb46				  -getline3   lda	#0
    104  fb46				  -	      sta	BUFFER,x
    105  fb46				  -	      txa		;will set/clear Z
    106  fb46					      endif
    107  fb46		       60		      rts
    108  fb47							;
    109  fb47							;*********************************************************
    110  fb47							; This converts the buffer to all lower case.
    111  fb47							;
    112  fb47				   ToLower
    113  fb47				  -	      if	EnableParse
    114  fb47				  -	      ldx	#0
    115  fb47				  -ToLower1   lda	BUFFER,x
    116  fb47				  -	      beq	ToLowerDone
    117  fb47				  -			;
    118  fb47				  -	      cmp	#'a
    119  fb47				  -	      bcc	ToLower2
    120  fb47				  -	      cmp	#'z+1
    121  fb47				  -	      bcs	ToLower2
    122  fb47				  -	      clc
    123  fb47				  -	      sbc	#$20	;convert
    124  fb47				  -	      sta	BUFFER,x
    125  fb47				  -ToLower2   inx
    126  fb47				  -	      bne	ToLower1
    127  fb47					      endif
    128  fb47		       60	   ToLowerDone rts
    129  fb48							;
    130  fb48							;*********************************************************
    131  fb48							; This parses the current contents of BUFFER.	It scans
    132  fb48							; until finding whitespace, terminates the string (puts a
    133  fb48							; null), then scans until finding the next non-whitespace
    134  fb48							; and repeats the process again.  Saves the offset to each
    135  fb48							; word in argc, and has a total count in argv.  Yes, I am
    136  fb48							; a C programmer.
    137  fb48							;
    138  fb48				   parse
    139  fb48				  -	      if	EnableParse
    140  fb48				  -	      ldx	#0
    141  fb48				  -	      stx	argc	;clear count
    142  fb48				  -	      dex
    143  fb48				  -			;
    144  fb48				  -			; Skip whitespace
    145  fb48				  -			;
    146  fb48				  -parse1     inx
    147  fb48				  -	      lda	BUFFER,x
    148  fb48				  -	      beq	parse2	;at EOL
    149  fb48				  -	      cmp	#' '
    150  fb48				  -	      beq	parse1	;whitespace
    151  fb48				  -			;
    152  fb48				  -			; Not whitespace
    153  fb48				  -			;
    154  fb48				  -	      ldy	argc
    155  fb48				  -	      stx	argv,y
    156  fb48				  -	      iny
    157  fb48				  -	      cpy	#MAX_ARGC
    158  fb48				  -	      beq	parse2
    159  fb48				  -	      sty	argv
    160  fb48				  -			;
    161  fb48				  -			; Now skip until whitespace found again
    162  fb48				  -			;
    163  fb48				  -parse3     inx
    164  fb48				  -	      lda	BUFFER,x
    165  fb48				  -	      beq	parse2
    166  fb48				  -	      cmp	#' '
    167  fb48				  -	      bne	parse3
    168  fb48				  -	      lda	#0
    169  fb48				  -	      sta	BUFFER,x	;terminate
    170  fb48				  -	      jmp	parse1
    171  fb48				  -			;
    172  fb48					      endif
    173  fb48		       60	   parse2     rts
    174  fb49							;
    175  fb49							;*********************************************************
    176  fb49							; Dump the contents of A as two hex digits.  Preserves
    177  fb49							; all registers.
    178  fb49							;
    179  fb49		       48	   HexA       pha		;save value
    180  fb4a		       48		      pha
    181  fb4b		       4a		      lsr		;a
    182  fb4c		       4a		      lsr		;a
    183  fb4d		       4a		      lsr		;a
    184  fb4e		       4a		      lsr		;a
    185  fb4f		       20 58 fb 	      jsr	HexDigit
    186  fb52		       68		      pla
    187  fb53		       20 58 fb 	      jsr	HexDigit
    188  fb56		       68		      pla		;restore value
    189  fb57		       60		      rts
    190  fb58							;
    191  fb58		       29 0f	   HexDigit   and	#$0f
    192  fb5a		       c9 0a		      cmp	#$0a
    193  fb5c		       18		      clc
    194  fb5d		       30 02		      bmi	HexDigit1
    195  fb5f		       69 07		      adc	#7
    196  fb61		       69 30	   HexDigit1  adc	#'0
    197  fb63		       4c 8d fb 	      jmp	cout
    198  fb66							;
    199  fb66							;*********************************************************
    200  fb66							; Output a CR/LF combination to the console.  Preserves
    201  fb66							; all registers.
    202  fb66							;
    203  fb66		       48	   crlf       pha
    204  fb67		       a9 0d		      lda	#CR
    205  fb69		       20 8d fb 	      jsr	cout
    206  fb6c		       a9 0a		      lda	#LF
    207  fb6e		       20 8d fb 	      jsr	cout
    208  fb71		       68		      pla
    209  fb72		       60		      rts
    210  fb73							;
    211  fb73							;*********************************************************
    212  fb73							; Output one, two or three spaces.  Preserves all
    213  fb73							; register.
    214  fb73							;
    215  fb73		       20 79 fb    space3     jsr	space
    216  fb76		       20 79 fb    space2     jsr	space
    217  fb79		       48	   space      pha
    218  fb7a		       a9 20		      lda	#$20
    219  fb7c		       20 8d fb 	      jsr	cout
    220  fb7f		       68		      pla
    221  fb80		       60		      rts
    222  fb81
    223  fb81
------- FILE ctmon65.asm
------- FILE acia.asm LEVEL 2 PASS 2
      0  fb81					      include	"acia.asm"
      1  fb81					      processor	6502
      2  fb81					      Seg	Code
      3  fb81							;*********************************************************
      4  fb81							; FILE: acia.asm
      5  fb81							;*********************************************************
      6  fb81							;
      7  fb81		       00 00	   CONSOLE_SLOT equ	0
      8  fb81							;
      9  fb81		       e0 00	   ACIA       equ	(CONSOLE_SLOT*IO_SIZE)+IO_BASE
     10  fb81		       00 01	   RDRF       equ	%00000001
     11  fb81		       00 02	   TDRE       equ	%00000010
     12  fb81							;
     13  fb81							;*********************************************************
     14  fb81							; Initialize the ACIA
     15  fb81							;
     16  fb81		       a9 03	   cinit      lda	#%00000011	;reset
     17  fb83		       8d 00 e0 	      sta	ACIA
     18  fb86		       ea		      nop
     19  fb87		       a9 11		      lda	#%00010001	;8N2
     20  fb89		       8d 00 e0 	      sta	ACIA
     21  fb8c		       60		      rts
     22  fb8d							;
     23  fb8d							;*********************************************************
     24  fb8d							; Output the character in A to the console.  This will
     25  fb8d							; block until the character is queued.  Preserves all
     26  fb8d							; registers.
     27  fb8d							;
     28  fb8d		       48	   cout       pha
     29  fb8e		       ad 00 e0    cout1      lda	ACIA
     30  fb91		       29 02		      and	#TDRE
     31  fb93		       f0 f9		      beq	cout1	;not empty
     32  fb95		       68		      pla
     33  fb96		       8d 01 e0 	      sta	ACIA+1
     34  fb99		       60		      rts
     35  fb9a							;
     36  fb9a							;*********************************************************
     37  fb9a							; Gets a character from the console and returns it in A.
     38  fb9a							; Modifies no other registers.  This blocks until a
     39  fb9a							; character is available.
     40  fb9a							;
     41  fb9a		       ad 00 e0    cin	      lda	ACIA
     42  fb9d		       29 01		      and	#RDRF
     43  fb9f		       f0 f9		      beq	cin
     44  fba1		       ad 01 e0 	      lda	ACIA+1
     45  fba4		       60		      rts
     46  fba5							;
     47  fba5							;*********************************************************
     48  fba5							; Get the status of the console.  Returns Z set if no
     49  fba5							; characters are available, Z clear if a character is
     50  fba5							; ready.
     51  fba5							;
     52  fba5		       ad 00 e0    cstatus    lda	ACIA
     53  fba8		       29 01		      and	#RDRF
     54  fbaa		       60		      rts
------- FILE ctmon65.asm
   1584  fbab
   1585  fbab					      if	SD_ENABLED
------- FILE parproto.inc LEVEL 2 PASS 2
      0  fbab					      include	"parproto.inc"
      1  fbab					      Processor	6502
      2  fbab							;*****************************************************
      3  fbab							; Parallel port protocol
      4  fbab							;
      5  fbab							; This is the header file for making applications
      6  fbab							; compliant with The Remote Disk Protocol Guide which
      7  fbab							; is on the Corsham Technologies web page somewhere:
      8  fbab							;
      9  fbab							;    www.corshamtech.com
     10  fbab							;
     11  fbab							; This was updated 06/13/2015 to be compliant with the
     12  fbab							; official specification, so the opcode values changed.
     13  fbab							;
     14  fbab							; Another update on 09/04/2017
     15  fbab							;
     16  fbab							;=====================================================
     17  fbab							; Commands from host to Arduino
     18  fbab							;
     19  fbab		       00 01	   PC_GET_VERSION equ	$01
     20  fbab		       00 05	   PC_PING    equ	$05	;ping Arduino
     21  fbab		       00 06	   PC_LED_CONTROL equ	$06	;LED control
     22  fbab		       00 10	   PC_GET_DIR equ	$10	;Get directory
     23  fbab		       00 11	   PC_GET_MOUNTED equ	$11	;Get mounted drive list
     24  fbab		       00 12	   PC_MOUNT   equ	$12	;Mount drive
     25  fbab		       00 13	   PC_UNMOUNT equ	$13	;Unmount drive
     26  fbab		       00 14	   PC_GET_STATUS equ	$14	;Get status for one drive
     27  fbab		       00 15	   PC_DONE    equ	$15	;Stop data
     28  fbab		       00 15	   PC_ABORT   equ	PC_DONE
     29  fbab		       00 16	   PC_READ_FILE equ	$16	;Read regular file (non-DSK)
     30  fbab		       00 17	   PC_READ_BYTES equ	$17	;Read sequential bytes
     31  fbab		       00 18	   PC_RD_SECTOR equ	$18	;Read FLEX sector
     32  fbab		       00 19	   PC_WR_SECTOR equ	$19	;Write FLEX sector
     33  fbab		       00 1a	   PC_GET_MAX equ	$1a	;Get maximum drives
     34  fbab		       00 1b	   PC_WRITE_FILE equ	$1b	;Open file for writing
     35  fbab		       00 1c	   PC_WRITE_BYTES equ	$1c	;Data to be written
     36  fbab		       00 1d	   PC_SAVE_CONFIG equ	$1d	;Save SD.CFG with current values
     37  fbab		       00 1e	   PC_SET_TIMER equ	$1e	;Set RTC timer
     38  fbab		       00 1f	   PC_WR_SEC_LONG equ	$1f	;Write sector with long sec num
     39  fbab		       00 20	   PC_RD_SEC_LONG equ	$20	;Read sector with long sec num
     40  fbab		       00 21	   PC_RM_FILE equ	$21	;remove a file non-dsk
     41  fbab							;
     42  fbab							;=====================================================
     43  fbab							; Responses from Arduino to host
     44  fbab							;
     45  fbab		       00 81	   PR_VERSION_INFO equ	$81	;Contains version information
     46  fbab		       00 82	   PR_ACK     equ	$82	;ACK (no additional information)
     47  fbab		       00 83	   PR_NAK     equ	$83	;NAK - one status byte follows
     48  fbab		       00 85	   PR_PONG    equ	$85	;Reply to a ping
     49  fbab		       00 90	   PR_DIR_ENTRY equ	$90	;Directory entry
     50  fbab		       00 91	   PR_DIR_END equ	$91	;End of directory entries
     51  fbab		       00 92	   PR_FILE_DATA equ	$92	;File data
     52  fbab		       00 93	   PR_STATUS  equ	$93	;Drive status
     53  fbab		       00 94	   PR_SECTOR_DATA equ	$94	;Sector data
     54  fbab		       00 95	   PR_MOUNT_INFO equ	$95	;Mount entry
     55  fbab		       00 96	   PR_MAX_DRIVES equ	$96	;Maximum number of drives
     56  fbab							;
     57  fbab							;=====================================================
     58  fbab							; Error codes for NAK events.	Yes, these are in
     59  fbab							; decimal due to an error in the original
     60  fbab							; documentation.
     61  fbab							;
     62  fbab		       00 00	   ERR_NONE   equ	0
     63  fbab		       00 0a	   ERR_NOT_MOUNTED equ	10
     64  fbab		       00 0b	   ERR_MOUNTED equ	11
     65  fbab		       00 0c	   ERR_NOT_FOUND equ	12
     66  fbab		       00 0d	   ERR_READ_ONLY equ	13
     67  fbab		       00 0e	   ERR_BAD_DRIVE equ	14
     68  fbab		       00 0f	   ERR_BAD_TRACK equ	15
     69  fbab		       00 10	   ERR_BAD_SECTOR equ	16
     70  fbab		       00 11	   ERR_READ_ERROR equ	17
     71  fbab		       00 12	   ERR_WRITE_ERROR equ	18
     72  fbab		       00 13	   ERR_NOT_PRESENT equ	19
     73  fbab		       00 14	   ERR_NOT_IMPL equ	20	;Command not implemented
     74  fbab
------- FILE ctmon65.asm
------- FILE pario.asm LEVEL 2 PASS 2
      0  fbab					      include	"pario.asm"
      1  fbab					      Processor	6502
      2  fbab							;CTMON65 version using a 6821
      3  fbab
      4  fbab							;*****************************************************
      5  fbab							; These are the low-level I/O routines to talk to the
      6  fbab							; Arduino processor connected to the KIM's I/O port.
      7  fbab							;
      8  fbab							; August 2014, Bob Applegate K2UT, bob@corshamtech.com
      9  fbab							;
     10  fbab							; Which port bits are used for what:
     11  fbab							;
     12  fbab							; A0 = Data 0, alternates input/output
     13  fbab							; A1 = Data 1, alternates input/output
     14  fbab							; A2 = Data 2, alternates input/output
     15  fbab							; A3 = Data 3, alternates input/output
     16  fbab							; A4 = Data 4, alternates input/output
     17  fbab							; A5 = Data 5, alternates input/output
     18  fbab							; A6 = Data 6, alternates input/output
     19  fbab							; A7 = Data 7, alternates input/output
     20  fbab							;
     21  fbab							; B0 = Direction bit, always output
     22  fbab							; B1 = Write strobe or ACK, always output
     23  fbab							; B2 = Read strobe or ACK, always input
     24  fbab							;
     25  fbab							;----------------------------------------------------
     26  fbab							; Bits in the B register
     27  fbab							;
     28  fbab		       00 01	   DIRECTION  equ	%00000001
     29  fbab		       00 02	   PSTROBE    equ	%00000010
     30  fbab		       00 04	   ACK	      equ	%00000100
     31  fbab							;
     32  fbab							;----------------------------------------------------
     33  fbab							; Which slot the parallel board is in.  This needs to
     34  fbab							; be set for the system in use.  As long as the user
     35  fbab							; programs only call functions in here, no other
     36  fbab							; file/application should know which slot the board
     37  fbab							; is in.
     38  fbab							;
     39  fbab		       00 01	   PIASLOT    equ	1
     40  fbab							;
     41  fbab							; Computed addresses of 6821 registers
     42  fbab							;
     43  fbab		       e0 10	   PIABASE    equ	IO_BASE+(PIASLOT*IO_SIZE)
     44  fbab		       e0 10	   PIAREGA    equ	PIABASE	;data reg A
     45  fbab		       e0 10	   PIADDRA    equ	PIABASE	;data dir reg A
     46  fbab		       e0 11	   PIACTLA    equ	PIABASE+1	;control reg A
     47  fbab		       e0 12	   PIAREGB    equ	PIABASE+2	;data reg B
     48  fbab		       e0 12	   PIADDRB    equ	PIABASE+2	;data dir reg B
     49  fbab		       e0 13	   PIACTLB    equ	PIABASE+3	;control reg B
     50  fbab
     51  fbab					      Seg	Code
     52  fbab							;page
     53  fbab							;
     54  fbab							;*****************************************************
     55  fbab							; This is the initialization function.  Call before
     56  fbab							; doing anything else with the parallel port.
     57  fbab							;
     58  fbab				   xParInit
     59  fbab							;
     60  fbab							; Set up the data direction register for port B so that
     61  fbab							; the DIRECTION and PSTROBE bits are output.
     62  fbab							;
     63  fbab							;		  lda	#0		       ;select DDR
     64  fbab							;		  sta	PIACTLB		       ;...for port B
     65  fbab							;		  lda	#DIRECTION | PSTROBE
     66  fbab							;		  sta	PIADDRB
     67  fbab							;		  lda	#4		       ;select data reg
     68  fbab							;		  sta	PIACTLB
     69  fbab							;
     70  fbab							; Fall through to set up for writes...
     71  fbab							;
     72  fbab							;page
     73  fbab							;*****************************************************
     74  fbab							; This sets up for writing to the Arduino.  Sets up
     75  fbab							; direction registers, drives the direction bit, etc.
     76  fbab							;
     77  fbab		       a9 00	   xParSetWrite lda	#0	;select DDR
     78  fbad							;		 sta	PIACTLA	     ;...for port A
     79  fbad							;		 lda	#$ff		     ;set bits for output
     80  fbad							;		 sta	PIADDRA
     81  fbad							;		 lda	#4		     ;select data reg
     82  fbad							;		 sta	PIACTLA
     83  fbad							;
     84  fbad							; Set direction flag to output, clear ACK bit
     85  fbad							;
     86  fbad							;		lda	#DIRECTION
     87  fbad							;		sta	PIAREGB
     88  fbad		       60		      rts
     89  fbae							;page
     90  fbae							;*****************************************************
     91  fbae							; This sets up for reading from the Arduino.  Sets up
     92  fbae							; direction registers, clears the direction bit, etc.
     93  fbae							;
     94  fbae		       a9 00	   xParSetRead lda	#0	;select DDR
     95  fbb0							;		 sta	PIACTLA		 ;...for port A
     96  fbb0							;		 lda	#$00		 ;set bits for input
     97  fbb0							;		 sta	PIADDRA
     98  fbb0							;		 lda	#4		 ;select data reg
     99  fbb0							;		 sta	PIACTLA
    100  fbb0							;
    101  fbb0							; Set direction flag to input, clear ACK bit
    102  fbb0							;
    103  fbb0							;		lda	#0
    104  fbb0							;		sta	PIAREGB
    105  fbb0		       60		      rts
    106  fbb1							;page
    107  fbb1							;*****************************************************
    108  fbb1							; This writes a single byte to the Arduino.  On entry,
    109  fbb1							; the byte to write is in A.  This assumes ParSetWrite
    110  fbb1							; was already called.
    111  fbb1							;
    112  fbb1							; Destroys A, all other registers preserved.
    113  fbb1							;
    114  fbb1							; Write cycle:
    115  fbb1							;
    116  fbb1							;    1. Wait for other side to lower ACK.
    117  fbb1							;    2. Put data onto the bus.
    118  fbb1							;    3. Set DIRECTION and PSTROBE to indicate data
    119  fbb1							;	 is valid and ready to read.
    120  fbb1							;    4. Wait for ACK line to go high, indicating the
    121  fbb1							;	 other side has read the data.
    122  fbb1							;    5. Lower PSTROBE.
    123  fbb1							;    6. Wait for ACK to go low, indicating end of
    124  fbb1							;	 transfer.
    125  fbb1							;messed up for emulator, we need to protocols
    126  fbb1				   xParWriteByte
    127  fbb1							;		  pha		      ;save data
    128  fbb1							;Parwl22	  lda	PIAREGB	 ;check status
    129  fbb1							;		  and	#ACK
    130  fbb1							;		  bne	Parwl22	 ;wait for ACK to go low
    131  fbb1							;
    132  fbb1							; Now put the data onto the bus
    133  fbb1							;
    134  fbb1							;		 pla
    135  fbb1		       8d 10 e0 	      sta	PIAREGA
    136  fbb4							;
    137  fbb4							; Raise the strobe so the Arduino knows there is
    138  fbb4							; new data.
    139  fbb4							;
    140  fbb4							;		  lda	PIAREGB
    141  fbb4							;		  ora	#PSTROBE
    142  fbb4							;		  sta	PIAREGB
    143  fbb4							;
    144  fbb4							; Wait for ACK to go high, indicating the Arduino has
    145  fbb4							; pulled the data and is ready for more.
    146  fbb4							;
    147  fbb4							;Parwl33	  lda	PIAREGB
    148  fbb4							;		  and	#ACK
    149  fbb4							;		  beq	Parwl33
    150  fbb4							;
    151  fbb4							; Now lower the strobe, then wait for the Arduino to
    152  fbb4							; lower ACK.
    153  fbb4							;
    154  fbb4							;		  lda	PIAREGB
    155  fbb4							;		  and	#~PSTROBE
    156  fbb4							;		  sta	PIAREGB
    157  fbb4							;Parwl44	  lda	PIAREGB
    158  fbb4							;		  and	#ACK
    159  fbb4							;		  bne	Parwl44
    160  fbb4		       60		      rts
    161  fbb5							;page
    162  fbb5							;*****************************************************
    163  fbb5							; This reads a byte from the Arduino and returns it in
    164  fbb5							; A.  Assumes ParSetRead was called before.
    165  fbb5							;
    166  fbb5							; This does not have a time-out.
    167  fbb5							;
    168  fbb5							; Preserves all other registers.
    169  fbb5							;
    170  fbb5							; Read cycle:
    171  fbb5							;
    172  fbb5							;    1. Wait for other side to raise ACK, indicating
    173  fbb5							;	 data is ready.
    174  fbb5							;    2. Read data.
    175  fbb5							;    3. Raise PSTROBE indicating data was read.
    176  fbb5							;    4. Wait for ACK to go low.
    177  fbb5							;    5. Lower PSTROBE.
    178  fbb5							;
    179  fbb5		       ad 12 e0    xParReadByte lda	PIAREGB
    180  fbb8		       29 04		      and	#ACK	;is their strobe high?
    181  fbba		       f0 f9		      beq	xParReadByte	;nope, no data
    182  fbbc							;
    183  fbbc							; Data is available, so grab and save it.
    184  fbbc							;
    185  fbbc		       ad 10 e0 	      lda	PIAREGA
    186  fbbf							;		  pha
    187  fbbf							;
    188  fbbf							; Now raise our strobe (their ACK), then wait for
    189  fbbf							; them to lower their strobe.
    190  fbbf							;
    191  fbbf							;		  lda	PIAREGB
    192  fbbf							;		  ora	#PSTROBE
    193  fbbf							;		  sta	PIAREGB
    194  fbbf							;Parrlp1	  lda	PIAREGB
    195  fbbf							;		  and	#ACK
    196  fbbf							;		  bne	Parrlp1		    ;still active
    197  fbbf							;
    198  fbbf							; Lower our ack, then were done.
    199  fbbf							;
    200  fbbf							;		  lda	PIAREGB
    201  fbbf							;		  and	#~PSTROBE
    202  fbbf							;		  sta	PIAREGB
    203  fbbf							;		  pla
    204  fbbf		       60		      rts
------- FILE ctmon65.asm
------- FILE diskfunc.asm LEVEL 2 PASS 2
      0  fbc0					      include	"diskfunc.asm"
      1  fbc0					      Processor	6502
      2  fbc0							;=====================================================
      3  fbc0							; This is a collection of functions for performing
      4  fbc0							; higher level disk functions.  This hides the nasty
      5  fbc0							; details of communications with the remote disk
      6  fbc0							; system.
      7  fbc0							;
      8  fbc0							; August 20, 2014 - Bob Applegate
      9  fbc0							;		     bob@corshamtech.com
     10  fbc0							;
     11  fbc0							; 06/14/2015 - Bob Applegate
     12  fbc0							;		Now that there is an official standard
     13  fbc0							;		for the protocol between the host (this
     14  fbc0							;		code) and the DCP (Arduino code), this
     15  fbc0							;		code has been updated to be compliant.
     16  fbc0							;
     17  fbc0							; 01/14/2016 - Bob Applegate
     18  fbc0							;		Finally converted to 6502.
     19  fbc0							;
     20  fbc0							; 02/8/2022  - JustLostInTime
     21  fbc0							;		added ability to remove disk file non-dsk
     22  fbc0							;
     23  fbc0							;		include	"parproto.inc"
     24  fbc0							;
     25  fbc0							; Number of drives emulated
     26  fbc0							;
     27  fbc0					      Seg	Code
     28  fbc0		       00 04	   DRIVES     equ	4
     29  fbc0							;
     30  fbc0							;=====================================================
     31  fbc0							; This is a sanity check to verify connectivity to the
     32  fbc0							; Arduino code is working.  Returns C clear if all is
     33  fbc0							; good, or C set if not.
     34  fbc0							;
     35  fbc0		       20 ab fb    DiskPing   jsr	xParSetWrite
     36  fbc3		       a9 05		      lda	#PC_PING	;command
     37  fbc5		       20 b1 fb 	      jsr	xParWriteByte	;send to Arduino
     38  fbc8		       20 ae fb 	      jsr	xParSetRead
     39  fbcb		       20 b5 fb 	      jsr	xParReadByte	;read their reply
     40  fbce		       20 ab fb    DiskRetGood jsr	xParSetWrite
     41  fbd1		       18		      clc		;assume it's good
     42  fbd2		       60		      rts
     43  fbd3							;page
     44  fbd3							;=====================================================
     45  fbd3							; This starts a directory read of the raw drive, not
     46  fbd3							; the mounted drive.  No input parameters.  This simply
     47  fbd3							; sets up for reading the entries, then the user must
     48  fbd3							; read each entry.
     49  fbd3							;
     50  fbd3							; Returns with C clear on success.  If error, C is set
     51  fbd3							; and A contains the error code.
     52  fbd3							;
     53  fbd3		       20 ab fb    DiskDir    jsr	xParSetWrite
     54  fbd6		       a9 10		      lda	#PC_GET_DIR	;send command
     55  fbd8		       20 b1 fb 	      jsr	xParWriteByte
     56  fbdb		       18		      clc		;assume it works
     57  fbdc		       60		      rts
     58  fbdd							;page
     59  fbdd							;=====================================================
     60  fbdd							; Read the next directory entry.  On input, X (MSB)
     61  fbdd							; and Y (LSB) point to a 13 byte area to receive the
     62  fbdd							; drive data.
     63  fbdd							;
     64  fbdd							; Returns C set if end of directory (ie, attempt to
     65  fbdd							; read and there are none left).  Else, C is clear
     66  fbdd							; and X/Y point to the null at end of filename.
     67  fbdd							;
     68  fbdd		       86 f1	   DiskDirNext stx	sptr+1
     69  fbdf		       84 f0		      sty	sptr
     70  fbe1		       20 ae fb 	      jsr	xParSetRead	;read results
     71  fbe4		       20 b5 fb 	      jsr	xParReadByte	;get response code
     72  fbe7		       c9 83		      cmp	#PR_NAK	;error?
     73  fbe9		       f0 1e		      beq	DDNErr
     74  fbeb		       c9 91		      cmp	#PR_DIR_END	;end?
     75  fbed		       f0 1a		      beq	DDNErr
     76  fbef							;
     77  fbef							; This contains a directory entry.
     78  fbef							;
     79  fbef		       a0 00		      ldy	#0
     80  fbf1		       20 b5 fb    DDNloop    jsr	xParReadByte
     81  fbf4		       91 f0		      sta	(sptr),y
     82  fbf6		       c9 00		      cmp	#0	;end?
     83  fbf8		       f0 06		      beq	DDNEnd
     84  fbfa		       20 73 f9 	      jsr	INCPT
     85  fbfd		       4c f1 fb 	      jmp	DDNloop
     86  fc00		       20 ab fb    DDNEnd     jsr	xParSetWrite
     87  fc03		       a6 f1		      ldx	sptr+1
     88  fc05		       a4 f0		      ldy	sptr
     89  fc07		       18		      clc		;not end of files
     90  fc08		       60		      rts
     91  fc09							;
     92  fc09							; Error.  Set C and return.  This is not really
     93  fc09							; proper, since this implies a simple end of the
     94  fc09							; directory rather than an error.
     95  fc09							;
     96  fc09		       20 ab fb    DDNErr     jsr	xParSetWrite
     97  fc0c		       38		      sec
     98  fc0d		       60		      rts
     99  fc0e							;page
    100  fc0e							;=====================================================
    101  fc0e							; This opens a file on the SD for reading.  On entry,
    102  fc0e							; X (MSB) and Y (LSB) point to a null-terminated
    103  fc0e							; filename to open.  On return, C is clear if the file
    104  fc0e							; is open, or C set if an error (usually means the
    105  fc0e							; file does not exist.
    106  fc0e							;
    107  fc0e							; Assumes write mode has been set.  Returns with it set.
    108  fc0e							;
    109  fc0e		       a9 16	   DiskOpenRead lda	#PC_READ_FILE
    110  fc10		       84 f2	   DiskOpen   sty	INL	;save ptr to filename
    111  fc12		       86 f3		      stx	INH
    112  fc14		       48		      pha
    113  fc15		       20 ab fb 	      jsr	xParSetWrite
    114  fc18		       68		      pla
    115  fc19		       20 b1 fb 	      jsr	xParWriteByte
    116  fc1c		       a0 ff		      ldy	#-1
    117  fc1e		       c8	   DiskOpenLoop iny
    118  fc1f		       b1 f2		      lda	(INL),y
    119  fc21		       20 b1 fb 	      jsr	xParWriteByte
    120  fc24		       b1 f2		      lda	(INL),y
    121  fc26		       d0 f6		      bne	DiskOpenLoop
    122  fc28		       20 ae fb 	      jsr	xParSetRead
    123  fc2b		       20 b5 fb 	      jsr	xParReadByte	;get response
    124  fc2e		       c9 82		      cmp	#PR_ACK
    125  fc30		       d0 05		      bne	DiskOpenErr
    126  fc32		       20 ab fb 	      jsr	xParSetWrite	;back to write mode
    127  fc35		       18		      clc
    128  fc36		       60		      rts
    129  fc37							;
    130  fc37							; Got an error.
    131  fc37							;
    132  fc37		       20 b5 fb    DiskOpenErr jsr	xParReadByte	;get error code
    133  fc3a		       20 ab fb 	      jsr	xParSetWrite	;back to write mode
    134  fc3d		       38		      sec
    135  fc3e		       60		      rts
    136  fc3f							;=====================================================
    137  fc3f							; This opens a file on the SD for writing.  On entry,
    138  fc3f							; X (MSB) and Y (LSB) point to a null-terminated
    139  fc3f							; filename to open.  On return, C is clear if the file
    140  fc3f							; is open, or C set if an error.
    141  fc3f							;
    142  fc3f							; Assumes write mode has been set.  Returns with it set.
    143  fc3f							;
    144  fc3f		       a9 1b	   DiskOpenWrite lda	#PC_WRITE_FILE
    145  fc41		       4c 10 fc 	      jmp	DiskOpen	;jump into common code
    146  fc44							;=====================================================
    147  fc44							; This Removes a file from the SD for writing.  On entry,
    148  fc44							; X (MSB) and Y (LSB) point to a null-terminated
    149  fc44							; filename to remove.	On return, C is clear if the file
    150  fc44							; is removed, or C set if an error.
    151  fc44							;
    152  fc44							; Assumes write mode has been set.  Returns with it set.
    153  fc44							;
    154  fc44		       a9 21	   DiskRemoveFile lda	#PC_RM_FILE
    155  fc46		       4c 10 fc 	      jmp	DiskOpen
    156  fc49							;
    157  fc49							;=====================================================
    158  fc49							; On entry, A contains the number of bytes to read
    159  fc49							; from the file, X (MSB) and Y (LSB) point to the
    160  fc49							; buffer where to put the data.  On return, C will
    161  fc49							; be set if EOF was reached (and no data read), or
    162  fc49							; C will be clear and A contains the number of bytes
    163  fc49							; actually read into the buffer.
    164  fc49							;
    165  fc49							; Modifies A, X and Y.  Also modifies INL and INH
    166  fc49							; (00F8 and 00F9).
    167  fc49							;
    168  fc49		       48	   DiskRead   pha
    169  fc4a		       84 f2		      sty	INL	;save ptr to buffer
    170  fc4c		       86 f3		      stx	INH
    171  fc4e		       a9 17		      lda	#PC_READ_BYTES
    172  fc50		       20 b1 fb 	      jsr	xParWriteByte	;command
    173  fc53		       68		      pla		;number of bytes to get
    174  fc54		       20 b1 fb 	      jsr	xParWriteByte
    175  fc57		       20 ae fb 	      jsr	xParSetRead	;get ready for response
    176  fc5a		       20 b5 fb 	      jsr	xParReadByte	;assume PR_FILE_DATA
    177  fc5d		       20 b5 fb 	      jsr	xParReadByte	;length
    178  fc60		       48		      pha
    179  fc61		       aa		      tax		;count
    180  fc62		       f0 11		      beq	DiskReadEof	;zero = EOF
    181  fc64		       a0 00		      ldy	#0	;offset
    182  fc66		       20 b5 fb    DiskReadLoop jsr	xParReadByte
    183  fc69		       91 f2		      sta	(INL),y
    184  fc6b		       c8		      iny		;next offset
    185  fc6c		       ca		      dex
    186  fc6d		       d0 f7		      bne	DiskReadLoop
    187  fc6f		       20 ab fb 	      jsr	xParSetWrite
    188  fc72		       68		      pla		;retrieve byte count
    189  fc73		       18	   DiskOk     clc
    190  fc74		       60		      rts
    191  fc75		       20 ab fb    DiskReadEof jsr	xParSetWrite
    192  fc78		       68		      pla
    193  fc79		       38		      sec
    194  fc7a		       60		      rts
    195  fc7b							;
    196  fc7b							;=====================================================
    197  fc7b							; On entry, A contains the number of bytes to write
    198  fc7b							; to the file, X (MSB) and Y (LSB) point to the
    199  fc7b							; buffer where to get the data.  On return, C will
    200  fc7b							; be set if an error was detected, or C will be clear
    201  fc7b							; if no error.  Note that if A contains 0 on entry,
    202  fc7b							; no bytes are written.
    203  fc7b							;
    204  fc7b							; Modifies A, X and Y.  Also modifies INL and INH
    205  fc7b							; (00F8 and 00F9).
    206  fc7b							;
    207  fc7b		       c9 00	   DiskWrite  cmp	#0
    208  fc7d		       f0 f4		      beq	DiskOk
    209  fc7f		       84 f2		      sty	INL	;save ptr to filename
    210  fc81		       86 f3		      stx	INH
    211  fc83		       48		      pha
    212  fc84		       a9 1c		      lda	#PC_WRITE_BYTES
    213  fc86		       20 b1 fb 	      jsr	xParWriteByte	;command
    214  fc89		       68		      pla		;number of bytes to write
    215  fc8a		       48		      pha		;save again
    216  fc8b		       20 b1 fb 	      jsr	xParWriteByte
    217  fc8e		       68		      pla
    218  fc8f		       aa		      tax		;count
    219  fc90		       a0 00		      ldy	#0	;offset
    220  fc92		       b1 f2	   DiskWriteLoop lda	(INL),y	;get next byte
    221  fc94		       20 b1 fb 	      jsr	xParWriteByte
    222  fc97		       c8		      iny		;next offset
    223  fc98		       ca		      dex
    224  fc99		       d0 f7		      bne	DiskWriteLoop
    225  fc9b		       20 ae fb 	      jsr	xParSetRead	;read the status
    226  fc9e		       20 b5 fb 	      jsr	xParReadByte
    227  fca1		       c9 82		      cmp	#PR_ACK
    228  fca3		       f0 08		      beq	DiskOk1	;all good
    229  fca5		       20 b5 fb 	      jsr	xParReadByte	;read error code
    230  fca8		       20 ab fb 	      jsr	xParSetWrite
    231  fcab		       38		      sec
    232  fcac		       60		      rts
    233  fcad							;
    234  fcad		       20 ab fb    DiskOk1    jsr	xParSetWrite
    235  fcb0		       18		      clc
    236  fcb1		       60		      rts
    237  fcb2							;
    238  fcb2							;=====================================================
    239  fcb2							; Call this to close any open file.  No parameters
    240  fcb2							; and no return status.
    241  fcb2							;
    242  fcb2		       a9 15	   DiskClose  lda	#PC_DONE
    243  fcb4		       4c b1 fb 	      jmp	xParWriteByte
    244  fcb7
    245  fcb7
------- FILE ctmon65.asm
   1589  fcb7					      endif
   1590  fcb7							;
   1591  fcb7							;*********************************************************
   1592  fcb7							; Handlers for the interrupts.  Basiclly just jump
   1593  fcb7							; through the vectors and hope they are set up properly.
   1594  fcb7							;
   1595  fcb7		       6c 02 df    HandleNMI  jmp	(NMIvec)
   1596  fcba		       6c 00 df    HandleIRQ  jmp	(IRQvec)
   1597  fcbd							;
   1598  fcbd							;*********************************************************
   1599  fcbd							; Default handler.  Save the state of the machine for
   1600  fcbd							; debugging.  This is taken from the KIM monitor SAVE
   1601  fcbd							; routine.
   1602  fcbd							;
   1603  fcbd				   DefaultNMI
   1604  fcbd		       8d 8e df    DefaultIRQ sta	SaveA
   1605  fcc0		       68		      pla
   1606  fcc1		       8d 93 df 	      sta	SaveC
   1607  fcc4		       68		      pla
   1608  fcc5		       8d 91 df 	      sta	SavePC
   1609  fcc8		       68		      pla
   1610  fcc9		       8d 92 df 	      sta	SavePC+1
   1611  fccc		       8c 90 df 	      sty	SaveY
   1612  fccf		       8e 8f df 	      stx	SaveX
   1613  fcd2		       ba		      tsx
   1614  fcd3		       8e 94 df 	      stx	SaveSP
   1615  fcd6		       20 db f6 	      jsr	DumpRegisters
   1616  fcd9		       20 66 fb 	      jsr	crlf
   1617  fcdc		       4c f9 f0 	      jmp	WARM
   1618  fcdf							;
   1619  fcdf							;*********************************************************
   1620  fcdf							; 6502 vectors
   1621  fcdf							;
   1622  fffa					      org	$fffa
      0  fffa					      dw	HandleNMI
      1  fffa		       b7 fc		      .word.w	HandleNMI
      0  fffc					      dw	RESET
      1  fffc		       48 f0		      .word.w	RESET
      0  fffe					      dw	HandleIRQ
      1  fffe		       ba fc		      .word.w	HandleIRQ
   1626  10000
