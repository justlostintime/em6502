------- FILE ctmon65.asm LEVEL 1 PASS 2
      1  10000					       Processor	6502
      2 U00f6 ????				      seg.U	ZEROPAGE
      3 U0000					      org	$0000
      4 U0000							;*********************************************************
      5 U0000							; CTMON65
      6 U0000							;
      7 U0000							; This is the monitor for the Corsham Techologies, LLC
      8 U0000							; SS-50 65C02 board.  It's a fairly generic monitor that
      9 U0000							; can be ported to other 6502 based systems.
     10 U0000							;
     11 U0000							; Written mostly while on a family vacation in 2018, but
     12 U0000							; ideas and code were taken from other Corsham Tech
     13 U0000							; projects and various web pages (credit given in the
     14 U0000							; code).
     15 U0000							;
     16 U0000							; Bob Applegate
     17 U0000							; bob@corshamtech.com
     18 U0000							; www.corshamtech.com
     19 U0000					      mac	db
     20 U0000					      .byte	{0}
     21 U0000					      endm
     22 U0000					      Mac	dw
     23 U0000					      .word	{0}
     24 U0000					      endm
     25 U0000
     26 U0000							;*********************************************************
     27 U0000							;
------- FILE config.inc LEVEL 2 PASS 2
      0 U0000					      include	"config.inc"
      1 U0000					      Processor	6502
      2 U0000							;*********************************************************
      3 U0000							; FILE: config.inc
      4 U0000							;
      5 U0000							; General configuration file
      6 U0000							;*********************************************************
      7 U0000							;
      8 U0000		       00 00	   FALSE      equ	0
      9 U0000		       00 01	   TRUE       equ	!FALSE
     10 U0000							;
     11 U0000							; SS-50 bus constants
     12 U0000							;
     13 U0000		       e0 00	   IO_BASE    equ	$E000
     14 U0000		       00 10	   IO_SIZE    equ	16
     15 U0000							;
     16 U0000							; Memory usage
     17 U0000							;
     18 U0000		       00 f0	   ZERO_PAGE_START equ	$00f0
     19 U0000		       f0 00	   ROM_START  equ	$f000
     20 U0000		       df 00	   RAM_START  equ	$df00
     21 U0000							;
     22 U0000							; If enabled, turn on buffered input code.
     23 U0000							;
     24 U0000		       00 00	   BUFFERED_INPUT equ	FALSE
     25 U0000							;
     26 U0000		       00 05	   MAX_ARGC   equ	5
     27 U0000							;
     28 U0000							; If enabled, the debugger will display the flag register
     29 U0000							; in ASCII.  Nice, but takes more code.
     30 U0000							;
     31 U0000		       00 01	   FULL_STATUS equ	TRUE
     32 U0000							;
     33 U0000							; Enable EXTENDED_CMDS to allow linking external commands
     34 U0000							; to the command handler.
     35 U0000							;
     36 U0000		       00 00	   EXTENDED_CMDS equ	FALSE
     37 U0000							;
     38 U0000							; Define to enable SD related functions
     39 U0000							;
     40 U0000		       00 01	   SD_ENABLED equ	TRUE
     41 U0000							;
     42 U0000							; Size of the keyboard buffer
     43 U0000							;
     44 U0000		       00 84	   BUFFER_SIZE equ	132
     45 U0000
------- FILE ctmon65.asm
     29 U0000							;
     30 U0000							; Current version and revision
     31 U0000							;
     32 U0000		       00 00	   VERSION    equ	0
     33 U0000		       00 04	   REVISION   equ	4
     34 U0000							;
     35 U0000							;---------------------------------------------------------
     36 U0000							; ASCII constants
     37 U0000							;
     38 U0000		       00 07	   BELL       equ	$07
     39 U0000		       00 08	   BS	      equ	$08
     40 U0000		       00 0a	   LF	      equ	$0a
     41 U0000		       00 0d	   CR	      equ	$0d
     42 U0000							;
     43 U0000							; Max number of bytes per line for hex dump
     44 U0000							;
     45 U0000		       00 10	   BYTESLINE  equ	16
     46 U0000							;
     47 U0000							; These are various buffer sizes
     48 U0000							;
     49 U0000		       00 0c	   FILENAME_SIZE equ	12
     50 U0000							;
     51 U0000							; Intel HEX record types
     52 U0000							;
     53 U0000		       00 00	   DATA_RECORD equ	$00
     54 U0000		       00 01	   EOF_RECORD equ	$01
     55 U0000							;
     56 U0000							; Zero-page data
     57 U0000							;
     58 U0000							;	  zpage
     59 U0000					      seg.U	ZEROPAGE
     60 U00f0					      org	ZERO_PAGE_START
     61 U00f0		       00 00	   sptr       ds	2
     62 U00f2		       00	   INL	      ds	1
     63 U00f3		       00	   INH	      ds	1
     64 U00f4		       00 00	   putsp      ds	2
     65 U00f6							;
     66 U00f6							; Non zero-page data
     67 U00f6							;
     68 Udfad ????				      Seg.u	Data
     69 Udf00					      org	RAM_START
     70 Udf00							;
     71 Udf00							; The use of memory starting from here will remain
     72 Udf00							; constant through different versions of CTMON65.
     73 Udf00							;
     74 Udf00		       00 00	   IRQvec     ds	2
     75 Udf02		       00 00	   NMIvec     ds	2
     76 Udf04							;
     77 Udf04							; Before a L(oad) command, these are set to $FF.
     78 Udf04							; After loading, if they are different, jump to
     79 Udf04							; that address.
     80 Udf04							;
     81 Udf04		       00 00	   AutoRun    ds	2
     82 Udf06							;
     83 Udf06							; Pointer to the subroutine that gets the next input
     84 Udf06							; character.  Used for doing disk/console input.
     85 Udf06							;
     86 Udf06		       00 00	   inputVector ds	2
     87 Udf08							;
     88 Udf08							; Same thing for output.
     89 Udf08							;
     90 Udf08		       00 00	   outputVector ds	2
     91 Udf0a							;
     92 Udf0a							; Buffer for GETLINE
     93 Udf0a							;
     94 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
     95 Udf8e							;
     96 Udf8e							; Anything from here can be moved between versions.
     97 Udf8e							;
     98 Udf8e		       00	   SaveA      ds	1
     99 Udf8f		       00	   SaveX      ds	1
    100 Udf90		       00	   SaveY      ds	1
    101 Udf91		       00 00	   SavePC     ds	2
    102 Udf93		       00	   SaveC      ds	1
    103 Udf94		       00	   SaveSP     ds	1
    104 Udf95		       00	   SAL	      ds	1
    105 Udf96		       00	   SAH	      ds	1
    106 Udf97		       00	   EAL	      ds	1
    107 Udf98		       00	   EAH	      ds	1
    108 Udf99		       00	   tempA      ds	1
    109 Udf9a		       00 00 00 00*filename   ds	FILENAME_SIZE+1
    110 Udfa7		       00	   diskBufOffset ds	1
    111 Udfa8		       00	   diskBufLength ds	1
    112 Udfa9		       00	   CHKL       ds	1
    113 Udfaa		       00	   ID	      ds	1
    114 Udfab		       00	   Temp16L    ds	1
    115 Udfac		       00	   Temp16H    ds	1
    116 Udfad							;
    117 Udfad							; This weird bit of DBs is to allow for the fact that
    118 Udfad							; I'm putting a 4K monitor into the top half of an
    119 Udfad							; 8K EEPROM.  This forces the actual code to the top
    120 Udfad							; 4K section.
    121 Udfad							;
    122 Udfad							;	  Seg  rcode
    123 Udfad							;	  org	 ROM_START-$1000
    124 Udfad							;	  db	"This space for rent.",CR,LF
    125 Udfad							;	  db	"Actually, this just forces the "
    126 Udfad							;	  db	"binary file to be 8K long."
    127 Udfad
    128 Udfad
    129  10000 ????				       Seg	Code
    130  f000					      org	ROM_START
    131  f000							;
    132  f000							;=========================================================
    133  f000							; Jump table to common functions.  The entries in this
    134  f000							; table are used by external programs, so nothing can be
    135  f000							; moved or removed from this table.  New entries always
    136  f000							; go at the end.  Many of these are internal functions
    137  f000							; and I figured they might be handy for others.
    138  f000							;
    139  f000		       4c 48 f0    COLDvec    jmp	RESET
    140  f003		       4c 59 f1    WARMvec    jmp	WARM
    141  f006							;
    142  f006							; These are the major and minor revision numbers so that
    143  f006							; code can check to see which CTMON65 version is running.
    144  f006							;
      0  f006				   CTMON65ver db	VERSION
      1  f006		       00		      .byte.b	VERSION
      0  f007				   CTMON65rev db	REVISION
      1  f007		       04		      .byte.b	REVISION
      0  f008					      db	0
      1  f008		       00		      .byte.b	0
    148  f009							;
    149  f009							; Console related functions
    150  f009							;
    151  f009		       4c fa fb    CINvec     jmp	cin
    152  f00c		       4c ed fb    COUTvec    jmp	cout
    153  f00f		       4c 05 fc    CSTATvec   jmp	cstatus
    154  f012		       4c 68 fb    PUTSILvec  jmp	putsil
    155  f015		       4c a6 fb    GETLINEvec jmp	getline
    156  f018		       4c c6 fb    CRLFvec    jmp	crlf
    157  f01b		       4c a9 fb    OUTHEXvec  jmp	HexA
    158  f01e							;
    159  f01e							; Low-level functions to access the SD card system
    160  f01e							;
    161  f01e					      if	SD_ENABLED
    162  f01e		       4c 0b fc    XPARINITvev jmp	xParInit
    163  f021		       4c 0b fc    XPARSETWRITEvec jmp	xParSetWrite
    164  f024		       4c 0e fc    XPARSETREADvec jmp	xParSetRead
    165  f027		       4c 11 fc    XPARWRITEvec jmp	xParWriteByte
    166  f02a		       4c 15 fc    XPARREADvec jmp	xParReadByte
    167  f02d							;
    168  f02d							; Higher level SD card functions
    169  f02d							;
    170  f02d		       4c 20 fc    DISKPINGvec jmp	DiskPing
    171  f030		       4c 33 fc    DISKDIRvec jmp	DiskDir
    172  f033		       4c 3d fc    DISKDIRNEXTVEC jmp	DiskDirNext
    173  f036		       4c 6e fc    DISKOPENREADvec jmp	DiskOpenRead
    174  f039		       4c 9f fc    DISKOPENWRITvec jmp	DiskOpenWrite
    175  f03c		       4c a9 fc    DISKREADvec jmp	DiskRead
    176  f03f		       4c db fc    DISKWRITEvec jmp	DiskWrite
    177  f042		       4c 12 fd    DISKCLOSEvec jmp	DiskClose
    178  f045		       4c a4 fc    DISKRMvec  JMP	DiskRemoveFile
    179  f048					      endif		;SD_ENABLED
    180  f048							;
    181  f048							;---------------------------------------------------------
    182  f048							; Cold start entry point
    183  f048							;
    184  f048		       a2 ff	   RESET      ldx	#$ff
    185  f04a		       9a		      txs
    186  f04b		       20 e1 fb 	      jsr	cinit
    187  f04e		       20 0b fc 	      jsr	xParInit
    188  f051							;
    189  f051							; Reset the NMI and IRQ vectors
    190  f051							;
    191  f051		       a9 1d		      lda	#DefaultNMI&$ff
    192  f053		       8d 02 df 	      sta	NMIvec
    193  f056		       a9 fd		      lda	#DefaultNMI>>8
    194  f058		       8d 03 df 	      sta	NMIvec+1
    195  f05b							;
    196  f05b		       a9 1d		      lda	#DefaultIRQ&$ff
    197  f05d		       8d 00 df 	      sta	IRQvec
    198  f060		       a9 fd		      lda	#DefaultIRQ>>8
    199  f062		       8d 01 df 	      sta	IRQvec+1
    200  f065							;
    201  f065							; Print start-up message
    202  f065							;
    203  f065		       20 68 fb 	      jsr	putsil
      0  f068					      db	CR,LF,LF,LF,LF
      1  f068		       0d 0a 0a 0a*	      .byte.b	CR,LF,LF,LF,LF
      0  f06d					      db	"CTMON65 rev "
      1  f06d		       43 54 4d 4f*	      .byte.b	"CTMON65 rev "
      0  f079					      db	VERSION+'0,'.
      1  f079		       30 2e		      .byte.b	VERSION+'0,'.
      0  f07b					      db	REVISION+'2
      1  f07b		       36		      .byte.b	REVISION+'2
      0  f07c					      db	CR,LF
      1  f07c		       0d 0a		      .byte.b	CR,LF
      0  f07e					      db	"02/12/2023 update Justlostintime justlostintime@gmail.com"
      1  f07e		       30 32 2f 31*	      .byte.b	"02/12/2023 update Justlostintime justlostintime@gmail.com"
      0  f0b7					      db	CR,LF
      1  f0b7		       0d 0a		      .byte.b	CR,LF
      0  f0b9					      db	"04/13/2022 by Bob Applegate K2UT/JustLostInTime"
      1  f0b9		       30 34 2f 31*	      .byte.b	"04/13/2022 by Bob Applegate K2UT/JustLostInTime"
      0  f0e8					      db	CR,LF
      1  f0e8		       0d 0a		      .byte.b	CR,LF
      0  f0ea					      db	"Authors: justlostintime@gmail.com,bob@corshamtech.com"
      1  f0ea		       41 75 74 68*	      .byte.b	"Authors: justlostintime@gmail.com,bob@corshamtech.com"
      0  f11f					      db	CR,LF
      1  f11f		       0d 0a		      .byte.b	CR,LF
      0  f121					      db	"Project @ , https://github.com/justlostintime/em6502"
      1  f121		       50 72 6f 6a*	      .byte.b	"Project @ , https://github.com/justlostintime/em6502"
      0  f155					      db	CR,LF,LF,0
      1  f155		       0d 0a 0a 00	      .byte.b	CR,LF,LF,0
    217  f159							;
    218  f159							;---------------------------------------------------------
    219  f159							; Warm start entry point.  This is the best place to jump
    220  f159							; in the code after a user program has ended.	Go through
    221  f159							; the vector, of course!
    222  f159							;
    223  f159		       a2 ff	   WARM       ldx	#$ff
    224  f15b		       9a		      txs
    225  f15c							;
    226  f15c							; Prompt the user and get a line of text
    227  f15c							;
    228  f15c		       20 54 fa    prompt     jsr	setOutputConsole
    229  f15f		       20 6f fa 	      jsr	setInputConsole
    230  f162		       20 68 fb 	      jsr	putsil
      0  f165					      db	CR,LF
      1  f165		       0d 0a		      .byte.b	CR,LF
      0  f167					      db	"CTMON65> "
      1  f167		       43 54 4d 4f*	      .byte.b	"CTMON65> "
      0  f170					      db	0
      1  f170		       00		      .byte.b	0
    234  f171		       20 fa fb    prompt2    jsr	cin
    235  f174		       c9 0d		      cmp	#CR
    236  f176		       f0 e4		      beq	prompt
    237  f178		       c9 0a		      cmp	#LF
    238  f17a		       f0 f5		      beq	prompt2	;don't prompt
    239  f17c		       8d 99 df 	      sta	tempA
    240  f17f							;
    241  f17f							; Now cycle through the list of commands looking for
    242  f17f							; what the user just pressed.
    243  f17f							;
    244  f17f		       a9 98		      lda	#commandTable&$ff
    245  f181		       85 f0		      sta	sptr
    246  f183		       a9 f1		      lda	#commandTable/256
    247  f185		       85 f1		      sta	sptr+1
    248  f187		       20 3d f3 	      jsr	searchCmd	;try to find it
    249  f18a							;
    250  f18a							; Hmmm... wasn't one of the built in commands, so
    251  f18a							; see if it's an extended command.
    252  f18a							;
    253  f18a				  -	      if	EXTENDED_CMDS
    254  f18a				  -	      lda	ExtensionAddr
    255  f18a				  -	      sta	sptr
    256  f18a				  -	      lda	ExtensionAddr+1
    257  f18a				  -	      sta	sptr+1
    258  f18a				  -	      jsr	searchCmd	;try to find it
    259  f18a					      endif
    260  f18a							;
    261  f18a							; If that returns, then the command was not found.
    262  f18a							; Print that it's unknown.
    263  f18a							;
    264  f18a		       20 68 fb 	      jsr	putsil
      0  f18d					      db	" - Huh?",0
      1  f18d		       20 2d 20 48*	      .byte.b	" - Huh?",0
    266  f195		       4c 5c f1    cmdFound   jmp	prompt
    267  f198							;
    268  f198							;=====================================================
    269  f198							; Vector table of commands.  Each entry consists of a
    270  f198							; single ASCII character (the command), a pointer to
    271  f198							; the function which handles the command, and a pointer
    272  f198							; to a string that describes the command.
    273  f198							;
    274  f198				   commandTable
      0  f198					      db	'?
      1  f198		       3f		      .byte.b	'?
      0  f199					      dw	showHelp
      1  f199		       67 f8		      .word.w	showHelp
      0  f19b					      dw	quesDesc
      1  f19b		       d5 f1		      .word.w	quesDesc
    278  f19d							;
      0  f19d					      db	'C
      1  f19d		       43		      .byte.b	'C
      0  f19e					      dw	doContinue
      1  f19e		       d0 f7		      .word.w	doContinue
      0  f1a0					      dw	cDesc
      1  f1a0		       f2 f1		      .word.w	cDesc
    282  f1a2							;
      0  f1a2					      db	'D
      1  f1a2		       44		      .byte.b	'D
      0  f1a3					      dw	doDiskDir
      1  f1a3		       fa f9		      .word.w	doDiskDir
      0  f1a5					      dw	dDesc
      1  f1a5		       13 f2		      .word.w	dDesc
    286  f1a7							;
      0  f1a7					      db	'E	;edit memory
      1  f1a7		       45		      .byte.b	'E
      0  f1a8					      dw	editMemory
      1  f1a8		       12 f4		      .word.w	editMemory
      0  f1aa					      dw	eDesc
      1  f1aa		       30 f2		      .word.w	eDesc
    290  f1ac							;
      0  f1ac					      db	'H	;hex dump
      1  f1ac		       48		      .byte.b	'H
      0  f1ad					      dw	hexDump
      1  f1ad		       82 f3		      .word.w	hexDump
      0  f1af					      dw	hDesc
      1  f1af		       4a f2		      .word.w	hDesc
    294  f1b1							;
      0  f1b1					      db	'J	;jump to address
      1  f1b1		       4a		      .byte.b	'J
      0  f1b2					      dw	jumpAddress
      1  f1b2		       68 f3		      .word.w	jumpAddress
      0  f1b4					      dw	jDesc
      1  f1b4		       68 f2		      .word.w	jDesc
    298  f1b6							;
      0  f1b6					      db	'L	;load Intel HEX file
      1  f1b6		       4c		      .byte.b	'L
      0  f1b7					      dw	loadHex
      1  f1b7		       73 f4		      .word.w	loadHex
      0  f1b9					      dw	lDesc
      1  f1b9		       86 f2		      .word.w	lDesc
    302  f1bb							;
      0  f1bb					      db	'M	;perform memory test
      1  f1bb		       4d		      .byte.b	'M
      0  f1bc					      dw	memTest
      1  f1bc		       ba f8		      .word.w	memTest
      0  f1be					      dw	mDesc
      1  f1be		       a2 f2		      .word.w	mDesc
    306  f1c0							;
      0  f1c0					      db	'P	;ping remote disk
      1  f1c0		       50		      .byte.b	'P
      0  f1c1					      dw	pingDisk
      1  f1c1		       da f9		      .word.w	pingDisk
      0  f1c3					      dw	pDesc
      1  f1c3		       bc f2		      .word.w	pDesc
    310  f1c5							;
      0  f1c5					      db	'R	;remove a file from disk
      1  f1c5		       52		      .byte.b	'R
      0  f1c6					      dw	rmFile
      1  f1c6		       c8 fa		      .word.w	rmFile
      0  f1c8					      dw	rDesc
      1  f1c8		       df f2		      .word.w	rDesc
    314  f1ca							;
      0  f1ca					      db	'S	;save memory as hex file
      1  f1ca		       53		      .byte.b	'S
      0  f1cb					      dw	saveHex
      1  f1cb		       b9 f5		      .word.w	saveHex
      0  f1cd					      dw	sDesc
      1  f1cd		       fe f2		      .word.w	sDesc
    318  f1cf							;
      0  f1cf					      db	'T	;type a file on SD
      1  f1cf		       54		      .byte.b	'T
      0  f1d0					      dw	typeFile
      1  f1d0		       ff fa		      .word.w	typeFile
      0  f1d2					      dw	tDesc
      1  f1d2		       20 f3		      .word.w	tDesc
    322  f1d4							;
      0  f1d4					      db	0	;marks end of table
      1  f1d4		       00		      .byte.b	0
    324  f1d5							;
    325  f1d5							;=====================================================
    326  f1d5							; Descriptions for each command in the command table.
    327  f1d5							; This wastes a lot of space... I'm open for any
    328  f1d5							; suggestions to keep the commands clear but reducing
    329  f1d5							; the amount of space this table consumes.
    330  f1d5							;
      0  f1d5				   quesDesc   db	"? ........... Show this help",0
      1  f1d5		       3f 20 2e 2e*	      .byte.b	"? ........... Show this help",0
      0  f1f2				   cDesc      db	"C ........... Continue execution",0
      1  f1f2		       43 20 2e 2e*	      .byte.b	"C ........... Continue execution",0
      0  f213				   dDesc      db	"D ........... Disk directory",0
      1  f213		       44 20 2e 2e*	      .byte.b	"D ........... Disk directory",0
      0  f230				   eDesc      db	"E xxxx ...... Edit memory",0
      1  f230		       45 20 78 78*	      .byte.b	"E xxxx ...... Edit memory",0
      0  f24a				   hDesc      db	"H xxxx xxxx . Hex dump memory",0
      1  f24a		       48 20 78 78*	      .byte.b	"H xxxx xxxx . Hex dump memory",0
      0  f268				   jDesc      db	"J xxxx ...... Jump to address",0
      1  f268		       4a 20 78 78*	      .byte.b	"J xxxx ...... Jump to address",0
      0  f286				   lDesc      db	"L ........... Load HEX file",0
      1  f286		       4c 20 2e 2e*	      .byte.b	"L ........... Load HEX file",0
      0  f2a2				   mDesc      db	"M xxxx xxxx . Memory test",0
      1  f2a2		       4d 20 78 78*	      .byte.b	"M xxxx xxxx . Memory test",0
      0  f2bc				   pDesc      db	"P ........... Ping disk controller",0
      1  f2bc		       50 20 2e 2e*	      .byte.b	"P ........... Ping disk controller",0
      0  f2df				   rDesc      db	"R ........... Remove disk file",0
      1  f2df		       52 20 2e 2e*	      .byte.b	"R ........... Remove disk file",0
      0  f2fe				   sDesc      db	"S xxxx xxxx . Save memory to file",0
      1  f2fe		       53 20 78 78*	      .byte.b	"S xxxx xxxx . Save memory to file",0
      0  f320				   tDesc      db	"T ........... Type disk file",0
      1  f320		       54 20 2e 2e*	      .byte.b	"T ........... Type disk file",0
    343  f33d							;
    344  f33d							;=====================================================
    345  f33d							; This subroutine will search for a command in a table
    346  f33d							; and call the appropriate handler.  See the command
    347  f33d							; table near the start of the code for what the format
    348  f33d							; is.	If a match is found, pop off the return address
    349  f33d							; from the stack and jump to the code.  Else, return.
    350  f33d							;
    351  f33d		       a0 00	   searchCmd  ldy	#0
    352  f33f		       b1 f0	   cmdLoop    lda	(sptr),y
    353  f341		       f0 24		      beq	cmdNotFound
    354  f343		       cd 99 df 	      cmp	tempA	;compare to user's input
    355  f346		       f0 0e		      beq	cmdMatch
    356  f348		       09 20		      ora	#$20	;allow lower case cmds
    357  f34a		       cd 99 df 	      cmp	tempA	;try users input again
    358  f34d		       f0 07		      beq	cmdMatch
    359  f34f		       c8		      iny		;start of function ptr
    360  f350		       c8		      iny
    361  f351		       c8		      iny		;start of help
    362  f352		       c8		      iny
    363  f353		       c8		      iny		;move to next command
    364  f354		       d0 e9		      bne	cmdLoop
    365  f356							;
    366  f356							; It's found!	Load up the address of the code to call,
    367  f356							; pop the return address off the stack and jump to the
    368  f356							; handler.
    369  f356							;
    370  f356		       c8	   cmdMatch   iny
    371  f357		       b1 f0		      lda	(sptr),y	;handler LSB
    372  f359		       48		      pha
    373  f35a		       c8		      iny
    374  f35b		       b1 f0		      lda	(sptr),y	;handler MSB
    375  f35d		       85 f1		      sta	sptr+1
    376  f35f		       68		      pla
    377  f360		       85 f0		      sta	sptr
    378  f362		       68		      pla		;pop return address
    379  f363		       68		      pla
    380  f364		       6c f0 00 	      jmp	(sptr)
    381  f367							;
    382  f367							; Not found, so just return.
    383  f367							;
    384  f367		       60	   cmdNotFound rts
    385  f368							;
    386  f368							;=====================================================
    387  f368							; Handles the command to prompt for an address and then
    388  f368							; jump to it.
    389  f368							;
    390  f368		       20 68 fb    jumpAddress jsr	putsil
      0  f36b					      db	"Jump to ",0
      1  f36b		       4a 75 6d 70*	      .byte.b	"Jump to ",0
    392  f374		       20 24 f8 	      jsr	getStartAddr
    393  f377		       b0 06		      bcs	cmdRet	;branch on bad address
    394  f379		       20 c6 fb 	      jsr	crlf
    395  f37c		       6c 95 df 	      jmp	(SAL)	;else jump to address
    396  f37f							;
    397  f37f		       4c 5c f1    cmdRet     jmp	prompt
    398  f382							;
    399  f382							;=====================================================
    400  f382							; Do a hex dump of a region of memory.
    401  f382							;
    402  f382							; Slight bug: the starting address is rounded down to
    403  f382							; a multiple of 16.  I'll fix it eventually.
    404  f382							;
    405  f382		       20 68 fb    hexDump    jsr	putsil
      0  f385					      db	"Hex dump ",0
      1  f385		       48 65 78 20*	      .byte.b	"Hex dump ",0
    407  f38f		       20 48 f8 	      jsr	getAddrRange
    408  f392		       b0 eb		      bcs	cmdRet
    409  f394		       20 c6 fb 	      jsr	crlf
    410  f397							;
    411  f397							; Move start address to sptr but rounded down to the
    412  f397							; 16 byte boundary.  While it's really cool to start at
    413  f397							; the exact address specified by the user, it adds
    414  f397							; code that really doesn't add much (any?) value.
    415  f397							;
    416  f397		       ad 96 df 	      lda	SAH
    417  f39a		       85 f1		      sta	sptr+1
    418  f39c		       ad 95 df 	      lda	SAL
    419  f39f		       29 f0		      and	#$f0	;force to 16 byte
    420  f3a1		       85 f0		      sta	sptr
    421  f3a3							;
    422  f3a3							;-----------------------------------------------------
    423  f3a3							; This starts each line.  Set flag to indcate we're
    424  f3a3							; doing the hex portion, print address, etc.
    425  f3a3							;
    426  f3a3		       20 c6 fb    hexdump1   jsr	crlf
    427  f3a6		       a5 f1		      lda	sptr+1
    428  f3a8		       20 a9 fb 	      jsr	HexA	;print the address
    429  f3ab		       a5 f0		      lda	sptr
    430  f3ad		       20 a9 fb 	      jsr	HexA
    431  f3b0		       20 d6 fb 	      jsr	space2	;two spaces after address
    432  f3b3							;
    433  f3b3							;-----------------------------------------------------
    434  f3b3							; This loop gets the next byte, prints the value in
    435  f3b3							; hex and adds the appropriate ASCII character to the
    436  f3b3							; buffer.
    437  f3b3							;
    438  f3b3		       a0 00		      ldy	#0	;offset from sptr
    439  f3b5		       a2 00	   hexdump3   ldx	#0	;bytes on line
    440  f3b7		       b1 f0	   hexdump2   lda	(sptr),y	;get byte
    441  f3b9		       20 a9 fb 	      jsr	HexA	;print hex version of it
    442  f3bc		       20 d9 fb 	      jsr	space	;space before next value
    443  f3bf							;
    444  f3bf							; Put the byte into the buffer.  If it is not printable
    445  f3bf							; ASCII then substitute a dot instead.
    446  f3bf							;
    447  f3bf		       c9 20		      cmp	#$20
    448  f3c1		       90 04		      bcc	hexdot
    449  f3c3		       c9 7e		      cmp	#'~
    450  f3c5		       90 02		      bcc	hexpr
    451  f3c7		       a9 2e	   hexdot     lda	#'.
    452  f3c9		       9d 0a df    hexpr      sta	buffer,x	;save for later
    453  f3cc							;
    454  f3cc							; See if the end of the user defined area was just dumped
    455  f3cc							;
    456  f3cc		       a5 f0	   hexdumpchk lda	sptr
    457  f3ce		       cd 97 df 	      cmp	EAL
    458  f3d1		       d0 07		      bne	hexdump4
    459  f3d3		       a5 f1		      lda	sptr+1
    460  f3d5		       cd 98 df 	      cmp	EAH
    461  f3d8		       f0 0e		      beq	hexdumpend
    462  f3da							;
    463  f3da							; Not done yet, so see if at end of the line
    464  f3da							;
    465  f3da		       20 d3 f9    hexdump4   jsr	INCPT	;move to next address
    466  f3dd		       e8		      inx
    467  f3de		       e0 10		      cpx	#BYTESLINE
    468  f3e0		       d0 d5		      bne	hexdump2
    469  f3e2							;
    470  f3e2							; At end, so dump ASCII contents
    471  f3e2							;
    472  f3e2		       20 f2 f3 	      jsr	dumpBuffer
    473  f3e5		       4c a3 f3 	      jmp	hexdump1
    474  f3e8							;
    475  f3e8							; At the end but still need to dump the ASCII version.
    476  f3e8							;
    477  f3e8		       e8	   hexdumpend inx		;count last byte output
    478  f3e9		       20 f2 f3 	      jsr	dumpBuffer
    479  f3ec		       20 c6 fb 	      jsr	crlf
    480  f3ef		       4c 5c f1    ret1       jmp	prompt
    481  f3f2							;
    482  f3f2							;=====================================================
    483  f3f2							; A helper function that prints the ASCII data in the
    484  f3f2							; buffer.  On entry X contains the number of bytes
    485  f3f2							; in the buffer.
    486  f3f2							;
    487  f3f2		       e0 10	   dumpBuffer cpx	#BYTESLINE	;is buffer full?
    488  f3f4		       f0 0b		      beq	hexdump91	;jump if so
    489  f3f6		       a9 20		      lda	#$20	;else fill with spaces
    490  f3f8		       9d 0a df 	      sta	buffer,x
    491  f3fb		       20 d3 fb 	      jsr	space3	;and space over
    492  f3fe		       e8		      inx
    493  f3ff		       d0 f1		      bne	dumpBuffer
    494  f401							;
    495  f401		       20 d3 fb    hexdump91  jsr	space3	;separate the two passes
    496  f404		       a2 00		      ldx	#0
    497  f406		       bd 0a df    hexdump99  lda	buffer,x
    498  f409		       20 ed fb 	      jsr	cout	;print char in buffer
    499  f40c		       e8		      inx
    500  f40d		       e0 10		      cpx	#BYTESLINE
    501  f40f		       d0 f5		      bne	hexdump99
    502  f411		       60		      rts
    503  f412							;
    504  f412							;=====================================================
    505  f412							; Edit memory.  This waits for a starting address to be
    506  f412							; entered.  It will display the current address and its
    507  f412							; contents.  Possible user inputs and actions:
    508  f412							;
    509  f412							;   Two hex digits will place that value in memory
    510  f412							;   RETURN moves to next address
    511  f412							;   BACKSPACE moves back one address
    512  f412							;
    513  f412		       20 68 fb    editMemory jsr	putsil
      0  f415					      db	"Edit memory ",0
      1  f415		       45 64 69 74*	      .byte.b	"Edit memory ",0
    515  f422		       20 24 f8 	      jsr	getStartAddr
    516  f425		       b0 c8		      bcs	ret1
    517  f427		       ad 95 df 	      lda	SAL	;move address into...
    518  f42a		       85 f0		      sta	sptr	;...POINT
    519  f42c		       ad 96 df 	      lda	SAH
    520  f42f		       85 f1		      sta	sptr+1
    521  f431							;
    522  f431							; Display the current location
    523  f431							;
    524  f431		       20 c6 fb    editMem1   jsr	crlf
    525  f434		       a5 f1		      lda	sptr+1
    526  f436		       20 a9 fb 	      jsr	HexA
    527  f439		       a5 f0		      lda	sptr
    528  f43b		       20 a9 fb 	      jsr	HexA
    529  f43e		       20 d9 fb 	      jsr	space
    530  f441		       a0 00		      ldy	#0
    531  f443		       b1 f0		      lda	(sptr),y	;get byte
    532  f445		       20 a9 fb 	      jsr	HexA	;print it
    533  f448		       20 d9 fb 	      jsr	space
    534  f44b							;
    535  f44b		       20 ea f7 	      jsr	getHex
    536  f44e		       b0 0d		      bcs	editMem2	;not hex
    537  f450		       a0 00		      ldy	#0
    538  f452		       91 f0		      sta	(sptr),y	;save new value
    539  f454							;
    540  f454							; Bump POINT to next location
    541  f454							;
    542  f454		       e6 f0	   editMem3   inc	sptr
    543  f456		       d0 d9		      bne	editMem1
    544  f458		       e6 f1		      inc	sptr+1
    545  f45a		       4c 31 f4 	      jmp	editMem1
    546  f45d							;
    547  f45d							; Not hex, so see if another command
    548  f45d							;
    549  f45d		       c9 0d	   editMem2   cmp	#CR
    550  f45f		       f0 f3		      beq	editMem3	;move to next
    551  f461		       c9 08		      cmp	#BS
    552  f463		       d0 8a		      bne	ret1	;else exit
    553  f465							;
    554  f465							; Move back one location
    555  f465							;
    556  f465		       38		      sec
    557  f466		       a5 f0		      lda	sptr
    558  f468		       e9 01		      sbc	#1
    559  f46a		       85 f0		      sta	sptr
    560  f46c		       b0 c3		      bcs	editMem1
    561  f46e		       c6 f1		      dec	sptr+1
    562  f470		       4c 31 f4 	      jmp	editMem1
    563  f473							;
    564  f473							;=====================================================
    565  f473							; This handles the Load hex command.
    566  f473							;
    567  f473		       a9 ff	   loadHex    lda	#$ff
    568  f475		       8d 05 df 	      sta	AutoRun+1
    569  f478							;
    570  f478		       20 68 fb 	      jsr	putsil
      0  f47b					      db	CR,LF
      1  f47b		       0d 0a		      .byte.b	CR,LF
      0  f47d					      db	"Enter filename, or Enter to "
      1  f47d		       45 6e 74 65*	      .byte.b	"Enter filename, or Enter to "
      0  f499					      db	"load from console: ",0
      1  f499		       6c 6f 61 64*	      .byte.b	"load from console: ",0
    574  f4ad							;
    575  f4ad		       20 e7 f6 	      jsr	getFileName	;get filename
    576  f4b0		       ad 9a df 	      lda	filename	;null?
    577  f4b3		       f0 2d		      beq	loadHexConsole	;load from console
    578  f4b5							;
    579  f4b5							; Open the file
    580  f4b5							;
    581  f4b5		       a0 9a		      ldy	#filename&$ff
    582  f4b7		       a2 df		      ldx	#filename/256
    583  f4b9		       20 6e fc 	      jsr	DiskOpenRead
    584  f4bc		       90 1e		      bcc	loadHexOk	;opened ok
    585  f4be							;
    586  f4be		       20 68 fb    openfail   jsr	putsil
      0  f4c1					      db	CR,LF
      1  f4c1		       0d 0a		      .byte.b	CR,LF
      0  f4c3					      db	"Failed to open file"
      1  f4c3		       46 61 69 6c*	      .byte.b	"Failed to open file"
      0  f4d6					      db	CR,LF,0
      1  f4d6		       0d 0a 00 	      .byte.b	CR,LF,0
    590  f4d9		       4c 5c f1    cmdRet3    jmp	prompt
    591  f4dc							;
    592  f4dc		       20 83 fa    loadHexOk  jsr	setInputFile	;redirect input
    593  f4df		       4c 10 f5 	      jmp	loadStart
    594  f4e2							;
    595  f4e2							; They are loading from the console
    596  f4e2							;
    597  f4e2		       20 68 fb    loadHexConsole jsr	putsil
      0  f4e5					      db	CR,LF
      1  f4e5		       0d 0a		      .byte.b	CR,LF
      0  f4e7					      db	"Waiting for file, or ESC to"
      1  f4e7		       57 61 69 74*	      .byte.b	"Waiting for file, or ESC to"
      0  f502					      db	" exit..."
      1  f502		       20 65 78 69*	      .byte.b	" exit..."
      0  f50a					      db	CR,LF,0
      1  f50a		       0d 0a 00 	      .byte.b	CR,LF,0
    602  f50d		       20 6f fa 	      jsr	setInputConsole
    603  f510							;
    604  f510							; The start of a line.  First character should be a
    605  f510							; colon, but toss out CRs, LFs, etc.  Anything else
    606  f510							; causes an abort.
    607  f510							;
    608  f510		       20 96 fa    loadStart  jsr	redirectedGetch	;get start of line
    609  f513		       c9 0d		      cmp	#CR
    610  f515		       f0 f9		      beq	loadStart
    611  f517		       c9 0a		      cmp	#LF
    612  f519		       f0 f5		      beq	loadStart
    613  f51b		       c9 3a		      cmp	#':	;what we expect
    614  f51d		       d0 34		      bne	loadAbort
    615  f51f							;
    616  f51f							; Get the header of the record
    617  f51f							;
    618  f51f		       a9 00		      lda	#0
    619  f521		       8d a9 df 	      sta	CHKL	;initialize checksum
    620  f524							;
    621  f524		       20 ea f7 	      jsr	getHex	;get byte count
    622  f527		       b0 2a		      bcs	loadAbort
    623  f529		       8d 8f df 	      sta	SaveX	;save byte count
    624  f52c		       20 2d fa 	      jsr	updateCrc
    625  f52f		       20 ea f7 	      jsr	getHex	;get the MSB of offset
    626  f532		       b0 1f		      bcs	loadAbort
    627  f534		       85 f1		      sta	sptr+1
    628  f536		       20 2d fa 	      jsr	updateCrc
    629  f539		       20 ea f7 	      jsr	getHex	;get LSB of offset
    630  f53c		       b0 15		      bcs	loadAbort
    631  f53e		       85 f0		      sta	sptr
    632  f540		       20 2d fa 	      jsr	updateCrc
    633  f543		       20 ea f7 	      jsr	getHex	;get the record type
    634  f546		       b0 0b		      bcs	loadAbort
    635  f548		       20 2d fa 	      jsr	updateCrc
    636  f54b							;
    637  f54b							; Only handle two record types:
    638  f54b							;    00 = data record
    639  f54b							;    01 = end of file record
    640  f54b							;
    641  f54b		       c9 00		      cmp	#DATA_RECORD
    642  f54d		       f0 3a		      beq	loadDataRec
    643  f54f		       c9 01		      cmp	#EOF_RECORD
    644  f551		       f0 16		      beq	loadEof
    645  f553							;
    646  f553							; Unknown record type
    647  f553							;
    648  f553		       20 68 fb    loadAbort  jsr	putsil
      0  f556					      db	CR,LF
      1  f556		       0d 0a		      .byte.b	CR,LF
      0  f558					      db	"Aborting"
      1  f558		       41 62 6f 72*	      .byte.b	"Aborting"
      0  f560					      db	CR,LF,0
      1  f560		       0d 0a 00 	      .byte.b	CR,LF,0
    652  f563		       20 6f fa    loadExit   jsr	setInputConsole
    653  f566		       4c 5c f1 	      jmp	prompt
    654  f569							;
    655  f569							; EOF is easy
    656  f569							;
    657  f569		       20 ea f7    loadEof    jsr	getHex	;get checksum
    658  f56c		       20 68 fb 	      jsr	putsil
      0  f56f					      db	CR,LF
      1  f56f		       0d 0a		      .byte.b	CR,LF
      0  f571					      db	"Success!"
      1  f571		       53 75 63 63*	      .byte.b	"Success!"
      0  f579					      db	CR,LF,0
      1  f579		       0d 0a 00 	      .byte.b	CR,LF,0
    662  f57c							;
    663  f57c							; If the auto-run vector is no longer $ffff, then jump
    664  f57c							; to whatever it points to.
    665  f57c							;
    666  f57c		       ad 05 df 	      lda	AutoRun+1
    667  f57f		       c9 ff		      cmp	#$ff	;unchanged?
    668  f581		       f0 03		      beq	lExit1
    669  f583		       6c 04 df 	      jmp	(AutoRun)	;execute!
    670  f586							;
    671  f586		       4c 63 f5    lExit1     jmp	loadExit
    672  f589							;
    673  f589							; Data records have more work.  After processing the
    674  f589							; line, print a dot to indicate progress.  This should
    675  f589							; be re-thought as it could slow down loading a really
    676  f589							; big file if the console speed is slow.
    677  f589							;
    678  f589		       ae 8f df    loadDataRec ldx	SaveX	;byte count
    679  f58c		       a0 00		      ldy	#0	;offset
    680  f58e		       8e 8f df    loadData1  stx	SaveX
    681  f591		       8c 90 df 	      sty	SaveY
    682  f594		       20 ea f7 	      jsr	getHex
    683  f597		       b0 ba		      bcs	loadAbort
    684  f599		       20 2d fa 	      jsr	updateCrc
    685  f59c		       ac 90 df 	      ldy	SaveY
    686  f59f		       ae 8f df 	      ldx	SaveX
    687  f5a2		       91 f0		      sta	(sptr),y
    688  f5a4		       c8		      iny
    689  f5a5		       ca		      dex
    690  f5a6		       d0 e6		      bne	loadData1
    691  f5a8							;
    692  f5a8							; All the bytes were read so get the checksum and see
    693  f5a8							; if it agrees.  The checksum is a twos-complement, so
    694  f5a8							; just add the checksum into what we've been calculating
    695  f5a8							; and if the result is zero then the record is good.
    696  f5a8							;
    697  f5a8		       20 ea f7 	      jsr	getHex	;get checksum
    698  f5ab		       18		      clc
    699  f5ac		       6d a9 df 	      adc	CHKL
    700  f5af		       d0 a2		      bne	loadAbort	;non-zero is error
    701  f5b1							;
    702  f5b1		       a9 2e		      lda	#'.	;sanity indicator when
    703  f5b3		       20 ed fb 	      jsr	cout	;...loading from file
    704  f5b6		       4c 10 f5 	      jmp	loadStart
    705  f5b9							;
    706  f5b9							;=====================================================
    707  f5b9							; Handles the command to save a region of memory as a
    708  f5b9							; file on the SD.
    709  f5b9							;
    710  f5b9		       20 48 f8    saveHex    jsr	getAddrRange	;get range to dump
    711  f5bc		       b0 c8		      bcs	lExit1	;abort on error
    712  f5be							;
    713  f5be							; Get the filename to save to
    714  f5be							;
    715  f5be		       20 68 fb 	      jsr	putsil
      0  f5c1					      db	CR,LF
      1  f5c1		       0d 0a		      .byte.b	CR,LF
      0  f5c3					      db	"Enter filename, or Enter to "
      1  f5c3		       45 6e 74 65*	      .byte.b	"Enter filename, or Enter to "
      0  f5df					      db	"load from console: ",0
      1  f5df		       6c 6f 61 64*	      .byte.b	"load from console: ",0
    719  f5f3							;
    720  f5f3		       20 e7 f6 	      jsr	getFileName	;get filename
    721  f5f6		       ad 9a df 	      lda	filename	;null?
    722  f5f9		       f0 12		      beq	saveHexConsole	;dump to console
    723  f5fb							;
    724  f5fb							; They selected a file, so try to open it.
    725  f5fb							;
    726  f5fb		       a2 df		      ldx	#filename>>8
    727  f5fd		       a0 9a		      ldy	#filename&$ff
    728  f5ff		       20 9f fc 	      jsr	DiskOpenWrite	;attempt to open file
    729  f602		       90 03		      bcc	sopenok	;branch if opened ok
    730  f604		       4c be f4 	      jmp	openfail
    731  f607							;
    732  f607		       20 5f fa    sopenok    jsr	setOutputFile
    733  f60a		       4c 10 f6 	      jmp	savehex2
    734  f60d							;
    735  f60d							; They are saving to the console.  Set up the output
    736  f60d							; vector and do the job.
    737  f60d							;
    738  f60d		       20 54 fa    saveHexConsole jsr	setOutputConsole
    739  f610							;
    740  f610							; Compute the number of bytes to dump
    741  f610							;
    742  f610		       38	   savehex2   sec
    743  f611		       ad 97 df 	      lda	EAL
    744  f614		       ed 95 df 	      sbc	SAL
    745  f617		       8d ab df 	      sta	Temp16L
    746  f61a		       ad 98 df 	      lda	EAH
    747  f61d		       ed 96 df 	      sbc	SAH
    748  f620		       8d ac df 	      sta	Temp16H
    749  f623		       90 42		      bcc	SDone	;start > end
    750  f625		       05 00		      ora	0
    751  f627		       30 3e		      bmi	SDone	;more than 32K seems wrong
    752  f629							;
    753  f629							; Add one to the count
    754  f629							;
    755  f629		       ee ab df 	      inc	Temp16L
    756  f62c		       d0 03		      bne	slab1
    757  f62e		       ee ac df 	      inc	Temp16H
    758  f631							;
    759  f631							; Move pointer to zero page
    760  f631							;
    761  f631		       ad 95 df    slab1      lda	SAL
    762  f634		       85 f0		      sta	sptr
    763  f636		       ad 96 df 	      lda	SAH
    764  f639		       85 f1		      sta	sptr+1
    765  f63b							;
    766  f63b							; Top of each loop.  Start by seeing if there are any bytes
    767  f63b							; left to dump.
    768  f63b							;
    769  f63b		       ad ac df    Sloop1     lda	Temp16H
    770  f63e		       d0 2a		      bne	Sgo	;more to do
    771  f640		       ad ab df 	      lda	Temp16L
    772  f643		       d0 25		      bne	Sgo	;more to do
    773  f645							;
    774  f645							; At end of the region, so output an end record.  This
    775  f645							; probably looks like overkill but keep in mind this
    776  f645							; might be going to a file so we can't use the normal
    777  f645							; string put functions.
    778  f645							;
    779  f645		       a9 3a		      lda	#':
    780  f647		       20 51 fa 	      jsr	redirectedOutch
    781  f64a		       a9 00		      lda	#0
    782  f64c		       20 37 fa 	      jsr	HexToOutput
    783  f64f		       20 37 fa 	      jsr	HexToOutput
    784  f652		       20 37 fa 	      jsr	HexToOutput
    785  f655		       a9 01		      lda	#1
    786  f657		       20 37 fa 	      jsr	HexToOutput
    787  f65a		       a9 ff		      lda	#$ff
    788  f65c		       20 37 fa 	      jsr	HexToOutput
    789  f65f							;
    790  f65f							; If output to file, flush and close the file.
    791  f65f							;
    792  f65f		       ad 9a df 	      lda	filename
    793  f662		       f0 03		      beq	SDone	;it's going to console
    794  f664		       20 59 fb 	      jsr	CloseOutFile
    795  f667		       4c 5c f1    SDone      jmp	prompt	;back to the monitor
    796  f66a							;
    797  f66a							; This dumps the next line.  See how many bytes are left to do
    798  f66a							; and if more than BYTESLINE, then just do BYTESLINE.
    799  f66a							;
    800  f66a		       ad ac df    Sgo	      lda	Temp16H
    801  f66d		       d0 07		      bne	Sdef	;do default number of bytes
    802  f66f		       ad ab df 	      lda	Temp16L
    803  f672		       c9 10		      cmp	#BYTESLINE
    804  f674		       90 02		      bcc	Scnt	;more than max per line
    805  f676		       a9 10	   Sdef       lda	#BYTESLINE
    806  f678		       8d 99 df    Scnt       sta	tempA	;for decrementing
    807  f67b		       8d aa df 	      sta	ID	;for subtracting
    808  f67e							;
    809  f67e							; Put out the header
    810  f67e							;
    811  f67e		       a9 3a		      lda	#':
    812  f680		       20 51 fa 	      jsr	redirectedOutch
    813  f683							;
    814  f683		       ad 99 df 	      lda	tempA
    815  f686		       8d a9 df 	      sta	CHKL	;start checksum
    816  f689		       20 37 fa 	      jsr	HexToOutput
    817  f68c							;
    818  f68c		       a5 f1		      lda	sptr+1	;starting address
    819  f68e		       20 2d fa 	      jsr	updateCrc
    820  f691		       20 37 fa 	      jsr	HexToOutput
    821  f694		       a5 f0		      lda	sptr
    822  f696		       20 2d fa 	      jsr	updateCrc
    823  f699		       20 37 fa 	      jsr	HexToOutput
    824  f69c							;
    825  f69c		       a9 00		      lda	#0	;record type - data
    826  f69e		       20 37 fa 	      jsr	HexToOutput
    827  f6a1							;
    828  f6a1							; Now print the proper number of bytes
    829  f6a1							;
    830  f6a1		       a0 00	   Sloop2     ldy	#0
    831  f6a3		       b1 f0		      lda	(sptr),y	;get byte
    832  f6a5		       20 2d fa 	      jsr	updateCrc
    833  f6a8		       20 37 fa 	      jsr	HexToOutput
    834  f6ab		       20 d3 f9 	      jsr	INCPT	;increment pointer
    835  f6ae							;
    836  f6ae		       ce 99 df    sdec       dec	tempA
    837  f6b1		       d0 ee		      bne	Sloop2
    838  f6b3							;
    839  f6b3							; Now print checksum
    840  f6b3							;
    841  f6b3		       ad a9 df 	      lda	CHKL
    842  f6b6		       49 ff		      eor	#$ff	;one's complement
    843  f6b8		       18		      clc
    844  f6b9		       69 01		      adc	#1	;two's complement
    845  f6bb		       20 37 fa 	      jsr	HexToOutput
    846  f6be							;
    847  f6be							; Output a CR/LF
    848  f6be							;
    849  f6be		       a9 0d		      lda	#CR
    850  f6c0		       20 51 fa 	      jsr	redirectedOutch
    851  f6c3		       a9 0a		      lda	#LF
    852  f6c5		       20 51 fa 	      jsr	redirectedOutch
    853  f6c8							;
    854  f6c8							; If saving to disk, output a dot to indicate progress.
    855  f6c8							;
    856  f6c8		       ad 9a df 	      lda	filename
    857  f6cb		       f0 05		      beq	shf2
    858  f6cd							;
    859  f6cd		       a9 2e		      lda	#'.
    860  f6cf		       20 ed fb 	      jsr	cout	;goes to console
    861  f6d2							;
    862  f6d2		       38	   shf2       sec
    863  f6d3		       ad ab df 	      lda	Temp16L
    864  f6d6		       ed aa df 	      sbc	ID
    865  f6d9		       8d ab df 	      sta	Temp16L
    866  f6dc		       ad ac df 	      lda	Temp16H
    867  f6df		       e9 00		      sbc	#0
    868  f6e1		       8d ac df 	      sta	Temp16H
    869  f6e4							;
    870  f6e4		       4c 3b f6 	      jmp	Sloop1
    871  f6e7							;
    872  f6e7							;=====================================================
    873  f6e7							; Get a disk filename.
    874  f6e7							;
    875  f6e7		       a2 00	   getFileName ldx	#0
    876  f6e9		       20 fa fb    getFilename1 jsr	cin	;get next key
    877  f6ec		       c9 0d		      cmp	#CR	;end of the input?
    878  f6ee		       f0 27		      beq	getFnDone
    879  f6f0		       c9 08		      cmp	#BS	;backspace?
    880  f6f2		       f0 0d		      beq	getFnDel
    881  f6f4		       e0 0c		      cpx	#FILENAME_SIZE	;check size
    882  f6f6		       f0 f1		      beq	getFilename1	;at length limit
    883  f6f8		       9d 9a df 	      sta	filename,x	;else save it
    884  f6fb		       20 ed fb 	      jsr	cout
    885  f6fe		       e8		      inx
    886  f6ff		       d0 e8		      bne	getFilename1
    887  f701							;
    888  f701		       ca	   getFnDel   dex
    889  f702		       30 10		      bmi	getFnU	;no charac here
    890  f704		       a9 08		      lda	#BS
    891  f706		       20 ed fb 	      jsr	cout
    892  f709		       a9 20		      lda	#$20
    893  f70b		       20 ed fb 	      jsr	cout
    894  f70e		       a9 08		      lda	#BS
    895  f710		       20 ed fb 	      jsr	cout
    896  f713		       ca		      dex
    897  f714		       e8	   getFnU     inx		;can't go past start
    898  f715		       10 d2		      bpl	getFilename1
    899  f717		       a9 00	   getFnDone  lda	#0	;terminate line
    900  f719		       9d 9a df 	      sta	filename,x
    901  f71c		       4c c6 fb 	      jmp	crlf
    902  f71f							;
    903  f71f							;=====================================================
    904  f71f							; Add the byte in A to the output buffer.  If the
    905  f71f							; buffer is full, flush it to disk.
    906  f71f							;
    907  f71f		       ae a7 df    putNextFileByte ldx	diskBufOffset
    908  f722		       e0 84		      cpx	#BUFFER_SIZE	;buffer full?
    909  f724		       d0 0d		      bne	pNFB	;no
    910  f726							;
    911  f726							; The buffer is full, so write it out.
    912  f726							;
    913  f726		       48		      pha		;save byte
    914  f727		       a9 84		      lda	#BUFFER_SIZE
    915  f729		       a2 df		      ldx	#buffer>>8
    916  f72b		       a0 0a		      ldy	#buffer&$ff
    917  f72d		       20 db fc 	      jsr	DiskWrite
    918  f730							;
    919  f730		       a2 00		      ldx	#0	;reset index
    920  f732		       68		      pla
    921  f733		       9d 0a df    pNFB       sta	buffer,x
    922  f736		       e8		      inx
    923  f737		       8e a7 df 	      stx	diskBufOffset
    924  f73a		       60		      rts
    925  f73b							;
    926  f73b							;*********************************************************
    927  f73b							; Dump the current registers based on values in the Save*
    928  f73b							; locations.
    929  f73b							;
    930  f73b				   DumpRegisters
    931  f73b		       20 68 fb 	      jsr	putsil
      0  f73e					      db	"PC:",0
      1  f73e		       50 43 3a 00	      .byte.b	"PC:",0
    933  f742		       ad 92 df 	      lda	SavePC+1
    934  f745		       20 a9 fb 	      jsr	HexA
    935  f748		       ad 91 df 	      lda	SavePC
    936  f74b		       20 a9 fb 	      jsr	HexA
    937  f74e							;
    938  f74e		       20 68 fb 	      jsr	putsil
      0  f751					      db	" A:",0
      1  f751		       20 41 3a 00	      .byte.b	" A:",0
    940  f755		       ad 8e df 	      lda	SaveA
    941  f758		       20 a9 fb 	      jsr	HexA
    942  f75b							;
    943  f75b		       20 68 fb 	      jsr	putsil
      0  f75e					      db	" X:",0
      1  f75e		       20 58 3a 00	      .byte.b	" X:",0
    945  f762		       ad 8f df 	      lda	SaveX
    946  f765		       20 a9 fb 	      jsr	HexA
    947  f768							;
    948  f768		       20 68 fb 	      jsr	putsil
      0  f76b					      db	" Y:",0
      1  f76b		       20 59 3a 00	      .byte.b	" Y:",0
    950  f76f		       ad 90 df 	      lda	SaveY
    951  f772		       20 a9 fb 	      jsr	HexA
    952  f775							;
    953  f775		       20 68 fb 	      jsr	putsil
      0  f778					      db	" SP:",0
      1  f778		       20 53 50 3a*	      .byte.b	" SP:",0
    955  f77d		       ad 94 df 	      lda	SaveSP
    956  f780		       20 a9 fb 	      jsr	HexA
    957  f783							;
    958  f783							; Last is the condition register.  For this, print the
    959  f783							; actual flags.  Lower case for clear, upper for set.
    960  f783							;
    961  f783		       20 68 fb 	      jsr	putsil
      0  f786					      db	" Flags:",0
      1  f786		       20 46 6c 61*	      .byte.b	" Flags:",0
    963  f78e					      if	FULL_STATUS
    964  f78e							;
    965  f78e							; N - bit 7
    966  f78e							;
    967  f78e		       a9 80		      lda	#$80	;bit to test
    968  f790		       a2 4e		      ldx	#'N	;set ACII char
    969  f792		       20 c1 f7 	      jsr	testbit
    970  f795							;
    971  f795							; V - bit 6
    972  f795							;
    973  f795		       a9 40		      lda	#$40	;bit to test
    974  f797		       a2 56		      ldx	#'V	;set ACII char
    975  f799		       20 c1 f7 	      jsr	testbit
    976  f79c							;
    977  f79c		       a9 2d		      lda	#'-	;unused bit
    978  f79e		       20 ed fb 	      jsr	cout
    979  f7a1							;
    980  f7a1							; B - bit 4
    981  f7a1							;
    982  f7a1		       a9 10		      lda	#$10	;bit to test
    983  f7a3		       a2 42		      ldx	#'B	;set ACII char
    984  f7a5		       20 c1 f7 	      jsr	testbit
    985  f7a8							;
    986  f7a8							; D - bit 3
    987  f7a8							;
    988  f7a8		       a9 08		      lda	#$08	;bit to test
    989  f7aa		       a2 44		      ldx	#'D	;set ACII char
    990  f7ac		       20 c1 f7 	      jsr	testbit
    991  f7af							;
    992  f7af							; I - bit 2
    993  f7af							;
    994  f7af		       a9 04		      lda	#$04	;bit to test
    995  f7b1		       a2 49		      ldx	#'I	;set ACII char
    996  f7b3		       20 c1 f7 	      jsr	testbit
    997  f7b6							;
    998  f7b6							; Z - bit 1
    999  f7b6							;
   1000  f7b6		       a9 02		      lda	#$02	;bit to test
   1001  f7b8		       a2 5a		      ldx	#'Z	;set ACII char
   1002  f7ba		       20 c1 f7 	      jsr	testbit
   1003  f7bd							;
   1004  f7bd							; C - bit 0
   1005  f7bd							;
   1006  f7bd		       a9 01		      lda	#$01	;bit to test
   1007  f7bf		       a2 43		      ldx	#'C	;set ACII char
   1008  f7c1							;
   1009  f7c1							; Fall through...
   1010  f7c1							;
   1011  f7c1							;*********************************************************
   1012  f7c1							; Given a bit mask in A and an upper case character
   1013  f7c1							; indicating the flag name in X, see if the flag is set or
   1014  f7c1							; not.  Output upper case if set, lower case if not.
   1015  f7c1							;
   1016  f7c1		       2d 93 df    testbit    and	SaveC	;is bit set?
   1017  f7c4		       d0 06		      bne	testbit1	;yes
   1018  f7c6		       8a		      txa
   1019  f7c7		       09 20		      ora	#$20	;make lower case
   1020  f7c9		       4c ed fb 	      jmp	cout
   1021  f7cc		       8a	   testbit1   txa
   1022  f7cd		       4c ed fb 	      jmp	cout
   1023  f7d0				  -	      else
   1024  f7d0				  -	      lda	SaveSP
   1025  f7d0				  -	      jmp	HexA
   1026  f7d0					      endif
   1027  f7d0							;
   1028  f7d0							;=====================================================
   1029  f7d0							; This continues executing from the last saved state,
   1030  f7d0							; such as from a call to DefaultNMI.
   1031  f7d0							;
   1032  f7d0				   doContinue
   1033  f7d0		       ae 94 df 	      ldx	SaveSP
   1034  f7d3		       9a		      txs
   1035  f7d4		       ad 92 df 	      lda	SavePC+1
   1036  f7d7		       48		      pha
   1037  f7d8		       ad 91 df 	      lda	SavePC
   1038  f7db		       48		      pha
   1039  f7dc		       ad 93 df 	      lda	SaveC
   1040  f7df		       48		      pha
   1041  f7e0		       ae 8f df 	      ldx	SaveX
   1042  f7e3		       ac 90 df 	      ldy	SaveY
   1043  f7e6		       ad 8e df 	      lda	SaveA
   1044  f7e9		       40		      rti
   1045  f7ea							;
   1046  f7ea							;=====================================================
   1047  f7ea							; This gets two hex characters and returns the value
   1048  f7ea							; in A with carry clear.  If a non-hex digit is
   1049  f7ea							; entered, then A contans the offending character and
   1050  f7ea							; carry is set.
   1051  f7ea							;
   1052  f7ea		       20 02 f8    getHex     jsr	getNibble
   1053  f7ed		       b0 20		      bcs	getNibBad
   1054  f7ef		       0a		      asl		; a
   1055  f7f0		       0a		      asl		; a
   1056  f7f1		       0a		      asl		; a
   1057  f7f2		       0a		      asl		; a
   1058  f7f3		       29 f0		      and	#$f0
   1059  f7f5		       8d 99 df 	      sta	tempA
   1060  f7f8		       20 02 f8 	      jsr	getNibble
   1061  f7fb		       b0 12		      bcs	getNibBad
   1062  f7fd		       0d 99 df 	      ora	tempA
   1063  f800		       18		      clc
   1064  f801		       60		      rts
   1065  f802							;
   1066  f802							; Helper.  Gets next input char and converts to a
   1067  f802							; value from 0-F in A and returns C clear.  If not a
   1068  f802							; valid hex character, return C set.
   1069  f802							;
   1070  f802		       20 96 fa    getNibble  jsr	redirectedGetch
   1071  f805		       a2 0f		      ldx	#nibbleHexEnd-nibbleHex-1
   1072  f807		       dd 14 f8    getNibble1 cmp	nibbleHex,x
   1073  f80a		       f0 05		      beq	getNibF	;got match
   1074  f80c		       ca		      dex
   1075  f80d		       10 f8		      bpl	getNibble1
   1076  f80f		       38	   getNibBad  sec
   1077  f810		       60		      rts
   1078  f811
   1079  f811		       8a	   getNibF    txa		;index is value
   1080  f812		       18		      clc
   1081  f813		       60		      rts
   1082  f814							;
      0  f814				   nibbleHex  db	"0123456789ABCDEF"
      1  f814		       30 31 32 33*	      .byte.b	"0123456789ABCDEF"
   1084  f814		       f8 24	   nibbleHexEnd equ	*
   1085  f824							;
   1086  f824							;=====================================================
   1087  f824							; Gets a four digit hex address amd places it in
   1088  f824							; SAL and SAH.  Returns C clear if all is well, or C
   1089  f824							; set on error and A contains the character.
   1090  f824							;
   1091  f824		       20 ea f7    getStartAddr jsr	getHex
   1092  f827		       b0 0c		      bcs	getDone
   1093  f829		       8d 96 df 	      sta	SAH
   1094  f82c		       20 ea f7 	      jsr	getHex
   1095  f82f		       b0 04		      bcs	getDone
   1096  f831		       8d 95 df 	      sta	SAL
   1097  f834		       18		      clc
   1098  f835		       60	   getDone    rts
   1099  f836							;
   1100  f836							;=====================================================
   1101  f836							; Gets a four digit hex address and places it in
   1102  f836							; EAL and EAH.  Returns C clear if all is well, or C
   1103  f836							; set on error and A contains the character.
   1104  f836							;
   1105  f836		       20 ea f7    getEndAddr jsr	getHex
   1106  f839		       b0 fa		      bcs	getDone
   1107  f83b		       8d 98 df 	      sta	EAH
   1108  f83e		       20 ea f7 	      jsr	getHex
   1109  f841		       b0 f2		      bcs	getDone
   1110  f843		       8d 97 df 	      sta	EAL
   1111  f846		       18		      clc
   1112  f847		       60		      rts
   1113  f848							;
   1114  f848							;=====================================================
   1115  f848							; Get an address range and leave them in SAL and EAL.
   1116  f848							;
   1117  f848		       20 68 fb    getAddrRange jsr	putsil
      0  f84b					      db	"Start: ",0
      1  f84b		       53 74 61 72*	      .byte.b	"Start: ",0
   1119  f853		       20 24 f8 	      jsr	getStartAddr
   1120  f856		       b0 dd		      bcs	getDone
   1121  f858		       20 68 fb 	      jsr	putsil
      0  f85b					      db	", End: ",0
      1  f85b		       2c 20 45 6e*	      .byte.b	", End: ",0
   1123  f863		       20 36 f8 	      jsr	getEndAddr
   1124  f866		       60		      rts
   1125  f867							;
   1126  f867							;=====================================================
   1127  f867							; Command handler for the ? command
   1128  f867							;
   1129  f867		       20 68 fb    showHelp   jsr	putsil
      0  f86a					      db	CR,LF
      1  f86a		       0d 0a		      .byte.b	CR,LF
      0  f86c					      db	"Available commands:"
      1  f86c		       41 76 61 69*	      .byte.b	"Available commands:"
      0  f87f					      db	CR,LF,LF,0
      1  f87f		       0d 0a 0a 00	      .byte.b	CR,LF,LF,0
   1133  f883							;
   1134  f883							; Print help for built-in commands...
   1135  f883							;
   1136  f883		       a9 98		      lda	#commandTable&$ff
   1137  f885		       85 f0		      sta	sptr
   1138  f887		       a9 f1		      lda	#commandTable/256
   1139  f889		       85 f1		      sta	sptr+1
   1140  f88b		       20 91 f8 	      jsr	displayHelp	;display help
   1141  f88e							;
   1142  f88e							; Now print help for the extension commands...
   1143  f88e							;
   1144  f88e				  -	      if	EXTENDED_CMDS
   1145  f88e				  -	      lda	ExtensionAddr
   1146  f88e				  -	      sta	sptr
   1147  f88e				  -	      lda	ExtensionAddr+1
   1148  f88e				  -	      sta	sptr+1
   1149  f88e				  -	      jsr	displayHelp
   1150  f88e				  -	      jsr	crlf
   1151  f88e					      endif
   1152  f88e		       4c 5c f1 	      jmp	prompt
   1153  f891							;
   1154  f891							;=====================================================
   1155  f891							; Given a pointer to a command table in POINT, display
   1156  f891							; the help text for all commands in the table.
   1157  f891							;
   1158  f891		       a0 00	   displayHelp ldy	#0	;index into command table
   1159  f893		       b1 f0	   showHelpLoop lda	(sptr),y	;get command
   1160  f895		       f0 1c		      beq	showHelpDone	;jump if at end
   1161  f897							;
   1162  f897							; Display this entry's descriptive text
   1163  f897							;
   1164  f897		       c8		      iny		;skip over command
   1165  f898		       c8		      iny		;skip over function ptr
   1166  f899		       c8		      iny
   1167  f89a		       b1 f0		      lda	(sptr),y
   1168  f89c		       85 f2		      sta	INL
   1169  f89e		       c8		      iny
   1170  f89f		       b1 f0		      lda	(sptr),y
   1171  f8a1		       85 f3		      sta	INH
   1172  f8a3		       98		      tya
   1173  f8a4		       48		      pha
   1174  f8a5		       20 d6 fb 	      jsr	space2
   1175  f8a8		       20 8b fb 	      jsr	puts	;print description
   1176  f8ab		       20 c6 fb 	      jsr	crlf
   1177  f8ae		       68		      pla
   1178  f8af		       a8		      tay
   1179  f8b0		       c8		      iny		;point to next entry
   1180  f8b1		       d0 e0		      bne	showHelpLoop
   1181  f8b3		       60	   showHelpDone rts
   1182  f8b4							;
   1183  f8b4							;=====================================================
   1184  f8b4							; This does a memory test of a region of memory.
   1185  f8b4							;
   1186  f8b4							; Asks for the starting and ending locations.
   1187  f8b4							;
   1188  f8b4							; This cycles a rolling bit, then adds a ninth
   1189  f8b4							; pattern to help detect shorted address bits.
   1190  f8b4							; Ie: 01, 02, 04, 08, 10, 20, 40, 80, BA
   1191  f8b4							;
   1192  f8b4		       df 8e	   pattern    equ	SaveA	;re-use some other locations
   1193  f8b4		       df 8f	   original   equ	SaveX
   1194  f8b4							;
   1195  f8b4							; Test patterns
   1196  f8b4							;
   1197  f8b4		       00 01	   PATTERN_0  equ	$01
   1198  f8b4		       00 ba	   PATTERN_9  equ	$ba
   1199  f8b4							;
   1200  f8b4		       20 fa fb    memabort   jsr	cin	;eat pending key
   1201  f8b7		       4c 5c f1    cmdRet2    jmp	prompt
   1202  f8ba							;
   1203  f8ba		       20 68 fb    memTest    jsr	putsil
      0  f8bd					      db	"Memory test ",0
      1  f8bd		       4d 65 6d 6f*	      .byte.b	"Memory test ",0
   1205  f8ca		       20 48 f8 	      jsr	getAddrRange	;get range
   1206  f8cd		       b0 e8		      bcs	cmdRet2	;branch if abort
   1207  f8cf							;
   1208  f8cf		       20 68 fb 	      jsr	putsil
      0  f8d2					      db	CR,LF
      1  f8d2		       0d 0a		      .byte.b	CR,LF
      0  f8d4					      db	"Testing memory.  Press any key to abort"
      1  f8d4		       54 65 73 74*	      .byte.b	"Testing memory.  Press any key to abort"
      0  f8fb					      db	0
      1  f8fb		       00		      .byte.b	0
   1212  f8fc		       a9 01		      lda	#PATTERN_0	;only set initial...
   1213  f8fe		       8d 8e df 	      sta	pattern	;..pattern once
   1214  f901							;
   1215  f901							; Start of loop.  This fills/tests one complete pass
   1216  f901							; of memory.
   1217  f901							;
   1218  f901		       20 05 fc    memTestMain jsr	cstatus	;key pressed?
   1219  f904		       d0 ae		      bne	memabort	;branch if yes
   1220  f906		       ad 95 df 	      lda	SAL	;reset pointer to start
   1221  f909		       85 f0		      sta	sptr
   1222  f90b		       ad 96 df 	      lda	SAH
   1223  f90e		       85 f1		      sta	sptr+1
   1224  f910							;
   1225  f910							; Fill memory with the rolling pattern until the last
   1226  f910							; location is filled.
   1227  f910							;
   1228  f910		       a0 00		      ldy	#0
   1229  f912		       ad 8e df 	      lda	pattern
   1230  f915		       8d 8f df 	      sta	original
   1231  f918		       91 f0	   memTestFill sta	(sptr),y
   1232  f91a		       c9 ba		      cmp	#PATTERN_9	;at last pattern?
   1233  f91c		       d0 05		      bne	memFill3
   1234  f91e		       a9 01		      lda	#PATTERN_0	;restart pattern
   1235  f920		       4c 28 f9 	      jmp	memFill4
   1236  f923							;
   1237  f923							; Rotate pattern left one bit
   1238  f923							;
   1239  f923		       0a	   memFill3   asl		; a
   1240  f924		       90 02		      bcc	memFill4	;branch if not overflow
   1241  f926		       a9 ba		      lda	#PATTERN_9	;ninth pattern
   1242  f928							;
   1243  f928							; The new pattern is in A.  Now see if we've reached
   1244  f928							; the end of the area to be tested.
   1245  f928							;
   1246  f928		       48	   memFill4   pha		;save pattern
   1247  f929		       a5 f0		      lda	sptr
   1248  f92b		       cd 97 df 	      cmp	EAL
   1249  f92e		       d0 07		      bne	memFill5
   1250  f930		       a5 f1		      lda	sptr+1
   1251  f932		       cd 98 df 	      cmp	EAH
   1252  f935		       f0 07		      beq	memCheck
   1253  f937							;
   1254  f937							; Not done, so move to next address and keep going.
   1255  f937							;
   1256  f937		       20 d3 f9    memFill5   jsr	INCPT
   1257  f93a		       68		      pla		;recover pattern
   1258  f93b		       4c 18 f9 	      jmp	memTestFill
   1259  f93e							;
   1260  f93e							; Okay, memory is filled, so now go back and test it.
   1261  f93e							; We kept a backup copy of the initial pattern to
   1262  f93e							; use, but save the current pattern as the starting
   1263  f93e							; point for the next pass.
   1264  f93e							;
   1265  f93e		       68	   memCheck   pla
   1266  f93f		       8d 8e df 	      sta	pattern	;for next pass
   1267  f942		       ad 95 df 	      lda	SAL	;reset pointer to start
   1268  f945		       85 f0		      sta	sptr
   1269  f947		       ad 96 df 	      lda	SAH
   1270  f94a		       85 f1		      sta	sptr+1
   1271  f94c		       ad 8f df 	      lda	original	;restore initial pattern
   1272  f94f		       a0 00		      ldy	#0
   1273  f951		       d1 f0	   memTest2   cmp	(sptr),y
   1274  f953		       d0 2c		      bne	memFail
   1275  f955		       c9 ba		      cmp	#PATTERN_9
   1276  f957		       d0 04		      bne	memTest3
   1277  f959							;
   1278  f959							; Time to reload the pattern
   1279  f959							;
   1280  f959		       a9 01		      lda	#PATTERN_0
   1281  f95b		       d0 05		      bne	memTest4
   1282  f95d							;
   1283  f95d							; Rotate pattern left one bit
   1284  f95d							;
   1285  f95d		       0a	   memTest3   asl		; a
   1286  f95e		       90 02		      bcc	memTest4
   1287  f960		       a9 ba		      lda	#PATTERN_9
   1288  f962							;
   1289  f962							; The new pattern is in A.
   1290  f962							;
   1291  f962		       48	   memTest4   pha		;save pattern
   1292  f963		       a5 f0		      lda	sptr
   1293  f965		       cd 97 df 	      cmp	EAL
   1294  f968		       d0 07		      bne	memTest5	;not at end
   1295  f96a		       a5 f1		      lda	sptr+1
   1296  f96c		       cd 98 df 	      cmp	EAH
   1297  f96f		       f0 07		      beq	memDone	;at end of pass
   1298  f971							;
   1299  f971							; Not at end yet, so inc pointer and continue
   1300  f971							;
   1301  f971		       20 d3 f9    memTest5   jsr	INCPT
   1302  f974		       68		      pla
   1303  f975		       4c 51 f9 	      jmp	memTest2
   1304  f978							;
   1305  f978							; Another pass has completed.
   1306  f978							;
   1307  f978		       68	   memDone    pla
   1308  f979		       a9 2e		      lda	#'.
   1309  f97b		       20 ed fb 	      jsr	cout
   1310  f97e		       4c 01 f9 	      jmp	memTestMain
   1311  f981							;
   1312  f981							; Failure.  Display the failed address, the expected
   1313  f981							; value and what was actually there.
   1314  f981							;
   1315  f981		       48	   memFail    pha		;save pattern for error report
   1316  f982		       20 68 fb 	      jsr	putsil
      0  f985					      db	CR,LF
      1  f985		       0d 0a		      .byte.b	CR,LF
      0  f987					      db	"Failure at address ",0
      1  f987		       46 61 69 6c*	      .byte.b	"Failure at address ",0
   1319  f99b		       a5 f1		      lda	sptr+1
   1320  f99d		       20 a9 fb 	      jsr	HexA
   1321  f9a0		       a5 f0		      lda	sptr
   1322  f9a2		       20 a9 fb 	      jsr	HexA
   1323  f9a5		       20 68 fb 	      jsr	putsil
      0  f9a8					      db	".  Expected ",0
      1  f9a8		       2e 20 20 45*	      .byte.b	".  Expected ",0
   1325  f9b5		       68		      pla
   1326  f9b6		       20 a9 fb 	      jsr	HexA
   1327  f9b9		       20 68 fb 	      jsr	putsil
      0  f9bc					      db	" but got ",0
      1  f9bc		       20 62 75 74*	      .byte.b	" but got ",0
   1329  f9c6		       a0 00		      ldy	#0
   1330  f9c8		       b1 f0		      lda	(sptr),y
   1331  f9ca		       20 a9 fb 	      jsr	HexA
   1332  f9cd		       20 c6 fb 	      jsr	crlf
   1333  f9d0		       4c 5c f1    cmdRet4    jmp	prompt
   1334  f9d3							;
   1335  f9d3							;=====================================================
   1336  f9d3							; Increment sptr
   1337  f9d3							;
   1338  f9d3		       e6 f0	   INCPT      inc	sptr
   1339  f9d5		       d0 02		      bne	incpt2
   1340  f9d7		       e6 f1		      inc	sptr+1
   1341  f9d9		       60	   incpt2     rts
   1342  f9da							;
   1343  f9da							;=====================================================
   1344  f9da							; Ping the Arduino disk controller.  This just sends the
   1345  f9da							; PING command gets back one character, then returns.
   1346  f9da							; Not much of a test but is sufficient to prove the
   1347  f9da							; link is working.
   1348  f9da							;
   1349  f9da		       20 68 fb    pingDisk   jsr	putsil
      0  f9dd					      db	"Ping... ",0
      1  f9dd		       50 69 6e 67*	      .byte.b	"Ping... ",0
   1351  f9e6		       20 20 fc 	      jsr	DiskPing
   1352  f9e9		       20 68 fb 	      jsr	putsil
      0  f9ec					      db	"success!"
      1  f9ec		       73 75 63 63*	      .byte.b	"success!"
      0  f9f4					      db	CR,LF,0
      1  f9f4		       0d 0a 00 	      .byte.b	CR,LF,0
   1355  f9f7		       4c 5c f1    doDiskDirEnd jmp	prompt
   1356  f9fa							;
   1357  f9fa							;=====================================================
   1358  f9fa							; Do a disk directory of the SD card.
   1359  f9fa							;
   1360  f9fa		       20 68 fb    doDiskDir  jsr	putsil
      0  f9fd					      db	"Disk Directory..."
      1  f9fd		       44 69 73 6b*	      .byte.b	"Disk Directory..."
      0  fa0e					      db	CR,LF,0
      1  fa0e		       0d 0a 00 	      .byte.b	CR,LF,0
   1363  fa11							;		 jsr	xParInit
   1364  fa11		       20 33 fc 	      jsr	DiskDir
   1365  fa14							;
   1366  fa14							; Get/Display each entry
   1367  fa14							;
   1368  fa14		       a2 df	   doDiskDirLoop ldx	#filename/256	;pointer to buffer
   1369  fa16		       a0 9a		      ldy	#filename&$ff
   1370  fa18		       86 f3		      stx	INH	;save for puts
   1371  fa1a		       84 f2		      sty	INL
   1372  fa1c		       20 3d fc 	      jsr	DiskDirNext	;get next entry
   1373  fa1f		       b0 d6		      bcs	doDiskDirEnd	;carry = end of list
   1374  fa21		       20 d3 fb 	      jsr	space3
   1375  fa24		       20 8b fb 	      jsr	puts	;else print name
   1376  fa27		       20 c6 fb 	      jsr	crlf
   1377  fa2a		       4c 14 fa 	      jmp	doDiskDirLoop	;do next entry
   1378  fa2d							;
   1379  fa2d							;=====================================================
   1380  fa2d							; Adds the character in A to the CRC.	Preserves A.
   1381  fa2d							;
   1382  fa2d		       48	   updateCrc  pha
   1383  fa2e		       18		      clc
   1384  fa2f		       6d a9 df 	      adc	CHKL
   1385  fa32		       8d a9 df 	      sta	CHKL
   1386  fa35		       68		      pla
   1387  fa36		       60		      rts
   1388  fa37							;
   1389  fa37							;=====================================================
   1390  fa37							; Print character in A as two hex digits to the
   1391  fa37							; current output device (console or file).
   1392  fa37							;
   1393  fa37		       48	   HexToOutput pha		;save return value
   1394  fa38		       48		      pha
   1395  fa39		       4a		      lsr		;a    ;move top nibble to bottom
   1396  fa3a		       4a		      lsr		;a
   1397  fa3b		       4a		      lsr		;a
   1398  fa3c		       4a		      lsr		;a
   1399  fa3d		       20 46 fa 	      jsr	hexta	;output nibble
   1400  fa40		       68		      pla
   1401  fa41		       20 46 fa 	      jsr	hexta
   1402  fa44		       68		      pla		;restore
   1403  fa45		       60		      rts
   1404  fa46							;
   1405  fa46		       29 0f	   hexta      and	#%0001111
   1406  fa48		       c9 0a		      cmp	#$0a
   1407  fa4a		       18		      clc
   1408  fa4b		       30 02		      bmi	hexta1
   1409  fa4d		       69 07		      adc	#7
   1410  fa4f		       69 30	   hexta1     adc	#'0	;then fall into...
   1411  fa51							;
   1412  fa51							;=====================================================
   1413  fa51							; This is a helper function used for redirected I/O.
   1414  fa51							; It simply does a jump through the output vector
   1415  fa51							; pointer to send the character in A to the proper
   1416  fa51							; device.
   1417  fa51							;
   1418  fa51		       6c 08 df    redirectedOutch jmp	(outputVector)
   1419  fa54							;
   1420  fa54							;=====================================================
   1421  fa54							; Set up the output vector to point to the normal
   1422  fa54							; console output subroutine.
   1423  fa54							;
   1424  fa54				   setOutputConsole
   1425  fa54		       a9 ed		      lda	#cout&$ff
   1426  fa56		       8d 08 df 	      sta	outputVector
   1427  fa59		       a9 fb		      lda	#cout/256
   1428  fa5b		       8d 09 df 	      sta	outputVector+1
   1429  fa5e		       60		      rts
   1430  fa5f							;
   1431  fa5f							;=====================================================
   1432  fa5f							; Set up the output vector to point to a file write
   1433  fa5f							; subroutine.
   1434  fa5f							;
   1435  fa5f				   setOutputFile
   1436  fa5f		       a9 1f		      lda	#putNextFileByte&$ff
   1437  fa61		       8d 08 df 	      sta	outputVector
   1438  fa64		       a9 f7		      lda	#putNextFileByte/256
   1439  fa66		       8d 09 df 	      sta	outputVector+1
   1440  fa69							;
   1441  fa69							; Clear counts and offsets so the next read will
   1442  fa69							; cause the file to be read.
   1443  fa69							;
   1444  fa69		       a9 00		      lda	#0
   1445  fa6b		       8d a7 df 	      sta	diskBufOffset
   1446  fa6e		       60		      rts
   1447  fa6f							;
   1448  fa6f							;=====================================================
   1449  fa6f							; Set up the input vector to point to the normal
   1450  fa6f							; console input subroutine.
   1451  fa6f							;
   1452  fa6f				   setInputConsole
   1453  fa6f		       a9 7a		      lda	#cinecho&$ff
   1454  fa71		       8d 06 df 	      sta	inputVector
   1455  fa74		       a9 fa		      lda	#cinecho/256
   1456  fa76		       8d 07 df 	      sta	inputVector+1
   1457  fa79		       60		      rts
   1458  fa7a							;
   1459  fa7a		       20 fa fb    cinecho    jsr	cin
   1460  fa7d		       48		      pha
   1461  fa7e		       20 ed fb 	      jsr	cout
   1462  fa81		       68		      pla
   1463  fa82		       60		      rts
   1464  fa83							;
   1465  fa83							;=====================================================
   1466  fa83							; Set up the input vector to point to a file read
   1467  fa83							; subroutine.
   1468  fa83							;
   1469  fa83				   setInputFile
   1470  fa83		       a9 99		      lda	#getNextFileByte&$ff
   1471  fa85		       8d 06 df 	      sta	inputVector
   1472  fa88		       a9 fa		      lda	#getNextFileByte/256
   1473  fa8a		       8d 07 df 	      sta	inputVector+1
   1474  fa8d							;
   1475  fa8d							; Clear counts and offsets so the next read will
   1476  fa8d							; cause the file to be read.
   1477  fa8d							;
   1478  fa8d		       a9 00		      lda	#0
   1479  fa8f		       8d a7 df 	      sta	diskBufOffset
   1480  fa92		       8d a8 df 	      sta	diskBufLength
   1481  fa95		       60		      rts
   1482  fa96							;
   1483  fa96							;=====================================================
   1484  fa96							; This is a helper function used for redirected I/O.
   1485  fa96							; It simply does a jump through the input vector
   1486  fa96							; pointer to get the next input character.
   1487  fa96							;
   1488  fa96		       6c 06 df    redirectedGetch jmp	(inputVector)
   1489  fa99							;
   1490  fa99							;=====================================================
   1491  fa99							; This gets the next byte from an open disk file.  If
   1492  fa99							; there are no more bytes left, this returns C set.
   1493  fa99							; Else, C is clear and A contains the character.
   1494  fa99							;
   1495  fa99		       ae a7 df    getNextFileByte ldx	diskBufOffset
   1496  fa9c		       ec a8 df 	      cpx	diskBufLength
   1497  fa9f		       d0 14		      bne	hasdata	;branch if still data
   1498  faa1							;
   1499  faa1							; There is no data left in the buffer, so read a
   1500  faa1							; block from the SD system.
   1501  faa1							;
   1502  faa1		       a9 84		      lda	#BUFFER_SIZE
   1503  faa3		       a2 df		      ldx	#buffer>>8
   1504  faa5		       a0 0a		      ldy	#buffer&$ff
   1505  faa7		       20 a9 fc 	      jsr	DiskRead
   1506  faaa		       b0 12		      bcs	getNextEof
   1507  faac							;
   1508  faac							; A contains the number of bytes actually read.
   1509  faac							;
   1510  faac		       8d a8 df 	      sta	diskBufLength	;save length
   1511  faaf		       c9 00		      cmp	#0	;shouldn't happen
   1512  fab1		       f0 0b		      beq	getNextEof
   1513  fab3							;
   1514  fab3		       a2 00		      ldx	#0
   1515  fab5		       bd 0a df    hasdata    lda	buffer,x
   1516  fab8		       e8		      inx
   1517  fab9		       8e a7 df 	      stx	diskBufOffset
   1518  fabc		       18		      clc
   1519  fabd		       60		      rts
   1520  fabe							;
   1521  fabe		       a9 00	   getNextEof lda	#0
   1522  fac0		       8d a7 df 	      sta	diskBufOffset
   1523  fac3		       8d a8 df 	      sta	diskBufLength
   1524  fac6		       38		      sec
   1525  fac7		       60		      rts
   1526  fac8
   1527  fac8							;page
   1528  fac8							;
   1529  fac8							;========================================jlit 8/2/2022
   1530  fac8							; Remove a file from the disk
   1531  fac8							;
   1532  fac8		       20 68 fb    rmFile     jsr	putsil
      0  facb					      db	"Enter filename to rm ",0
      1  facb		       45 6e 74 65*	      .byte.b	"Enter filename to rm ",0
   1534  fae1		       20 e7 f6 	      jsr	getFileName
   1535  fae4		       a0 9a		      ldy	#filename&$ff
   1536  fae6		       a2 df		      ldx	#filename/256
   1537  fae8							;		 jsr	xParInit
   1538  fae8		       20 a4 fc 	      jsr	DiskRemoveFile
   1539  faeb		       90 0f		      bcc	rmOk	; removed ok
   1540  faed		       20 68 fb 	      jsr	putsil
      0  faf0					      db	"rm failed"
      1  faf0		       72 6d 20 66*	      .byte.b	"rm failed"
      0  faf9					      db	CR,LF,0
      1  faf9		       0d 0a 00 	      .byte.b	CR,LF,0
   1543  fafc		       4c 5c f1    rmOk       jmp	prompt
   1544  faff							;
   1545  faff							;=====================================================
   1546  faff							; Type the contents of an SD file to console.
   1547  faff							;
   1548  faff		       20 68 fb    typeFile   jsr	putsil
      0  fb02					      db	"Enter filename to type: ",0
      1  fb02		       45 6e 74 65*	      .byte.b	"Enter filename to type: ",0
   1550  fb1b		       20 e7 f6 	      jsr	getFileName
   1551  fb1e		       a0 9a		      ldy	#filename&$ff
   1552  fb20		       a2 df		      ldx	#filename/256
   1553  fb22							;	     jsr    xParInit
   1554  fb22		       20 6e fc 	      jsr	DiskOpenRead
   1555  fb25		       90 1e		      bcc	typeFile1	;opened ok
   1556  fb27							;
   1557  fb27		       20 68 fb 	      jsr	putsil
      0  fb2a					      db	CR,LF
      1  fb2a		       0d 0a		      .byte.b	CR,LF
      0  fb2c					      db	"Failed to open file"
      1  fb2c		       46 61 69 6c*	      .byte.b	"Failed to open file"
      0  fb3f					      db	CR,LF,0
      1  fb3f		       0d 0a 00 	      .byte.b	CR,LF,0
   1561  fb42		       4c 5c f1 	      jmp	prompt
   1562  fb45							;
   1563  fb45							; Now just keep reading in bytes and displaying them.
   1564  fb45							;
   1565  fb45		       20 83 fa    typeFile1  jsr	setInputFile	;reading from file
   1566  fb48		       20 99 fa    typeFileLoop jsr	getNextFileByte
   1567  fb4b		       b0 06		      bcs	typeEof
   1568  fb4d		       20 ed fb 	      jsr	cout	;display character
   1569  fb50		       4c 48 fb 	      jmp	typeFileLoop
   1570  fb53							;
   1571  fb53		       20 12 fd    typeEof    jsr	DiskClose
   1572  fb56		       4c 5c f1 	      jmp	prompt
   1573  fb59							;
   1574  fb59							;=====================================================
   1575  fb59							; This flushes any data remaining in the disk buffer
   1576  fb59							; and then closes the file.
   1577  fb59							;
   1578  fb59		       ad a7 df    CloseOutFile lda	diskBufOffset
   1579  fb5c		       f0 07		      beq	closeonly
   1580  fb5e		       a2 df		      ldx	#buffer>>8
   1581  fb60		       a0 0a		      ldy	#buffer&$ff
   1582  fb62		       20 db fc 	      jsr	DiskWrite
   1583  fb65							;
   1584  fb65		       4c 12 fd    closeonly  jmp	DiskClose
   1585  fb68							;
------- FILE io.asm LEVEL 2 PASS 2
      0  fb68					      include	"io.asm"
      1  fb68					      Processor	6502
      2  fb68							;*********************************************************
      3  fb68							; FILE: io.asm
      4  fb68							;
      5  fb68							; This contains slightly higher level console related
      6  fb68							; functions like text output, reading a line, etc.
      7  fb68							;*********************************************************
      8  fb68							;
      9  fb68							;
     10  fb68		       00 00	   EnableGetline equ	0	;Disable the Getline function
     11  fb68		       00 00	   EnableParse equ	0	;Disable the parse line function
     12  fb68				  -	      if	EnableGetline
     13  fb68				  -	      SEG.U	RomScratch
     14  fb68				  -BUFFER     ds	BUFFER_SIZE
     15  fb68				  -argc       ds	1
     16  fb68				  -argv       ds	MAX_ARGC
     17  fb68					      endif
     18  fb68					      Seg	Code
     19  fb68							;
     20  fb68							;*********************************************************
     21  fb68							; Print the string that follows the JSR to this code.
     22  fb68							; Taken from http://www.6502.org/source/io/primm.htm
     23  fb68							; The last example by Ross Archer.
     24  fb68							;
     25  fb68		       68	   putsil     pla		;Get the low part of "return" address
     26  fb69							;(data start address)
     27  fb69		       85 f4		      sta	putsp
     28  fb6b		       68		      pla
     29  fb6c		       85 f5		      sta	putsp+1	;Get the high part of "return" address
     30  fb6e							;(data start address)
     31  fb6e							;Note: actually we're pointing one short
     32  fb6e		       a0 01	   PSINB      ldy	#1
     33  fb70		       b1 f4		      lda	(putsp),y	;Get the next string character
     34  fb72		       e6 f4		      inc	putsp	;update the pointer
     35  fb74		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
     36  fb76		       e6 f5		      inc	putsp+1	;account for page crossing
     37  fb78		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
     38  fb7a							;   Accumulator
     39  fb7a		       f0 06		      beq	PSIX1	;don't print the final NULL
     40  fb7c		       20 ed fb 	      jsr	cout	;write it out
     41  fb7f		       4c 6e fb 	      jmp	PSINB	;back around
     42  fb82		       e6 f4	   PSIX1      inc	putsp
     43  fb84		       d0 02		      bne	PSIX2
     44  fb86		       e6 f5		      inc	putsp+1	;account for page crossing
     45  fb88		       6c f4 00    PSIX2      jmp	(putsp)	;return to byte following final NULL
     46  fb8b							;
     47  fb8b							;=====================================================
     48  fb8b							; This prints the null terminated string pointed to by
     49  fb8b							; INL and INH.  Modifies those locations to point to
     50  fb8b							; the end of the string.
     51  fb8b							;
     52  fb8b		       a0 00	   puts       ldy	#0
     53  fb8d		       b1 f2	   putsy      lda	(INL),y
     54  fb8f		       e6 f2		      inc	INL
     55  fb91		       d0 02		      bne	puts1
     56  fb93		       e6 f3		      inc	INH
     57  fb95		       09 00	   puts1      ora	#0
     58  fb97		       f0 0c		      beq	putsdone
     59  fb99		       8c 90 df 	      sty	SaveY
     60  fb9c		       20 ed fb 	      jsr	cout	;print character
     61  fb9f		       ac 90 df 	      ldy	SaveY
     62  fba2		       4c 8d fb 	      jmp	putsy
     63  fba5		       60	   putsdone   rts
     64  fba6							;
     65  fba6							;*********************************************************
     66  fba6							; Get a line of text from the console and put it into
     67  fba6							; BUFFER.  This only allows printable characters, will
     68  fba6							; limit the amount of text to BUFFER_SIZE-1 characters,
     69  fba6							; and allows some editing.  Returns the string with a null
     70  fba6							; byte at the end and the length in A.  If the length is
     71  fba6							; zero, return Z set.
     72  fba6							;
     73  fba6				   getline
     74  fba6				  -	      if	EnableGetline
     75  fba6				  -	      ldx	#0
     76  fba6				  -	      beq	getline1
     77  fba6				  -			;
     78  fba6				  -			; This outputs a bell.  Used when the user
     79  fba6				  -			; does something bad, like non-printable
     80  fba6				  -			; characters or exceeding line length.
     81  fba6				  -			;
     82  fba6				  -getline2   lda	#BELL
     83  fba6				  -	      jsr	cout
     84  fba6				  -			;
     85  fba6				  -			; Get the next character
     86  fba6				  -			;
     87  fba6				  -getline1   jsr	cin	;get character
     88  fba6				  -	      cmp	#' '	;
     89  fba6				  -	      bcc	getline2	;not printable
     90  fba6				  -	      cmp	#'~'+1
     91  fba6				  -	      bcs	getline2	;not printable
     92  fba6				  -	      cmp	#CR	;end of input?
     93  fba6				  -	      beq	getline3
     94  fba6				  -	      cpx	#BUFFER_SIZE-1
     95  fba6				  -	      beq	getline1	;too long
     96  fba6				  -	      sta	BUFFER,x
     97  fba6				  -	      jsr	cout	;echo, echo, echo...
     98  fba6				  -	      inx
     99  fba6				  -	      bne	getline1
    100  fba6				  -			;
    101  fba6				  -			; Got a CR, so terminate the string.
    102  fba6				  -			;
    103  fba6				  -getline3   lda	#0
    104  fba6				  -	      sta	BUFFER,x
    105  fba6				  -	      txa		;will set/clear Z
    106  fba6					      endif
    107  fba6		       60		      rts
    108  fba7							;
    109  fba7							;*********************************************************
    110  fba7							; This converts the buffer to all lower case.
    111  fba7							;
    112  fba7				   ToLower
    113  fba7				  -	      if	EnableParse
    114  fba7				  -	      ldx	#0
    115  fba7				  -ToLower1   lda	BUFFER,x
    116  fba7				  -	      beq	ToLowerDone
    117  fba7				  -			;
    118  fba7				  -	      cmp	#'a
    119  fba7				  -	      bcc	ToLower2
    120  fba7				  -	      cmp	#'z+1
    121  fba7				  -	      bcs	ToLower2
    122  fba7				  -	      clc
    123  fba7				  -	      sbc	#$20	;convert
    124  fba7				  -	      sta	BUFFER,x
    125  fba7				  -ToLower2   inx
    126  fba7				  -	      bne	ToLower1
    127  fba7					      endif
    128  fba7		       60	   ToLowerDone rts
    129  fba8							;
    130  fba8							;*********************************************************
    131  fba8							; This parses the current contents of BUFFER.	It scans
    132  fba8							; until finding whitespace, terminates the string (puts a
    133  fba8							; null), then scans until finding the next non-whitespace
    134  fba8							; and repeats the process again.  Saves the offset to each
    135  fba8							; word in argc, and has a total count in argv.  Yes, I am
    136  fba8							; a C programmer.
    137  fba8							;
    138  fba8				   parse
    139  fba8				  -	      if	EnableParse
    140  fba8				  -	      ldx	#0
    141  fba8				  -	      stx	argc	;clear count
    142  fba8				  -	      dex
    143  fba8				  -			;
    144  fba8				  -			; Skip whitespace
    145  fba8				  -			;
    146  fba8				  -parse1     inx
    147  fba8				  -	      lda	BUFFER,x
    148  fba8				  -	      beq	parse2	;at EOL
    149  fba8				  -	      cmp	#' '
    150  fba8				  -	      beq	parse1	;whitespace
    151  fba8				  -			;
    152  fba8				  -			; Not whitespace
    153  fba8				  -			;
    154  fba8				  -	      ldy	argc
    155  fba8				  -	      stx	argv,y
    156  fba8				  -	      iny
    157  fba8				  -	      cpy	#MAX_ARGC
    158  fba8				  -	      beq	parse2
    159  fba8				  -	      sty	argv
    160  fba8				  -			;
    161  fba8				  -			; Now skip until whitespace found again
    162  fba8				  -			;
    163  fba8				  -parse3     inx
    164  fba8				  -	      lda	BUFFER,x
    165  fba8				  -	      beq	parse2
    166  fba8				  -	      cmp	#' '
    167  fba8				  -	      bne	parse3
    168  fba8				  -	      lda	#0
    169  fba8				  -	      sta	BUFFER,x	;terminate
    170  fba8				  -	      jmp	parse1
    171  fba8				  -			;
    172  fba8					      endif
    173  fba8		       60	   parse2     rts
    174  fba9							;
    175  fba9							;*********************************************************
    176  fba9							; Dump the contents of A as two hex digits.  Preserves
    177  fba9							; all registers.
    178  fba9							;
    179  fba9		       48	   HexA       pha		;save value
    180  fbaa		       48		      pha
    181  fbab		       4a		      lsr		;a
    182  fbac		       4a		      lsr		;a
    183  fbad		       4a		      lsr		;a
    184  fbae		       4a		      lsr		;a
    185  fbaf		       20 b8 fb 	      jsr	HexDigit
    186  fbb2		       68		      pla
    187  fbb3		       20 b8 fb 	      jsr	HexDigit
    188  fbb6		       68		      pla		;restore value
    189  fbb7		       60		      rts
    190  fbb8							;
    191  fbb8		       29 0f	   HexDigit   and	#$0f
    192  fbba		       c9 0a		      cmp	#$0a
    193  fbbc		       18		      clc
    194  fbbd		       30 02		      bmi	HexDigit1
    195  fbbf		       69 07		      adc	#7
    196  fbc1		       69 30	   HexDigit1  adc	#'0
    197  fbc3		       4c ed fb 	      jmp	cout
    198  fbc6							;
    199  fbc6							;*********************************************************
    200  fbc6							; Output a CR/LF combination to the console.  Preserves
    201  fbc6							; all registers.
    202  fbc6							;
    203  fbc6		       48	   crlf       pha
    204  fbc7		       a9 0d		      lda	#CR
    205  fbc9		       20 ed fb 	      jsr	cout
    206  fbcc		       a9 0a		      lda	#LF
    207  fbce		       20 ed fb 	      jsr	cout
    208  fbd1		       68		      pla
    209  fbd2		       60		      rts
    210  fbd3							;
    211  fbd3							;*********************************************************
    212  fbd3							; Output one, two or three spaces.  Preserves all
    213  fbd3							; register.
    214  fbd3							;
    215  fbd3		       20 d9 fb    space3     jsr	space
    216  fbd6		       20 d9 fb    space2     jsr	space
    217  fbd9		       48	   space      pha
    218  fbda		       a9 20		      lda	#$20
    219  fbdc		       20 ed fb 	      jsr	cout
    220  fbdf		       68		      pla
    221  fbe0		       60		      rts
    222  fbe1
    223  fbe1
------- FILE ctmon65.asm
------- FILE acia.asm LEVEL 2 PASS 2
      0  fbe1					      include	"acia.asm"
      1  fbe1					      processor	6502
      2  fbe1					      Seg	Code
      3  fbe1							;*********************************************************
      4  fbe1							; FILE: acia.asm
      5  fbe1							;*********************************************************
      6  fbe1							;
      7  fbe1		       00 00	   CONSOLE_SLOT equ	0
      8  fbe1							;
      9  fbe1		       e0 00	   ACIA       equ	(CONSOLE_SLOT*IO_SIZE)+IO_BASE
     10  fbe1		       00 01	   RDRF       equ	%00000001
     11  fbe1		       00 02	   TDRE       equ	%00000010
     12  fbe1							;
     13  fbe1							;*********************************************************
     14  fbe1							; Initialize the ACIA
     15  fbe1							;
     16  fbe1		       a9 03	   cinit      lda	#%00000011	;reset
     17  fbe3		       8d 00 e0 	      sta	ACIA
     18  fbe6		       ea		      nop
     19  fbe7		       a9 11		      lda	#%00010001	;8N2
     20  fbe9		       8d 00 e0 	      sta	ACIA
     21  fbec		       60		      rts
     22  fbed							;
     23  fbed							;*********************************************************
     24  fbed							; Output the character in A to the console.  This will
     25  fbed							; block until the character is queued.  Preserves all
     26  fbed							; registers.
     27  fbed							;
     28  fbed		       48	   cout       pha
     29  fbee		       ad 00 e0    cout1      lda	ACIA
     30  fbf1		       29 02		      and	#TDRE
     31  fbf3		       f0 f9		      beq	cout1	;not empty
     32  fbf5		       68		      pla
     33  fbf6		       8d 01 e0 	      sta	ACIA+1
     34  fbf9		       60		      rts
     35  fbfa							;
     36  fbfa							;*********************************************************
     37  fbfa							; Gets a character from the console and returns it in A.
     38  fbfa							; Modifies no other registers.  This blocks until a
     39  fbfa							; character is available.
     40  fbfa							;
     41  fbfa		       ad 00 e0    cin	      lda	ACIA
     42  fbfd		       29 01		      and	#RDRF
     43  fbff		       f0 f9		      beq	cin
     44  fc01		       ad 01 e0 	      lda	ACIA+1
     45  fc04		       60		      rts
     46  fc05							;
     47  fc05							;*********************************************************
     48  fc05							; Get the status of the console.  Returns Z set if no
     49  fc05							; characters are available, Z clear if a character is
     50  fc05							; ready.
     51  fc05							;
     52  fc05		       ad 00 e0    cstatus    lda	ACIA
     53  fc08		       29 01		      and	#RDRF
     54  fc0a		       60		      rts
------- FILE ctmon65.asm
   1588  fc0b
   1589  fc0b					      if	SD_ENABLED
------- FILE parproto.inc LEVEL 2 PASS 2
      0  fc0b					      include	"parproto.inc"
      1  fc0b					      Processor	6502
      2  fc0b							;*****************************************************
      3  fc0b							; Parallel port protocol
      4  fc0b							;
      5  fc0b							; This is the header file for making applications
      6  fc0b							; compliant with The Remote Disk Protocol Guide which
      7  fc0b							; is on the Corsham Technologies web page somewhere:
      8  fc0b							;
      9  fc0b							;    www.corshamtech.com
     10  fc0b							;
     11  fc0b							; This was updated 06/13/2015 to be compliant with the
     12  fc0b							; official specification, so the opcode values changed.
     13  fc0b							;
     14  fc0b							; Another update on 09/04/2017
     15  fc0b							;
     16  fc0b							;=====================================================
     17  fc0b							; Commands from host to Arduino
     18  fc0b							;
     19  fc0b		       00 01	   PC_GET_VERSION equ	$01
     20  fc0b		       00 05	   PC_PING    equ	$05	;ping Arduino
     21  fc0b		       00 06	   PC_LED_CONTROL equ	$06	;LED control
     22  fc0b		       00 10	   PC_GET_DIR equ	$10	;Get directory
     23  fc0b		       00 11	   PC_GET_MOUNTED equ	$11	;Get mounted drive list
     24  fc0b		       00 12	   PC_MOUNT   equ	$12	;Mount drive
     25  fc0b		       00 13	   PC_UNMOUNT equ	$13	;Unmount drive
     26  fc0b		       00 14	   PC_GET_STATUS equ	$14	;Get status for one drive
     27  fc0b		       00 15	   PC_DONE    equ	$15	;Stop data
     28  fc0b		       00 15	   PC_ABORT   equ	PC_DONE
     29  fc0b		       00 16	   PC_READ_FILE equ	$16	;Read regular file (non-DSK)
     30  fc0b		       00 17	   PC_READ_BYTES equ	$17	;Read sequential bytes
     31  fc0b		       00 18	   PC_RD_SECTOR equ	$18	;Read FLEX sector
     32  fc0b		       00 19	   PC_WR_SECTOR equ	$19	;Write FLEX sector
     33  fc0b		       00 1a	   PC_GET_MAX equ	$1a	;Get maximum drives
     34  fc0b		       00 1b	   PC_WRITE_FILE equ	$1b	;Open file for writing
     35  fc0b		       00 1c	   PC_WRITE_BYTES equ	$1c	;Data to be written
     36  fc0b		       00 1d	   PC_SAVE_CONFIG equ	$1d	;Save SD.CFG with current values
     37  fc0b		       00 1e	   PC_SET_TIMER equ	$1e	;Set RTC timer
     38  fc0b		       00 1f	   PC_WR_SEC_LONG equ	$1f	;Write sector with long sec num
     39  fc0b		       00 20	   PC_RD_SEC_LONG equ	$20	;Read sector with long sec num
     40  fc0b		       00 21	   PC_RM_FILE equ	$21	;remove a file non-dsk
     41  fc0b							;
     42  fc0b							;=====================================================
     43  fc0b							; Responses from Arduino to host
     44  fc0b							;
     45  fc0b		       00 81	   PR_VERSION_INFO equ	$81	;Contains version information
     46  fc0b		       00 82	   PR_ACK     equ	$82	;ACK (no additional information)
     47  fc0b		       00 83	   PR_NAK     equ	$83	;NAK - one status byte follows
     48  fc0b		       00 85	   PR_PONG    equ	$85	;Reply to a ping
     49  fc0b		       00 90	   PR_DIR_ENTRY equ	$90	;Directory entry
     50  fc0b		       00 91	   PR_DIR_END equ	$91	;End of directory entries
     51  fc0b		       00 92	   PR_FILE_DATA equ	$92	;File data
     52  fc0b		       00 93	   PR_STATUS  equ	$93	;Drive status
     53  fc0b		       00 94	   PR_SECTOR_DATA equ	$94	;Sector data
     54  fc0b		       00 95	   PR_MOUNT_INFO equ	$95	;Mount entry
     55  fc0b		       00 96	   PR_MAX_DRIVES equ	$96	;Maximum number of drives
     56  fc0b							;
     57  fc0b							;=====================================================
     58  fc0b							; Error codes for NAK events.	Yes, these are in
     59  fc0b							; decimal due to an error in the original
     60  fc0b							; documentation.
     61  fc0b							;
     62  fc0b		       00 00	   ERR_NONE   equ	0
     63  fc0b		       00 0a	   ERR_NOT_MOUNTED equ	10
     64  fc0b		       00 0b	   ERR_MOUNTED equ	11
     65  fc0b		       00 0c	   ERR_NOT_FOUND equ	12
     66  fc0b		       00 0d	   ERR_READ_ONLY equ	13
     67  fc0b		       00 0e	   ERR_BAD_DRIVE equ	14
     68  fc0b		       00 0f	   ERR_BAD_TRACK equ	15
     69  fc0b		       00 10	   ERR_BAD_SECTOR equ	16
     70  fc0b		       00 11	   ERR_READ_ERROR equ	17
     71  fc0b		       00 12	   ERR_WRITE_ERROR equ	18
     72  fc0b		       00 13	   ERR_NOT_PRESENT equ	19
     73  fc0b		       00 14	   ERR_NOT_IMPL equ	20	;Command not implemented
     74  fc0b
------- FILE ctmon65.asm
------- FILE pario.asm LEVEL 2 PASS 2
      0  fc0b					      include	"pario.asm"
      1  fc0b					      Processor	6502
      2  fc0b							;CTMON65 version using a 6821
      3  fc0b
      4  fc0b							;*****************************************************
      5  fc0b							; These are the low-level I/O routines to talk to the
      6  fc0b							; Arduino processor connected to the KIM's I/O port.
      7  fc0b							;
      8  fc0b							; August 2014, Bob Applegate K2UT, bob@corshamtech.com
      9  fc0b							;
     10  fc0b							; Which port bits are used for what:
     11  fc0b							;
     12  fc0b							; A0 = Data 0, alternates input/output
     13  fc0b							; A1 = Data 1, alternates input/output
     14  fc0b							; A2 = Data 2, alternates input/output
     15  fc0b							; A3 = Data 3, alternates input/output
     16  fc0b							; A4 = Data 4, alternates input/output
     17  fc0b							; A5 = Data 5, alternates input/output
     18  fc0b							; A6 = Data 6, alternates input/output
     19  fc0b							; A7 = Data 7, alternates input/output
     20  fc0b							;
     21  fc0b							; B0 = Direction bit, always output
     22  fc0b							; B1 = Write strobe or ACK, always output
     23  fc0b							; B2 = Read strobe or ACK, always input
     24  fc0b							;
     25  fc0b							;----------------------------------------------------
     26  fc0b							; Bits in the B register
     27  fc0b							;
     28  fc0b		       00 01	   DIRECTION  equ	%00000001
     29  fc0b		       00 02	   PSTROBE    equ	%00000010
     30  fc0b		       00 04	   ACK	      equ	%00000100
     31  fc0b							;
     32  fc0b							;----------------------------------------------------
     33  fc0b							; Which slot the parallel board is in.  This needs to
     34  fc0b							; be set for the system in use.  As long as the user
     35  fc0b							; programs only call functions in here, no other
     36  fc0b							; file/application should know which slot the board
     37  fc0b							; is in.
     38  fc0b							;
     39  fc0b		       00 01	   PIASLOT    equ	1
     40  fc0b							;
     41  fc0b							; Computed addresses of 6821 registers
     42  fc0b							;
     43  fc0b		       e0 10	   PIABASE    equ	IO_BASE+(PIASLOT*IO_SIZE)
     44  fc0b		       e0 10	   PIAREGA    equ	PIABASE	;data reg A
     45  fc0b		       e0 10	   PIADDRA    equ	PIABASE	;data dir reg A
     46  fc0b		       e0 11	   PIACTLA    equ	PIABASE+1	;control reg A
     47  fc0b		       e0 12	   PIAREGB    equ	PIABASE+2	;data reg B
     48  fc0b		       e0 12	   PIADDRB    equ	PIABASE+2	;data dir reg B
     49  fc0b		       e0 13	   PIACTLB    equ	PIABASE+3	;control reg B
     50  fc0b
     51  fc0b					      Seg	Code
     52  fc0b							;page
     53  fc0b							;
     54  fc0b							;*****************************************************
     55  fc0b							; This is the initialization function.  Call before
     56  fc0b							; doing anything else with the parallel port.
     57  fc0b							;
     58  fc0b				   xParInit
     59  fc0b							;
     60  fc0b							; Set up the data direction register for port B so that
     61  fc0b							; the DIRECTION and PSTROBE bits are output.
     62  fc0b							;
     63  fc0b							;		  lda	#0		       ;select DDR
     64  fc0b							;		  sta	PIACTLB		       ;...for port B
     65  fc0b							;		  lda	#DIRECTION | PSTROBE
     66  fc0b							;		  sta	PIADDRB
     67  fc0b							;		  lda	#4		       ;select data reg
     68  fc0b							;		  sta	PIACTLB
     69  fc0b							;
     70  fc0b							; Fall through to set up for writes...
     71  fc0b							;
     72  fc0b							;page
     73  fc0b							;*****************************************************
     74  fc0b							; This sets up for writing to the Arduino.  Sets up
     75  fc0b							; direction registers, drives the direction bit, etc.
     76  fc0b							;
     77  fc0b		       a9 00	   xParSetWrite lda	#0	;select DDR
     78  fc0d							;		 sta	PIACTLA	     ;...for port A
     79  fc0d							;		 lda	#$ff		     ;set bits for output
     80  fc0d							;		 sta	PIADDRA
     81  fc0d							;		 lda	#4		     ;select data reg
     82  fc0d							;		 sta	PIACTLA
     83  fc0d							;
     84  fc0d							; Set direction flag to output, clear ACK bit
     85  fc0d							;
     86  fc0d							;		lda	#DIRECTION
     87  fc0d							;		sta	PIAREGB
     88  fc0d		       60		      rts
     89  fc0e							;page
     90  fc0e							;*****************************************************
     91  fc0e							; This sets up for reading from the Arduino.  Sets up
     92  fc0e							; direction registers, clears the direction bit, etc.
     93  fc0e							;
     94  fc0e		       a9 00	   xParSetRead lda	#0	;select DDR
     95  fc10							;		 sta	PIACTLA		 ;...for port A
     96  fc10							;		 lda	#$00		 ;set bits for input
     97  fc10							;		 sta	PIADDRA
     98  fc10							;		 lda	#4		 ;select data reg
     99  fc10							;		 sta	PIACTLA
    100  fc10							;
    101  fc10							; Set direction flag to input, clear ACK bit
    102  fc10							;
    103  fc10							;		lda	#0
    104  fc10							;		sta	PIAREGB
    105  fc10		       60		      rts
    106  fc11							;page
    107  fc11							;*****************************************************
    108  fc11							; This writes a single byte to the Arduino.  On entry,
    109  fc11							; the byte to write is in A.  This assumes ParSetWrite
    110  fc11							; was already called.
    111  fc11							;
    112  fc11							; Destroys A, all other registers preserved.
    113  fc11							;
    114  fc11							; Write cycle:
    115  fc11							;
    116  fc11							;    1. Wait for other side to lower ACK.
    117  fc11							;    2. Put data onto the bus.
    118  fc11							;    3. Set DIRECTION and PSTROBE to indicate data
    119  fc11							;	 is valid and ready to read.
    120  fc11							;    4. Wait for ACK line to go high, indicating the
    121  fc11							;	 other side has read the data.
    122  fc11							;    5. Lower PSTROBE.
    123  fc11							;    6. Wait for ACK to go low, indicating end of
    124  fc11							;	 transfer.
    125  fc11							;messed up for emulator, we need to protocols
    126  fc11				   xParWriteByte
    127  fc11							;		  pha		      ;save data
    128  fc11							;Parwl22	  lda	PIAREGB	 ;check status
    129  fc11							;		  and	#ACK
    130  fc11							;		  bne	Parwl22	 ;wait for ACK to go low
    131  fc11							;
    132  fc11							; Now put the data onto the bus
    133  fc11							;
    134  fc11							;		 pla
    135  fc11		       8d 10 e0 	      sta	PIAREGA
    136  fc14							;
    137  fc14							; Raise the strobe so the Arduino knows there is
    138  fc14							; new data.
    139  fc14							;
    140  fc14							;		  lda	PIAREGB
    141  fc14							;		  ora	#PSTROBE
    142  fc14							;		  sta	PIAREGB
    143  fc14							;
    144  fc14							; Wait for ACK to go high, indicating the Arduino has
    145  fc14							; pulled the data and is ready for more.
    146  fc14							;
    147  fc14							;Parwl33	  lda	PIAREGB
    148  fc14							;		  and	#ACK
    149  fc14							;		  beq	Parwl33
    150  fc14							;
    151  fc14							; Now lower the strobe, then wait for the Arduino to
    152  fc14							; lower ACK.
    153  fc14							;
    154  fc14							;		  lda	PIAREGB
    155  fc14							;		  and	#~PSTROBE
    156  fc14							;		  sta	PIAREGB
    157  fc14							;Parwl44	  lda	PIAREGB
    158  fc14							;		  and	#ACK
    159  fc14							;		  bne	Parwl44
    160  fc14		       60		      rts
    161  fc15							;page
    162  fc15							;*****************************************************
    163  fc15							; This reads a byte from the Arduino and returns it in
    164  fc15							; A.  Assumes ParSetRead was called before.
    165  fc15							;
    166  fc15							; This does not have a time-out.
    167  fc15							;
    168  fc15							; Preserves all other registers.
    169  fc15							;
    170  fc15							; Read cycle:
    171  fc15							;
    172  fc15							;    1. Wait for other side to raise ACK, indicating
    173  fc15							;	 data is ready.
    174  fc15							;    2. Read data.
    175  fc15							;    3. Raise PSTROBE indicating data was read.
    176  fc15							;    4. Wait for ACK to go low.
    177  fc15							;    5. Lower PSTROBE.
    178  fc15							;
    179  fc15		       ad 12 e0    xParReadByte lda	PIAREGB
    180  fc18		       29 04		      and	#ACK	;is their strobe high?
    181  fc1a		       f0 f9		      beq	xParReadByte	;nope, no data
    182  fc1c							;
    183  fc1c							; Data is available, so grab and save it.
    184  fc1c							;
    185  fc1c		       ad 10 e0 	      lda	PIAREGA
    186  fc1f							;		  pha
    187  fc1f							;
    188  fc1f							; Now raise our strobe (their ACK), then wait for
    189  fc1f							; them to lower their strobe.
    190  fc1f							;
    191  fc1f							;		  lda	PIAREGB
    192  fc1f							;		  ora	#PSTROBE
    193  fc1f							;		  sta	PIAREGB
    194  fc1f							;Parrlp1	  lda	PIAREGB
    195  fc1f							;		  and	#ACK
    196  fc1f							;		  bne	Parrlp1		    ;still active
    197  fc1f							;
    198  fc1f							; Lower our ack, then were done.
    199  fc1f							;
    200  fc1f							;		  lda	PIAREGB
    201  fc1f							;		  and	#~PSTROBE
    202  fc1f							;		  sta	PIAREGB
    203  fc1f							;		  pla
    204  fc1f		       60		      rts
------- FILE ctmon65.asm
------- FILE diskfunc.asm LEVEL 2 PASS 2
      0  fc20					      include	"diskfunc.asm"
      1  fc20					      Processor	6502
      2  fc20							;=====================================================
      3  fc20							; This is a collection of functions for performing
      4  fc20							; higher level disk functions.  This hides the nasty
      5  fc20							; details of communications with the remote disk
      6  fc20							; system.
      7  fc20							;
      8  fc20							; August 20, 2014 - Bob Applegate
      9  fc20							;		     bob@corshamtech.com
     10  fc20							;
     11  fc20							; 06/14/2015 - Bob Applegate
     12  fc20							;		Now that there is an official standard
     13  fc20							;		for the protocol between the host (this
     14  fc20							;		code) and the DCP (Arduino code), this
     15  fc20							;		code has been updated to be compliant.
     16  fc20							;
     17  fc20							; 01/14/2016 - Bob Applegate
     18  fc20							;		Finally converted to 6502.
     19  fc20							;
     20  fc20							; 02/8/2022  - JustLostInTime
     21  fc20							;		added ability to remove disk file non-dsk
     22  fc20							;
     23  fc20							;		include	"parproto.inc"
     24  fc20							;
     25  fc20							; Number of drives emulated
     26  fc20							;
     27  fc20					      Seg	Code
     28  fc20		       00 04	   DRIVES     equ	4
     29  fc20							;
     30  fc20							;=====================================================
     31  fc20							; This is a sanity check to verify connectivity to the
     32  fc20							; Arduino code is working.  Returns C clear if all is
     33  fc20							; good, or C set if not.
     34  fc20							;
     35  fc20		       20 0b fc    DiskPing   jsr	xParSetWrite
     36  fc23		       a9 05		      lda	#PC_PING	;command
     37  fc25		       20 11 fc 	      jsr	xParWriteByte	;send to Arduino
     38  fc28		       20 0e fc 	      jsr	xParSetRead
     39  fc2b		       20 15 fc 	      jsr	xParReadByte	;read their reply
     40  fc2e		       20 0b fc    DiskRetGood jsr	xParSetWrite
     41  fc31		       18		      clc		;assume it's good
     42  fc32		       60		      rts
     43  fc33							;page
     44  fc33							;=====================================================
     45  fc33							; This starts a directory read of the raw drive, not
     46  fc33							; the mounted drive.  No input parameters.  This simply
     47  fc33							; sets up for reading the entries, then the user must
     48  fc33							; read each entry.
     49  fc33							;
     50  fc33							; Returns with C clear on success.  If error, C is set
     51  fc33							; and A contains the error code.
     52  fc33							;
     53  fc33		       20 0b fc    DiskDir    jsr	xParSetWrite
     54  fc36		       a9 10		      lda	#PC_GET_DIR	;send command
     55  fc38		       20 11 fc 	      jsr	xParWriteByte
     56  fc3b		       18		      clc		;assume it works
     57  fc3c		       60		      rts
     58  fc3d							;page
     59  fc3d							;=====================================================
     60  fc3d							; Read the next directory entry.  On input, X (MSB)
     61  fc3d							; and Y (LSB) point to a 13 byte area to receive the
     62  fc3d							; drive data.
     63  fc3d							;
     64  fc3d							; Returns C set if end of directory (ie, attempt to
     65  fc3d							; read and there are none left).  Else, C is clear
     66  fc3d							; and X/Y point to the null at end of filename.
     67  fc3d							;
     68  fc3d		       86 f1	   DiskDirNext stx	sptr+1
     69  fc3f		       84 f0		      sty	sptr
     70  fc41		       20 0e fc 	      jsr	xParSetRead	;read results
     71  fc44		       20 15 fc 	      jsr	xParReadByte	;get response code
     72  fc47		       c9 83		      cmp	#PR_NAK	;error?
     73  fc49		       f0 1e		      beq	DDNErr
     74  fc4b		       c9 91		      cmp	#PR_DIR_END	;end?
     75  fc4d		       f0 1a		      beq	DDNErr
     76  fc4f							;
     77  fc4f							; This contains a directory entry.
     78  fc4f							;
     79  fc4f		       a0 00		      ldy	#0
     80  fc51		       20 15 fc    DDNloop    jsr	xParReadByte
     81  fc54		       91 f0		      sta	(sptr),y
     82  fc56		       c9 00		      cmp	#0	;end?
     83  fc58		       f0 06		      beq	DDNEnd
     84  fc5a		       20 d3 f9 	      jsr	INCPT
     85  fc5d		       4c 51 fc 	      jmp	DDNloop
     86  fc60		       20 0b fc    DDNEnd     jsr	xParSetWrite
     87  fc63		       a6 f1		      ldx	sptr+1
     88  fc65		       a4 f0		      ldy	sptr
     89  fc67		       18		      clc		;not end of files
     90  fc68		       60		      rts
     91  fc69							;
     92  fc69							; Error.  Set C and return.  This is not really
     93  fc69							; proper, since this implies a simple end of the
     94  fc69							; directory rather than an error.
     95  fc69							;
     96  fc69		       20 0b fc    DDNErr     jsr	xParSetWrite
     97  fc6c		       38		      sec
     98  fc6d		       60		      rts
     99  fc6e							;page
    100  fc6e							;=====================================================
    101  fc6e							; This opens a file on the SD for reading.  On entry,
    102  fc6e							; X (MSB) and Y (LSB) point to a null-terminated
    103  fc6e							; filename to open.  On return, C is clear if the file
    104  fc6e							; is open, or C set if an error (usually means the
    105  fc6e							; file does not exist.
    106  fc6e							;
    107  fc6e							; Assumes write mode has been set.  Returns with it set.
    108  fc6e							;
    109  fc6e		       a9 16	   DiskOpenRead lda	#PC_READ_FILE
    110  fc70		       84 f2	   DiskOpen   sty	INL	;save ptr to filename
    111  fc72		       86 f3		      stx	INH
    112  fc74		       48		      pha
    113  fc75		       20 0b fc 	      jsr	xParSetWrite
    114  fc78		       68		      pla
    115  fc79		       20 11 fc 	      jsr	xParWriteByte
    116  fc7c		       a0 ff		      ldy	#-1
    117  fc7e		       c8	   DiskOpenLoop iny
    118  fc7f		       b1 f2		      lda	(INL),y
    119  fc81		       20 11 fc 	      jsr	xParWriteByte
    120  fc84		       b1 f2		      lda	(INL),y
    121  fc86		       d0 f6		      bne	DiskOpenLoop
    122  fc88		       20 0e fc 	      jsr	xParSetRead
    123  fc8b		       20 15 fc 	      jsr	xParReadByte	;get response
    124  fc8e		       c9 82		      cmp	#PR_ACK
    125  fc90		       d0 05		      bne	DiskOpenErr
    126  fc92		       20 0b fc 	      jsr	xParSetWrite	;back to write mode
    127  fc95		       18		      clc
    128  fc96		       60		      rts
    129  fc97							;
    130  fc97							; Got an error.
    131  fc97							;
    132  fc97		       20 15 fc    DiskOpenErr jsr	xParReadByte	;get error code
    133  fc9a		       20 0b fc 	      jsr	xParSetWrite	;back to write mode
    134  fc9d		       38		      sec
    135  fc9e		       60		      rts
    136  fc9f							;=====================================================
    137  fc9f							; This opens a file on the SD for writing.  On entry,
    138  fc9f							; X (MSB) and Y (LSB) point to a null-terminated
    139  fc9f							; filename to open.  On return, C is clear if the file
    140  fc9f							; is open, or C set if an error.
    141  fc9f							;
    142  fc9f							; Assumes write mode has been set.  Returns with it set.
    143  fc9f							;
    144  fc9f		       a9 1b	   DiskOpenWrite lda	#PC_WRITE_FILE
    145  fca1		       4c 70 fc 	      jmp	DiskOpen	;jump into common code
    146  fca4							;=====================================================
    147  fca4							; This Removes a file from the SD for writing.  On entry,
    148  fca4							; X (MSB) and Y (LSB) point to a null-terminated
    149  fca4							; filename to remove.	On return, C is clear if the file
    150  fca4							; is removed, or C set if an error.
    151  fca4							;
    152  fca4							; Assumes write mode has been set.  Returns with it set.
    153  fca4							;
    154  fca4		       a9 21	   DiskRemoveFile lda	#PC_RM_FILE
    155  fca6		       4c 70 fc 	      jmp	DiskOpen
    156  fca9							;
    157  fca9							;=====================================================
    158  fca9							; On entry, A contains the number of bytes to read
    159  fca9							; from the file, X (MSB) and Y (LSB) point to the
    160  fca9							; buffer where to put the data.  On return, C will
    161  fca9							; be set if EOF was reached (and no data read), or
    162  fca9							; C will be clear and A contains the number of bytes
    163  fca9							; actually read into the buffer.
    164  fca9							;
    165  fca9							; Modifies A, X and Y.  Also modifies INL and INH
    166  fca9							; (00F8 and 00F9).
    167  fca9							;
    168  fca9		       48	   DiskRead   pha
    169  fcaa		       84 f2		      sty	INL	;save ptr to buffer
    170  fcac		       86 f3		      stx	INH
    171  fcae		       a9 17		      lda	#PC_READ_BYTES
    172  fcb0		       20 11 fc 	      jsr	xParWriteByte	;command
    173  fcb3		       68		      pla		;number of bytes to get
    174  fcb4		       20 11 fc 	      jsr	xParWriteByte
    175  fcb7		       20 0e fc 	      jsr	xParSetRead	;get ready for response
    176  fcba		       20 15 fc 	      jsr	xParReadByte	;assume PR_FILE_DATA
    177  fcbd		       20 15 fc 	      jsr	xParReadByte	;length
    178  fcc0		       48		      pha
    179  fcc1		       aa		      tax		;count
    180  fcc2		       f0 11		      beq	DiskReadEof	;zero = EOF
    181  fcc4		       a0 00		      ldy	#0	;offset
    182  fcc6		       20 15 fc    DiskReadLoop jsr	xParReadByte
    183  fcc9		       91 f2		      sta	(INL),y
    184  fccb		       c8		      iny		;next offset
    185  fccc		       ca		      dex
    186  fccd		       d0 f7		      bne	DiskReadLoop
    187  fccf		       20 0b fc 	      jsr	xParSetWrite
    188  fcd2		       68		      pla		;retrieve byte count
    189  fcd3		       18	   DiskOk     clc
    190  fcd4		       60		      rts
    191  fcd5		       20 0b fc    DiskReadEof jsr	xParSetWrite
    192  fcd8		       68		      pla
    193  fcd9		       38		      sec
    194  fcda		       60		      rts
    195  fcdb							;
    196  fcdb							;=====================================================
    197  fcdb							; On entry, A contains the number of bytes to write
    198  fcdb							; to the file, X (MSB) and Y (LSB) point to the
    199  fcdb							; buffer where to get the data.  On return, C will
    200  fcdb							; be set if an error was detected, or C will be clear
    201  fcdb							; if no error.  Note that if A contains 0 on entry,
    202  fcdb							; no bytes are written.
    203  fcdb							;
    204  fcdb							; Modifies A, X and Y.  Also modifies INL and INH
    205  fcdb							; (00F8 and 00F9).
    206  fcdb							;
    207  fcdb		       c9 00	   DiskWrite  cmp	#0
    208  fcdd		       f0 f4		      beq	DiskOk
    209  fcdf		       84 f2		      sty	INL	;save ptr to filename
    210  fce1		       86 f3		      stx	INH
    211  fce3		       48		      pha
    212  fce4		       a9 1c		      lda	#PC_WRITE_BYTES
    213  fce6		       20 11 fc 	      jsr	xParWriteByte	;command
    214  fce9		       68		      pla		;number of bytes to write
    215  fcea		       48		      pha		;save again
    216  fceb		       20 11 fc 	      jsr	xParWriteByte
    217  fcee		       68		      pla
    218  fcef		       aa		      tax		;count
    219  fcf0		       a0 00		      ldy	#0	;offset
    220  fcf2		       b1 f2	   DiskWriteLoop lda	(INL),y	;get next byte
    221  fcf4		       20 11 fc 	      jsr	xParWriteByte
    222  fcf7		       c8		      iny		;next offset
    223  fcf8		       ca		      dex
    224  fcf9		       d0 f7		      bne	DiskWriteLoop
    225  fcfb		       20 0e fc 	      jsr	xParSetRead	;read the status
    226  fcfe		       20 15 fc 	      jsr	xParReadByte
    227  fd01		       c9 82		      cmp	#PR_ACK
    228  fd03		       f0 08		      beq	DiskOk1	;all good
    229  fd05		       20 15 fc 	      jsr	xParReadByte	;read error code
    230  fd08		       20 0b fc 	      jsr	xParSetWrite
    231  fd0b		       38		      sec
    232  fd0c		       60		      rts
    233  fd0d							;
    234  fd0d		       20 0b fc    DiskOk1    jsr	xParSetWrite
    235  fd10		       18		      clc
    236  fd11		       60		      rts
    237  fd12							;
    238  fd12							;=====================================================
    239  fd12							; Call this to close any open file.  No parameters
    240  fd12							; and no return status.
    241  fd12							;
    242  fd12		       a9 15	   DiskClose  lda	#PC_DONE
    243  fd14		       4c 11 fc 	      jmp	xParWriteByte
    244  fd17
    245  fd17
------- FILE ctmon65.asm
   1593  fd17					      endif
   1594  fd17							;
   1595  fd17							;*********************************************************
   1596  fd17							; Handlers for the interrupts.  Basiclly just jump
   1597  fd17							; through the vectors and hope they are set up properly.
   1598  fd17							;
   1599  fd17		       6c 02 df    HandleNMI  jmp	(NMIvec)
   1600  fd1a		       6c 00 df    HandleIRQ  jmp	(IRQvec)
   1601  fd1d							;
   1602  fd1d							;*********************************************************
   1603  fd1d							; Default handler.  Save the state of the machine for
   1604  fd1d							; debugging.  This is taken from the KIM monitor SAVE
   1605  fd1d							; routine.
   1606  fd1d							;
   1607  fd1d				   DefaultNMI
   1608  fd1d		       8d 8e df    DefaultIRQ sta	SaveA
   1609  fd20		       68		      pla
   1610  fd21		       8d 93 df 	      sta	SaveC
   1611  fd24		       68		      pla
   1612  fd25		       8d 91 df 	      sta	SavePC
   1613  fd28		       68		      pla
   1614  fd29		       8d 92 df 	      sta	SavePC+1
   1615  fd2c		       8c 90 df 	      sty	SaveY
   1616  fd2f		       8e 8f df 	      stx	SaveX
   1617  fd32		       ba		      tsx
   1618  fd33		       8e 94 df 	      stx	SaveSP
   1619  fd36		       20 3b f7 	      jsr	DumpRegisters
   1620  fd39		       20 c6 fb 	      jsr	crlf
   1621  fd3c		       4c 59 f1 	      jmp	WARM
   1622  fd3f							;
   1623  fd3f							;*********************************************************
   1624  fd3f							; 6502 vectors
   1625  fd3f							;
   1626  fffa					      org	$fffa
      0  fffa					      dw	HandleNMI
      1  fffa		       17 fd		      .word.w	HandleNMI
      0  fffc					      dw	RESET
      1  fffc		       48 f0		      .word.w	RESET
      0  fffe					      dw	HandleIRQ
      1  fffe		       1a fd		      .word.w	HandleIRQ
   1630  10000
