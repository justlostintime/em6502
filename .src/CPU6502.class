' Gambas class file

'Author Westwood JustLostintime
'Released Under:
'  GNU GENERAL Public LICENSE
'  Version 3, 29 June 2007
'  See project license file.

Fast Unsafe

Public PC As Long = &H0000                ' Program counter
Public SP As Byte = &HFF                  ' Stack Pointer 0x100-0x1ff 256 bytes fifo

Public SR As Byte = (1 Shl 3)             ' Status Register start with irq disabled
Public Enum SR_Carry, SR_Zero, SR_Interrupt, SR_Decimal, SR_Break, SR_Ignored, SR_Overflow, SR_Negative

Public AC As Byte = &h0                   ' Acumulator
Public X As Byte = &h0                    ' X register
Public Y As Byte = &h0                    ' Y Register

Public DataBus As Integer = &h0           ' Data on databus
Public AddressBus As Long = &h0           ' Address Bus current address
Property BreakPoints As Boolean Use $BreakPoints  ' turn on breakpoint checking
Public BreakPointList As Long[]           ' an array of breakpoints
Public InstProfile As Profiler            ' when profiling is on then this counts cycles per instruction
Property ProfileSortOrder As Boolean Use $ProfileSortOrder

'When the following Is False just Return $ff On a bad Memory Read Or Write
Property ChkBadMemAccess As Boolean Use $ChkBadMemAccess = True ' turn on or off catching bad read or writes

Public Enum mem_read = 1, mem_write = 2, mem_rw = 4

Public AddressMap_Read As New Object[]            ' Address bus map object pointers
Public AddressMap_Write As New Object[]           ' Address bus map object pointers

Public RealMemory_Read As New Object[1024 * 64]   ' Used to map for read byte lots of space
Public RealMemory_Write As New Object[1024 * 64]  ' Used to map for write byte lots of space

Property SingleStep As Boolean Use $SingleStep                 '' Turn On single step mode
Property DisplayStatus As Boolean Use $DisplayStatus           '' Turn On the status screen
Property DisplayInstruction As Boolean Use $DisplayInstruction '' Cause the instruction to be executed to be displayed to the trace screen
Property DisplayMemory As Boolean Use $DisplayMemory           '' Causes the update of all memory monitor Watch list etc
Private DisplayRequired As Boolean = False                                                 ' Used for faster check if anydisplay info needed
Public LastTraceInstruction As String                                                             ' When trace is on this will contain the last data
Public TotalInstructions As Long = 0                                                               ' Number of instructions executed
Property Read InstructionsPerSecond As Long Use $InstructionsPerSecond '' Number of instructions executed per second

Public CpuClock As Timer                                                                                    ' will run at 1 millisecond intervals       will have to do some sort of multiplyer

Property Read CyclesPerSecond As Long Use $CyclesPerSecond          ' will track the actual number of cycles per second
Property Read TotalCycles As Long Use $TotalCycles                                 ' Total Number of Cycles executed

Property SpeedScaler As Long Use $SpeedScaler                                         ' use this as each cpu we run on may have a different clock
Property InteruptPending As Boolean Use $InteruptPending = False
Property IRQPending As Boolean Use $IRQPending = False
Property NMIPending As Boolean Use $NMIPending = False
Property ResetPending As Boolean Use $ResetPending = False
Property Halted As Boolean Use $Halted = False
Property Profiling As Boolean Use $Profiling = False

Property cpu65c02 As Boolean Use $cpu65c02 = False

Property MillisecondTicks As Long Use $MillisecondTicks = 2000        ' based upon @mhz oscillator speed
Property ExternalOssilator As Variant Use $ExternalOssilator = Null   ' will callback to this each millisecond
Private OssilatorCounter As Long = 0                                  ' This is the counter used by the cpu to queue the call to ossilator

Event StatusInfo(information As Cpustatus)
Event NextInst(Inst As String)
Event breakpoint(pc As Long)
Event BinaryLoaded(address As Long, BinName As String, info As String)
Event Abort(Reason As String)
Event MemUpdated()

Fast Unsafe Public Sub _new()

  If FMain.Verbose Then Error Disassembler.version
  $TotalCycles = 0
  $CyclesPerSecond = 0
  $InstructionsPerSecond = 0
  CpuClock = New Timer As "MyClock"
  CpuClock.Delay = 1000
  CpuClock.enabled = True
  $SpeedScaler = 500
  $BreakPoints = False
  BreakPointList = New Long[]

End

Fast Unsafe Public Sub _free()

  CpuClock.enabled = False

End

Private Sub SingleStep_write(value As Boolean)             ' Turn On single step mode

  If value Then
    DisplayRequired = True
    $SingleStep = True
  Else
    $SingleStep = False
    If $DisplayInstruction Or $DisplayMemory Or $DisplayStatus Then
      Return
    Endif
    DisplayRequired = False
  Endif

End

Private Sub SingleStep_read() As Boolean

  Return $SingleStep

End

Private Sub DisplayStatus_write(value As Boolean)          ' Turn On the status screen

  If value Then
    DisplayRequired = True
    $DisplayStatus = True
  Else
    $DisplayStatus = False
    If $DisplayInstruction Or $DisplayMemory Or $SingleStep Then
      Return
    Endif
    DisplayRequired = False
  Endif

End

Private Sub DisplayStatus_Read() As Boolean

  Return $DisplayStatus

End

Private Sub DisplayInstruction_write(value As Boolean)     ' Cause the instruction to be executed to be displayed to the trace screen

  If value Then
    DisplayRequired = True
    $DisplayInstruction = True
  Else
    $DisplayInstruction = False
    If $SingleStep Or $DisplayMemory Or $Displaystatus Then
      Return
    Endif
    DisplayRequired = False
  Endif

End

Private Sub DisplayInstruction_Read() As Boolean

  Return $DisplayInstruction

End

Private Sub DisplayMemory_write(value As Boolean)          ' Causes the update of all memory monitor Watch list etc

  If value Then
    DisplayRequired = True
    $DisplayMemory = True
  Else
    $DisplayMemory = False
    If $DisplayInstruction Or $SingleStep Or $DisplayStatus Then
      Return
    Endif
    DisplayRequired = False
  Endif

End

Private Sub DisplayMemory_Read() As Boolean

  Return $DisplayMemory

End

Public Sub MyClock_Timer()                     ' the cpu psudotimer

  Static StartInstructionCount As Long = 0
  Static StartCycleCount As Long = 0

  $InstructionsPerSecond = TotalInstructions - StartInstructionCount
  StartInstructionCount = TotalInstructions
  $CyclesPerSecond = $TotalCycles - StartCycleCount
  StartCycleCount = $TotalCycles

End

Public Sub Halt()

  CpuClock.Enabled = False                                              ' Stop the cpu internal clock
  $SingleStep = True
  $Halted = True
  Wait 0.001

  For Each o As Object In AddressMap_Read
    If Object.Class(o).Exist("halt") Then
      o.halt()                                                          ' tell each device to shutdown if needed
      Wait 0.001
    Endif
  Next

  For Each o As Object In AddressMap_Write
    If AddressMap_Read.Exist(o) Then Continue                           ' Dont repeat the message if wr object
    If Object.Class(o).Exist("halt") Then
      o.halt()                                                          ' tell each device to shutdown if needed
      Wait 0.001
    Endif
  Next

End

Public Sub ReadBytes(address As Long, length As Integer) As Byte[]

  Dim result As New Byte[]
  Dim sdb As Byte = databus
  Dim sab As Long = AddressBus

  For i As Integer = 0 To length - 1

    AddressBus = address + i
    ReadByte()
    result.Add(DataBus)

  Next

  DataBus = sdb
  AddressBus = sab
  Return result

End

Public Sub WriteBytes(buffer As Byte[], address As Long, length As Integer)

  Dim sdb As Byte = databus
  Dim sab As Long = AddressBus

  For i As Integer = 0 To length - 1

    DataBus = buffer[i]
    AddressBus = address + i
    WriteByte()

  Next

  DataBus = sdb
  AddressBus = sab

End

Public Sub LoadMemory(FileName As String)

  Dim BinInfo As File
  Dim al, ah As Byte
  Dim buffer As Byte[]
  Dim address As Long = 0
  Dim BinName As String = File.BaseName(FileName)

  Try BinInfo = Open filename For Read
  If Error Then
    Raise BinaryLoaded(address, "", ("Fail:") & BinName & ":" & Error.text)
    Return
  Endif

  Read #BinInfo, al
  Read #BinInfo, ah

  Address = Address Or ah
  Address = ((Address Shl 8) Or al)
  If FMain.Verbose Then Error "@ "; ("Loading Image to address "); Hex(address, 4)

  Dim Length As Integer = Lof(BinInfo) - 2
  buffer = New Byte[length]
  buffer.Read(bininfo)
  Try WriteBytes(buffer, address, length)
  If Error Then
    Raise BinaryLoaded(address, "", ("Fail Writing bytes:") & BinName & ":" & Error.text)
  Endif
  Raise BinaryLoaded(address, BinName, "$" & Hex(address, 4) & "-" & Hex(Address + Length - 1, 4) & " - " & BinName)

End

Public Sub Run()

  Dim counter As Long = 0

  While Not $halted
    If $Breakpoints Or $InteruptPending Then
      If $BreakPoints Then
        If BreakPointList.ExistSorted(pc) Then
          $SingleStep = True
          $Breakpoints = False
          Raise breakpoint(pc)
          StepInfo()
          Return
        Endif
      Endif

      If $InteruptPending Then
        $InteruptPending = False
        If $ResetPending Then
          CycleCount += 9
          Reset()
        Else If $NMIPending Then
          CycleCount += 5
          NMI()
        Else If $IRQPending Then
          CycleCount += 5
          IRQ()
        Endif
      Endif
    Endif

    If $ExternalOssilator Then
      If OssilatorCounter = 0 Then
        OssilatorCounter = $MillisecondTicks
        $ExternalOssilator.Tick()
      Else
        Dec OssilatorCounter
      Endif
    Endif

    'ExecuteInstruction()
    'Public Sub ExecuteInstruction()

    Dim inst As Integer
    Dim addrMode, aaa, cc As Integer

    If pc > &h0ffff Or If pc < 0 Then
      Stop
    Endif

    AddressBus = pc

    ReadByte()
    inst = DataBus

    CycleCount = Disassembler.InstructionCycles[inst]
    $TotalCycles += CycleCount

    If $Profiling Then
      InstProfile.count(pc, CycleCount)
    Endif

    Inc pc
    AddressBus = pc

    'addrMode = Disassembler.AddrMode[inst]
    ' address mode is same as bbb in instruction
    addrMode = (inst Shr 2) And &h07
    'aaa = disassembler.aaa[inst]
    aaa = inst Shr 5
    'cc = disassembler.cc[inst]
    cc = inst And &h03

    Select Case cc
      Case 0
        Group0(Me, aaa, addrMode)
      Case 1
        Group1(Me, aaa, AddrMode)
      Case 2
        Group2(Me, aaa, AddrMode)
      Case 3
        Group3(Me, aaa, AddrMode)
    End Select

    Inc TotalInstructions

    'End
    '
    'If $DisplayRequired Or If $DisplayMemory Or $SingleStep Or $DisplayInstruction Or $DisplayStatus Then
    If DisplayRequired Then

      If $DisplayStatus Then
        Dim pinfo As New CpuStatus(pc, sp, ac, X, Y, sr, DataBus, AddressBus, TotalInstructions, $InstructionsPerSecond, $TotalCycles, $CyclesPerSecond)
        Raise StatusInfo(pinfo)
      Endif

      If $DisplayMemory Then
        Raise MemUpdated()
      Endif

      If $SingleStep Or If $DisplayInstruction Then
        StepInfo()
        If $SingleStep Then Return
      Endif

    Endif

    If counter = $SpeedScaler Then   'This is also used to keep the GUI responsive to inputs
      Wait 0.0001                                       'This is used to check the GUI and throttle the cpu speed
      counter = 0                                        'The larger the number the faster the cpu functions
    Else
      Inc counter
    Endif

  Wend

End

'' Create an event with all the information needed to display the next Instruction with status
Sub StepInfo()
  ''@NOTE: add highlighting

  LastTraceInstruction = Left(Disassembler.Inst(Me, pc) & Space(40), 40) & "->[" & SRText() & "] " & Hex(ac, 2) & " " & Hex(X, 2) & " " & Hex(Y, 2) & " " & "1" & Hex(sp, 2)
  Raise NextInst(LastTraceInstruction)

End

Public Sub ResetOssilator()

  OssilatorCounter = $MillisecondTicks

End

FlagsOn As String[] = ["C", "Z", "I", "D", "B", "-", "V", "N"]
FlagsOff As String[] = ["c", "z", "i", "d", "b", "-", "v", "n"]

Sub SRText() As String

  Dim flag As String = ""

  For i As Integer = 7 DownTo 0
    If BTst(sr, i) Then
      flag &= "\e[32m" & FlagsOn[i] & "\e[0m"
    Else
      flag &= FlagsOff[i]
    Endif

  Next
  Return flag

End

CycleCount As Integer

Public Sub ExecuteInstruction()

  Dim inst As Integer
  Dim addrMode, aaa, cc As Integer

  If pc > &h0ffff Or If pc < 0 Then
    Stop
  Endif

  AddressBus = pc

  ReadByte()
  inst = DataBus

  CycleCount = Disassembler.InstructionCycles[inst]
  $TotalCycles += CycleCount

  If $Profiling Then
    InstProfile.count(pc, CycleCount)
  Endif

  Inc pc
  AddressBus = pc

  'addrMode = Disassembler.AddrMode[inst]
  ' address mode is same as bbb in instruction
  addrMode = (inst Shr 2) And &h07
  'aaa = disassembler.aaa[inst]
  aaa = inst Shr 5
  'cc = disassembler.cc[inst]
  cc = inst And &h03

  Select Case cc
    Case 0
      Group0(Me, aaa, addrMode)
    Case 1
      Group1(Me, aaa, AddrMode)
    Case 2
      Group2(Me, aaa, AddrMode)
    Case 3
      Group3(Me, aaa, AddrMode)
  End Select

  Inc TotalInstructions

End

Public Sub Absolute()

  Dim addrTemp As Long

  ReadByte()
  addrTemp = DataBus
  Inc pc
  Inc AddressBus
  ReadByte()
  AddressBus = ((DataBus Shl 8) Or addrTemp)
  Inc PC

End

Public Sub AbsX()

  Absolute()
  AddressBus += X

End

Public Sub AbsY()

  Absolute()
  AddressBus += Y

End

Public Sub ZeroPage()

  ReadByte()
  AddressBus = DataBus
  Inc PC

End

Public Sub ZeroPageIndirect()

  Dim addrTemp As Long

  ZeroPage()
  ReadByte()
  addrTemp = DataBus
  Inc AddressBus
  ReadByte()
  AddressBus = (DataBus Shl 8) Or addrTemp

End

Public Sub ZeroPageX()

  ZeroPage()
  AddressBus += X

End

Public Sub ZeroPageY()

  ZeroPage()
  AddressBus += Y

End

Public Sub Immediate()

  AddressBus = PC
  Inc pc

End

Public Sub IndirectAbsX()

  Dim addrTemp As Long

  AbsX()                                       ' get the table and offset

  ReadByte()                                   ' Get the value into the address bus
  addrTemp = DataBus
  Inc AddressBus
  ReadByte()
  AddressBus = (DataBus Shl 8) Or addrTemp

End

Public Sub IndirectX()

  Dim addrTemp As Long

  ReadByte()
  AddressBus = DataBus + x
  ReadByte()
  addrTemp = DataBus
  Inc AddressBus
  ReadByte()
  AddressBus = (DataBus Shl 8) Or addrTemp
  Inc PC

End

Public Sub IndirectY()

  Dim addrTemp As Long

  ReadByte()
  AddressBus = DataBus
  ReadByte()
  addrTemp = DataBus
  Inc AddressBus
  Try ReadByte()
  If Error Then
    Stop
  Endif
  AddressBus = (DataBus Shl 8) Or addrTemp
  AddressBus += Y
  Inc PC

End

Public Sub Indirect()

  Dim addrTemp As Long

  Absolute()
  ReadByte()
  addrTemp = DataBus
  Inc AddressBus
  ReadByte()
  AddressBus = (DataBus Shl 8) Or addrTemp

End

Public Sub AddMap(Start As Long, Len As Long, Device As Class, Optional vParams As Variant = "", rw As Integer = mem_rw) As Object

  Dim iorw As Integer

  Dim params As Variant[] = [Start, Len, vParams]

  Dim dev As Object = Device.New(params)

  If Device.Exist("TheCpu") Then
    dev.TheCpu = Me
    If Device.Exist("CpuInit") Then
      dev.CpuInit()
    Endif
  Endif

  object.attach(dev, Me, "MyDevice")

  If (rw And &h0005) > 0 Then AddressMap_Read.Add(Dev)
  If (rw And &h0006) > 0 Then AddressMap_Write.Add(Dev)

  If len = 0 Then Return dev                            ' allow devices which require no memory, such as buttons and switches

  'mapLow.Add(Start)
  'mapHigh.Add(Start + len - 1)

  For mem As Integer = Start To Start + len - 1        ' build a real map of the memory for speed later.. I know lots of wasted space
    If (rw And &h0005) > 0 Then RealMemory_read[mem] = Dev
    If (rw And &h0006) > 0 Then RealMemory_write[mem] = Dev
  Next

  If Device.Exist("IoAddress") Then                    '  We allow a device to also have an io control address
    If device.Exist("IoRw") Then
      iorw = device.IoRw
    Else
      iorw = mem_rw
    Endif

    If (rw And &h0005) > 0 Then AddressMap_Read.Add(Dev)
    If (rw And &h0006) > 0 Then AddressMap_Write.Add(Dev)

    If Device.Exist("IoLength") Then

      For mem = Dev.IoAddress To (Dev.IoAddress + Dev.IoLength - 1)
        If (iorw And &h0005) > 0 Then RealMemory_read[mem] = Dev
        If (iorw And &h0006) > 0 Then RealMemory_write[mem] = Dev
      Next

    Else

      If (iorw And &h0005) > 0 Then RealMemory_read[Dev.IoAddress] = dev
      If (iorw And &h0006) > 0 Then RealMemory_write[Dev.IoAddress] = dev

    Endif

  Endif

  ' now let the computer know what binary images were loaded when the device was created
  If Object.Class(dev).Exist("BinLoaded") Then
    Dim binImage As String[] = Split(dev.BinLoaded, ",")
    For Each s As String In BinImage
      Dim info As String[] = Split(s, ":")
      Dim address As Long = Eval("&H0" & info[1])
      Raise BinaryLoaded(address, File.BaseName(info[0]), "$" & info[1] & " - " & File.BaseName(info[0]))
    Next
  Endif

  Return dev

End

Public Sub GetDevice(Address As Long, Optional rw As Integer = mem_read) As Object

  Dim dev As Object

  If rw = mem_read Or If rw = mem_rw Then
    dev = RealMemory_read[Address]
  Else If rw = mem_write Then
    dev = RealMemory_write[address]
  End If

  If $ChkBadMemAccess And If dev = Null Then Error.Raise(("Invalid Memory Address") & " [" & Hex(Address, 4) & "]")

  Return dev

End

Public Sub ReadByte()

  Dim dev As Object = Null

  Try dev = RealMemory_Read[AddressBus]
  If Error Then
    dev = Null
  Endif

  If dev Then
    DataBus = dev[AddressBus]
  Else
    If $ChkBadMemAccess Then
      Error.Raise(("Invalid Read Memory Address") & " [" & Hex(AddressBus, 4) & "]")
    Else
      DataBus = &HFF
    Endif
  Endif

End

Public Sub WriteByte()

  Dim dev As Object = Null

  Try dev = RealMemory_write[AddressBus]
  If Error Then
    dev = Null
  Endif

  If dev Then
    dev[AddressBus] = Databus
  Else
    If $ChkBadMemAccess Then
      Error.Raise(("Invalid Write Memory Address") & " [" & Hex(AddressBus, 4) & "]")
    Endif
  Endif

End

Public Sub Reset()

  $NMIPending = False
  $IRQPending = False
  $ResetPending = False

  For Each od As Object In AddressMap_read
    If Object.Class(od).Exist("Reset") Then
      od.reset()
    Endif
  Next

  For Each od As Object In AddressMap_write
    If AddressMap_read.Exist(od) Then Continue             ' dont tell device twice to reset
    If Object.Class(od).Exist("Reset") Then
      od.reset()
    Endif
  Next

  SR = (1 Shl 2)                ' set the irq disabled bit
  ac = 0
  SetSR(AC)

  AddressBus = &H00FFFC
  ReadByte()                    ' load Databus with value
  PC = CLong(DataBus)
  Inc AddressBus
  ReadByte()
  PC = PC Or (CLong(DataBus) Shl 8)

  If $SingleStep Then
    If FMain.Verbose Then Error "@ "; ("PC Reset");; Hex(pc)
    StepInfo()
  Endif

End

Public Sub DisplayCurrentInst()

  StepInfo()

End

Public Sub Branch()

  If BTst(databus, 7) Then
    Dim offset As Byte = &100 - databus
    pc -= offset
  Else
    pc += databus
  Endif

End

Public Sub Compare(Value As Byte)

  Dim RSLT As Byte = value - DATABUS

  If Value = DataBus Then
    Sr = BSet(Sr, 1)
    sr = BSet(sr, 0)
    sr = BClr(sr, 7)
  Else If Value < DataBus Then
    sr = BClr(sr, 0)
    sr = BClr(sr, 1)
  Else  ' greater than
    sr = BClr(sr, 1)
    sr = BSet(sr, 0)
  Endif
  If BTst(RSLT, 7) Then
    SR = BSet(SR, 7)
  Else
    SR = BClr(SR, 7)
  Endif

End

Public Sub Push(Optional Value As Byte = databus)

  databus = Value
  AddressBus = &h0100 + sp
  WriteByte()
  Dec sp

End

Public Sub Pop() As Byte

  Inc sp
  AddressBus = &h0100 + sp
  ReadByte()
  Return DataBus

End

Public Sub interupt(sVector As Long)

  Push(pc Shr 8)
  Push(pc And &h000ff)
  Push(SR)
  AddressBus = sVector
  Readbyte()
  pc = DataBus
  Inc AddressBus
  ReadByte()
  If $cpu65c02 Then SR = BClr(SR, 3)                  'clear the decimal flag
  PC = (PC Or (CInt(DataBus) Shl 8))

End

Public Sub NMI()

  $NMIPending = False

  interupt(&H0FFFA)
  SR = BSet(sr, 2)                                                     ' disable the IRQ

End

Public Sub IRQ()

  $IRQPending = False
  If BTst(sr, 2) Then Return                                   ' Ignore this if the irq is disabled

  SR = BClr(sr, 4)                                                      ' Clear the break bit, this is an irq
  interupt(&h0FFFE)
  SR = BSet(sr, 2)                                                     ' Disable the IRQ, restored upon irq return

End

Public Sub BRK()

  Inc PC                                                               ' Skip the extra byte used to identify the brk type
  sr = BSet(sr, 4)                                              ' set the break flag
  interupt(&H0FFFE)
  SR = BSet(sr, 2)                                             ' disable the IRQ
  SR = BClr(SR, 4)                                             ' This flag is never really stored disabled for testing

End

Public Sub SetSR(reg As Byte)

  If reg = 0 Then sr = BSet(sr, 1) Else sr = BClr(sr, 1)       ' correctly set the zero flag
  If BTst(reg, 7) Then sr = BSet(sr, 7) Else sr = BClr(sr, 7)  ' correctly set the negative flag

End

Public Sub ShiftRight()

  If BTst(Databus, 0) Then sr = BSet(sr, 0) Else sr = BClr(sr, 0)
  Dim newvalue As Byte = (Databus Shr 1)
  SetSR(newvalue)
  DataBus = newvalue

End

Public Sub ShiftLeft()

  If BTst(Databus, 7) Then sr = BSet(sr, 0) Else sr = BClr(sr, 0)
  Dim newvalue As Byte = (DataBus Shl 1)
  SetSR(newvalue)
  DataBus = newvalue

End

Public Sub RotateRight()

  Dim newvalue As Byte = (DataBus Shr 1)

  If BTst(sr, 0) Then newvalue = BSet(newvalue, 7)
  If BTst(DataBus, 0) Then sr = BSet(sr, 0) Else sr = BClr(sr, 0)
  SetSR(newvalue)
  dataBus = newvalue

End

Public Sub RotateLeft()

  Dim newvalue As Byte = (DataBus Shl 1)

  If BTst(sr, 0) Then newvalue = BSet(newvalue, 0)
  If BTst(DataBus, 7) Then sr = BSet(sr, 0) Else sr = BClr(sr, 0)
  SetSR(newvalue)
  dataBus = newvalue

End

Public Sub AndAc()

  ac = (ac And DataBus)
  SetSR(ac)

End

Public Sub AdcDecMode()

  Dim carry As Integer = IIf(BTst(sr, 0), 1, 0)

  Dim dac As Integer = (AC And &h0F) + (((AC And &hf0) Shr 4) * 10)
  Dim ddc As Integer = (databus And &h0F) + (((databus And &hf0) Shr 4) * 10)

  dac += ddc + carry
  If dac > 99 Then sr = BSet(sr, 0) Else sr = BClr(sr, 0) ' set the carry bit
  SetBcd(dac)

End

Public Sub SbcDecMode()

  Dim carry As Integer = IIf(BTst(sr, 0), 1, 0)

  Dim dac As Integer = (AC And &h0F) + (((AC And &hf0) Shr 4) * 10)
  Dim ddc As Integer = (databus And &h0F) + (((databus And &hf0) Shr 4) * 10)

  dac -= ddc - carry
  If dac < -1 Then sr = BSet(sr, 0) Else sr = BClr(sr, 0)  ' set the carry bit If above - 1
  If dac < 0 Then
    dac = 100 - Abs(dac)
    sr = BSet(sr, 7)
  Endif
  SetBcd(Dac)

End

Sub SetBcd(Value As Integer) ' ignore the extra 100's value

  Dim ones As Integer = Value Mod 10
  Dim tens As Integer = (value \ 10) Mod 10

  ac = (tens Shl 4) Or ones

End

Public Sub AdcAc()

  If BTst(SR, 3) Then
    AdcDecMode()
    Return
  Endif

  Dim addone As Integer = IIf(BTst(sr, 0), 1, 0)
  Dim tmp As Integer
  Dim result As Byte
  Dim v As Integer
  Dim tac, tdb As Integer

  tac = (0 Or ac)
  tdb = (0 Or Databus)

  tmp = tac + tdb + addone
  'Print "Result="; tmp, "AC="; ac, "Databus="; Databus, "Carry = "; addone
  If BTst(tmp, 8) Then sr = BSet(sr, 0) Else sr = BClr(sr, 0)           ' set the carry bit
  result = (tmp And &h00ff)                                             ' set the value
  If BTst(result, 7) Then sr = BSet(sr, 7) Else sr = BClr(sr, 7)        ' Set the negative
  If result = 0 Then sr = BSet(sr, 1) Else sr = BClr(sr, 1)             ' set the zero flag
  ' Print (ac Xor result), (databus Xor result), ((ac Xor result) And (databus Xor result))
  'Print (((ac Xor result) And (databus Xor result)) And &h080)
  'v = !!((a ^ result) & (val ^ result) & 0x80U);
  v = (((ac Xor result) And (databus Xor result)) And &h080)
  If v <> 0 Then sr = BSet(sr, 6) Else sr = BClr(sr, 6)
  'Print "Overflow= "; BTst(sr, 6)
  ac = result

End

Public Sub SbcAc()

  If BTst(SR, 3) Then
    SbcDecMode()
    Return
  Endif

  Dim tmp As Byte = (DataBus Xor &h0FF)

  DataBus = tmp
  AdcAc()

End

Public Sub EorAc()

  ac = (ac Xor databus)
  SetSR(ac)

End

Public Sub OrAc()

  ac = (ac Or databus)
  SetSR(ac)

End

Public Sub Peek(Addr As Long) As Byte

  Dim dev As Object

  dev = RealMemory_Read[addr]

  If dev = Null Then
    If $ChkBadMemAccess Then
      Error.Raise(("Invalid Memory Address - Read") & " [" & Hex(Addr, 4) & "]")
    Else
      Return &h0FF
    Endif
  Endif

  Return dev[Addr]

End

Public Sub Poke(addr As Long, value As Variant)

  Dim dev As Object

  dev = RealMemory_Write[addr]
  If dev = Null
    If $ChkBadMemAccess Then
      Error.Raise(("Invalid Memory Address - Write") & " [" & Hex(Addr, 4) & "]")
    Else
      Return
    Endif
  Endif

  dev[Addr] = CByte(value)

End

Private Function SpeedScaler_Read() As Long

  Return $SpeedScaler

End

Private Sub SpeedScaler_Write(Value As Long)

  $SpeedScaler = value

End

Public Sub MyDevice_halt(Reason As String)

  Halt()
  Print Reason

End

Public Sub MyDevice_IRQ()

  $IRQPending = True
  $InteruptPending = True

End

Public Sub MyDevice_NMI()

  $NMIPending = True
  $InteruptPending = True

End

Public Sub MyDevice_Reset()

  $ResetPending = True
  $InteruptPending = True

End

Private Function Profiling_Read() As Boolean

  Return $Profiling

End

Private Sub Profiling_Write(Value As Boolean)

  If Value = True Then
    InstProfile = New Profiler(Me)
    $Profiling = True
  Else
    $Profiling = False
  Endif

End

Public Sub ProfileReset()

  If InstProfile Then InstProfile.reset()

End

'Property Read ProfileInfo As String[]
Public Function ProfileInfo(Optional StartAddress As Integer = -1, length As Integer = 0) As String[]

  If InstProfile Then
    Return InstProfile.report(startAddress, length, $ProfileSortOrder)
  Endif

End

' to optimize the cpu speed and work better with fast unsafe
' moved group files integre-rated here
' Gambas module file

'****************************************************************************************************************
'Public ongoto_vector_table As Label[] = [Grp0Case00]
'***************************************************************************************************************

Public Sub Group0(TheCpu As Cpu6502, aaa As Integer, addressmode As Integer)

  With TheCpu
    Dim tempreg As Long
    On aaa Goto Grp0Case0, Grp0Case1, Grp0Case2, Grp0Case3, Grp0Case4, Grp0Case5, Grp0Case6, Grp0Case7
    Return

  Grp0Case0:
    On addressmode Goto Grp0Case00, Grp0Case01, Grp0Case02, Grp0Case03, Grp0Case04, Grp0Case05, Grp0Case06, Grp0Case07
    Return

  Grp0Case00: 'brk for 65C02 must clear the decimal mode as well
    ' Inc .pc            ' allow for extra byte to identify type of break
    '.push(.pc Shr 8)
    '.push(.pc And &h000FF)
    'If $cpu65c02 Then BSet(.sr, 3)clear the decimal flag
    .brk()
    Return

  Grp0Case02: 'php
    .push(.sr)
    Return

  Grp0Case04: ' bpl
    .Immediate()
    If Not BTst(.Sr, 7) Then
      .ReadByte()
      .Branch()
    Endif
    Return

  Grp0Case06: ' clc
    .sr = BClr(.sr, 0)
    Return

  Grp0Case01:'TSB zeropage    65c02
    .ZeroPage()

  TSB:
    Dim Tsba As Byte = .AC
    .ReadByte()
    .OrAc()
    .DataBus = .AC
    .AC = Tsba
    .WriteByte
    Return

  Grp0Case03:'TSB absolute   65c02
    .Absolute()
    Goto TSB

  Grp0Case05:'TRB ZeroPage  65c02
    .ZeroPage()

  TRB:
    tsba = .AC
    .DataBus = &h0FF
    .EorAc()
    .ReadByte()
    .AndAc()
    .DataBus = .AC
    .WriteByte()
    .AC = tsba
    Return

  Grp0Case07:'TRB Absolute  65c02
    .Absolute()
    Goto TRB

    '-------------------------------------------------------------------
  Grp0Case1:
    On addressmode Goto Grp0Case10, Grp0Case11, Grp0Case12, Grp0Case13, Grp0Case14, Grp0Case15, Grp0Case16, Grp0Case17
    Return

  Grp0Case10:'JSR abs
    .Absolute()
    tempreg = .AddressBus
    Dec .pc
    .push(.pc Shr 8)
    .push(.pc And &h000FF)
    .pc = tempreg
    Return

  Grp0Case11:'bit zpg
    .ZeroPage()

  bitDo:
    .ReadByte()
    Dim bittmp As Byte = (.AC And .DataBus)
    If BTst(.DataBus, 7) Then .Sr = BSet(.SR, 7) Else .SR = BClr(.SR, 7)
    If BTst(.DataBus, 6) Then .Sr = BSet(.SR, 6) Else .SR = BClr(.SR, 6)
    If bittmp = 0 Then .SR = BSet(.SR, 1) Else .sr = BClr(.sr, 1)
    Return

  Grp0Case12:'plp
    .sr = .Pop()
    .sr = BClr(.sr, 4)           ' Brk And ignore are Not releoaded
    .sr = BClr(.sr, 5)
    Return

  Grp0Case13:'bit abs
    .Absolute()
    Goto bitDo

  Grp0Case14:'bmi rel
    .Immediate()
    If BTst(.Sr, 7) Then
      .ReadByte()
      .Branch()
    Endif
    Return

  Grp0Case16:'sec impl
    .sr = BSet(.sr, 0)
    Return

  Grp0Case15:'BIT ZeroPage,X 65c02
    .ZeroPageX
    Goto bitDo

  Grp0Case17:'BIT Abs,X 65c02
    .AbsX()
    Goto bitDo

    '-------------------------------------------------------------------
  Grp0Case2:
    On addressmode Goto Grp0Case20, Grp0Case21, Grp0Case22, Grp0Case23, Grp0Case24, Grp0Case25, Grp0Case26, Grp0Case27
    Return

  Grp0Case20:  ' rti
    .sr = BClr(.pop(), 4)              '  Brk Bit not reloaded
    .sr = BClr(.sr, 5)                 '  ignore are not reloaded
    Dim tmplow As Byte = .Pop()
    .PC = .Pop()      ' Pop The high Byte
    .Pc = .PC Shl 8
    .PC = .PC Or tmpLow
    Return

  Grp0Case22:  'pha
    .push(.AC)
    Return

  Grp0Case23: ' jmp abs
    .Absolute()
    .pc = .AddressBus
    Return

  Grp0Case24: 'BVC rel
    .Immediate()
    If Not BTst(.Sr, 6) Then
      .ReadByte()
      .Branch()
    Endif
    Return

  Grp0Case26: 'cli impl
    .sr = BClr(.sr, 2)
    Return

  Grp0Case21: ' unused
  Grp0Case25: ' unused
  Grp0Case27: ' unused
    Return
    '-----------------------------------------------------------------------------------
  Grp0Case3:
    On addressmode Goto Grp0Case30, Grp0Case31, Grp0Case32, Grp0Case33, Grp0Case34, Grp0Case35, Grp0Case36, Grp0Case37
    Return

  Grp0Case30:' rts
    tmplow = .Pop()
    .PC = .Pop()      ' Pop The high Byte
    .Pc = .PC Shl 8
    .PC = .PC Or tmpLow
    Inc .PC
    Return

  Grp0Case32: 'pla
    .ac = .pop()
    .setsr(.ac)
    Return

  Grp0Case33:' jmp Indirect
    .Indirect()
    .pc = .AddressBus
    Return

  Grp0Case34:' BVS rel
    .Immediate()
    If BTst(.Sr, 6) Then
      .ReadByte()
      .Branch()
    Endif
    Return

  Grp0Case36:'SEI impl
    .sr = BSet(.sr, 2)
    Return

  Grp0Case31:'STZ ZeroPage  65c02
    .ZeroPage()
  STZ:
    .DataBus = 0
    .WriteByte()
    Return

  Grp0Case35:'STZ ZeroPage,X 65c02
    .ZeroPageX()
    Goto STZ

  Grp0Case37:'JMP (indirect,X) 65c02
    .IndirectAbsX()
    .pc = .AddressBus
    Return

    '---------------------------------------------------------------------------------------------------------------
  Grp0Case4:
    On addressmode Goto Grp0Case40, Grp0Case41, Grp0Case42, Grp0Case43, Grp0Case44, Grp0Case45, Grp0Case46, Grp0Case47
    Return

  Grp0Case40: 'BRA branch always
    .Immediate()
    .ReadByte()
    .Branch()
    Return

  Grp0Case41:' sty zpg
    .ZeroPage()
    .databus = .Y
    .writebyte()
    Return

  Grp0Case42:'dey impl
    Dec .y
    .SetSR(.y)
    .SetSR(.Y)
    Return

  Grp0Case43:' sty abs
    .Absolute()
    .databus = .Y
    .WriteByte()
    Return

  Grp0Case44:'bcc rel
    .Immediate()
    If Not (BTst(.Sr, 0)) Then
      .ReadByte()
      .Branch()
    Endif
    Return

  Grp0Case45:' sty zpg,x
    .ZeroPageX()
    .databus = .Y
    .WriteByte()
    Return

  Grp0Case46:'tya impl
    .ac = .Y
    .setsr(.AC)
    Return

  Grp0Case47: 'STZ ABS 65c02
    .DataBus = 0
    .Absolute()
    .WriteByte()
    Return

    '------------------------------------------------------------------------------------------
  Grp0Case5:
    On addressmode Goto Grp0Case50, Grp0Case51, Grp0Case52, Grp0Case53, Grp0Case54, Grp0Case55, Grp0Case56, Grp0Case57
    Return

  Grp0Case50:'ldy #
    .Immediate()
    .ReadByte()
    .Y = .DataBus
    .SetSR(.Y)
    Return

  Grp0Case51:'ldy zpg
    .ZeroPage()
    .ReadByte()
    .y = .DataBus
    .SetSR(.Y)
    Return

  Grp0Case52:'tay impl
    .Y = .AC
    .SetSR(.AC)
    Return

  Grp0Case53:'ldy abs
    .Absolute()
    .ReadByte()
    .Y = .databus
    .Setsr(.Y)
    Return

  Grp0Case54:'BCS Rel
    .Immediate()
    If BTst(.Sr, 0) Then
      .ReadByte()
      .Branch()
    Endif
    Return

  Grp0Case55:'$B4 LDY zpg,X
    .ZeroPageX()
    .ReadByte()
    .Y = .DataBus
    .SetSR(.Y)
    Return

  Grp0Case56:'$B8 CLV impl
    .sr = BClr(.SR, 6)
    Return

  Grp0Case57: '$BC LDY abs,X
    .AbsX()
    .ReadByte()
    .Y = .DataBus
    .SetSR(.Y)
    Return

    '--------------------------------------------------------------------------------------------------------------
  Grp0Case6:
    On addressmode Goto Grp0Case60, Grp0Case61, Grp0Case62, Grp0Case63, Grp0Case64, Grp0Case65, Grp0Case66, Grp0Case67
    Return

  Grp0Case60:'$C0 CPY #
    .Immediate()
  CmpY:
    .ReadByte()
    .Compare(.Y)
    Return

  Grp0Case61:'$C4 CPY zpg
    .ZeroPage()
    Goto CmpY

  Grp0Case62:'$C8 INY impl
    Inc .Y
    .SetSR(.Y)
    Return

  Grp0Case63:'$CC CPY abs
    .Absolute()
    Goto CmpY

  Grp0Case64:'$D0 BNE rel
    .Immediate()
    If Not BTst(.sr, 1) Then
      .ReadByte()
      .Branch()
    Endif
    Return

  Grp0Case66:'$D8 CLD impl
    .SR = BClr(.SR, 3)
    Return

  Grp0Case65:'Not Used
  Grp0Case67:'No tUsed
    Return

    '-----------------------------------------------------------------------------------------------
  Grp0Case7:
    On addressmode Goto Grp0Case70, Grp0Case71, Grp0Case72, Grp0Case73, Grp0Case74, Grp0Case75, Grp0Case76, Grp0Case77
  Grp0Case70:'$E0 CPX #
    .Immediate()
    .ReadByte()
    .compare(.X)
    Return

  Grp0Case71:'$E4 CPX zpg
    .ZeroPage()
    .ReadByte()
    .Compare(.X)               'Bug fix , missing parameter 01-17-2023
    Return

  Grp0Case72:'$E8 INX impl
    Inc .X
    .SetSR(.X)
    Return

  Grp0Case73:' $EC CPX abs
    .Absolute()
    .ReadByte()
    .compare(.X)
    Return

  Grp0Case74:' $F0 BEQ rel
    .Immediate()
    If BTst(.sr, 1) Then
      .ReadByte()
      .Branch()
    Endif
    Return

  Grp0Case76:' $F8 SED impl
    .SR = BSet(.SR, 3)
    Return

  Grp0Case75:' Not Used
  Grp0Case77:' Not Used
    Return

  End With

End

'****************************************************************************************************************
'***************************************************************************************************************
Public Sub Group1(TheCpu As Cpu6502, aaa As Integer, addressmode As Integer)

  With TheCpu
    On aaa Goto Grp1Case0, Grp1Case1, Grp1Case2, Grp1Case3, Grp1Case4, Grp1Case5, Grp1Case6, Grp1Case7
    Return

  Grp1Case0:
    On addressmode Goto Grp1Case00, Grp1Case01, Grp1Case02, Grp1Case03, Grp1Case04, Grp1Case05, Grp1Case06, Grp1Case07
    Return

  Grp1Case00:'$01 ORA X,ind
    .IndirectX
  ora:
    .ReadByte()
    .ac = (.ac Or .databus)
    .SetSR(.ac)
    Return

  Grp1Case01:'$05 ORA zpg
    .ZeroPage()
    Goto ora

  Grp1Case02:'$09 ORA #
    .Immediate()
    Goto ora

  Grp1Case03:'$0D ORA abs
    .Absolute()
    Goto ora

  Grp1Case04:'$11 ORA ind,Y
    .IndirectY()
    Goto ora

  Grp1Case05:'$15 ORA zpg,X
    .ZeroPageX()
    Goto ora

  Grp1Case06:'$19 ORA abs,Y
    .AbsY()
    Goto ora

  Grp1Case07:'$1D ORA abs,X
    .AbsX()
    Goto ora
    '----------------------------------------------------------------------------
  Grp1Case1:
    On addressmode Goto Grp1Case10, Grp1Case11, Grp1Case12, Grp1Case13, Grp1Case14, Grp1Case15, Grp1Case16, Grp1Case17
    Return

  Grp1Case10:'$21 AND X,ind
    .IndirectX()
  DoAnd:
    .ReadByte()
    .ac = (.ac And .Databus)
    .SetSR(.AC)
    Return

  Grp1Case11:' $25 AND zpg
    .ZeroPage()
    Goto DoAnd

  Grp1Case12:' $29 AND #
    .Immediate()
    Goto DoAnd

  Grp1Case13:' $2D AND abs
    .Absolute()
    Goto DoAnd

  Grp1Case14:'$31 AND ind,Y
    .IndirectY()
    Goto DoAnd

  Grp1Case15:'$35 AND zpg,X
    .ZeroPageX()
    Goto DoAnd

  Grp1Case16:'$39 AND abs,Y
    .AbsY()
    Goto DoAnd

  Grp1Case17:'$3D AND abs,X
    .AbsX()
    Goto DoAnd

  Grp1Case2:
    On addressmode Goto Grp1Case20, Grp1Case21, Grp1Case22, Grp1Case23, Grp1Case24, Grp1Case25, Grp1Case26, Grp1Case27
    Return

  Grp1Case20:'$41 EOR X,ind
    .IndirectX()
  EOR:
    .ReadByte()
    .AC = (.AC Xor .DataBus)
    .SetSR(.AC)
    Return

  Grp1Case21:'$45 EOR zpg
    .ZeroPage()
    Goto EOR

  Grp1Case22:'$49 EOR #
    .Immediate()
    Goto EOR

  Grp1Case23:'$4D EOR abs
    .Absolute()
    Goto EOR

  Grp1Case24:'$51 EOR ind, Y
    .IndirectY()
    Goto EOR

  Grp1Case25:'$55 EOR zpg, X
    .ZeroPageX()
    Goto EOR

  Grp1Case26:'$59 EOR abs, Y
    .AbsY()
    Goto EOR

  Grp1Case27:'$5D EOR abs, X
    .AbsY()
    Goto EOR

    '-------------------------------------------------------------------------------
  Grp1Case3:
    On addressmode Goto Grp1Case30, Grp1Case31, Grp1Case32, Grp1Case33, Grp1Case34, Grp1Case35, Grp1Case36, Grp1Case37
    Return

  Grp1Case30:'$61 ADC X, ind
    .IndirectX()
  AddAc:
    .ReadByte()
    .AdcAC()
    Return

  Grp1Case31:'$65 ADC zpg
    .ZeroPage()
    Goto AddAC

  Grp1Case32:'$69 ADC #
    .Immediate()
    Goto AddAc

  Grp1Case33:'$6D ADC abs
    .Absolute()
    Goto AddAC

  Grp1Case34:'$71 ADC ind, Y
    .IndirectY()
    Goto AddAC

  Grp1Case35:'$75 ADC zpg, X
    .ZeroPage()
    Goto AddAC

  Grp1Case36:'$79 ADC abs, Y
    .AbsY()
    Goto AddAc

  Grp1Case37:'$7D ADC abs, X
    .AbsX()
    Goto AddAc
    '----------------------------------------------------------------------------
  Grp1Case4:
    On addressmode Goto Grp1Case40, Grp1Case41, Grp1Case42, Grp1Case43, Grp1Case44, Grp1Case45, Grp1Case46, Grp1Case47
    Return

  Grp1Case40: ' sta x, ind
    .IndirectX
    Goto StoreAC

  Grp1Case41: ' sta zeropage 65c02
    .ZeroPage
    Goto StoreAC

  Grp1Case43: ' sta $8000 abs
    .Absolute()
    Goto StoreAC

  Grp1Case44: ' sta ind,y
    .IndirectY()
    Goto StoreAC

  Grp1Case45: ' sta zeropage,x
    .ZeroPageX()
    Goto StoreAC

  Grp1Case46: ' sta abs,y
    .AbsY()
    Goto StoreAC

  Grp1Case47: ' sta abs,X
    .AbsX()

  StoreAC:
    .DataBus = .AC
    .WriteByte()
    Return

  Grp1Case42: 'BIT immediate
    .Immediate()
    .ReadByte()
    Dim bittmp As Byte = (.AC And .DataBus)
    If BTst(.DataBus, 7) Then .Sr = BSet(.SR, 7) Else .SR = BClr(.SR, 7)
    If BTst(.DataBus, 6) Then .Sr = BSet(.SR, 6) Else .SR = BClr(.SR, 6)
    If bittmp = 0 Then .SR = BSet(.SR, 1) Else .sr = BClr(.sr, 1)
    Return

    '-------------------------------------------------------------------------------------
  Grp1Case5:
    On addressmode Goto Grp1Case50, Grp1Case51, Grp1Case52, Grp1Case53, Grp1Case54, Grp1Case55, Grp1Case56, Grp1Case57
    Return

  Grp1Case50:  'lda Indirect,X
    .IndirectX()
    Goto LoadAC

  Grp1Case51:  'lda zpg
    .ZeroPage()
    Goto LoadAc

  Grp1Case52:  'lda,#
    .Immediate()
    Goto LoadAC

  Grp1Case53:  'lda $8000   Absolute address
    .Absolute()
    Goto LoadAC

  Grp1Case54:
    .IndirectY()
    Goto LoadAC

  Grp1Case55: ' lda zpg,X
    .ZeroPageX
    Goto LoadAC

  Grp1Case56: ' lda abs,y
    TheCpu.AbsY()
    Goto LoadAC

  Grp1Case57: ' lda abs,x
    .AbsX()
    Goto LoadAc

  LoadAC:
    .ReadByte()
    .ac = .DataBus
    .setsr(.ac)
    Return

  Grp1Case6:
    On addressmode Goto Grp1Case60, Grp1Case61, Grp1Case62, Grp1Case63, Grp1Case64, Grp1Case65, Grp1Case66, Grp1Case67
    Return

  Grp1Case60:'$C1 CMP X, ind
    .IndirectX()
  cmp:
    .ReadByte()
    .Compare(.ac)
    Return

  Grp1Case61:'$C5 CMP zpg
    .ZeroPage()
    Goto cmp

  Grp1Case62:'$C9 CMP #
    .Immediate()
    Goto Cmp

  Grp1Case63:'$CD CMP abs
    .Absolute()
    Goto Cmp

  Grp1Case64:'$D1 CMP ind, Y
    .IndirectY()
    Goto cmp

  Grp1Case65:'$D5 CMP zpg, X
    .ZeroPageX()
    Goto cmp

  Grp1Case66:'$D9 CMP abs, Y
    .AbsY()
    Goto cmp

  Grp1Case67:'$DD CMP abs, X
    .AbsX()
    Goto cmp
    '-------------------------------------------------------------------------------------------
  Grp1Case7:
    On addressmode Goto Grp1Case70, Grp1Case71, Grp1Case72, Grp1Case73, Grp1Case74, Grp1Case75, Grp1Case76, Grp1Case77
  Grp1Case70:'$E1 SBC X, ind
    .IndirectX()
  sbc:
    .ReadByte()
    .SbcAc()
    Return

  Grp1Case71:'$E5 SBC zpg
    .ZeroPage()
    Goto Sbc

  Grp1Case72:'$E9 SBC #
    .Immediate()
    Goto SBC

  Grp1Case73:'$ED SBC abs
    .Absolute()
    Goto SBC

  Grp1Case74:'$F1 SBC ind, Y
    .IndirectY()
    Goto sbc

  Grp1Case75:'$F5 SBC zpg, X
    .ZeroPageX()
    Goto sbc

  Grp1Case76:'$F9 SBC abs, Y
    .AbsY()
    Goto sbc

  Grp1Case77:'$FD SBC abs, X
    .AbsX()
    Goto sbc

  End With

End

'****************************************************************************************************************
'***************************************************************************************************************
Public Sub Group2(TheCpu As Cpu6502, aaa As Integer, addressmode As Integer)

  With TheCpu
    On aaa Goto Grp2Case0, Grp2Case1, Grp2Case2, Grp2Case3, Grp2Case4, Grp2Case5, Grp2Case6, Grp2Case7
    Return

  Grp2Case0:
    On addressmode Goto Grp2Case00, Grp2Case01, Grp2Case02, Grp2Case03, Grp2Case04, Grp2Case05, Grp2Case06, Grp2Case07
    Return

  Grp2Case00:' not used
    Return

  Grp2Case01:'$06 ASL zpg
    .ZeroPage()

  DoAsl:
    .ReadByte()
    .ShiftLeft()
    .WriteByte()
    Return

  Grp2Case02:'$0A ASL A
    .DataBus = .AC
    .ShiftLeft()
    .AC = .DataBus
    Return

  Grp2Case03:'$0E ASL abs
    .Absolute()
    Goto DoAsl

  Grp2Case05:'$16 ASL zpg, X
    .ZeroPageX()
    Goto DoAsl

  Grp2Case07:'$1E ASL abs, X
    .AbsX()
    Goto DoAsl

  Grp2Case04: 'ORA (ZeroPageIndirect) 65c02
    .ZeroPageIndirect()
    .ReadByte()
    .OrAc()
    Return

  Grp2Case06: 'INA - inc A 65c02
    Inc .AC
    .setsr(.ac)
    Return

    '---------------------------------------------------------------------------
  Grp2Case1:
    On addressmode Goto Grp2Case10, Grp2Case11, Grp2Case12, Grp2Case13, Grp2Case14, Grp2Case15, Grp2Case16, Grp2Case17
    Return

  Grp2Case10:'not used
    Return

  Grp2Case11:'$26 ROL zpg
    .ZeroPage()
  DoRol:
    .ReadByte()
    .RotateLeft()
    .WriteByte()
    Return

  Grp2Case12:'$2A ROL A
    .DataBus = .AC
    .RotateLeft()
    .AC = .DataBus
    Return

  Grp2Case13:'$2E ROL abs
    .Absolute()
    Goto DoRol

  Grp2Case15:'$36 ROL zpg, X
    .ZeroPageX()
    Goto DoRol

  Grp2Case16:'DEA  - dec A 65c02
    Dec .AC
    .setsr(.ac)
    Return

  Grp2Case17:'$3E ROL abs, X
    .AbsX()
    Goto DoRol

  Grp2Case14:'AND ZeroPageIndirect 65c02
    .ZeroPageIndirect()
    .ReadByte()
    .AndAc()
    Return

    '=============================================================================================
  Grp2Case2:
    On addressmode Goto Grp2Case20, Grp2Case21, Grp2Case22, Grp2Case23, Grp2Case24, Grp2Case25, Grp2Case26, Grp2Case27
    Return

  Grp2Case20:' not used
    Return

  Grp2Case21:'$46 LSR zpg
    .ZeroPage()

  DoLsr:
    .ReadByte
    .ShiftRight()
    .WriteByte()
    Return

  Grp2Case22:'$4A LSR A
    .databus = .AC
    .ShiftRight()
    .AC = .DataBus
    Return

  Grp2Case23:'$4E LSR abs
    .Absolute()
    Goto DoLsr

  Grp2Case25:'$56 LSR zpg, X
    .ZeroPageX()
    Goto DoLsr

  Grp2Case27:'$5E LSR abs, X
    .AbsX()
    Goto DoLsr

  Grp2Case24:'EOR ZeroPageIndirect 65c02
    .ZeroPageIndirect()
    .ReadByte()
    .EorAc()
    Return

  Grp2Case26:'PHY - Push Y 65c02
    .Push(.Y)
    Return
    '----------------------------------------------------------------------------
  Grp2Case3:
    On addressmode Goto Grp2Case30, Grp2Case31, Grp2Case32, Grp2Case33, Grp2Case34, Grp2Case35, Grp2Case36, Grp2Case37
    Return

  Grp2Case30:'not used
    Return

  Grp2Case31:'$66 ROR zpg
    .ZeroPage()

  DoRor:
    .ReadByte()
    .RotateRight()
    .WriteByte()
    Return

  Grp2Case32:'$6A ROR A
    .DataBus = .AC
    .RotateRight()
    .AC = .DataBus
    Return

  Grp2Case33:'$6E ROR abs
    .Absolute()
    Goto DoRor

  Grp2Case35:'$76 ROR zpg, X
    .ZeroPageX()
    Goto DoRor

  Grp2Case37:'$7E ROR abs, X
    .AbsX()
    Goto DoRor

  Grp2Case34:'ADC ZeroPageIndirect 65c02
    .ZeroPageIndirect
    .ReadByte()
    .AdcAc()
    Return

  Grp2Case36:'PLY - Pull Y 65c02
    .Y = .Pop()
    .setsr(.Y)
    Return

    '-----------------------------------------------------------------------------

  Grp2Case4:
    On addressmode Goto Grp2Case40, Grp2Case41, Grp2Case42, Grp2Case43, Grp2Case44, Grp2Case45, Grp2Case46, Grp2Case47
    Return

  Grp2Case40:'not used
    Return

  Grp2Case41:'$86 STX zpg
    .ZeroPage()
  storeX:
    .DataBus = .X
    .WriteByte()
    Return

  Grp2Case42:'$8A TXA impl
    .ac = .X
    .SetSR(.AC)
    Return

  Grp2Case43:'$8E STX abs
    .Absolute()
    Goto storeX

  Grp2Case44:'STA ZeroPageIndirect 65c02
    .ZeroPageIndirect()
    .DataBus = .AC
    .WriteByte()
    Return

  Grp2Case45:'$96 STX zpg, Y
    .ZeroPageX()
    Goto storeX

  Grp2Case46:'$9A TXS impl
    .sp = .X
    Return

  Grp2Case47:'STZ abs,X  65c02
    .AbsX()
    .DataBus = 0
    .WriteByte()
    Return
    '--------------------------------------------------------------------------
  Grp2Case5:
    On addressmode Goto Grp2Case50, Grp2Case51, Grp2Case52, Grp2Case53, Grp2Case54, Grp2Case55, Grp2Case56, Grp2Case57
    Return

  Grp2Case50:'$A2 LDX #
    .Immediate()
  ldx:
    .ReadByte()
    .X = .DataBus
    .SetSR(.X)
    Return

  Grp2Case51:'$A6 LDX zpg
    .ZeroPage()
    Goto ldx

  Grp2Case52:'$AA TAX impl
    .X = .AC
    .SetSR(.X)
    Return

  Grp2Case53:'$AE LDX abs
    .Absolute()
    Goto ldx

  Grp2Case55:'$B6 LDX zpg, Y
    .ZeroPageY()
    Goto ldx

  Grp2Case56:'$BA TSX impl
    .X = .SP
    Return

  Grp2Case57:'$BE LDX abs, Y
    .AbsY()
    Goto Ldx

  Grp2Case54:'LDA ZeroPageIndirect
    .ZeroPageIndirect()
    .ReadByte()
    .ac = .DataBus
    .setsr(.ac)
    Return

    '-------------------------------------------------------------------------------------
  Grp2Case6:
    On addressmode Goto Grp2Case60, Grp2Case61, Grp2Case62, Grp2Case63, Grp2Case64, Grp2Case65, Grp2Case66, Grp2Case67
    Return

  Grp2Case60:' Not Used
    Return

  Grp2Case61:'$C6 DEC zpg
    .ZeroPage()
  DecMem:
    .ReadByte()
    Dec .DataBus
    .WriteByte()
    .SetSR(.DataBus)
    Return

  Grp2Case62:'$CA DEX impl
    Dec .X
    .SetSR(.X)
    Return

  Grp2Case63:'$CE DEC abs
    .Absolute()
    Goto DecMem

  Grp2Case65:'$D6 DEC zpg, X
    .ZeroPageX()
    Goto DecMem

  Grp2Case67:'$DE DEC abs, X
    .AbsX()
    Goto DecMem

  Grp2Case64:'CMP ZeroPageIndirect
    .ZeroPageIndirect()
    .ReadByte()
    .Compare(.ac)
    Return

  Grp2Case66:'PHX Push X  65c02
    .Push(.X)
    Return

    '------------------------------------------------------------------------------------------------
  Grp2Case7:
    On addressmode Goto Grp2Case70, Grp2Case71, Grp2Case72, Grp2Case73, Grp2Case74, Grp2Case75, Grp2Case76, Grp2Case77

  Grp2Case70:' not used
    Return

  Grp2Case71:'$E6 INC zpg
    .ZeroPage()

  IncMem:
    .ReadByte()
    Inc .DataBus
    .WriteByte()
    .SetSR(.DataBus)
    Return

  Grp2Case72:'$EA NOP impl
    Return

  Grp2Case73:'$EE INC abs
    .Absolute()
    Goto IncMem

  Grp2Case75:'$F6 INC zpg, X
    .ZeroPageX()
    Goto incMem

  Grp2Case74:'SBC ZeroPageIndirect
    .ZeroPageIndirect()
    .ReadByte()
    .SbcAc()
    Return

  Grp2Case77:'$FE INC abs, X
    .AbsX()
    Goto IncMem

  Grp2Case76:'PLX Pull X   65c02
    .X = .Pop()
    .SetSR(.X)
    Return

  End With

End

'****************************************************************************************************************
'****************************************************************************************************************

Public Sub Group3(TheCpu As Cpu6502, aaa As Integer, addressmode As Integer)

  With TheCpu

    On aaa Goto Grp3Case0, Grp3Case1, Grp3Case2, Grp3Case3, Grp3Case4, Grp3Case5, Grp3Case6, Grp3Case7
    Return

  Grp3Case0:
    On addressmode Goto Grp3Case00, Grp3Case01, Grp3Case02, Grp3Case03, Grp3Case04, Grp3Case05, Grp3Case06, Grp3Case07
    Return

  Grp3Case00:
  Grp3Case01:
  Grp3Case02:
  Grp3Case03:
  Grp3Case04:
  Grp3Case05:
  Grp3Case06:
  Grp3Case07:
    Return

  Grp3Case1:
    On addressmode Goto Grp3Case10, Grp3Case11, Grp3Case12, Grp3Case13, Grp3Case14, Grp3Case15, Grp3Case16, Grp3Case17
    Return

  Grp3Case10:
  Grp3Case11:
  Grp3Case12:
  Grp3Case13:
  Grp3Case14:
  Grp3Case15:
  Grp3Case16:
  Grp3Case17:
    Return

    '-------------------------------------------------------------------
  Grp3Case2:
    On addressmode Goto Grp3Case20, Grp3Case21, Grp3Case22, Grp3Case23, Grp3Case24, Grp3Case25, Grp3Case26, Grp3Case27
    Return

  Grp3Case20:
  Grp3Case21:
  Grp3Case22:
  Grp3Case23:
  Grp3Case24:
  Grp3Case25:
  Grp3Case26:
  Grp3Case27:
    Return

  Grp3Case3:
    On addressmode Goto Grp3Case30, Grp3Case31, Grp3Case32, Grp3Case33, Grp3Case34, Grp3Case35, Grp3Case36, Grp3Case37
    Return

  Grp3Case30:
  Grp3Case31:
  Grp3Case32:
  Grp3Case33:
  Grp3Case34:
  Grp3Case35:
  Grp3Case36:
  Grp3Case37:
    Return

    '---------------------------------------------------------------------------------------------------------------
  Grp3Case4:
    On addressmode Goto Grp3Case40, Grp3Case41, Grp3Case42, Grp3Case43, Grp3Case44, Grp3Case45, Grp3Case46, Grp3Case47
    Return

  Grp3Case40:
  Grp3Case41:
  Grp3Case42:
  Grp3Case43:
  Grp3Case44:
  Grp3Case45:
  Grp3Case46:
  Grp3Case47:
    Return

    '------------------------------------------------------------------------------------------
  Grp3Case5:
    On addressmode Goto Grp3Case50, Grp3Case51, Grp3Case52, Grp3Case53, Grp3Case54, Grp3Case55, Grp3Case56, Grp3Case57
    Return

  Grp3Case50:
  Grp3Case51:
  Grp3Case52:
  Grp3Case53:
  Grp3Case54:
  Grp3Case55:
  Grp3Case56:
  Grp3Case57:
    Return

    '--------------------------------------------------------------------------------------------------------------
  Grp3Case6:
    On addressmode Goto Grp3Case60, Grp3Case61, Grp3Case62, Grp3Case63, Grp3Case64, Grp3Case65, Grp3Case66, Grp3Case67
    Return

  Grp3Case60:
  Grp3Case61:
  Grp3Case62:
  Grp3Case63:
  Grp3Case64:
  Grp3Case65:
  Grp3Case66:
  Grp3Case67:
    Return

    '-----------------------------------------------------------------------------------------------
  Grp3Case7:
    On addressmode Goto Grp3Case70, Grp3Case71, Grp3Case72, Grp3Case73, Grp3Case74, Grp3Case75, Grp3Case76, Grp3Case77

  Grp3Case70:
  Grp3Case71:
  Grp3Case72:
  Grp3Case73:
  Grp3Case74:
  Grp3Case75:
  Grp3Case76:
  Grp3Case77:
    Return

  End With

End
