------- FILE ctmon65.asm LEVEL 1 PASS 2
      1  10000					       Processor	6502
      2 U00f6 ????				      seg.U	ZEROPAGE
      3 U0000					      org	$0000
      4 U0000							;*********************************************************
      5 U0000							; CTMON65
      6 U0000							;
      7 U0000							; This is the monitor for the Corsham Techologies, LLC
      8 U0000							; SS-50 65C02 board.  It's a fairly generic monitor that
      9 U0000							; can be ported to other 6502 based systems.
     10 U0000							;
     11 U0000							; Written mostly while on a family vacation in 2018, but
     12 U0000							; ideas and code were taken from other Corsham Tech
     13 U0000							; projects and various web pages (credit given in the
     14 U0000							; code).
     15 U0000							;
     16 U0000							; Bob Applegate
     17 U0000							; bob@corshamtech.com
     18 U0000							; www.corshamtech.com
     19 U0000					      mac	db
     20 U0000					      .byte	{0}
     21 U0000					      endm
     22 U0000					      Mac	dw
     23 U0000					      .word	{0}
     24 U0000					      endm
     25 U0000
     26 U0000							;*********************************************************
     27 U0000							;
------- FILE config.inc LEVEL 2 PASS 2
      0 U0000					      include	"config.inc"
      1 U0000					      Processor	6502
      2 U0000							;*********************************************************
      3 U0000							; FILE: config.inc
      4 U0000							;
      5 U0000							; General configuration file
      6 U0000							;*********************************************************
      7 U0000							;
      8 U0000		       00 00	   FALSE      equ	0
      9 U0000		       00 01	   TRUE       equ	!FALSE
     10 U0000							;
     11 U0000							; SS-50 bus constants
     12 U0000							;
     13 U0000		       e0 00	   IO_BASE    equ	$E000
     14 U0000		       00 10	   IO_SIZE    equ	16
     15 U0000							;
     16 U0000							; Memory usage
     17 U0000							;
     18 U0000		       00 f0	   ZERO_PAGE_START equ	$00f0
     19 U0000		       f0 00	   ROM_START  equ	$f000
     20 U0000		       df 00	   RAM_START  equ	$df00
     21 U0000							;
     22 U0000							; If enabled, turn on buffered input code.
     23 U0000							;
     24 U0000		       00 00	   BUFFERED_INPUT equ	FALSE
     25 U0000							;
     26 U0000		       00 05	   MAX_ARGC   equ	5
     27 U0000							;
     28 U0000							; If enabled, the debugger will display the flag register
     29 U0000							; in ASCII.  Nice, but takes more code.
     30 U0000							;
     31 U0000		       00 01	   FULL_STATUS equ	TRUE
     32 U0000							;
     33 U0000							; Enable EXTENDED_CMDS to allow linking external commands
     34 U0000							; to the command handler.
     35 U0000							;
     36 U0000		       00 00	   EXTENDED_CMDS equ	FALSE
     37 U0000							;
     38 U0000							; Define to enable SD related functions
     39 U0000							;
     40 U0000		       00 01	   SD_ENABLED equ	TRUE
     41 U0000							;
     42 U0000							; Size of the keyboard buffer
     43 U0000							;
     44 U0000		       00 84	   BUFFER_SIZE equ	132
     45 U0000
------- FILE ctmon65.asm
     29 U0000							;
     30 U0000							; Current version and revision
     31 U0000							;
     32 U0000		       00 00	   VERSION    equ	0
     33 U0000		       00 03	   REVISION   equ	3
     34 U0000							;
     35 U0000							;---------------------------------------------------------
     36 U0000							; ASCII constants
     37 U0000							;
     38 U0000		       00 07	   BELL       equ	$07
     39 U0000		       00 08	   BS	      equ	$08
     40 U0000		       00 0a	   LF	      equ	$0a
     41 U0000		       00 0d	   CR	      equ	$0d
     42 U0000							;
     43 U0000							; Max number of bytes per line for hex dump
     44 U0000							;
     45 U0000		       00 10	   BYTESLINE  equ	16
     46 U0000							;
     47 U0000							; These are various buffer sizes
     48 U0000							;
     49 U0000		       00 0c	   FILENAME_SIZE equ	12
     50 U0000							;
     51 U0000							; Intel HEX record types
     52 U0000							;
     53 U0000		       00 00	   DATA_RECORD equ	$00
     54 U0000		       00 01	   EOF_RECORD equ	$01
     55 U0000							;
     56 U0000							; Zero-page data
     57 U0000							;
     58 U0000							;		zpage
     59 U0000					      seg.U	ZEROPAGE
     60 U00f0					      org	ZERO_PAGE_START
     61 U00f0		       00 00	   sptr       ds	2
     62 U00f2		       00	   INL	      ds	1
     63 U00f3		       00	   INH	      ds	1
     64 U00f4		       00 00	   putsp      ds	2
     65 U00f6							;
     66 U00f6							; Non zero-page data
     67 U00f6							;
     68 Udfad ????				      Seg.u	RomScratch
     69 Udf00					      org	RAM_START
     70 Udf00							;
     71 Udf00							; The use of memory starting from here will remain
     72 Udf00							; constant through different versions of CTMON65.
     73 Udf00							;
     74 Udf00		       00 00	   IRQvec     ds	2
     75 Udf02		       00 00	   NMIvec     ds	2
     76 Udf04							;
     77 Udf04							; Before a L(oad) command, these are set to $FF.
     78 Udf04							; After loading, if they are different, jump to
     79 Udf04							; that address.
     80 Udf04							;
     81 Udf04		       00 00	   AutoRun    ds	2
     82 Udf06							;
     83 Udf06							; Pointer to the subroutine that gets the next input
     84 Udf06							; character.  Used for doing disk/console input.
     85 Udf06							;
     86 Udf06		       00 00	   inputVector ds	2
     87 Udf08							;
     88 Udf08							; Same thing for output.
     89 Udf08							;
     90 Udf08		       00 00	   outputVector ds	2
     91 Udf0a							;
     92 Udf0a							; Buffer for GETLINE
     93 Udf0a							;
     94 Udf0a		       00 00 00 00*buffer     ds	BUFFER_SIZE
     95 Udf8e							;
     96 Udf8e							; Anything from here can be moved between versions.
     97 Udf8e							;
     98 Udf8e		       00	   SaveA      ds	1
     99 Udf8f		       00	   SaveX      ds	1
    100 Udf90		       00	   SaveY      ds	1
    101 Udf91		       00 00	   SavePC     ds	2
    102 Udf93		       00	   SaveC      ds	1
    103 Udf94		       00	   SaveSP     ds	1
    104 Udf95		       00	   SAL	      ds	1
    105 Udf96		       00	   SAH	      ds	1
    106 Udf97		       00	   EAL	      ds	1
    107 Udf98		       00	   EAH	      ds	1
    108 Udf99		       00	   tempA      ds	1
    109 Udf9a		       00 00 00 00*filename   ds	FILENAME_SIZE+1
    110 Udfa7		       00	   diskBufOffset ds	1
    111 Udfa8		       00	   diskBufLength ds	1
    112 Udfa9		       00	   CHKL       ds	1
    113 Udfaa		       00	   ID	      ds	1
    114 Udfab		       00	   Temp16L    ds	1
    115 Udfac		       00	   Temp16H    ds	1
    116 Udfad							;
    117 Udfad							; This weird bit of DBs is to allow for the fact that
    118 Udfad							; I'm putting a 4K monitor into the top half of an
    119 Udfad							; 8K EEPROM.  This forces the actual code to the top
    120 Udfad							; 4K section.
    121 Udfad							;
    122 Udfad							;		Seg  rcode
    123 Udfad							;		org	ROM_START-$1000
    124 Udfad							;		db	"This space for rent.",CR,LF
    125 Udfad							;		db	"Actually, this just forces the "
    126 Udfad							;		db	"binary file to be 8K long."
    127 Udfad
    128 Udfad
    129  10000 ????				       Seg	Code
    130  f000					      org	ROM_START
    131  f000							;
    132  f000							;=========================================================
    133  f000							; Jump table to common functions.  The entries in this
    134  f000							; table are used by external programs, so nothing can be
    135  f000							; moved or removed from this table.  New entries always
    136  f000							; go at the end.  Many of these are internal functions
    137  f000							; and I figured they might be handy for others.
    138  f000							;
    139  f000		       4c 48 f0    COLDvec    jmp	RESET
    140  f003		       4c b7 f0    WARMvec    jmp	WARM
    141  f006							;
    142  f006							; These are the major and minor revision numbers so that
    143  f006							; code can check to see which CTMON65 version is running.
    144  f006							;
      0  f006				   CTMON65ver db	VERSION
      1  f006		       00		      .byte.b	VERSION
      0  f007				   CTMON65rev db	REVISION
      1  f007		       03		      .byte.b	REVISION
      0  f008					      db	0
      1  f008		       00		      .byte.b	0
    148  f009							;
    149  f009							; Console related functions
    150  f009							;
    151  f009		       4c 58 fb    CINvec     jmp	cin
    152  f00c		       4c 4b fb    COUTvec    jmp	cout
    153  f00f		       4c 63 fb    CSTATvec   jmp	cstatus
    154  f012		       4c c6 fa    PUTSILvec  jmp	putsil
    155  f015		       4c 04 fb    GETLINEvec jmp	getline
    156  f018		       4c 24 fb    CRLFvec    jmp	crlf
    157  f01b		       4c 07 fb    OUTHEXvec  jmp	HexA
    158  f01e							;
    159  f01e							; Low-level functions to access the SD card system
    160  f01e							;
    161  f01e					      if	SD_ENABLED
    162  f01e		       4c 69 fb    XPARINITvev jmp	xParInit
    163  f021		       4c 69 fb    XPARSETWRITEvec jmp	xParSetWrite
    164  f024		       4c 6c fb    XPARSETREADvec jmp	xParSetRead
    165  f027		       4c 6f fb    XPARWRITEvec jmp	xParWriteByte
    166  f02a		       4c 73 fb    XPARREADvec jmp	xParReadByte
    167  f02d							;
    168  f02d							; Higher level SD card functions
    169  f02d							;
    170  f02d		       4c 7e fb    DISKPINGvec jmp	DiskPing
    171  f030		       4c 91 fb    DISKDIRvec jmp	DiskDir
    172  f033		       4c 9b fb    DISKDIRNEXTVEC jmp	DiskDirNext
    173  f036		       4c cc fb    DISKOPENREADvec jmp	DiskOpenRead
    174  f039		       4c fd fb    DISKOPENWRITvec jmp	DiskOpenWrite
    175  f03c		       4c 07 fc    DISKREADvec jmp	DiskRead
    176  f03f		       4c 39 fc    DISKWRITEvec jmp	DiskWrite
    177  f042		       4c 70 fc    DISKCLOSEvec jmp	DiskClose
    178  f045		       4c 02 fc    DISKRMvec  JMP	DiskRemoveFile
    179  f048					      endif		;SD_ENABLED
    180  f048							;
    181  f048							;---------------------------------------------------------
    182  f048							; Cold start entry point
    183  f048							;
    184  f048		       a2 ff	   RESET      ldx	#$ff
    185  f04a		       9a		      txs
    186  f04b		       20 3f fb 	      jsr	cinit
    187  f04e		       20 69 fb 	      jsr	xParInit
    188  f051							;
    189  f051							; Reset the NMI and IRQ vectors
    190  f051							;
    191  f051		       a9 7b		      lda	#DefaultNMI&$ff
    192  f053		       8d 02 df 	      sta	NMIvec
    193  f056		       a9 fc		      lda	#DefaultNMI>>8
    194  f058		       8d 03 df 	      sta	NMIvec+1
    195  f05b							;
    196  f05b		       a9 7b		      lda	#DefaultIRQ&$ff
    197  f05d		       8d 00 df 	      sta	IRQvec
    198  f060		       a9 fc		      lda	#DefaultIRQ>>8
    199  f062		       8d 01 df 	      sta	IRQvec+1
    200  f065							;
    201  f065							; Print start-up message
    202  f065							;
    203  f065		       20 c6 fa 	      jsr	putsil
      0  f068					      db	CR,LF,LF,LF,LF
      1  f068		       0d 0a 0a 0a*	      .byte.b	CR,LF,LF,LF,LF
      0  f06d					      db	"CTMON65 rev "
      1  f06d		       43 54 4d 4f*	      .byte.b	"CTMON65 rev "
      0  f079					      db	VERSION+'0,'.
      1  f079		       30 2e		      .byte.b	VERSION+'0,'.
      0  f07b					      db	REVISION+'0
      1  f07b		       33		      .byte.b	REVISION+'0
      0  f07c					      db	CR,LF
      1  f07c		       0d 0a		      .byte.b	CR,LF
      0  f07e					      db	"09/20/2018 by Bob Applegate K2UT"
      1  f07e		       30 39 2f 32*	      .byte.b	"09/20/2018 by Bob Applegate K2UT"
      0  f09e					      db	", bob@corshamtech.com"
      1  f09e		       2c 20 62 6f*	      .byte.b	", bob@corshamtech.com"
      0  f0b3					      db	CR,LF,LF,0
      1  f0b3		       0d 0a 0a 00	      .byte.b	CR,LF,LF,0
    212  f0b7							;
    213  f0b7							;---------------------------------------------------------
    214  f0b7							; Warm start entry point.  This is the best place to jump
    215  f0b7							; in the code after a user program has ended.	Go through
    216  f0b7							; the vector, of course!
    217  f0b7							;
    218  f0b7		       a2 ff	   WARM       ldx	#$ff
    219  f0b9		       9a		      txs
    220  f0ba							;
    221  f0ba							; Prompt the user and get a line of text
    222  f0ba							;
    223  f0ba		       20 b2 f9    prompt     jsr	setOutputConsole
    224  f0bd		       20 cd f9 	      jsr	setInputConsole
    225  f0c0		       20 c6 fa 	      jsr	putsil
      0  f0c3					      db	CR,LF
      1  f0c3		       0d 0a		      .byte.b	CR,LF
      0  f0c5					      db	"CTMON65> "
      1  f0c5		       43 54 4d 4f*	      .byte.b	"CTMON65> "
      0  f0ce					      db	0
      1  f0ce		       00		      .byte.b	0
    229  f0cf		       20 58 fb    prompt2    jsr	cin
    230  f0d2		       c9 0d		      cmp	#CR
    231  f0d4		       f0 e4		      beq	prompt
    232  f0d6		       c9 0a		      cmp	#LF
    233  f0d8		       f0 f5		      beq	prompt2	;don't prompt
    234  f0da		       8d 99 df 	      sta	tempA
    235  f0dd							;
    236  f0dd							; Now cycle through the list of commands looking for
    237  f0dd							; what the user just pressed.
    238  f0dd							;
    239  f0dd		       a9 f6		      lda	#commandTable&$ff
    240  f0df		       85 f0		      sta	sptr
    241  f0e1		       a9 f0		      lda	#commandTable/256
    242  f0e3		       85 f1		      sta	sptr+1
    243  f0e5		       20 9b f2 	      jsr	searchCmd	;try to find it
    244  f0e8							;
    245  f0e8							; Hmmm... wasn't one of the built in commands, so
    246  f0e8							; see if it's an extended command.
    247  f0e8							;
    248  f0e8				  -	      if	EXTENDED_CMDS
    249  f0e8				  -	      lda	ExtensionAddr
    250  f0e8				  -	      sta	sptr
    251  f0e8				  -	      lda	ExtensionAddr+1
    252  f0e8				  -	      sta	sptr+1
    253  f0e8				  -	      jsr	searchCmd	;try to find it
    254  f0e8					      endif
    255  f0e8							;
    256  f0e8							; If that returns, then the command was not found.
    257  f0e8							; Print that it's unknown.
    258  f0e8							;
    259  f0e8		       20 c6 fa 	      jsr	putsil
      0  f0eb					      db	" - Huh?",0
      1  f0eb		       20 2d 20 48*	      .byte.b	" - Huh?",0
    261  f0f3		       4c ba f0    cmdFound   jmp	prompt
    262  f0f6							;
    263  f0f6							;=====================================================
    264  f0f6							; Vector table of commands.  Each entry consists of a
    265  f0f6							; single ASCII character (the command), a pointer to
    266  f0f6							; the function which handles the command, and a pointer
    267  f0f6							; to a string that describes the command.
    268  f0f6							;
    269  f0f6				   commandTable
      0  f0f6					      db	'?
      1  f0f6		       3f		      .byte.b	'?
      0  f0f7					      dw	showHelp
      1  f0f7		       c5 f7		      .word.w	showHelp
      0  f0f9					      dw	quesDesc
      1  f0f9		       33 f1		      .word.w	quesDesc
    273  f0fb							;
      0  f0fb					      db	'C
      1  f0fb		       43		      .byte.b	'C
      0  f0fc					      dw	doContinue
      1  f0fc		       2e f7		      .word.w	doContinue
      0  f0fe					      dw	cDesc
      1  f0fe		       50 f1		      .word.w	cDesc
    277  f100							;
      0  f100					      db	'D
      1  f100		       44		      .byte.b	'D
      0  f101					      dw	doDiskDir
      1  f101		       58 f9		      .word.w	doDiskDir
      0  f103					      dw	dDesc
      1  f103		       71 f1		      .word.w	dDesc
    281  f105							;
      0  f105					      db	'E	;edit memory
      1  f105		       45		      .byte.b	'E
      0  f106					      dw	editMemory
      1  f106		       70 f3		      .word.w	editMemory
      0  f108					      dw	eDesc
      1  f108		       8e f1		      .word.w	eDesc
    285  f10a							;
      0  f10a					      db	'H	;hex dump
      1  f10a		       48		      .byte.b	'H
      0  f10b					      dw	hexDump
      1  f10b		       e0 f2		      .word.w	hexDump
      0  f10d					      dw	hDesc
      1  f10d		       a8 f1		      .word.w	hDesc
    289  f10f							;
      0  f10f					      db	'J	;jump to address
      1  f10f		       4a		      .byte.b	'J
      0  f110					      dw	jumpAddress
      1  f110		       c6 f2		      .word.w	jumpAddress
      0  f112					      dw	jDesc
      1  f112		       c6 f1		      .word.w	jDesc
    293  f114							;
      0  f114					      db	'L	;load Intel HEX file
      1  f114		       4c		      .byte.b	'L
      0  f115					      dw	loadHex
      1  f115		       d1 f3		      .word.w	loadHex
      0  f117					      dw	lDesc
      1  f117		       e4 f1		      .word.w	lDesc
    297  f119							;
      0  f119					      db	'M	;perform memory test
      1  f119		       4d		      .byte.b	'M
      0  f11a					      dw	memTest
      1  f11a		       18 f8		      .word.w	memTest
      0  f11c					      dw	mDesc
      1  f11c		       00 f2		      .word.w	mDesc
    301  f11e							;
      0  f11e					      db	'P	;ping remote disk
      1  f11e		       50		      .byte.b	'P
      0  f11f					      dw	pingDisk
      1  f11f		       38 f9		      .word.w	pingDisk
      0  f121					      dw	pDesc
      1  f121		       1a f2		      .word.w	pDesc
    305  f123							;
      0  f123					      db	'R	;remove a file from disk
      1  f123		       52		      .byte.b	'R
      0  f124					      dw	rmFile
      1  f124		       26 fa		      .word.w	rmFile
      0  f126					      dw	rDesc
      1  f126		       3d f2		      .word.w	rDesc
    309  f128							;
      0  f128					      db	'S	;save memory as hex file
      1  f128		       53		      .byte.b	'S
      0  f129					      dw	saveHex
      1  f129		       17 f5		      .word.w	saveHex
      0  f12b					      dw	sDesc
      1  f12b		       5c f2		      .word.w	sDesc
    313  f12d							;
      0  f12d					      db	'T	;type a file on SD
      1  f12d		       54		      .byte.b	'T
      0  f12e					      dw	typeFile
      1  f12e		       5d fa		      .word.w	typeFile
      0  f130					      dw	tDesc
      1  f130		       7e f2		      .word.w	tDesc
    317  f132							;
      0  f132					      db	0	;marks end of table
      1  f132		       00		      .byte.b	0
    319  f133							;
    320  f133							;=====================================================
    321  f133							; Descriptions for each command in the command table.
    322  f133							; This wastes a lot of space... I'm open for any
    323  f133							; suggestions to keep the commands clear but reducing
    324  f133							; the amount of space this table consumes.
    325  f133							;
      0  f133				   quesDesc   db	"? ........... Show this help",0
      1  f133		       3f 20 2e 2e*	      .byte.b	"? ........... Show this help",0
      0  f150				   cDesc      db	"C ........... Continue execution",0
      1  f150		       43 20 2e 2e*	      .byte.b	"C ........... Continue execution",0
      0  f171				   dDesc      db	"D ........... Disk directory",0
      1  f171		       44 20 2e 2e*	      .byte.b	"D ........... Disk directory",0
      0  f18e				   eDesc      db	"E xxxx ...... Edit memory",0
      1  f18e		       45 20 78 78*	      .byte.b	"E xxxx ...... Edit memory",0
      0  f1a8				   hDesc      db	"H xxxx xxxx . Hex dump memory",0
      1  f1a8		       48 20 78 78*	      .byte.b	"H xxxx xxxx . Hex dump memory",0
      0  f1c6				   jDesc      db	"J xxxx ...... Jump to address",0
      1  f1c6		       4a 20 78 78*	      .byte.b	"J xxxx ...... Jump to address",0
      0  f1e4				   lDesc      db	"L ........... Load HEX file",0
      1  f1e4		       4c 20 2e 2e*	      .byte.b	"L ........... Load HEX file",0
      0  f200				   mDesc      db	"M xxxx xxxx . Memory test",0
      1  f200		       4d 20 78 78*	      .byte.b	"M xxxx xxxx . Memory test",0
      0  f21a				   pDesc      db	"P ........... Ping disk controller",0
      1  f21a		       50 20 2e 2e*	      .byte.b	"P ........... Ping disk controller",0
      0  f23d				   rDesc      db	"R ........... Remove disk file",0
      1  f23d		       52 20 2e 2e*	      .byte.b	"R ........... Remove disk file",0
      0  f25c				   sDesc      db	"S xxxx xxxx . Save memory to file",0
      1  f25c		       53 20 78 78*	      .byte.b	"S xxxx xxxx . Save memory to file",0
      0  f27e				   tDesc      db	"T ........... Type disk file",0
      1  f27e		       54 20 2e 2e*	      .byte.b	"T ........... Type disk file",0
    338  f29b							;
    339  f29b							;=====================================================
    340  f29b							; This subroutine will search for a command in a table
    341  f29b							; and call the appropriate handler.  See the command
    342  f29b							; table near the start of the code for what the format
    343  f29b							; is.	If a match is found, pop off the return address
    344  f29b							; from the stack and jump to the code.  Else, return.
    345  f29b							;
    346  f29b		       a0 00	   searchCmd  ldy	#0
    347  f29d		       b1 f0	   cmdLoop    lda	(sptr),y
    348  f29f		       f0 24		      beq	cmdNotFound
    349  f2a1		       cd 99 df 	      cmp	tempA	;compare to user's input
    350  f2a4		       f0 0e		      beq	cmdMatch
    351  f2a6		       09 20		      ora	#$20	;allow lower case cmds
    352  f2a8		       cd 99 df 	      cmp	tempA	;try users input again
    353  f2ab		       f0 07		      beq	cmdMatch
    354  f2ad		       c8		      iny		;start of function ptr
    355  f2ae		       c8		      iny
    356  f2af		       c8		      iny		;start of help
    357  f2b0		       c8		      iny
    358  f2b1		       c8		      iny		;move to next command
    359  f2b2		       d0 e9		      bne	cmdLoop
    360  f2b4							;
    361  f2b4							; It's found!	Load up the address of the code to call,
    362  f2b4							; pop the return address off the stack and jump to the
    363  f2b4							; handler.
    364  f2b4							;
    365  f2b4		       c8	   cmdMatch   iny
    366  f2b5		       b1 f0		      lda	(sptr),y	;handler LSB
    367  f2b7		       48		      pha
    368  f2b8		       c8		      iny
    369  f2b9		       b1 f0		      lda	(sptr),y	;handler MSB
    370  f2bb		       85 f1		      sta	sptr+1
    371  f2bd		       68		      pla
    372  f2be		       85 f0		      sta	sptr
    373  f2c0		       68		      pla		;pop return address
    374  f2c1		       68		      pla
    375  f2c2		       6c f0 00 	      jmp	(sptr)
    376  f2c5							;
    377  f2c5							; Not found, so just return.
    378  f2c5							;
    379  f2c5		       60	   cmdNotFound rts
    380  f2c6							;
    381  f2c6							;=====================================================
    382  f2c6							; Handles the command to prompt for an address and then
    383  f2c6							; jump to it.
    384  f2c6							;
    385  f2c6		       20 c6 fa    jumpAddress jsr	putsil
      0  f2c9					      db	"Jump to ",0
      1  f2c9		       4a 75 6d 70*	      .byte.b	"Jump to ",0
    387  f2d2		       20 82 f7 	      jsr	getStartAddr
    388  f2d5		       b0 06		      bcs	cmdRet	;branch on bad address
    389  f2d7		       20 24 fb 	      jsr	crlf
    390  f2da		       6c 95 df 	      jmp	(SAL)	;else jump to address
    391  f2dd							;
    392  f2dd		       4c ba f0    cmdRet     jmp	prompt
    393  f2e0							;
    394  f2e0							;=====================================================
    395  f2e0							; Do a hex dump of a region of memory.
    396  f2e0							;
    397  f2e0							; Slight bug: the starting address is rounded down to
    398  f2e0							; a multiple of 16.  I'll fix it eventually.
    399  f2e0							;
    400  f2e0		       20 c6 fa    hexDump    jsr	putsil
      0  f2e3					      db	"Hex dump ",0
      1  f2e3		       48 65 78 20*	      .byte.b	"Hex dump ",0
    402  f2ed		       20 a6 f7 	      jsr	getAddrRange
    403  f2f0		       b0 eb		      bcs	cmdRet
    404  f2f2		       20 24 fb 	      jsr	crlf
    405  f2f5							;
    406  f2f5							; Move start address to sptr but rounded down to the
    407  f2f5							; 16 byte boundary.  While it's really cool to start at
    408  f2f5							; the exact address specified by the user, it adds
    409  f2f5							; code that really doesn't add much (any?) value.
    410  f2f5							;
    411  f2f5		       ad 96 df 	      lda	SAH
    412  f2f8		       85 f1		      sta	sptr+1
    413  f2fa		       ad 95 df 	      lda	SAL
    414  f2fd		       29 f0		      and	#$f0	;force to 16 byte
    415  f2ff		       85 f0		      sta	sptr
    416  f301							;
    417  f301							;-----------------------------------------------------
    418  f301							; This starts each line.  Set flag to indcate we're
    419  f301							; doing the hex portion, print address, etc.
    420  f301							;
    421  f301		       20 24 fb    hexdump1   jsr	crlf
    422  f304		       a5 f1		      lda	sptr+1
    423  f306		       20 07 fb 	      jsr	HexA	;print the address
    424  f309		       a5 f0		      lda	sptr
    425  f30b		       20 07 fb 	      jsr	HexA
    426  f30e		       20 34 fb 	      jsr	space2	;two spaces after address
    427  f311							;
    428  f311							;-----------------------------------------------------
    429  f311							; This loop gets the next byte, prints the value in
    430  f311							; hex and adds the appropriate ASCII character to the
    431  f311							; buffer.
    432  f311							;
    433  f311		       a0 00		      ldy	#0	;offset from sptr
    434  f313		       a2 00	   hexdump3   ldx	#0	;bytes on line
    435  f315		       b1 f0	   hexdump2   lda	(sptr),y	;get byte
    436  f317		       20 07 fb 	      jsr	HexA	;print hex version of it
    437  f31a		       20 37 fb 	      jsr	space	;space before next value
    438  f31d							;
    439  f31d							; Put the byte into the buffer.  If it is not printable
    440  f31d							; ASCII then substitute a dot instead.
    441  f31d							;
    442  f31d		       c9 20		      cmp	#$20
    443  f31f		       90 04		      bcc	hexdot
    444  f321		       c9 7e		      cmp	#'~
    445  f323		       90 02		      bcc	hexpr
    446  f325		       a9 2e	   hexdot     lda	#'.
    447  f327		       9d 0a df    hexpr      sta	buffer,x	;save for later
    448  f32a							;
    449  f32a							; See if the end of the user defined area was just dumped
    450  f32a							;
    451  f32a		       a5 f0	   hexdumpchk lda	sptr
    452  f32c		       cd 97 df 	      cmp	EAL
    453  f32f		       d0 07		      bne	hexdump4
    454  f331		       a5 f1		      lda	sptr+1
    455  f333		       cd 98 df 	      cmp	EAH
    456  f336		       f0 0e		      beq	hexdumpend
    457  f338							;
    458  f338							; Not done yet, so see if at end of the line
    459  f338							;
    460  f338		       20 31 f9    hexdump4   jsr	INCPT	;move to next address
    461  f33b		       e8		      inx
    462  f33c		       e0 10		      cpx	#BYTESLINE
    463  f33e		       d0 d5		      bne	hexdump2
    464  f340							;
    465  f340							; At end, so dump ASCII contents
    466  f340							;
    467  f340		       20 50 f3 	      jsr	dumpBuffer
    468  f343		       4c 01 f3 	      jmp	hexdump1
    469  f346							;
    470  f346							; At the end but still need to dump the ASCII version.
    471  f346							;
    472  f346		       e8	   hexdumpend inx		;count last byte output
    473  f347		       20 50 f3 	      jsr	dumpBuffer
    474  f34a		       20 24 fb 	      jsr	crlf
    475  f34d		       4c ba f0    ret1       jmp	prompt
    476  f350							;
    477  f350							;=====================================================
    478  f350							; A helper function that prints the ASCII data in the
    479  f350							; buffer.  On entry X contains the number of bytes
    480  f350							; in the buffer.
    481  f350							;
    482  f350		       e0 10	   dumpBuffer cpx	#BYTESLINE	;is buffer full?
    483  f352		       f0 0b		      beq	hexdump91	;jump if so
    484  f354		       a9 20		      lda	#$20		;else fill with spaces
    485  f356		       9d 0a df 	      sta	buffer,x
    486  f359		       20 31 fb 	      jsr	space3	;and space over
    487  f35c		       e8		      inx
    488  f35d		       d0 f1		      bne	dumpBuffer
    489  f35f							;
    490  f35f		       20 31 fb    hexdump91  jsr	space3	;separate the two passes
    491  f362		       a2 00		      ldx	#0
    492  f364		       bd 0a df    hexdump99  lda	buffer,x
    493  f367		       20 4b fb 	      jsr	cout	;print char in buffer
    494  f36a		       e8		      inx
    495  f36b		       e0 10		      cpx	#BYTESLINE
    496  f36d		       d0 f5		      bne	hexdump99
    497  f36f		       60		      rts
    498  f370							;
    499  f370							;=====================================================
    500  f370							; Edit memory.  This waits for a starting address to be
    501  f370							; entered.  It will display the current address and its
    502  f370							; contents.  Possible user inputs and actions:
    503  f370							;
    504  f370							;   Two hex digits will place that value in memory
    505  f370							;   RETURN moves to next address
    506  f370							;   BACKSPACE moves back one address
    507  f370							;
    508  f370		       20 c6 fa    editMemory jsr	putsil
      0  f373					      db	"Edit memory ",0
      1  f373		       45 64 69 74*	      .byte.b	"Edit memory ",0
    510  f380		       20 82 f7 	      jsr	getStartAddr
    511  f383		       b0 c8		      bcs	ret1
    512  f385		       ad 95 df 	      lda	SAL	;move address into...
    513  f388		       85 f0		      sta	sptr	;...POINT
    514  f38a		       ad 96 df 	      lda	SAH
    515  f38d		       85 f1		      sta	sptr+1
    516  f38f							;
    517  f38f							; Display the current location
    518  f38f							;
    519  f38f		       20 24 fb    editMem1   jsr	crlf
    520  f392		       a5 f1		      lda	sptr+1
    521  f394		       20 07 fb 	      jsr	HexA
    522  f397		       a5 f0		      lda	sptr
    523  f399		       20 07 fb 	      jsr	HexA
    524  f39c		       20 37 fb 	      jsr	space
    525  f39f		       a0 00		      ldy	#0
    526  f3a1		       b1 f0		      lda	(sptr),y	;get byte
    527  f3a3		       20 07 fb 	      jsr	HexA	;print it
    528  f3a6		       20 37 fb 	      jsr	space
    529  f3a9							;
    530  f3a9		       20 48 f7 	      jsr	getHex
    531  f3ac		       b0 0d		      bcs	editMem2	;not hex
    532  f3ae		       a0 00		      ldy	#0
    533  f3b0		       91 f0		      sta	(sptr),y	;save new value
    534  f3b2							;
    535  f3b2							; Bump POINT to next location
    536  f3b2							;
    537  f3b2		       e6 f0	   editMem3   inc	sptr
    538  f3b4		       d0 d9		      bne	editMem1
    539  f3b6		       e6 f1		      inc	sptr+1
    540  f3b8		       4c 8f f3 	      jmp	editMem1
    541  f3bb							;
    542  f3bb							; Not hex, so see if another command
    543  f3bb							;
    544  f3bb		       c9 0d	   editMem2   cmp	#CR
    545  f3bd		       f0 f3		      beq	editMem3	;move to next
    546  f3bf		       c9 08		      cmp	#BS
    547  f3c1		       d0 8a		      bne	ret1	;else exit
    548  f3c3							;
    549  f3c3							; Move back one location
    550  f3c3							;
    551  f3c3		       38		      sec
    552  f3c4		       a5 f0		      lda	sptr
    553  f3c6		       e9 01		      sbc	#1
    554  f3c8		       85 f0		      sta	sptr
    555  f3ca		       b0 c3		      bcs	editMem1
    556  f3cc		       c6 f1		      dec	sptr+1
    557  f3ce		       4c 8f f3 	      jmp	editMem1
    558  f3d1							;
    559  f3d1							;=====================================================
    560  f3d1							; This handles the Load hex command.
    561  f3d1							;
    562  f3d1		       a9 ff	   loadHex    lda	#$ff
    563  f3d3		       8d 05 df 	      sta	AutoRun+1
    564  f3d6							;
    565  f3d6		       20 c6 fa 	      jsr	putsil
      0  f3d9					      db	CR,LF
      1  f3d9		       0d 0a		      .byte.b	CR,LF
      0  f3db					      db	"Enter filename, or Enter to "
      1  f3db		       45 6e 74 65*	      .byte.b	"Enter filename, or Enter to "
      0  f3f7					      db	"load from console: ",0
      1  f3f7		       6c 6f 61 64*	      .byte.b	"load from console: ",0
    569  f40b							;
    570  f40b		       20 45 f6 	      jsr	getFileName	;get filename
    571  f40e		       ad 9a df 	      lda	filename	;null?
    572  f411		       f0 2d		      beq	loadHexConsole	;load from console
    573  f413							;
    574  f413							; Open the file
    575  f413							;
    576  f413		       a0 9a		      ldy	#filename&$ff
    577  f415		       a2 df		      ldx	#filename/256
    578  f417		       20 cc fb 	      jsr	DiskOpenRead
    579  f41a		       90 1e		      bcc	loadHexOk	;opened ok
    580  f41c							;
    581  f41c		       20 c6 fa    openfail   jsr	putsil
      0  f41f					      db	CR,LF
      1  f41f		       0d 0a		      .byte.b	CR,LF
      0  f421					      db	"Failed to open file"
      1  f421		       46 61 69 6c*	      .byte.b	"Failed to open file"
      0  f434					      db	CR,LF,0
      1  f434		       0d 0a 00 	      .byte.b	CR,LF,0
    585  f437		       4c ba f0    cmdRet3    jmp	prompt
    586  f43a							;
    587  f43a		       20 e1 f9    loadHexOk  jsr	setInputFile	;redirect input
    588  f43d		       4c 6e f4 	      jmp	loadStart
    589  f440							;
    590  f440							; They are loading from the console
    591  f440							;
    592  f440		       20 c6 fa    loadHexConsole jsr	putsil
      0  f443					      db	CR,LF
      1  f443		       0d 0a		      .byte.b	CR,LF
      0  f445					      db	"Waiting for file, or ESC to"
      1  f445		       57 61 69 74*	      .byte.b	"Waiting for file, or ESC to"
      0  f460					      db	" exit..."
      1  f460		       20 65 78 69*	      .byte.b	" exit..."
      0  f468					      db	CR,LF,0
      1  f468		       0d 0a 00 	      .byte.b	CR,LF,0
    597  f46b		       20 cd f9 	      jsr	setInputConsole
    598  f46e							;
    599  f46e							; The start of a line.  First character should be a
    600  f46e							; colon, but toss out CRs, LFs, etc.  Anything else
    601  f46e							; causes an abort.
    602  f46e							;
    603  f46e		       20 f4 f9    loadStart  jsr	redirectedGetch	;get start of line
    604  f471		       c9 0d		      cmp	#CR
    605  f473		       f0 f9		      beq	loadStart
    606  f475		       c9 0a		      cmp	#LF
    607  f477		       f0 f5		      beq	loadStart
    608  f479		       c9 3a		      cmp	#':	;what we expect
    609  f47b		       d0 34		      bne	loadAbort
    610  f47d							;
    611  f47d							; Get the header of the record
    612  f47d							;
    613  f47d		       a9 00		      lda	#0
    614  f47f		       8d a9 df 	      sta	CHKL	;initialize checksum
    615  f482							;
    616  f482		       20 48 f7 	      jsr	getHex	;get byte count
    617  f485		       b0 2a		      bcs	loadAbort
    618  f487		       8d 8f df 	      sta	SaveX	;save byte count
    619  f48a		       20 8b f9 	      jsr	updateCrc
    620  f48d		       20 48 f7 	      jsr	getHex	;get the MSB of offset
    621  f490		       b0 1f		      bcs	loadAbort
    622  f492		       85 f1		      sta	sptr+1
    623  f494		       20 8b f9 	      jsr	updateCrc
    624  f497		       20 48 f7 	      jsr	getHex	;get LSB of offset
    625  f49a		       b0 15		      bcs	loadAbort
    626  f49c		       85 f0		      sta	sptr
    627  f49e		       20 8b f9 	      jsr	updateCrc
    628  f4a1		       20 48 f7 	      jsr	getHex	;get the record type
    629  f4a4		       b0 0b		      bcs	loadAbort
    630  f4a6		       20 8b f9 	      jsr	updateCrc
    631  f4a9							;
    632  f4a9							; Only handle two record types:
    633  f4a9							;    00 = data record
    634  f4a9							;    01 = end of file record
    635  f4a9							;
    636  f4a9		       c9 00		      cmp	#DATA_RECORD
    637  f4ab		       f0 3a		      beq	loadDataRec
    638  f4ad		       c9 01		      cmp	#EOF_RECORD
    639  f4af		       f0 16		      beq	loadEof
    640  f4b1							;
    641  f4b1							; Unknown record type
    642  f4b1							;
    643  f4b1		       20 c6 fa    loadAbort  jsr	putsil
      0  f4b4					      db	CR,LF
      1  f4b4		       0d 0a		      .byte.b	CR,LF
      0  f4b6					      db	"Aborting"
      1  f4b6		       41 62 6f 72*	      .byte.b	"Aborting"
      0  f4be					      db	CR,LF,0
      1  f4be		       0d 0a 00 	      .byte.b	CR,LF,0
    647  f4c1		       20 cd f9    loadExit   jsr	setInputConsole
    648  f4c4		       4c ba f0 	      jmp	prompt
    649  f4c7							;
    650  f4c7							; EOF is easy
    651  f4c7							;
    652  f4c7		       20 48 f7    loadEof    jsr	getHex	;get checksum
    653  f4ca		       20 c6 fa 	      jsr	putsil
      0  f4cd					      db	CR,LF
      1  f4cd		       0d 0a		      .byte.b	CR,LF
      0  f4cf					      db	"Success!"
      1  f4cf		       53 75 63 63*	      .byte.b	"Success!"
      0  f4d7					      db	CR,LF,0
      1  f4d7		       0d 0a 00 	      .byte.b	CR,LF,0
    657  f4da							;
    658  f4da							; If the auto-run vector is no longer $ffff, then jump
    659  f4da							; to whatever it points to.
    660  f4da							;
    661  f4da		       ad 05 df 	      lda	AutoRun+1
    662  f4dd		       c9 ff		      cmp	#$ff	;unchanged?
    663  f4df		       f0 03		      beq	lExit1
    664  f4e1		       6c 04 df 	      jmp	(AutoRun)	;execute!
    665  f4e4							;
    666  f4e4		       4c c1 f4    lExit1     jmp	loadExit
    667  f4e7							;
    668  f4e7							; Data records have more work.  After processing the
    669  f4e7							; line, print a dot to indicate progress.  This should
    670  f4e7							; be re-thought as it could slow down loading a really
    671  f4e7							; big file if the console speed is slow.
    672  f4e7							;
    673  f4e7		       ae 8f df    loadDataRec ldx	SaveX	;byte count
    674  f4ea		       a0 00		      ldy	#0	;offset
    675  f4ec		       8e 8f df    loadData1  stx	SaveX
    676  f4ef		       8c 90 df 	      sty	SaveY
    677  f4f2		       20 48 f7 	      jsr	getHex
    678  f4f5		       b0 ba		      bcs	loadAbort
    679  f4f7		       20 8b f9 	      jsr	updateCrc
    680  f4fa		       ac 90 df 	      ldy	SaveY
    681  f4fd		       ae 8f df 	      ldx	SaveX
    682  f500		       91 f0		      sta	(sptr),y
    683  f502		       c8		      iny
    684  f503		       ca		      dex
    685  f504		       d0 e6		      bne	loadData1
    686  f506							;
    687  f506							; All the bytes were read so get the checksum and see
    688  f506							; if it agrees.  The checksum is a twos-complement, so
    689  f506							; just add the checksum into what we've been calculating
    690  f506							; and if the result is zero then the record is good.
    691  f506							;
    692  f506		       20 48 f7 	      jsr	getHex	;get checksum
    693  f509		       18		      clc
    694  f50a		       6d a9 df 	      adc	CHKL
    695  f50d		       d0 a2		      bne	loadAbort	;non-zero is error
    696  f50f							;
    697  f50f		       a9 2e		      lda	#'.	;sanity indicator when
    698  f511		       20 4b fb 	      jsr	cout	;...loading from file
    699  f514		       4c 6e f4 	      jmp	loadStart
    700  f517							;
    701  f517							;=====================================================
    702  f517							; Handles the command to save a region of memory as a
    703  f517							; file on the SD.
    704  f517							;
    705  f517		       20 a6 f7    saveHex    jsr	getAddrRange	;get range to dump
    706  f51a		       b0 c8		      bcs	lExit1	;abort on error
    707  f51c							;
    708  f51c							; Get the filename to save to
    709  f51c							;
    710  f51c		       20 c6 fa 	      jsr	putsil
      0  f51f					      db	CR,LF
      1  f51f		       0d 0a		      .byte.b	CR,LF
      0  f521					      db	"Enter filename, or Enter to "
      1  f521		       45 6e 74 65*	      .byte.b	"Enter filename, or Enter to "
      0  f53d					      db	"load from console: ",0
      1  f53d		       6c 6f 61 64*	      .byte.b	"load from console: ",0
    714  f551							;
    715  f551		       20 45 f6 	      jsr	getFileName	;get filename
    716  f554		       ad 9a df 	      lda	filename	;null?
    717  f557		       f0 12		      beq	saveHexConsole	;dump to console
    718  f559							;
    719  f559							; They selected a file, so try to open it.
    720  f559							;
    721  f559		       a2 df		      ldx	#filename>>8
    722  f55b		       a0 9a		      ldy	#filename&$ff
    723  f55d		       20 fd fb 	      jsr	DiskOpenWrite	;attempt to open file
    724  f560		       90 03		      bcc	sopenok	;branch if opened ok
    725  f562		       4c 1c f4 	      jmp	openfail
    726  f565							;
    727  f565		       20 bd f9    sopenok    jsr	setOutputFile
    728  f568		       4c 6e f5 	      jmp	savehex2
    729  f56b							;
    730  f56b							; They are saving to the console.  Set up the output
    731  f56b							; vector and do the job.
    732  f56b							;
    733  f56b		       20 b2 f9    saveHexConsole jsr	setOutputConsole
    734  f56e							;
    735  f56e							; Compute the number of bytes to dump
    736  f56e							;
    737  f56e		       38	   savehex2   sec
    738  f56f		       ad 97 df 	      lda	EAL
    739  f572		       ed 95 df 	      sbc	SAL
    740  f575		       8d ab df 	      sta	Temp16L
    741  f578		       ad 98 df 	      lda	EAH
    742  f57b		       ed 96 df 	      sbc	SAH
    743  f57e		       8d ac df 	      sta	Temp16H
    744  f581		       90 42		      bcc	SDone	;start > end
    745  f583		       05 00		      ora	0
    746  f585		       30 3e		      bmi	SDone	;more than 32K seems wrong
    747  f587							;
    748  f587							; Add one to the count
    749  f587							;
    750  f587		       ee ab df 	      inc	Temp16L
    751  f58a		       d0 03		      bne	slab1
    752  f58c		       ee ac df 	      inc	Temp16H
    753  f58f							;
    754  f58f							; Move pointer to zero page
    755  f58f							;
    756  f58f		       ad 95 df    slab1      lda	SAL
    757  f592		       85 f0		      sta	sptr
    758  f594		       ad 96 df 	      lda	SAH
    759  f597		       85 f1		      sta	sptr+1
    760  f599							;
    761  f599							; Top of each loop.  Start by seeing if there are any bytes
    762  f599							; left to dump.
    763  f599							;
    764  f599		       ad ac df    Sloop1     lda	Temp16H
    765  f59c		       d0 2a		      bne	Sgo	;more to do
    766  f59e		       ad ab df 	      lda	Temp16L
    767  f5a1		       d0 25		      bne	Sgo	;more to do
    768  f5a3							;
    769  f5a3							; At end of the region, so output an end record.  This
    770  f5a3							; probably looks like overkill but keep in mind this
    771  f5a3							; might be going to a file so we can't use the normal
    772  f5a3							; string put functions.
    773  f5a3							;
    774  f5a3		       a9 3a		      lda	#':
    775  f5a5		       20 af f9 	      jsr	redirectedOutch
    776  f5a8		       a9 00		      lda	#0
    777  f5aa		       20 95 f9 	      jsr	HexToOutput
    778  f5ad		       20 95 f9 	      jsr	HexToOutput
    779  f5b0		       20 95 f9 	      jsr	HexToOutput
    780  f5b3		       a9 01		      lda	#1
    781  f5b5		       20 95 f9 	      jsr	HexToOutput
    782  f5b8		       a9 ff		      lda	#$ff
    783  f5ba		       20 95 f9 	      jsr	HexToOutput
    784  f5bd							;
    785  f5bd							; If output to file, flush and close the file.
    786  f5bd							;
    787  f5bd		       ad 9a df 	      lda	filename
    788  f5c0		       f0 03		      beq	SDone	;it's going to console
    789  f5c2		       20 b7 fa 	      jsr	CloseOutFile
    790  f5c5		       4c ba f0    SDone      jmp	prompt	;back to the monitor
    791  f5c8							;
    792  f5c8							; This dumps the next line.  See how many bytes are left to do
    793  f5c8							; and if more than BYTESLINE, then just do BYTESLINE.
    794  f5c8							;
    795  f5c8		       ad ac df    Sgo	      lda	Temp16H
    796  f5cb		       d0 07		      bne	Sdef	;do default number of bytes
    797  f5cd		       ad ab df 	      lda	Temp16L
    798  f5d0		       c9 10		      cmp	#BYTESLINE
    799  f5d2		       90 02		      bcc	Scnt	;more than max per line
    800  f5d4		       a9 10	   Sdef       lda	#BYTESLINE
    801  f5d6		       8d 99 df    Scnt       sta	tempA	;for decrementing
    802  f5d9		       8d aa df 	      sta	ID	;for subtracting
    803  f5dc							;
    804  f5dc							; Put out the header
    805  f5dc							;
    806  f5dc		       a9 3a		      lda	#':
    807  f5de		       20 af f9 	      jsr	redirectedOutch
    808  f5e1							;
    809  f5e1		       ad 99 df 	      lda	tempA
    810  f5e4		       8d a9 df 	      sta	CHKL	;start checksum
    811  f5e7		       20 95 f9 	      jsr	HexToOutput
    812  f5ea							;
    813  f5ea		       a5 f1		      lda	sptr+1	;starting address
    814  f5ec		       20 8b f9 	      jsr	updateCrc
    815  f5ef		       20 95 f9 	      jsr	HexToOutput
    816  f5f2		       a5 f0		      lda	sptr
    817  f5f4		       20 8b f9 	      jsr	updateCrc
    818  f5f7		       20 95 f9 	      jsr	HexToOutput
    819  f5fa							;
    820  f5fa		       a9 00		      lda	#0	;record type - data
    821  f5fc		       20 95 f9 	      jsr	HexToOutput
    822  f5ff							;
    823  f5ff							; Now print the proper number of bytes
    824  f5ff							;
    825  f5ff		       a0 00	   Sloop2     ldy	#0
    826  f601		       b1 f0		      lda	(sptr),y	;get byte
    827  f603		       20 8b f9 	      jsr	updateCrc
    828  f606		       20 95 f9 	      jsr	HexToOutput
    829  f609		       20 31 f9 	      jsr	INCPT	;increment pointer
    830  f60c							;
    831  f60c		       ce 99 df    sdec       dec	tempA
    832  f60f		       d0 ee		      bne	Sloop2
    833  f611							;
    834  f611							; Now print checksum
    835  f611							;
    836  f611		       ad a9 df 	      lda	CHKL
    837  f614		       49 ff		      eor	#$ff	;one's complement
    838  f616		       18		      clc
    839  f617		       69 01		      adc	#1	;two's complement
    840  f619		       20 95 f9 	      jsr	HexToOutput
    841  f61c							;
    842  f61c							; Output a CR/LF
    843  f61c							;
    844  f61c		       a9 0d		      lda	#CR
    845  f61e		       20 af f9 	      jsr	redirectedOutch
    846  f621		       a9 0a		      lda	#LF
    847  f623		       20 af f9 	      jsr	redirectedOutch
    848  f626							;
    849  f626							; If saving to disk, output a dot to indicate progress.
    850  f626							;
    851  f626		       ad 9a df 	      lda	filename
    852  f629		       f0 05		      beq	shf2
    853  f62b							;
    854  f62b		       a9 2e		      lda	#'.
    855  f62d		       20 4b fb 	      jsr	cout	;goes to console
    856  f630							;
    857  f630		       38	   shf2       sec
    858  f631		       ad ab df 	      lda	Temp16L
    859  f634		       ed aa df 	      sbc	ID
    860  f637		       8d ab df 	      sta	Temp16L
    861  f63a		       ad ac df 	      lda	Temp16H
    862  f63d		       e9 00		      sbc	#0
    863  f63f		       8d ac df 	      sta	Temp16H
    864  f642							;
    865  f642		       4c 99 f5 	      jmp	Sloop1
    866  f645							;
    867  f645							;=====================================================
    868  f645							; Get a disk filename.
    869  f645							;
    870  f645		       a2 00	   getFileName ldx	#0
    871  f647		       20 58 fb    getFilename1 jsr	cin	;get next key
    872  f64a		       c9 0d		      cmp	#CR	;end of the input?
    873  f64c		       f0 27		      beq	getFnDone
    874  f64e		       c9 08		      cmp	#BS	;backspace?
    875  f650		       f0 0d		      beq	getFnDel
    876  f652		       e0 0c		      cpx	#FILENAME_SIZE	;check size
    877  f654		       f0 f1		      beq	getFilename1	;at length limit
    878  f656		       9d 9a df 	      sta	filename,x	;else save it
    879  f659		       20 4b fb 	      jsr	cout
    880  f65c		       e8		      inx
    881  f65d		       d0 e8		      bne	getFilename1
    882  f65f							;
    883  f65f		       ca	   getFnDel   dex
    884  f660		       30 10		      bmi	getFnU	;no charac here
    885  f662		       a9 08		      lda	#BS
    886  f664		       20 4b fb 	      jsr	cout
    887  f667		       a9 20		      lda	#$20
    888  f669		       20 4b fb 	      jsr	cout
    889  f66c		       a9 08		      lda	#BS
    890  f66e		       20 4b fb 	      jsr	cout
    891  f671		       ca		      dex
    892  f672		       e8	   getFnU     inx		;can't go past start
    893  f673		       10 d2		      bpl	getFilename1
    894  f675		       a9 00	   getFnDone  lda	#0	;terminate line
    895  f677		       9d 9a df 	      sta	filename,x
    896  f67a		       4c 24 fb 	      jmp	crlf
    897  f67d							;
    898  f67d							;=====================================================
    899  f67d							; Add the byte in A to the output buffer.  If the
    900  f67d							; buffer is full, flush it to disk.
    901  f67d							;
    902  f67d		       ae a7 df    putNextFileByte ldx	diskBufOffset
    903  f680		       e0 84		      cpx	#BUFFER_SIZE	;buffer full?
    904  f682		       d0 0d		      bne	pNFB	;no
    905  f684							;
    906  f684							; The buffer is full, so write it out.
    907  f684							;
    908  f684		       48		      pha		;save byte
    909  f685		       a9 84		      lda	#BUFFER_SIZE
    910  f687		       a2 df		      ldx	#buffer>>8
    911  f689		       a0 0a		      ldy	#buffer&$ff
    912  f68b		       20 39 fc 	      jsr	DiskWrite
    913  f68e							;
    914  f68e		       a2 00		      ldx	#0	;reset index
    915  f690		       68		      pla
    916  f691		       9d 0a df    pNFB       sta	buffer,x
    917  f694		       e8		      inx
    918  f695		       8e a7 df 	      stx	diskBufOffset
    919  f698		       60		      rts
    920  f699							;
    921  f699							;*********************************************************
    922  f699							; Dump the current registers based on values in the Save*
    923  f699							; locations.
    924  f699							;
    925  f699				   DumpRegisters
    926  f699		       20 c6 fa 	      jsr	putsil
      0  f69c					      db	"PC:",0
      1  f69c		       50 43 3a 00	      .byte.b	"PC:",0
    928  f6a0		       ad 92 df 	      lda	SavePC+1
    929  f6a3		       20 07 fb 	      jsr	HexA
    930  f6a6		       ad 91 df 	      lda	SavePC
    931  f6a9		       20 07 fb 	      jsr	HexA
    932  f6ac							;
    933  f6ac		       20 c6 fa 	      jsr	putsil
      0  f6af					      db	" A:",0
      1  f6af		       20 41 3a 00	      .byte.b	" A:",0
    935  f6b3		       ad 8e df 	      lda	SaveA
    936  f6b6		       20 07 fb 	      jsr	HexA
    937  f6b9							;
    938  f6b9		       20 c6 fa 	      jsr	putsil
      0  f6bc					      db	" X:",0
      1  f6bc		       20 58 3a 00	      .byte.b	" X:",0
    940  f6c0		       ad 8f df 	      lda	SaveX
    941  f6c3		       20 07 fb 	      jsr	HexA
    942  f6c6							;
    943  f6c6		       20 c6 fa 	      jsr	putsil
      0  f6c9					      db	" Y:",0
      1  f6c9		       20 59 3a 00	      .byte.b	" Y:",0
    945  f6cd		       ad 90 df 	      lda	SaveY
    946  f6d0		       20 07 fb 	      jsr	HexA
    947  f6d3							;
    948  f6d3		       20 c6 fa 	      jsr	putsil
      0  f6d6					      db	" SP:",0
      1  f6d6		       20 53 50 3a*	      .byte.b	" SP:",0
    950  f6db		       ad 94 df 	      lda	SaveSP
    951  f6de		       20 07 fb 	      jsr	HexA
    952  f6e1							;
    953  f6e1							; Last is the condition register.  For this, print the
    954  f6e1							; actual flags.  Lower case for clear, upper for set.
    955  f6e1							;
    956  f6e1		       20 c6 fa 	      jsr	putsil
      0  f6e4					      db	" Flags:",0
      1  f6e4		       20 46 6c 61*	      .byte.b	" Flags:",0
    958  f6ec					      if	FULL_STATUS
    959  f6ec							;
    960  f6ec							; N - bit 7
    961  f6ec							;
    962  f6ec		       a9 80		      lda	#$80	;bit to test
    963  f6ee		       a2 4e		      ldx	#'N	;set ACII char
    964  f6f0		       20 1f f7 	      jsr	testbit
    965  f6f3							;
    966  f6f3							; V - bit 6
    967  f6f3							;
    968  f6f3		       a9 40		      lda	#$40	;bit to test
    969  f6f5		       a2 56		      ldx	#'V	;set ACII char
    970  f6f7		       20 1f f7 	      jsr	testbit
    971  f6fa							;
    972  f6fa		       a9 2d		      lda	#'-	;unused bit
    973  f6fc		       20 4b fb 	      jsr	cout
    974  f6ff							;
    975  f6ff							; B - bit 4
    976  f6ff							;
    977  f6ff		       a9 10		      lda	#$10	;bit to test
    978  f701		       a2 42		      ldx	#'B	;set ACII char
    979  f703		       20 1f f7 	      jsr	testbit
    980  f706							;
    981  f706							; D - bit 3
    982  f706							;
    983  f706		       a9 08		      lda	#$08	;bit to test
    984  f708		       a2 44		      ldx	#'D	;set ACII char
    985  f70a		       20 1f f7 	      jsr	testbit
    986  f70d							;
    987  f70d							; I - bit 2
    988  f70d							;
    989  f70d		       a9 04		      lda	#$04	;bit to test
    990  f70f		       a2 49		      ldx	#'I	;set ACII char
    991  f711		       20 1f f7 	      jsr	testbit
    992  f714							;
    993  f714							; Z - bit 1
    994  f714							;
    995  f714		       a9 02		      lda	#$02	;bit to test
    996  f716		       a2 5a		      ldx	#'Z	;set ACII char
    997  f718		       20 1f f7 	      jsr	testbit
    998  f71b							;
    999  f71b							; C - bit 0
   1000  f71b							;
   1001  f71b		       a9 01		      lda	#$01	;bit to test
   1002  f71d		       a2 43		      ldx	#'C	;set ACII char
   1003  f71f							;
   1004  f71f							; Fall through...
   1005  f71f							;
   1006  f71f							;*********************************************************
   1007  f71f							; Given a bit mask in A and an upper case character
   1008  f71f							; indicating the flag name in X, see if the flag is set or
   1009  f71f							; not.  Output upper case if set, lower case if not.
   1010  f71f							;
   1011  f71f		       2d 93 df    testbit    and	SaveC	;is bit set?
   1012  f722		       d0 06		      bne	testbit1	;yes
   1013  f724		       8a		      txa
   1014  f725		       09 20		      ora	#$20	;make lower case
   1015  f727		       4c 4b fb 	      jmp	cout
   1016  f72a		       8a	   testbit1   txa
   1017  f72b		       4c 4b fb 	      jmp	cout
   1018  f72e				  -	      else
   1019  f72e				  -	      lda	SaveSP
   1020  f72e				  -	      jmp	HexA
   1021  f72e					      endif
   1022  f72e							;
   1023  f72e							;=====================================================
   1024  f72e							; This continues executing from the last saved state,
   1025  f72e							; such as from a call to DefaultNMI.
   1026  f72e							;
   1027  f72e				   doContinue
   1028  f72e		       ae 94 df 	      ldx	SaveSP
   1029  f731		       9a		      txs
   1030  f732		       ad 92 df 	      lda	SavePC+1
   1031  f735		       48		      pha
   1032  f736		       ad 91 df 	      lda	SavePC
   1033  f739		       48		      pha
   1034  f73a		       ad 93 df 	      lda	SaveC
   1035  f73d		       48		      pha
   1036  f73e		       ae 8f df 	      ldx	SaveX
   1037  f741		       ac 90 df 	      ldy	SaveY
   1038  f744		       ad 8e df 	      lda	SaveA
   1039  f747		       40		      rti
   1040  f748							;
   1041  f748							;=====================================================
   1042  f748							; This gets two hex characters and returns the value
   1043  f748							; in A with carry clear.  If a non-hex digit is
   1044  f748							; entered, then A contans the offending character and
   1045  f748							; carry is set.
   1046  f748							;
   1047  f748		       20 60 f7    getHex     jsr	getNibble
   1048  f74b		       b0 20		      bcs	getNibBad
   1049  f74d		       0a		      asl		; a
   1050  f74e		       0a		      asl		; a
   1051  f74f		       0a		      asl		; a
   1052  f750		       0a		      asl		; a
   1053  f751		       29 f0		      and	#$f0
   1054  f753		       8d 99 df 	      sta	tempA
   1055  f756		       20 60 f7 	      jsr	getNibble
   1056  f759		       b0 12		      bcs	getNibBad
   1057  f75b		       0d 99 df 	      ora	tempA
   1058  f75e		       18		      clc
   1059  f75f		       60		      rts
   1060  f760							;
   1061  f760							; Helper.  Gets next input char and converts to a
   1062  f760							; value from 0-F in A and returns C clear.  If not a
   1063  f760							; valid hex character, return C set.
   1064  f760							;
   1065  f760		       20 f4 f9    getNibble  jsr	redirectedGetch
   1066  f763		       a2 0f		      ldx	#nibbleHexEnd-nibbleHex-1
   1067  f765		       dd 72 f7    getNibble1 cmp	nibbleHex,x
   1068  f768		       f0 05		      beq	getNibF	;got match
   1069  f76a		       ca		      dex
   1070  f76b		       10 f8		      bpl	getNibble1
   1071  f76d		       38	   getNibBad  sec
   1072  f76e		       60		      rts
   1073  f76f
   1074  f76f		       8a	   getNibF    txa		;index is value
   1075  f770		       18		      clc
   1076  f771		       60		      rts
   1077  f772							;
      0  f772				   nibbleHex  db	"0123456789ABCDEF"
      1  f772		       30 31 32 33*	      .byte.b	"0123456789ABCDEF"
   1079  f772		       f7 82	   nibbleHexEnd equ	*
   1080  f782							;
   1081  f782							;=====================================================
   1082  f782							; Gets a four digit hex address amd places it in
   1083  f782							; SAL and SAH.  Returns C clear if all is well, or C
   1084  f782							; set on error and A contains the character.
   1085  f782							;
   1086  f782		       20 48 f7    getStartAddr jsr	getHex
   1087  f785		       b0 0c		      bcs	getDone
   1088  f787		       8d 96 df 	      sta	SAH
   1089  f78a		       20 48 f7 	      jsr	getHex
   1090  f78d		       b0 04		      bcs	getDone
   1091  f78f		       8d 95 df 	      sta	SAL
   1092  f792		       18		      clc
   1093  f793		       60	   getDone    rts
   1094  f794							;
   1095  f794							;=====================================================
   1096  f794							; Gets a four digit hex address and places it in
   1097  f794							; EAL and EAH.  Returns C clear if all is well, or C
   1098  f794							; set on error and A contains the character.
   1099  f794							;
   1100  f794		       20 48 f7    getEndAddr jsr	getHex
   1101  f797		       b0 fa		      bcs	getDone
   1102  f799		       8d 98 df 	      sta	EAH
   1103  f79c		       20 48 f7 	      jsr	getHex
   1104  f79f		       b0 f2		      bcs	getDone
   1105  f7a1		       8d 97 df 	      sta	EAL
   1106  f7a4		       18		      clc
   1107  f7a5		       60		      rts
   1108  f7a6							;
   1109  f7a6							;=====================================================
   1110  f7a6							; Get an address range and leave them in SAL and EAL.
   1111  f7a6							;
   1112  f7a6		       20 c6 fa    getAddrRange jsr	putsil
      0  f7a9					      db	"Start: ",0
      1  f7a9		       53 74 61 72*	      .byte.b	"Start: ",0
   1114  f7b1		       20 82 f7 	      jsr	getStartAddr
   1115  f7b4		       b0 dd		      bcs	getDone
   1116  f7b6		       20 c6 fa 	      jsr	putsil
      0  f7b9					      db	", End: ",0
      1  f7b9		       2c 20 45 6e*	      .byte.b	", End: ",0
   1118  f7c1		       20 94 f7 	      jsr	getEndAddr
   1119  f7c4		       60		      rts
   1120  f7c5							;
   1121  f7c5							;=====================================================
   1122  f7c5							; Command handler for the ? command
   1123  f7c5							;
   1124  f7c5		       20 c6 fa    showHelp   jsr	putsil
      0  f7c8					      db	CR,LF
      1  f7c8		       0d 0a		      .byte.b	CR,LF
      0  f7ca					      db	"Available commands:"
      1  f7ca		       41 76 61 69*	      .byte.b	"Available commands:"
      0  f7dd					      db	CR,LF,LF,0
      1  f7dd		       0d 0a 0a 00	      .byte.b	CR,LF,LF,0
   1128  f7e1							;
   1129  f7e1							; Print help for built-in commands...
   1130  f7e1							;
   1131  f7e1		       a9 f6		      lda	#commandTable&$ff
   1132  f7e3		       85 f0		      sta	sptr
   1133  f7e5		       a9 f0		      lda	#commandTable/256
   1134  f7e7		       85 f1		      sta	sptr+1
   1135  f7e9		       20 ef f7 	      jsr	displayHelp	;display help
   1136  f7ec							;
   1137  f7ec							; Now print help for the extension commands...
   1138  f7ec							;
   1139  f7ec				  -	      if	EXTENDED_CMDS
   1140  f7ec				  -	      lda	ExtensionAddr
   1141  f7ec				  -	      sta	sptr
   1142  f7ec				  -	      lda	ExtensionAddr+1
   1143  f7ec				  -	      sta	sptr+1
   1144  f7ec				  -	      jsr	displayHelp
   1145  f7ec				  -	      jsr	crlf
   1146  f7ec					      endif
   1147  f7ec		       4c ba f0 	      jmp	prompt
   1148  f7ef							;
   1149  f7ef							;=====================================================
   1150  f7ef							; Given a pointer to a command table in POINT, display
   1151  f7ef							; the help text for all commands in the table.
   1152  f7ef							;
   1153  f7ef		       a0 00	   displayHelp ldy	#0	;index into command table
   1154  f7f1		       b1 f0	   showHelpLoop lda	(sptr),y	;get command
   1155  f7f3		       f0 1c		      beq	showHelpDone	;jump if at end
   1156  f7f5							;
   1157  f7f5							; Display this entry's descriptive text
   1158  f7f5							;
   1159  f7f5		       c8		      iny		;skip over command
   1160  f7f6		       c8		      iny		;skip over function ptr
   1161  f7f7		       c8		      iny
   1162  f7f8		       b1 f0		      lda	(sptr),y
   1163  f7fa		       85 f2		      sta	INL
   1164  f7fc		       c8		      iny
   1165  f7fd		       b1 f0		      lda	(sptr),y
   1166  f7ff		       85 f3		      sta	INH
   1167  f801		       98		      tya
   1168  f802		       48		      pha
   1169  f803		       20 34 fb 	      jsr	space2
   1170  f806		       20 e9 fa 	      jsr	puts	;print description
   1171  f809		       20 24 fb 	      jsr	crlf
   1172  f80c		       68		      pla
   1173  f80d		       a8		      tay
   1174  f80e		       c8		      iny		;point to next entry
   1175  f80f		       d0 e0		      bne	showHelpLoop
   1176  f811		       60	   showHelpDone rts
   1177  f812							;
   1178  f812							;=====================================================
   1179  f812							; This does a memory test of a region of memory.
   1180  f812							;
   1181  f812							; Asks for the starting and ending locations.
   1182  f812							;
   1183  f812							; This cycles a rolling bit, then adds a ninth
   1184  f812							; pattern to help detect shorted address bits.
   1185  f812							; Ie: 01, 02, 04, 08, 10, 20, 40, 80, BA
   1186  f812							;
   1187  f812		       df 8e	   pattern    equ	SaveA	;re-use some other locations
   1188  f812		       df 8f	   original   equ	SaveX
   1189  f812							;
   1190  f812							; Test patterns
   1191  f812							;
   1192  f812		       00 01	   PATTERN_0  equ	$01
   1193  f812		       00 ba	   PATTERN_9  equ	$ba
   1194  f812							;
   1195  f812		       20 58 fb    memabort   jsr	cin	;eat pending key
   1196  f815		       4c ba f0    cmdRet2    jmp	prompt
   1197  f818							;
   1198  f818		       20 c6 fa    memTest    jsr	putsil
      0  f81b					      db	"Memory test ",0
      1  f81b		       4d 65 6d 6f*	      .byte.b	"Memory test ",0
   1200  f828		       20 a6 f7 	      jsr	getAddrRange	;get range
   1201  f82b		       b0 e8		      bcs	cmdRet2	;branch if abort
   1202  f82d							;
   1203  f82d		       20 c6 fa 	      jsr	putsil
      0  f830					      db	CR,LF
      1  f830		       0d 0a		      .byte.b	CR,LF
      0  f832					      db	"Testing memory.  Press any key to abort"
      1  f832		       54 65 73 74*	      .byte.b	"Testing memory.  Press any key to abort"
      0  f859					      db	0
      1  f859		       00		      .byte.b	0
   1207  f85a		       a9 01		      lda	#PATTERN_0	;only set initial...
   1208  f85c		       8d 8e df 	      sta	pattern	;..pattern once
   1209  f85f							;
   1210  f85f							; Start of loop.  This fills/tests one complete pass
   1211  f85f							; of memory.
   1212  f85f							;
   1213  f85f		       20 63 fb    memTestMain jsr	cstatus	;key pressed?
   1214  f862		       d0 ae		      bne	memabort	;branch if yes
   1215  f864		       ad 95 df 	      lda	SAL	;reset pointer to start
   1216  f867		       85 f0		      sta	sptr
   1217  f869		       ad 96 df 	      lda	SAH
   1218  f86c		       85 f1		      sta	sptr+1
   1219  f86e							;
   1220  f86e							; Fill memory with the rolling pattern until the last
   1221  f86e							; location is filled.
   1222  f86e							;
   1223  f86e		       a0 00		      ldy	#0
   1224  f870		       ad 8e df 	      lda	pattern
   1225  f873		       8d 8f df 	      sta	original
   1226  f876		       91 f0	   memTestFill sta	(sptr),y
   1227  f878		       c9 ba		      cmp	#PATTERN_9	;at last pattern?
   1228  f87a		       d0 05		      bne	memFill3
   1229  f87c		       a9 01		      lda	#PATTERN_0	;restart pattern
   1230  f87e		       4c 86 f8 	      jmp	memFill4
   1231  f881							;
   1232  f881							; Rotate pattern left one bit
   1233  f881							;
   1234  f881		       0a	   memFill3   asl		; a
   1235  f882		       90 02		      bcc	memFill4	;branch if not overflow
   1236  f884		       a9 ba		      lda	#PATTERN_9	;ninth pattern
   1237  f886							;
   1238  f886							; The new pattern is in A.  Now see if we've reached
   1239  f886							; the end of the area to be tested.
   1240  f886							;
   1241  f886		       48	   memFill4   pha		;save pattern
   1242  f887		       a5 f0		      lda	sptr
   1243  f889		       cd 97 df 	      cmp	EAL
   1244  f88c		       d0 07		      bne	memFill5
   1245  f88e		       a5 f1		      lda	sptr+1
   1246  f890		       cd 98 df 	      cmp	EAH
   1247  f893		       f0 07		      beq	memCheck
   1248  f895							;
   1249  f895							; Not done, so move to next address and keep going.
   1250  f895							;
   1251  f895		       20 31 f9    memFill5   jsr	INCPT
   1252  f898		       68		      pla		;recover pattern
   1253  f899		       4c 76 f8 	      jmp	memTestFill
   1254  f89c							;
   1255  f89c							; Okay, memory is filled, so now go back and test it.
   1256  f89c							; We kept a backup copy of the initial pattern to
   1257  f89c							; use, but save the current pattern as the starting
   1258  f89c							; point for the next pass.
   1259  f89c							;
   1260  f89c		       68	   memCheck   pla
   1261  f89d		       8d 8e df 	      sta	pattern	;for next pass
   1262  f8a0		       ad 95 df 	      lda	SAL	;reset pointer to start
   1263  f8a3		       85 f0		      sta	sptr
   1264  f8a5		       ad 96 df 	      lda	SAH
   1265  f8a8		       85 f1		      sta	sptr+1
   1266  f8aa		       ad 8f df 	      lda	original	;restore initial pattern
   1267  f8ad		       a0 00		      ldy	#0
   1268  f8af		       d1 f0	   memTest2   cmp	(sptr),y
   1269  f8b1		       d0 2c		      bne	memFail
   1270  f8b3		       c9 ba		      cmp	#PATTERN_9
   1271  f8b5		       d0 04		      bne	memTest3
   1272  f8b7							;
   1273  f8b7							; Time to reload the pattern
   1274  f8b7							;
   1275  f8b7		       a9 01		      lda	#PATTERN_0
   1276  f8b9		       d0 05		      bne	memTest4
   1277  f8bb							;
   1278  f8bb							; Rotate pattern left one bit
   1279  f8bb							;
   1280  f8bb		       0a	   memTest3   asl		; a
   1281  f8bc		       90 02		      bcc	memTest4
   1282  f8be		       a9 ba		      lda	#PATTERN_9
   1283  f8c0							;
   1284  f8c0							; The new pattern is in A.
   1285  f8c0							;
   1286  f8c0		       48	   memTest4   pha		;save pattern
   1287  f8c1		       a5 f0		      lda	sptr
   1288  f8c3		       cd 97 df 	      cmp	EAL
   1289  f8c6		       d0 07		      bne	memTest5	;not at end
   1290  f8c8		       a5 f1		      lda	sptr+1
   1291  f8ca		       cd 98 df 	      cmp	EAH
   1292  f8cd		       f0 07		      beq	memDone	;at end of pass
   1293  f8cf							;
   1294  f8cf							; Not at end yet, so inc pointer and continue
   1295  f8cf							;
   1296  f8cf		       20 31 f9    memTest5   jsr	INCPT
   1297  f8d2		       68		      pla
   1298  f8d3		       4c af f8 	      jmp	memTest2
   1299  f8d6							;
   1300  f8d6							; Another pass has completed.
   1301  f8d6							;
   1302  f8d6		       68	   memDone    pla
   1303  f8d7		       a9 2e		      lda	#'.
   1304  f8d9		       20 4b fb 	      jsr	cout
   1305  f8dc		       4c 5f f8 	      jmp	memTestMain
   1306  f8df							;
   1307  f8df							; Failure.  Display the failed address, the expected
   1308  f8df							; value and what was actually there.
   1309  f8df							;
   1310  f8df		       48	   memFail    pha		;save pattern for error report
   1311  f8e0		       20 c6 fa 	      jsr	putsil
      0  f8e3					      db	CR,LF
      1  f8e3		       0d 0a		      .byte.b	CR,LF
      0  f8e5					      db	"Failure at address ",0
      1  f8e5		       46 61 69 6c*	      .byte.b	"Failure at address ",0
   1314  f8f9		       a5 f1		      lda	sptr+1
   1315  f8fb		       20 07 fb 	      jsr	HexA
   1316  f8fe		       a5 f0		      lda	sptr
   1317  f900		       20 07 fb 	      jsr	HexA
   1318  f903		       20 c6 fa 	      jsr	putsil
      0  f906					      db	".  Expected ",0
      1  f906		       2e 20 20 45*	      .byte.b	".  Expected ",0
   1320  f913		       68		      pla
   1321  f914		       20 07 fb 	      jsr	HexA
   1322  f917		       20 c6 fa 	      jsr	putsil
      0  f91a					      db	" but got ",0
      1  f91a		       20 62 75 74*	      .byte.b	" but got ",0
   1324  f924		       a0 00		      ldy	#0
   1325  f926		       b1 f0		      lda	(sptr),y
   1326  f928		       20 07 fb 	      jsr	HexA
   1327  f92b		       20 24 fb 	      jsr	crlf
   1328  f92e		       4c ba f0    cmdRet4    jmp	prompt
   1329  f931							;
   1330  f931							;=====================================================
   1331  f931							; Increment sptr
   1332  f931							;
   1333  f931		       e6 f0	   INCPT      inc	sptr
   1334  f933		       d0 02		      bne	incpt2
   1335  f935		       e6 f1		      inc	sptr+1
   1336  f937		       60	   incpt2     rts
   1337  f938							;
   1338  f938							;=====================================================
   1339  f938							; Ping the Arduino disk controller.  This just sends the
   1340  f938							; PING command gets back one character, then returns.
   1341  f938							; Not much of a test but is sufficient to prove the
   1342  f938							; link is working.
   1343  f938							;
   1344  f938		       20 c6 fa    pingDisk   jsr	putsil
      0  f93b					      db	"Ping... ",0
      1  f93b		       50 69 6e 67*	      .byte.b	"Ping... ",0
   1346  f944		       20 7e fb 	      jsr	DiskPing
   1347  f947		       20 c6 fa 	      jsr	putsil
      0  f94a					      db	"success!"
      1  f94a		       73 75 63 63*	      .byte.b	"success!"
      0  f952					      db	CR,LF,0
      1  f952		       0d 0a 00 	      .byte.b	CR,LF,0
   1350  f955		       4c ba f0    doDiskDirEnd jmp	prompt
   1351  f958							;
   1352  f958							;=====================================================
   1353  f958							; Do a disk directory of the SD card.
   1354  f958							;
   1355  f958		       20 c6 fa    doDiskDir  jsr	putsil
      0  f95b					      db	"Disk Directory..."
      1  f95b		       44 69 73 6b*	      .byte.b	"Disk Directory..."
      0  f96c					      db	CR,LF,0
      1  f96c		       0d 0a 00 	      .byte.b	CR,LF,0
   1358  f96f							;		 jsr	xParInit
   1359  f96f		       20 91 fb 	      jsr	DiskDir
   1360  f972							;
   1361  f972							; Get/Display each entry
   1362  f972							;
   1363  f972		       a2 df	   doDiskDirLoop ldx	#filename/256	;pointer to buffer
   1364  f974		       a0 9a		      ldy	#filename&$ff
   1365  f976		       86 f3		      stx	INH	;save for puts
   1366  f978		       84 f2		      sty	INL
   1367  f97a		       20 9b fb 	      jsr	DiskDirNext	;get next entry
   1368  f97d		       b0 d6		      bcs	doDiskDirEnd	;carry = end of list
   1369  f97f		       20 31 fb 	      jsr	space3
   1370  f982		       20 e9 fa 	      jsr	puts	;else print name
   1371  f985		       20 24 fb 	      jsr	crlf
   1372  f988		       4c 72 f9 	      jmp	doDiskDirLoop	;do next entry
   1373  f98b							;
   1374  f98b							;=====================================================
   1375  f98b							; Adds the character in A to the CRC.	Preserves A.
   1376  f98b							;
   1377  f98b		       48	   updateCrc  pha
   1378  f98c		       18		      clc
   1379  f98d		       6d a9 df 	      adc	CHKL
   1380  f990		       8d a9 df 	      sta	CHKL
   1381  f993		       68		      pla
   1382  f994		       60		      rts
   1383  f995							;
   1384  f995							;=====================================================
   1385  f995							; Print character in A as two hex digits to the
   1386  f995							; current output device (console or file).
   1387  f995							;
   1388  f995		       48	   HexToOutput pha		;save return value
   1389  f996		       48		      pha
   1390  f997		       4a		      lsr		;a	;move top nibble to bottom
   1391  f998		       4a		      lsr		;a
   1392  f999		       4a		      lsr		;a
   1393  f99a		       4a		      lsr		;a
   1394  f99b		       20 a4 f9 	      jsr	hexta	;output nibble
   1395  f99e		       68		      pla
   1396  f99f		       20 a4 f9 	      jsr	hexta
   1397  f9a2		       68		      pla		;restore
   1398  f9a3		       60		      rts
   1399  f9a4							;
   1400  f9a4		       29 0f	   hexta      and	#%0001111
   1401  f9a6		       c9 0a		      cmp	#$0a
   1402  f9a8		       18		      clc
   1403  f9a9		       30 02		      bmi	hexta1
   1404  f9ab		       69 07		      adc	#7
   1405  f9ad		       69 30	   hexta1     adc	#'0	;then fall into...
   1406  f9af							;
   1407  f9af							;=====================================================
   1408  f9af							; This is a helper function used for redirected I/O.
   1409  f9af							; It simply does a jump through the output vector
   1410  f9af							; pointer to send the character in A to the proper
   1411  f9af							; device.
   1412  f9af							;
   1413  f9af		       6c 08 df    redirectedOutch jmp	(outputVector)
   1414  f9b2							;
   1415  f9b2							;=====================================================
   1416  f9b2							; Set up the output vector to point to the normal
   1417  f9b2							; console output subroutine.
   1418  f9b2							;
   1419  f9b2				   setOutputConsole
   1420  f9b2		       a9 4b		      lda	#cout&$ff
   1421  f9b4		       8d 08 df 	      sta	outputVector
   1422  f9b7		       a9 fb		      lda	#cout/256
   1423  f9b9		       8d 09 df 	      sta	outputVector+1
   1424  f9bc		       60		      rts
   1425  f9bd							;
   1426  f9bd							;=====================================================
   1427  f9bd							; Set up the output vector to point to a file write
   1428  f9bd							; subroutine.
   1429  f9bd							;
   1430  f9bd				   setOutputFile
   1431  f9bd		       a9 7d		      lda	#putNextFileByte&$ff
   1432  f9bf		       8d 08 df 	      sta	outputVector
   1433  f9c2		       a9 f6		      lda	#putNextFileByte/256
   1434  f9c4		       8d 09 df 	      sta	outputVector+1
   1435  f9c7							;
   1436  f9c7							; Clear counts and offsets so the next read will
   1437  f9c7							; cause the file to be read.
   1438  f9c7							;
   1439  f9c7		       a9 00		      lda	#0
   1440  f9c9		       8d a7 df 	      sta	diskBufOffset
   1441  f9cc		       60		      rts
   1442  f9cd							;
   1443  f9cd							;=====================================================
   1444  f9cd							; Set up the input vector to point to the normal
   1445  f9cd							; console input subroutine.
   1446  f9cd							;
   1447  f9cd				   setInputConsole
   1448  f9cd		       a9 d8		      lda	#cinecho&$ff
   1449  f9cf		       8d 06 df 	      sta	inputVector
   1450  f9d2		       a9 f9		      lda	#cinecho/256
   1451  f9d4		       8d 07 df 	      sta	inputVector+1
   1452  f9d7		       60		      rts
   1453  f9d8							;
   1454  f9d8		       20 58 fb    cinecho    jsr	cin
   1455  f9db		       48		      pha
   1456  f9dc		       20 4b fb 	      jsr	cout
   1457  f9df		       68		      pla
   1458  f9e0		       60		      rts
   1459  f9e1							;
   1460  f9e1							;=====================================================
   1461  f9e1							; Set up the input vector to point to a file read
   1462  f9e1							; subroutine.
   1463  f9e1							;
   1464  f9e1				   setInputFile
   1465  f9e1		       a9 f7		      lda	#getNextFileByte&$ff
   1466  f9e3		       8d 06 df 	      sta	inputVector
   1467  f9e6		       a9 f9		      lda	#getNextFileByte/256
   1468  f9e8		       8d 07 df 	      sta	inputVector+1
   1469  f9eb							;
   1470  f9eb							; Clear counts and offsets so the next read will
   1471  f9eb							; cause the file to be read.
   1472  f9eb							;
   1473  f9eb		       a9 00		      lda	#0
   1474  f9ed		       8d a7 df 	      sta	diskBufOffset
   1475  f9f0		       8d a8 df 	      sta	diskBufLength
   1476  f9f3		       60		      rts
   1477  f9f4							;
   1478  f9f4							;=====================================================
   1479  f9f4							; This is a helper function used for redirected I/O.
   1480  f9f4							; It simply does a jump through the input vector
   1481  f9f4							; pointer to get the next input character.
   1482  f9f4							;
   1483  f9f4		       6c 06 df    redirectedGetch jmp	(inputVector)
   1484  f9f7							;
   1485  f9f7							;=====================================================
   1486  f9f7							; This gets the next byte from an open disk file.  If
   1487  f9f7							; there are no more bytes left, this returns C set.
   1488  f9f7							; Else, C is clear and A contains the character.
   1489  f9f7							;
   1490  f9f7		       ae a7 df    getNextFileByte ldx	diskBufOffset
   1491  f9fa		       ec a8 df 	      cpx	diskBufLength
   1492  f9fd		       d0 14		      bne	hasdata	;branch if still data
   1493  f9ff							;
   1494  f9ff							; There is no data left in the buffer, so read a
   1495  f9ff							; block from the SD system.
   1496  f9ff							;
   1497  f9ff		       a9 84		      lda	#BUFFER_SIZE
   1498  fa01		       a2 df		      ldx	#buffer>>8
   1499  fa03		       a0 0a		      ldy	#buffer&$ff
   1500  fa05		       20 07 fc 	      jsr	DiskRead
   1501  fa08		       b0 12		      bcs	getNextEof
   1502  fa0a							;
   1503  fa0a							; A contains the number of bytes actually read.
   1504  fa0a							;
   1505  fa0a		       8d a8 df 	      sta	diskBufLength	;save length
   1506  fa0d		       c9 00		      cmp	#0	;shouldn't happen
   1507  fa0f		       f0 0b		      beq	getNextEof
   1508  fa11							;
   1509  fa11		       a2 00		      ldx	#0
   1510  fa13		       bd 0a df    hasdata    lda	buffer,x
   1511  fa16		       e8		      inx
   1512  fa17		       8e a7 df 	      stx	diskBufOffset
   1513  fa1a		       18		      clc
   1514  fa1b		       60		      rts
   1515  fa1c							;
   1516  fa1c		       a9 00	   getNextEof lda	#0
   1517  fa1e		       8d a7 df 	      sta	diskBufOffset
   1518  fa21		       8d a8 df 	      sta	diskBufLength
   1519  fa24		       38		      sec
   1520  fa25		       60		      rts
   1521  fa26
   1522  fa26							;page
   1523  fa26							;
   1524  fa26							;========================================jlit 8/2/2022
   1525  fa26							; Remove a file from the disk
   1526  fa26							;
   1527  fa26		       20 c6 fa    rmFile     jsr	putsil
      0  fa29					      db	"Enter filename to rm ",0
      1  fa29		       45 6e 74 65*	      .byte.b	"Enter filename to rm ",0
   1529  fa3f		       20 45 f6 	      jsr	getFileName
   1530  fa42		       a0 9a		      ldy	#filename&$ff
   1531  fa44		       a2 df		      ldx	#filename/256
   1532  fa46							;		jsr	xParInit
   1533  fa46		       20 02 fc 	      jsr	DiskRemoveFile
   1534  fa49		       90 0f		      bcc	rmOk	; removed ok
   1535  fa4b		       20 c6 fa 	      jsr	putsil
      0  fa4e					      db	"rm failed"
      1  fa4e		       72 6d 20 66*	      .byte.b	"rm failed"
      0  fa57					      db	CR,LF,0
      1  fa57		       0d 0a 00 	      .byte.b	CR,LF,0
   1538  fa5a		       4c ba f0    rmOk       jmp	prompt
   1539  fa5d							;
   1540  fa5d							;=====================================================
   1541  fa5d							; Type the contents of an SD file to console.
   1542  fa5d							;
   1543  fa5d		       20 c6 fa    typeFile   jsr	putsil
      0  fa60					      db	"Enter filename to type: ",0
      1  fa60		       45 6e 74 65*	      .byte.b	"Enter filename to type: ",0
   1545  fa79		       20 45 f6 	      jsr	getFileName
   1546  fa7c		       a0 9a		      ldy	#filename&$ff
   1547  fa7e		       a2 df		      ldx	#filename/256
   1548  fa80							;	     jsr	xParInit
   1549  fa80		       20 cc fb 	      jsr	DiskOpenRead
   1550  fa83		       90 1e		      bcc	typeFile1	;opened ok
   1551  fa85							;
   1552  fa85		       20 c6 fa 	      jsr	putsil
      0  fa88					      db	CR,LF
      1  fa88		       0d 0a		      .byte.b	CR,LF
      0  fa8a					      db	"Failed to open file"
      1  fa8a		       46 61 69 6c*	      .byte.b	"Failed to open file"
      0  fa9d					      db	CR,LF,0
      1  fa9d		       0d 0a 00 	      .byte.b	CR,LF,0
   1556  faa0		       4c ba f0 	      jmp	prompt
   1557  faa3							;
   1558  faa3							; Now just keep reading in bytes and displaying them.
   1559  faa3							;
   1560  faa3		       20 e1 f9    typeFile1  jsr	setInputFile	;reading from file
   1561  faa6		       20 f7 f9    typeFileLoop jsr	getNextFileByte
   1562  faa9		       b0 06		      bcs	typeEof
   1563  faab		       20 4b fb 	      jsr	cout	;display character
   1564  faae		       4c a6 fa 	      jmp	typeFileLoop
   1565  fab1							;
   1566  fab1		       20 70 fc    typeEof    jsr	DiskClose
   1567  fab4		       4c ba f0 	      jmp	prompt
   1568  fab7							;
   1569  fab7							;=====================================================
   1570  fab7							; This flushes any data remaining in the disk buffer
   1571  fab7							; and then closes the file.
   1572  fab7							;
   1573  fab7		       ad a7 df    CloseOutFile lda	diskBufOffset
   1574  faba		       f0 07		      beq	closeonly
   1575  fabc		       a2 df		      ldx	#buffer>>8
   1576  fabe		       a0 0a		      ldy	#buffer&$ff
   1577  fac0		       20 39 fc 	      jsr	DiskWrite
   1578  fac3							;
   1579  fac3		       4c 70 fc    closeonly  jmp	DiskClose
   1580  fac6							;
------- FILE io.asm LEVEL 2 PASS 2
      0  fac6					      include	"io.asm"
      1  fac6					      Processor	6502
      2  fac6							;*********************************************************
      3  fac6							; FILE: io.asm
      4  fac6							;
      5  fac6							; This contains slightly higher level console related
      6  fac6							; functions like text output, reading a line, etc.
      7  fac6							;*********************************************************
      8  fac6							;
      9  fac6							;
     10  fac6		       00 00	   EnableGetline equ	0	;Disable the Getline function
     11  fac6		       00 00	   EnableParse equ	0	;Disable the parse line function
     12  fac6				  -	      if	EnableGetline
     13  fac6				  -	      SEG.U	RomScratch
     14  fac6				  -BUFFER     ds	BUFFER_SIZE
     15  fac6				  -argc       ds	1
     16  fac6				  -argv       ds	MAX_ARGC
     17  fac6					      endif
     18  fac6					      Seg	Code
     19  fac6							;
     20  fac6							;*********************************************************
     21  fac6							; Print the string that follows the JSR to this code.
     22  fac6							; Taken from http://www.6502.org/source/io/primm.htm
     23  fac6							; The last example by Ross Archer.
     24  fac6							;
     25  fac6		       68	   putsil     pla		;Get the low part of "return" address
     26  fac7							;(data start address)
     27  fac7		       85 f4		      sta	putsp
     28  fac9		       68		      pla
     29  faca		       85 f5		      sta	putsp+1	;Get the high part of "return" address
     30  facc							;(data start address)
     31  facc							;Note: actually we're pointing one short
     32  facc		       a0 01	   PSINB      ldy	#1
     33  face		       b1 f4		      lda	(putsp),y	;Get the next string character
     34  fad0		       e6 f4		      inc	putsp	;update the pointer
     35  fad2		       d0 02		      bne	PSICHO	;if not, we're pointing to next character
     36  fad4		       e6 f5		      inc	putsp+1	;account for page crossing
     37  fad6		       09 00	   PSICHO     ora	#0	;Set flags according to contents of
     38  fad8							;   Accumulator
     39  fad8		       f0 06		      beq	PSIX1	;don't print the final NULL
     40  fada		       20 4b fb 	      jsr	cout	;write it out
     41  fadd		       4c cc fa 	      jmp	PSINB	;back around
     42  fae0		       e6 f4	   PSIX1      inc	putsp
     43  fae2		       d0 02		      bne	PSIX2
     44  fae4		       e6 f5		      inc	putsp+1	;account for page crossing
     45  fae6		       6c f4 00    PSIX2      jmp	(putsp)	;return to byte following final NULL
     46  fae9							;
     47  fae9							;=====================================================
     48  fae9							; This prints the null terminated string pointed to by
     49  fae9							; INL and INH.  Modifies those locations to point to
     50  fae9							; the end of the string.
     51  fae9							;
     52  fae9		       a0 00	   puts       ldy	#0
     53  faeb		       b1 f2	   putsy      lda	(INL),y
     54  faed		       e6 f2		      inc	INL
     55  faef		       d0 02		      bne	puts1
     56  faf1		       e6 f3		      inc	INH
     57  faf3		       09 00	   puts1      ora	#0
     58  faf5		       f0 0c		      beq	putsdone
     59  faf7		       8c 90 df 	      sty	SaveY
     60  fafa		       20 4b fb 	      jsr	cout	;print character
     61  fafd		       ac 90 df 	      ldy	SaveY
     62  fb00		       4c eb fa 	      jmp	putsy
     63  fb03		       60	   putsdone   rts
     64  fb04							;
     65  fb04							;*********************************************************
     66  fb04							; Get a line of text from the console and put it into
     67  fb04							; BUFFER.  This only allows printable characters, will
     68  fb04							; limit the amount of text to BUFFER_SIZE-1 characters,
     69  fb04							; and allows some editing.  Returns the string with a null
     70  fb04							; byte at the end and the length in A.  If the length is
     71  fb04							; zero, return Z set.
     72  fb04							;
     73  fb04				   getline
     74  fb04				  -	      if	EnableGetline
     75  fb04				  -	      ldx	#0
     76  fb04				  -	      beq	getline1
     77  fb04				  -			;
     78  fb04				  -			; This outputs a bell.  Used when the user
     79  fb04				  -			; does something bad, like non-printable
     80  fb04				  -			; characters or exceeding line length.
     81  fb04				  -			;
     82  fb04				  -getline2   lda	#BELL
     83  fb04				  -	      jsr	cout
     84  fb04				  -			;
     85  fb04				  -			; Get the next character
     86  fb04				  -			;
     87  fb04				  -getline1   jsr	cin	;get character
     88  fb04				  -	      cmp	#' '
     89  fb04				  -	      bcc	getline2	;not printable
     90  fb04				  -	      cmp	#'~'+1
     91  fb04				  -	      bcs	getline2	;not printable
     92  fb04				  -	      cmp	#CR	;end of input?
     93  fb04				  -	      beq	getline3
     94  fb04				  -	      cpx	#BUFFER_SIZE-1
     95  fb04				  -	      beq	getline1	;too long
     96  fb04				  -	      sta	BUFFER,x
     97  fb04				  -	      jsr	cout	;echo, echo, echo...
     98  fb04				  -	      inx
     99  fb04				  -	      bne	getline1
    100  fb04				  -			;
    101  fb04				  -			; Got a CR, so terminate the string.
    102  fb04				  -			;
    103  fb04				  -getline3   lda	#0
    104  fb04				  -	      sta	BUFFER,x
    105  fb04				  -	      txa		;will set/clear Z
    106  fb04					      endif
    107  fb04		       60		      rts
    108  fb05							;
    109  fb05							;*********************************************************
    110  fb05							; This converts the buffer to all lower case.
    111  fb05							;
    112  fb05				   ToLower
    113  fb05				  -	      if	EnableParse
    114  fb05				  -	      ldx	#0
    115  fb05				  -ToLower1   lda	BUFFER,x
    116  fb05				  -	      beq	ToLowerDone
    117  fb05				  -			;
    118  fb05				  -	      cmp	#'a
    119  fb05				  -	      bcc	ToLower2
    120  fb05				  -	      cmp	#'z+1
    121  fb05				  -	      bcs	ToLower2
    122  fb05				  -	      clc
    123  fb05				  -	      sbc	#$20	;convert
    124  fb05				  -	      sta	BUFFER,x
    125  fb05				  -ToLower2   inx
    126  fb05				  -	      bne	ToLower1
    127  fb05					      endif
    128  fb05		       60	   ToLowerDone rts
    129  fb06							;
    130  fb06							;*********************************************************
    131  fb06							; This parses the current contents of BUFFER.	It scans
    132  fb06							; until finding whitespace, terminates the string (puts a
    133  fb06							; null), then scans until finding the next non-whitespace
    134  fb06							; and repeats the process again.  Saves the offset to each
    135  fb06							; word in argc, and has a total count in argv.  Yes, I am
    136  fb06							; a C programmer.
    137  fb06							;
    138  fb06				   parse
    139  fb06				  -	      if	EnableParse
    140  fb06				  -	      ldx	#0
    141  fb06				  -	      stx	argc	;clear count
    142  fb06				  -	      dex
    143  fb06				  -			;
    144  fb06				  -			; Skip whitespace
    145  fb06				  -			;
    146  fb06				  -parse1     inx
    147  fb06				  -	      lda	BUFFER,x
    148  fb06				  -	      beq	parse2	;at EOL
    149  fb06				  -	      cmp	#' '
    150  fb06				  -	      beq	parse1	;whitespace
    151  fb06				  -			;
    152  fb06				  -			; Not whitespace
    153  fb06				  -			;
    154  fb06				  -	      ldy	argc
    155  fb06				  -	      stx	argv,y
    156  fb06				  -	      iny
    157  fb06				  -	      cpy	#MAX_ARGC
    158  fb06				  -	      beq	parse2
    159  fb06				  -	      sty	argv
    160  fb06				  -			;
    161  fb06				  -			; Now skip until whitespace found again
    162  fb06				  -			;
    163  fb06				  -parse3     inx
    164  fb06				  -	      lda	BUFFER,x
    165  fb06				  -	      beq	parse2
    166  fb06				  -	      cmp	#' '
    167  fb06				  -	      bne	parse3
    168  fb06				  -	      lda	#0
    169  fb06				  -	      sta	BUFFER,x	;terminate
    170  fb06				  -	      jmp	parse1
    171  fb06				  -			;
    172  fb06					      endif
    173  fb06		       60	   parse2     rts
    174  fb07							;
    175  fb07							;*********************************************************
    176  fb07							; Dump the contents of A as two hex digits.  Preserves
    177  fb07							; all registers.
    178  fb07							;
    179  fb07		       48	   HexA       pha		;save value
    180  fb08		       48		      pha
    181  fb09		       4a		      lsr		;a
    182  fb0a		       4a		      lsr		;a
    183  fb0b		       4a		      lsr		;a
    184  fb0c		       4a		      lsr		;a
    185  fb0d		       20 16 fb 	      jsr	HexDigit
    186  fb10		       68		      pla
    187  fb11		       20 16 fb 	      jsr	HexDigit
    188  fb14		       68		      pla		;restore value
    189  fb15		       60		      rts
    190  fb16							;
    191  fb16		       29 0f	   HexDigit   and	#$0f
    192  fb18		       c9 0a		      cmp	#$0a
    193  fb1a		       18		      clc
    194  fb1b		       30 02		      bmi	HexDigit1
    195  fb1d		       69 07		      adc	#7
    196  fb1f		       69 30	   HexDigit1  adc	#'0
    197  fb21		       4c 4b fb 	      jmp	cout
    198  fb24							;
    199  fb24							;*********************************************************
    200  fb24							; Output a CR/LF combination to the console.  Preserves
    201  fb24							; all registers.
    202  fb24							;
    203  fb24		       48	   crlf       pha
    204  fb25		       a9 0d		      lda	#CR
    205  fb27		       20 4b fb 	      jsr	cout
    206  fb2a		       a9 0a		      lda	#LF
    207  fb2c		       20 4b fb 	      jsr	cout
    208  fb2f		       68		      pla
    209  fb30		       60		      rts
    210  fb31							;
    211  fb31							;*********************************************************
    212  fb31							; Output one, two or three spaces.  Preserves all
    213  fb31							; register.
    214  fb31							;
    215  fb31		       20 37 fb    space3     jsr	space
    216  fb34		       20 37 fb    space2     jsr	space
    217  fb37		       48	   space      pha
    218  fb38		       a9 20		      lda	#$20
    219  fb3a		       20 4b fb 	      jsr	cout
    220  fb3d		       68		      pla
    221  fb3e		       60		      rts
    222  fb3f
    223  fb3f
------- FILE ctmon65.asm
------- FILE acia.asm LEVEL 2 PASS 2
      0  fb3f					      include	"acia.asm"
      1  fb3f					      processor	6502
      2  fb3f					      Seg	Code
      3  fb3f							;*********************************************************
      4  fb3f							; FILE: acia.asm
      5  fb3f							;*********************************************************
      6  fb3f							;
      7  fb3f		       00 00	   CONSOLE_SLOT equ	0
      8  fb3f							;
      9  fb3f		       e0 00	   ACIA       equ	(CONSOLE_SLOT*IO_SIZE)+IO_BASE
     10  fb3f		       00 01	   RDRF       equ	%00000001
     11  fb3f		       00 02	   TDRE       equ	%00000010
     12  fb3f							;
     13  fb3f							;*********************************************************
     14  fb3f							; Initialize the ACIA
     15  fb3f							;
     16  fb3f		       a9 03	   cinit      lda	#%00000011	;reset
     17  fb41		       8d 00 e0 	      sta	ACIA
     18  fb44		       ea		      nop
     19  fb45		       a9 11		      lda	#%00010001	;8N2
     20  fb47		       8d 00 e0 	      sta	ACIA
     21  fb4a		       60		      rts
     22  fb4b							;
     23  fb4b							;*********************************************************
     24  fb4b							; Output the character in A to the console.  This will
     25  fb4b							; block until the character is queued.  Preserves all
     26  fb4b							; registers.
     27  fb4b							;
     28  fb4b		       48	   cout       pha
     29  fb4c		       ad 00 e0    cout1      lda	ACIA
     30  fb4f		       29 02		      and	#TDRE
     31  fb51		       f0 f9		      beq	cout1	;not empty
     32  fb53		       68		      pla
     33  fb54		       8d 01 e0 	      sta	ACIA+1
     34  fb57		       60		      rts
     35  fb58							;
     36  fb58							;*********************************************************
     37  fb58							; Gets a character from the console and returns it in A.
     38  fb58							; Modifies no other registers.  This blocks until a
     39  fb58							; character is available.
     40  fb58							;
     41  fb58		       ad 00 e0    cin	      lda	ACIA
     42  fb5b		       29 01		      and	#RDRF
     43  fb5d		       f0 f9		      beq	cin
     44  fb5f		       ad 01 e0 	      lda	ACIA+1
     45  fb62		       60		      rts
     46  fb63							;
     47  fb63							;*********************************************************
     48  fb63							; Get the status of the console.  Returns Z set if no
     49  fb63							; characters are available, Z clear if a character is
     50  fb63							; ready.
     51  fb63							;
     52  fb63		       ad 00 e0    cstatus    lda	ACIA
     53  fb66		       29 01		      and	#RDRF
     54  fb68		       60		      rts
------- FILE ctmon65.asm
   1583  fb69
   1584  fb69					      if	SD_ENABLED
------- FILE parproto.inc LEVEL 2 PASS 2
      0  fb69					      include	"parproto.inc"
      1  fb69					      Processor	6502
      2  fb69							;*****************************************************
      3  fb69							; Parallel port protocol
      4  fb69							;
      5  fb69							; This is the header file for making applications
      6  fb69							; compliant with The Remote Disk Protocol Guide which
      7  fb69							; is on the Corsham Technologies web page somewhere:
      8  fb69							;
      9  fb69							;    www.corshamtech.com
     10  fb69							;
     11  fb69							; This was updated 06/13/2015 to be compliant with the
     12  fb69							; official specification, so the opcode values changed.
     13  fb69							;
     14  fb69							; Another update on 09/04/2017
     15  fb69							;
     16  fb69							;=====================================================
     17  fb69							; Commands from host to Arduino
     18  fb69							;
     19  fb69		       00 01	   PC_GET_VERSION equ	$01
     20  fb69		       00 05	   PC_PING    equ	$05	;ping Arduino
     21  fb69		       00 06	   PC_LED_CONTROL equ	$06	;LED control
     22  fb69		       00 10	   PC_GET_DIR equ	$10	;Get directory
     23  fb69		       00 11	   PC_GET_MOUNTED equ	$11	;Get mounted drive list
     24  fb69		       00 12	   PC_MOUNT   equ	$12	;Mount drive
     25  fb69		       00 13	   PC_UNMOUNT equ	$13	;Unmount drive
     26  fb69		       00 14	   PC_GET_STATUS equ	$14	;Get status for one drive
     27  fb69		       00 15	   PC_DONE    equ	$15	;Stop data
     28  fb69		       00 15	   PC_ABORT   equ	PC_DONE
     29  fb69		       00 16	   PC_READ_FILE equ	$16	;Read regular file (non-DSK)
     30  fb69		       00 17	   PC_READ_BYTES equ	$17	;Read sequential bytes
     31  fb69		       00 18	   PC_RD_SECTOR equ	$18	;Read FLEX sector
     32  fb69		       00 19	   PC_WR_SECTOR equ	$19	;Write FLEX sector
     33  fb69		       00 1a	   PC_GET_MAX equ	$1a	;Get maximum drives
     34  fb69		       00 1b	   PC_WRITE_FILE equ	$1b	;Open file for writing
     35  fb69		       00 1c	   PC_WRITE_BYTES equ	$1c	;Data to be written
     36  fb69		       00 1d	   PC_SAVE_CONFIG equ	$1d	;Save SD.CFG with current values
     37  fb69		       00 1e	   PC_SET_TIMER equ	$1e	;Set RTC timer
     38  fb69		       00 1f	   PC_WR_SEC_LONG equ	$1f	;Write sector with long sec num
     39  fb69		       00 20	   PC_RD_SEC_LONG equ	$20	;Read sector with long sec num
     40  fb69		       00 21	   PC_RM_FILE equ	$21	;remove a file non-dsk
     41  fb69							;
     42  fb69							;=====================================================
     43  fb69							; Responses from Arduino to host
     44  fb69							;
     45  fb69		       00 81	   PR_VERSION_INFO equ	$81	;Contains version information
     46  fb69		       00 82	   PR_ACK     equ	$82	;ACK (no additional information)
     47  fb69		       00 83	   PR_NAK     equ	$83	;NAK - one status byte follows
     48  fb69		       00 85	   PR_PONG    equ	$85	;Reply to a ping
     49  fb69		       00 90	   PR_DIR_ENTRY equ	$90	;Directory entry
     50  fb69		       00 91	   PR_DIR_END equ	$91	;End of directory entries
     51  fb69		       00 92	   PR_FILE_DATA equ	$92	;File data
     52  fb69		       00 93	   PR_STATUS  equ	$93	;Drive status
     53  fb69		       00 94	   PR_SECTOR_DATA equ	$94	;Sector data
     54  fb69		       00 95	   PR_MOUNT_INFO equ	$95	;Mount entry
     55  fb69		       00 96	   PR_MAX_DRIVES equ	$96	;Maximum number of drives
     56  fb69							;
     57  fb69							;=====================================================
     58  fb69							; Error codes for NAK events.	Yes, these are in
     59  fb69							; decimal due to an error in the original
     60  fb69							; documentation.
     61  fb69							;
     62  fb69		       00 00	   ERR_NONE   equ	0
     63  fb69		       00 0a	   ERR_NOT_MOUNTED equ	10
     64  fb69		       00 0b	   ERR_MOUNTED equ	11
     65  fb69		       00 0c	   ERR_NOT_FOUND equ	12
     66  fb69		       00 0d	   ERR_READ_ONLY equ	13
     67  fb69		       00 0e	   ERR_BAD_DRIVE equ	14
     68  fb69		       00 0f	   ERR_BAD_TRACK equ	15
     69  fb69		       00 10	   ERR_BAD_SECTOR equ	16
     70  fb69		       00 11	   ERR_READ_ERROR equ	17
     71  fb69		       00 12	   ERR_WRITE_ERROR equ	18
     72  fb69		       00 13	   ERR_NOT_PRESENT equ	19
     73  fb69		       00 14	   ERR_NOT_IMPL equ	20	;Command not implemented
     74  fb69
------- FILE ctmon65.asm
------- FILE pario.asm LEVEL 2 PASS 2
      0  fb69					      include	"pario.asm"
      1  fb69					      Processor	6502
      2  fb69							;CTMON65 version using a 6821
      3  fb69
      4  fb69							;*****************************************************
      5  fb69							; These are the low-level I/O routines to talk to the
      6  fb69							; Arduino processor connected to the KIM's I/O port.
      7  fb69							;
      8  fb69							; August 2014, Bob Applegate K2UT, bob@corshamtech.com
      9  fb69							;
     10  fb69							; Which port bits are used for what:
     11  fb69							;
     12  fb69							; A0 = Data 0, alternates input/output
     13  fb69							; A1 = Data 1, alternates input/output
     14  fb69							; A2 = Data 2, alternates input/output
     15  fb69							; A3 = Data 3, alternates input/output
     16  fb69							; A4 = Data 4, alternates input/output
     17  fb69							; A5 = Data 5, alternates input/output
     18  fb69							; A6 = Data 6, alternates input/output
     19  fb69							; A7 = Data 7, alternates input/output
     20  fb69							;
     21  fb69							; B0 = Direction bit, always output
     22  fb69							; B1 = Write strobe or ACK, always output
     23  fb69							; B2 = Read strobe or ACK, always input
     24  fb69							;
     25  fb69							;----------------------------------------------------
     26  fb69							; Bits in the B register
     27  fb69							;
     28  fb69		       00 01	   DIRECTION  equ	%00000001
     29  fb69		       00 02	   PSTROBE    equ	%00000010
     30  fb69		       00 04	   ACK	      equ	%00000100
     31  fb69							;
     32  fb69							;----------------------------------------------------
     33  fb69							; Which slot the parallel board is in.  This needs to
     34  fb69							; be set for the system in use.  As long as the user
     35  fb69							; programs only call functions in here, no other
     36  fb69							; file/application should know which slot the board
     37  fb69							; is in.
     38  fb69							;
     39  fb69		       00 01	   PIASLOT    equ	1
     40  fb69							;
     41  fb69							; Computed addresses of 6821 registers
     42  fb69							;
     43  fb69		       e0 10	   PIABASE    equ	IO_BASE+(PIASLOT*IO_SIZE)
     44  fb69		       e0 10	   PIAREGA    equ	PIABASE	;data reg A
     45  fb69		       e0 10	   PIADDRA    equ	PIABASE	;data dir reg A
     46  fb69		       e0 11	   PIACTLA    equ	PIABASE+1	;control reg A
     47  fb69		       e0 12	   PIAREGB    equ	PIABASE+2	;data reg B
     48  fb69		       e0 12	   PIADDRB    equ	PIABASE+2	;data dir reg B
     49  fb69		       e0 13	   PIACTLB    equ	PIABASE+3	;control reg B
     50  fb69
     51  fb69					      Seg	Code
     52  fb69							;page
     53  fb69							;
     54  fb69							;*****************************************************
     55  fb69							; This is the initialization function.  Call before
     56  fb69							; doing anything else with the parallel port.
     57  fb69							;
     58  fb69				   xParInit
     59  fb69							;
     60  fb69							; Set up the data direction register for port B so that
     61  fb69							; the DIRECTION and PSTROBE bits are output.
     62  fb69							;
     63  fb69							;		  lda	#0		       ;select DDR
     64  fb69							;		  sta	PIACTLB		       ;...for port B
     65  fb69							;		  lda	#DIRECTION | PSTROBE
     66  fb69							;		  sta	PIADDRB
     67  fb69							;		  lda	#4		       ;select data reg
     68  fb69							;		  sta	PIACTLB
     69  fb69							;
     70  fb69							; Fall through to set up for writes...
     71  fb69							;
     72  fb69							;page
     73  fb69							;*****************************************************
     74  fb69							; This sets up for writing to the Arduino.  Sets up
     75  fb69							; direction registers, drives the direction bit, etc.
     76  fb69							;
     77  fb69		       a9 00	   xParSetWrite lda	#0	;select DDR
     78  fb6b							;		 sta	PIACTLA	     ;...for port A
     79  fb6b							;		 lda	#$ff		     ;set bits for output
     80  fb6b							;		 sta	PIADDRA
     81  fb6b							;		 lda	#4		     ;select data reg
     82  fb6b							;		 sta	PIACTLA
     83  fb6b							;
     84  fb6b							; Set direction flag to output, clear ACK bit
     85  fb6b							;
     86  fb6b							;		lda	#DIRECTION
     87  fb6b							;		sta	PIAREGB
     88  fb6b		       60		      rts
     89  fb6c							;page
     90  fb6c							;*****************************************************
     91  fb6c							; This sets up for reading from the Arduino.  Sets up
     92  fb6c							; direction registers, clears the direction bit, etc.
     93  fb6c							;
     94  fb6c		       a9 00	   xParSetRead lda	#0	;select DDR
     95  fb6e							;		 sta	PIACTLA		 ;...for port A
     96  fb6e							;		 lda	#$00		 ;set bits for input
     97  fb6e							;		 sta	PIADDRA
     98  fb6e							;		 lda	#4		 ;select data reg
     99  fb6e							;		 sta	PIACTLA
    100  fb6e							;
    101  fb6e							; Set direction flag to input, clear ACK bit
    102  fb6e							;
    103  fb6e							;		lda	#0
    104  fb6e							;		sta	PIAREGB
    105  fb6e		       60		      rts
    106  fb6f							;page
    107  fb6f							;*****************************************************
    108  fb6f							; This writes a single byte to the Arduino.  On entry,
    109  fb6f							; the byte to write is in A.  This assumes ParSetWrite
    110  fb6f							; was already called.
    111  fb6f							;
    112  fb6f							; Destroys A, all other registers preserved.
    113  fb6f							;
    114  fb6f							; Write cycle:
    115  fb6f							;
    116  fb6f							;    1. Wait for other side to lower ACK.
    117  fb6f							;    2. Put data onto the bus.
    118  fb6f							;    3. Set DIRECTION and PSTROBE to indicate data
    119  fb6f							;	 is valid and ready to read.
    120  fb6f							;    4. Wait for ACK line to go high, indicating the
    121  fb6f							;	 other side has read the data.
    122  fb6f							;    5. Lower PSTROBE.
    123  fb6f							;    6. Wait for ACK to go low, indicating end of
    124  fb6f							;	 transfer.
    125  fb6f							;messed up for emulator, we need to protocols
    126  fb6f				   xParWriteByte
    127  fb6f							;		  pha		      ;save data
    128  fb6f							;Parwl22	  lda	PIAREGB	 ;check status
    129  fb6f							;		  and	#ACK
    130  fb6f							;		  bne	Parwl22	 ;wait for ACK to go low
    131  fb6f							;
    132  fb6f							; Now put the data onto the bus
    133  fb6f							;
    134  fb6f							;		 pla
    135  fb6f		       8d 10 e0 	      sta	PIAREGA
    136  fb72							;
    137  fb72							; Raise the strobe so the Arduino knows there is
    138  fb72							; new data.
    139  fb72							;
    140  fb72							;		  lda	PIAREGB
    141  fb72							;		  ora	#PSTROBE
    142  fb72							;		  sta	PIAREGB
    143  fb72							;
    144  fb72							; Wait for ACK to go high, indicating the Arduino has
    145  fb72							; pulled the data and is ready for more.
    146  fb72							;
    147  fb72							;Parwl33	  lda	PIAREGB
    148  fb72							;		  and	#ACK
    149  fb72							;		  beq	Parwl33
    150  fb72							;
    151  fb72							; Now lower the strobe, then wait for the Arduino to
    152  fb72							; lower ACK.
    153  fb72							;
    154  fb72							;		  lda	PIAREGB
    155  fb72							;		  and	#~PSTROBE
    156  fb72							;		  sta	PIAREGB
    157  fb72							;Parwl44	  lda	PIAREGB
    158  fb72							;		  and	#ACK
    159  fb72							;		  bne	Parwl44
    160  fb72		       60		      rts
    161  fb73							;page
    162  fb73							;*****************************************************
    163  fb73							; This reads a byte from the Arduino and returns it in
    164  fb73							; A.  Assumes ParSetRead was called before.
    165  fb73							;
    166  fb73							; This does not have a time-out.
    167  fb73							;
    168  fb73							; Preserves all other registers.
    169  fb73							;
    170  fb73							; Read cycle:
    171  fb73							;
    172  fb73							;    1. Wait for other side to raise ACK, indicating
    173  fb73							;	 data is ready.
    174  fb73							;    2. Read data.
    175  fb73							;    3. Raise PSTROBE indicating data was read.
    176  fb73							;    4. Wait for ACK to go low.
    177  fb73							;    5. Lower PSTROBE.
    178  fb73							;
    179  fb73		       ad 12 e0    xParReadByte lda	PIAREGB
    180  fb76		       29 04		      and	#ACK	;is their strobe high?
    181  fb78		       f0 f9		      beq	xParReadByte	;nope, no data
    182  fb7a							;
    183  fb7a							; Data is available, so grab and save it.
    184  fb7a							;
    185  fb7a		       ad 10 e0 	      lda	PIAREGA
    186  fb7d							;		  pha
    187  fb7d							;
    188  fb7d							; Now raise our strobe (their ACK), then wait for
    189  fb7d							; them to lower their strobe.
    190  fb7d							;
    191  fb7d							;		  lda	PIAREGB
    192  fb7d							;		  ora	#PSTROBE
    193  fb7d							;		  sta	PIAREGB
    194  fb7d							;Parrlp1	  lda	PIAREGB
    195  fb7d							;		  and	#ACK
    196  fb7d							;		  bne	Parrlp1		    ;still active
    197  fb7d							;
    198  fb7d							; Lower our ack, then were done.
    199  fb7d							;
    200  fb7d							;		  lda	PIAREGB
    201  fb7d							;		  and	#~PSTROBE
    202  fb7d							;		  sta	PIAREGB
    203  fb7d							;		  pla
    204  fb7d		       60		      rts
------- FILE ctmon65.asm
------- FILE diskfunc.asm LEVEL 2 PASS 2
      0  fb7e					      include	"diskfunc.asm"
      1  fb7e					      Processor	6502
      2  fb7e							;=====================================================
      3  fb7e							; This is a collection of functions for performing
      4  fb7e							; higher level disk functions.  This hides the nasty
      5  fb7e							; details of communications with the remote disk
      6  fb7e							; system.
      7  fb7e							;
      8  fb7e							; August 20, 2014 - Bob Applegate
      9  fb7e							;		     bob@corshamtech.com
     10  fb7e							;
     11  fb7e							; 06/14/2015 - Bob Applegate
     12  fb7e							;		Now that there is an official standard
     13  fb7e							;		for the protocol between the host (this
     14  fb7e							;		code) and the DCP (Arduino code), this
     15  fb7e							;		code has been updated to be compliant.
     16  fb7e							;
     17  fb7e							; 01/14/2016 - Bob Applegate
     18  fb7e							;		Finally converted to 6502.
     19  fb7e							;
     20  fb7e							; 02/8/2022  - JustLostInTime
     21  fb7e							;		added ability to remove disk file non-dsk
     22  fb7e							;
     23  fb7e							;		include	"parproto.inc"
     24  fb7e							;
     25  fb7e							; Number of drives emulated
     26  fb7e							;
     27  fb7e					      Seg	Code
     28  fb7e		       00 04	   DRIVES     equ	4
     29  fb7e							;
     30  fb7e							;=====================================================
     31  fb7e							; This is a sanity check to verify connectivity to the
     32  fb7e							; Arduino code is working.  Returns C clear if all is
     33  fb7e							; good, or C set if not.
     34  fb7e							;
     35  fb7e		       20 69 fb    DiskPing   jsr	xParSetWrite
     36  fb81		       a9 05		      lda	#PC_PING	;command
     37  fb83		       20 6f fb 	      jsr	xParWriteByte	;send to Arduino
     38  fb86		       20 6c fb 	      jsr	xParSetRead
     39  fb89		       20 73 fb 	      jsr	xParReadByte	;read their reply
     40  fb8c		       20 69 fb    DiskRetGood jsr	xParSetWrite
     41  fb8f		       18		      clc		;assume it's good
     42  fb90		       60		      rts
     43  fb91							;page
     44  fb91							;=====================================================
     45  fb91							; This starts a directory read of the raw drive, not
     46  fb91							; the mounted drive.  No input parameters.  This simply
     47  fb91							; sets up for reading the entries, then the user must
     48  fb91							; read each entry.
     49  fb91							;
     50  fb91							; Returns with C clear on success.  If error, C is set
     51  fb91							; and A contains the error code.
     52  fb91							;
     53  fb91		       20 69 fb    DiskDir    jsr	xParSetWrite
     54  fb94		       a9 10		      lda	#PC_GET_DIR	;send command
     55  fb96		       20 6f fb 	      jsr	xParWriteByte
     56  fb99		       18		      clc		;assume it works
     57  fb9a		       60		      rts
     58  fb9b							;page
     59  fb9b							;=====================================================
     60  fb9b							; Read the next directory entry.  On input, X (MSB)
     61  fb9b							; and Y (LSB) point to a 13 byte area to receive the
     62  fb9b							; drive data.
     63  fb9b							;
     64  fb9b							; Returns C set if end of directory (ie, attempt to
     65  fb9b							; read and there are none left).  Else, C is clear
     66  fb9b							; and X/Y point to the null at end of filename.
     67  fb9b							;
     68  fb9b		       86 f1	   DiskDirNext stx	sptr+1
     69  fb9d		       84 f0		      sty	sptr
     70  fb9f		       20 6c fb 	      jsr	xParSetRead	;read results
     71  fba2		       20 73 fb 	      jsr	xParReadByte	;get response code
     72  fba5		       c9 83		      cmp	#PR_NAK	;error?
     73  fba7		       f0 1e		      beq	DDNErr
     74  fba9		       c9 91		      cmp	#PR_DIR_END	;end?
     75  fbab		       f0 1a		      beq	DDNErr
     76  fbad							;
     77  fbad							; This contains a directory entry.
     78  fbad							;
     79  fbad		       a0 00		      ldy	#0
     80  fbaf		       20 73 fb    DDNloop    jsr	xParReadByte
     81  fbb2		       91 f0		      sta	(sptr),y
     82  fbb4		       c9 00		      cmp	#0	;end?
     83  fbb6		       f0 06		      beq	DDNEnd
     84  fbb8		       20 31 f9 	      jsr	INCPT
     85  fbbb		       4c af fb 	      jmp	DDNloop
     86  fbbe		       20 69 fb    DDNEnd     jsr	xParSetWrite
     87  fbc1		       a6 f1		      ldx	sptr+1
     88  fbc3		       a4 f0		      ldy	sptr
     89  fbc5		       18		      clc		;not end of files
     90  fbc6		       60		      rts
     91  fbc7							;
     92  fbc7							; Error.  Set C and return.  This is not really
     93  fbc7							; proper, since this implies a simple end of the
     94  fbc7							; directory rather than an error.
     95  fbc7							;
     96  fbc7		       20 69 fb    DDNErr     jsr	xParSetWrite
     97  fbca		       38		      sec
     98  fbcb		       60		      rts
     99  fbcc							;page
    100  fbcc							;=====================================================
    101  fbcc							; This opens a file on the SD for reading.  On entry,
    102  fbcc							; X (MSB) and Y (LSB) point to a null-terminated
    103  fbcc							; filename to open.  On return, C is clear if the file
    104  fbcc							; is open, or C set if an error (usually means the
    105  fbcc							; file does not exist.
    106  fbcc							;
    107  fbcc							; Assumes write mode has been set.  Returns with it set.
    108  fbcc							;
    109  fbcc		       a9 16	   DiskOpenRead lda	#PC_READ_FILE
    110  fbce		       84 f2	   DiskOpen   sty	INL	;save ptr to filename
    111  fbd0		       86 f3		      stx	INH
    112  fbd2		       48		      pha
    113  fbd3		       20 69 fb 	      jsr	xParSetWrite
    114  fbd6		       68		      pla
    115  fbd7		       20 6f fb 	      jsr	xParWriteByte
    116  fbda		       a0 ff		      ldy	#-1
    117  fbdc		       c8	   DiskOpenLoop iny
    118  fbdd		       b1 f2		      lda	(INL),y
    119  fbdf		       20 6f fb 	      jsr	xParWriteByte
    120  fbe2		       b1 f2		      lda	(INL),y
    121  fbe4		       d0 f6		      bne	DiskOpenLoop
    122  fbe6		       20 6c fb 	      jsr	xParSetRead
    123  fbe9		       20 73 fb 	      jsr	xParReadByte	;get response
    124  fbec		       c9 82		      cmp	#PR_ACK
    125  fbee		       d0 05		      bne	DiskOpenErr
    126  fbf0		       20 69 fb 	      jsr	xParSetWrite	;back to write mode
    127  fbf3		       18		      clc
    128  fbf4		       60		      rts
    129  fbf5							;
    130  fbf5							; Got an error.
    131  fbf5							;
    132  fbf5		       20 73 fb    DiskOpenErr jsr	xParReadByte	;get error code
    133  fbf8		       20 69 fb 	      jsr	xParSetWrite	;back to write mode
    134  fbfb		       38		      sec
    135  fbfc		       60		      rts
    136  fbfd							;=====================================================
    137  fbfd							; This opens a file on the SD for writing.  On entry,
    138  fbfd							; X (MSB) and Y (LSB) point to a null-terminated
    139  fbfd							; filename to open.  On return, C is clear if the file
    140  fbfd							; is open, or C set if an error.
    141  fbfd							;
    142  fbfd							; Assumes write mode has been set.  Returns with it set.
    143  fbfd							;
    144  fbfd		       a9 1b	   DiskOpenWrite lda	#PC_WRITE_FILE
    145  fbff		       4c ce fb 	      jmp	DiskOpen	;jump into common code
    146  fc02							;=====================================================
    147  fc02							; This Removes a file from the SD for writing.  On entry,
    148  fc02							; X (MSB) and Y (LSB) point to a null-terminated
    149  fc02							; filename to remove.	On return, C is clear if the file
    150  fc02							; is removed, or C set if an error.
    151  fc02							;
    152  fc02							; Assumes write mode has been set.  Returns with it set.
    153  fc02							;
    154  fc02		       a9 21	   DiskRemoveFile lda	#PC_RM_FILE
    155  fc04		       4c ce fb 	      jmp	DiskOpen
    156  fc07							;
    157  fc07							;=====================================================
    158  fc07							; On entry, A contains the number of bytes to read
    159  fc07							; from the file, X (MSB) and Y (LSB) point to the
    160  fc07							; buffer where to put the data.  On return, C will
    161  fc07							; be set if EOF was reached (and no data read), or
    162  fc07							; C will be clear and A contains the number of bytes
    163  fc07							; actually read into the buffer.
    164  fc07							;
    165  fc07							; Modifies A, X and Y.  Also modifies INL and INH
    166  fc07							; (00F8 and 00F9).
    167  fc07							;
    168  fc07		       48	   DiskRead   pha
    169  fc08		       84 f2		      sty	INL	;save ptr to buffer
    170  fc0a		       86 f3		      stx	INH
    171  fc0c		       a9 17		      lda	#PC_READ_BYTES
    172  fc0e		       20 6f fb 	      jsr	xParWriteByte	;command
    173  fc11		       68		      pla		;number of bytes to get
    174  fc12		       20 6f fb 	      jsr	xParWriteByte
    175  fc15		       20 6c fb 	      jsr	xParSetRead	;get ready for response
    176  fc18		       20 73 fb 	      jsr	xParReadByte	;assume PR_FILE_DATA
    177  fc1b		       20 73 fb 	      jsr	xParReadByte	;length
    178  fc1e		       48		      pha
    179  fc1f		       aa		      tax		;count
    180  fc20		       f0 11		      beq	DiskReadEof	;zero = EOF
    181  fc22		       a0 00		      ldy	#0	;offset
    182  fc24		       20 73 fb    DiskReadLoop jsr	xParReadByte
    183  fc27		       91 f2		      sta	(INL),y
    184  fc29		       c8		      iny		;next offset
    185  fc2a		       ca		      dex
    186  fc2b		       d0 f7		      bne	DiskReadLoop
    187  fc2d		       20 69 fb 	      jsr	xParSetWrite
    188  fc30		       68		      pla		;retrieve byte count
    189  fc31		       18	   DiskOk     clc
    190  fc32		       60		      rts
    191  fc33		       20 69 fb    DiskReadEof jsr	xParSetWrite
    192  fc36		       68		      pla
    193  fc37		       38		      sec
    194  fc38		       60		      rts
    195  fc39							;
    196  fc39							;=====================================================
    197  fc39							; On entry, A contains the number of bytes to write
    198  fc39							; to the file, X (MSB) and Y (LSB) point to the
    199  fc39							; buffer where to get the data.  On return, C will
    200  fc39							; be set if an error was detected, or C will be clear
    201  fc39							; if no error.  Note that if A contains 0 on entry,
    202  fc39							; no bytes are written.
    203  fc39							;
    204  fc39							; Modifies A, X and Y.  Also modifies INL and INH
    205  fc39							; (00F8 and 00F9).
    206  fc39							;
    207  fc39		       c9 00	   DiskWrite  cmp	#0
    208  fc3b		       f0 f4		      beq	DiskOk
    209  fc3d		       84 f2		      sty	INL	;save ptr to filename
    210  fc3f		       86 f3		      stx	INH
    211  fc41		       48		      pha
    212  fc42		       a9 1c		      lda	#PC_WRITE_BYTES
    213  fc44		       20 6f fb 	      jsr	xParWriteByte	;command
    214  fc47		       68		      pla		;number of bytes to write
    215  fc48		       48		      pha		;save again
    216  fc49		       20 6f fb 	      jsr	xParWriteByte
    217  fc4c		       68		      pla
    218  fc4d		       aa		      tax		;count
    219  fc4e		       a0 00		      ldy	#0	;offset
    220  fc50		       b1 f2	   DiskWriteLoop lda	(INL),y	;get next byte
    221  fc52		       20 6f fb 	      jsr	xParWriteByte
    222  fc55		       c8		      iny		;next offset
    223  fc56		       ca		      dex
    224  fc57		       d0 f7		      bne	DiskWriteLoop
    225  fc59		       20 6c fb 	      jsr	xParSetRead	;read the status
    226  fc5c		       20 73 fb 	      jsr	xParReadByte
    227  fc5f		       c9 82		      cmp	#PR_ACK
    228  fc61		       f0 08		      beq	DiskOk1	;all good
    229  fc63		       20 73 fb 	      jsr	xParReadByte	;read error code
    230  fc66		       20 69 fb 	      jsr	xParSetWrite
    231  fc69		       38		      sec
    232  fc6a		       60		      rts
    233  fc6b							;
    234  fc6b		       20 69 fb    DiskOk1    jsr	xParSetWrite
    235  fc6e		       18		      clc
    236  fc6f		       60		      rts
    237  fc70							;
    238  fc70							;=====================================================
    239  fc70							; Call this to close any open file.  No parameters
    240  fc70							; and no return status.
    241  fc70							;
    242  fc70		       a9 15	   DiskClose  lda	#PC_DONE
    243  fc72		       4c 6f fb 	      jmp	xParWriteByte
    244  fc75
    245  fc75
------- FILE ctmon65.asm
   1588  fc75					      endif
   1589  fc75							;
   1590  fc75							;*********************************************************
   1591  fc75							; Handlers for the interrupts.  Basiclly just jump
   1592  fc75							; through the vectors and hope they are set up properly.
   1593  fc75							;
   1594  fc75		       6c 02 df    HandleNMI  jmp	(NMIvec)
   1595  fc78		       6c 00 df    HandleIRQ  jmp	(IRQvec)
   1596  fc7b							;
   1597  fc7b							;*********************************************************
   1598  fc7b							; Default handler.  Save the state of the machine for
   1599  fc7b							; debugging.  This is taken from the KIM monitor SAVE
   1600  fc7b							; routine.
   1601  fc7b							;
   1602  fc7b				   DefaultNMI
   1603  fc7b		       8d 8e df    DefaultIRQ sta	SaveA
   1604  fc7e		       68		      pla
   1605  fc7f		       8d 93 df 	      sta	SaveC
   1606  fc82		       68		      pla
   1607  fc83		       8d 91 df 	      sta	SavePC
   1608  fc86		       68		      pla
   1609  fc87		       8d 92 df 	      sta	SavePC+1
   1610  fc8a		       8c 90 df 	      sty	SaveY
   1611  fc8d		       8e 8f df 	      stx	SaveX
   1612  fc90		       ba		      tsx
   1613  fc91		       8e 94 df 	      stx	SaveSP
   1614  fc94		       20 99 f6 	      jsr	DumpRegisters
   1615  fc97		       20 24 fb 	      jsr	crlf
   1616  fc9a		       4c b7 f0 	      jmp	WARM
   1617  fc9d							;
   1618  fc9d							;*********************************************************
   1619  fc9d							; 6502 vectors
   1620  fc9d							;
   1621  fffa					      org	$fffa
      0  fffa					      dw	HandleNMI
      1  fffa		       75 fc		      .word.w	HandleNMI
      0  fffc					      dw	RESET
      1  fffc		       48 f0		      .word.w	RESET
      0  fffe					      dw	HandleIRQ
      1  fffe		       78 fc		      .word.w	HandleIRQ
   1625  10000
